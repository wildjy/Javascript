/**
 * FusionCharts Core Framework
 * This module contains the basic routines required by subsequent modules to
 * extend/scale or add functionality to the FusionCharts object.
 * @private
 *
 * @module fusioncharts.constructor
 */
 /* global window: false */
(function () {

    // In case FusionCharts object already exists, we skip this function.
    if (window.FusionCharts && window.FusionCharts.version) {
        return;
    }

    var win = window,
        doc = win.document,
        nav = win.navigator,

        // The global variable would store all private methods and properties
        // available to each module.
        global = {
            window: win
        },

        /**
         * ~var {object} modules For maintaining module information.
         */
        modules = global.modules = {},
        interpreters = global.interpreters = {},

        objectToStringFn = Object.prototype.toString,

        isIE = /msie/i.test(nav.userAgent) && !win.opera,
        hasLoaded = /loaded|complete/,

        mapLegacyDiscovered = false, // flag to keep track of legacy map script
        notifyLibraryInit = function () {// function to notify init of library
            var wasReady = global.ready;
            global.ready = true;
            if (global.raiseEvent) {
                global.readyNotified = true;
                /**
                 * This event is fired when the FusionCharts library is ready to be used. By the time this event is
                 * raised the browser's `DOM` is ready to be interacted with, which corresponds to the
                 * `DOMContentLoaded` event of browsers. In older browsers, where `DOMContentLoaded` is not fired, the
                 * `ready` event corresponds to the `load` event of the page. In case FusionCharts library is included
                 * in the page when the `DOMContentLoaded` event is already fired (i.e. script is loaded asyncronously
                 * using AJAX or by using script deferring methods,) the `ready` event is still fired to ensure
                 * integrity of all the listeners.
                 *
                 * In many ways the nature of this event is similar to `jQuery(document).ready` of jQuery library and
                 * `Ext.onReady` function of ExtJS library. One should interact with the FusionCharts framework (i.e.
                 * create new charts, set options, etc) only after this event has been fired. This event also helps you
                 * to neatly write your codes in separate script files and in page `<head>` thus keeping scripts from
                 * being part of your page `<body>`.
                 *
                 * An alternate (and shorthand) to subscribing the `ready` event is to use the
                 * {@link FusionCharts.ready} function. One advantage that {@link FusionCharts.ready} function has over
                 * this `ready` event is that the `ready` event is fired only once during the life-cycle of a page while
                 * functions passed  to the {@link FusionCharts.ready} function is executed even when attached after the
                 * `ready` event has been fired.
                 *
                 * > This is a framework level event and as such can be only listened via
                 * > {@link FusionCharts.addEventLsitener} on the `FusionCharts` class alone. It will not be fired if
                 * > subscribed from individual chart instances.
                 *
                 * @event FusionCharts.ready
                 * @group framework
                 * @since  3.4.0
                 *
                 * @param {array} version - The FusionCharts framework version is returned in form of an array. This is
                 * equivalent to the array {@link FusionCharts.version}
                 * @param {boolean} now - This indicates whether this event was fired at the instant of
                 * `window.ondomcontentloaded` event (or `window.onload` of older browsers) or whether the window was
                 * already loaded and this event is fired just to maintain integrity.
                 *
                 * @example
                 * <html>
                 * <head>
                 * <script type="text/javascript" src="/fusioncharts/js/fusioncharts.js"></script>
                 * <script type="text/javascript">
                 * // Render a chart within a chart container `div` element.
                 * FusionCharts.addEventListener('ready', function () {
                 *     var chart = new FusionCharts({
                 *         type: 'column2d',
                 *         renderAt: 'chart-container-div',
                 *         dataFormat: 'json',
                 *         dataSource: {
                 *             chart: {
                 *                 caption: "Quarterly sales summary",
                 *                 numberPrefix: "$"
                 *             }
                 *             data: [
                 *                 { label: "Q1", value: "213345"},
                 *                 { label: "Q2", value: "192672"},
                 *                 { label: "Q3", value: "201238"},
                 *                 { label: "Q4", value: "209881"},
                 *             ]
                 *         }
                 *     });
                 *     // Since we are in the `ready` block, the `chart-container-div`
                 *     // element should be available by now.
                 *     chart.render();
                 * });
                 * </script>
                 * <body>
                 *     <div id="chart-container-div">Chart loads here...</div>
                 * </body>
                 * </html>
                 */
                global.raiseEvent('ready', {
                    version: global.core.version,
                    now: !wasReady
                }, global.core);
            }
            global.readyNow = !wasReady;
        },

        FusionCharts,

        // recursive function that copies one object into another.
        merge = function (obj1, obj2) {
            var item, str;
            //check whether obj2 is an array
            //if array then iterate through it's index
            //**** MOOTOOLS precution
            if (obj2 instanceof Array) {
                for (item = 0; item < obj2.length; item += 1) {
                    if (typeof obj2[item] !== 'object') {
                        obj1[item] = obj2[item];
                    } else {
                        if (typeof obj1[item] !== 'object') {
                            obj1[item] = obj2[item] instanceof Array ? [] : {};
                        }
                        merge(obj1[item], obj2[item]);
                    }
                }
            }
            else {
                for (item in obj2) {
                    if (typeof obj2[item] === 'object') {
                        str = objectToStringFn.call(obj2[item]);
                        if (str === '[object Object]') {
                            if (typeof obj1[item] !== 'object') {
                                obj1[item] = {};
                            }
                            merge(obj1[item], obj2[item]);
                        }
                        else if (str === '[object Array]') {
                            if (!(obj1[item] instanceof Array)) {
                                obj1[item] = [];
                            }
                            merge(obj1[item], obj2[item]);
                        }
                        else {
                            obj1[item] = obj2[item];
                        }
                    }
                    else {
                        obj1[item] = obj2[item];
                    }
                }
            }
            return obj1;
        };

    /**
     * This method, when added to the prototype of an object,
     * allows shallow or deep extension of the object with another
     * object.
     */
    global.extend = function (sink, source, proto, deep) {
        var item;
        // When 'proto' is marked as true, the methods and properties
        // of source is not added to the prototype of the sink.
        if (proto && sink.prototype) {
            sink = sink.prototype;
        }

        // If deep extend is specified, then we use the deep copy function
        // 'merge'
        if (deep === true) {
            merge(sink, source);
        }
        // Copy all methods and properties of the object passed in parameter
        // to the object to which this function is attached.
        else {
            for (item in source) {
                sink[item] = source[item];
            }
        }

        return sink;
    };

    // Function that auto-generates a unique id.
    global.uniqueId = function () {
        return 'chartobject-' + (global.uniqueId.lastId += 1);
    };
    global.uniqueId.lastId = 0;

    // Define the policy to create default parameters for the swfObject.
    // Values are in format [sourceOption, defaultValue]
    // This helps in building the initial FusionCharts object when new instances
    // are created from user parameters.
    global.policies = {

        /**
         * Contains all the customizable options that are used by the library internally and has nothing to do with
         * renderer attributes, vars or parameters.
         * @memberOf FusionCharts
         * @type {object}
         * @private
         * @enum
         */
        options: {
            chartTypeSourcePath: ['typeSourcePath', ''],
            /** @ignore **/
            product: ['product', 'v3'],
            /**
             * Default insert mode of adding a FusionCharts to a container
             */
            insertMode: ['insertMode', 'replace'],
            safeMode: ['safeMode', true],
            /**
             * Default parameters for overlay button
             */
            overlayButton: ['overlayButton', undefined],

            containerBackgroundColor: ['containerBackgroundColor', '#ffffff'],
            containerBackgroundOpacity: ['containerBackgroundOpacity', 1],
            containerClassName: ['containerClassName', 'fusioncharts-container'],

            /**
             * In case you want to set a default chartType for all new instances of FusionCharts
             */
            chartType: ['type', undefined],

            /**
             * Default styling for chart messages
             */
            baseChartMessageFont: ['baseChartMessageFont', 'Verdana,sans'],
            baseChartMessageFontSize: ['baseChartMessageFontSize', '10'],
            baseChartMessageColor: ['baseChartMessageColor', '#666666'],

            /**
             * Default message for chart (data related)
             */
            dataLoadStartMessage: ['dataLoadStartMessage', 'Retrieving data. Please wait.'],
            dataLoadErrorMessage: ['dataLoadErrorMessage', 'Error in loading data.'],
            dataInvalidMessage: ['dataInvalidMessage', 'Invalid data.'],
            dataEmptyMessage: ['dataEmptyMessage', 'No data to display.'],

            /**
             * Default message for chart (chart related)
             */
            typeNotSupportedMessage: ['typeNotSupportedMessage', 'Chart type not supported.'],
            loadMessage: ['loadMessage', 'Loading chart. Please wait.'],
            renderErrorMessage: ['renderErrorMessage', 'Unable to render chart.']
        },
        /**
         * ~var {object} attributes Contains configurations pertaining to the
         * host (browser) environment.
         */
        attributes: {
            lang: ['lang', 'EN'],
            id: ['id', undefined]
        },

        /**
         * ~var {array} width configuration for width of the chart.
         * ~var {array} height configuration for height of the chart.
         * ~var {array} src specifies chart swf url
         */
        width: ['width', '400'],
        height: ['height', '300'],
        src: ['swfUrl', '']
    };

    // Specifies the order in which the parameters of the new
    // FusionCharts objects are interpreted and converted to options object.
    interpreters.stat = ['swfUrl', 'id', 'width', 'height',
            'debugMode', 'registerWithJS', 'backgroundColor', 'scaleMode',
            'lang', 'detectFlashVersion', 'autoInstallRedirect'];

    /**
     * Allows the core to process an arguments object based on a set of policies
     * and construct an object out of it that is mapped exactly as respective
     * parameter policy defines. In other words, it uses an object and
     * creates another object or updates another object with values from the
     * original arguments object in a particular hierarchy and name that a set
     * of rules (policies) define.
     */
    global.parsePolicies = function (obj, policies, options) {
        var prop, policy, value;

        // Iterate through the data policy and correspondingly create the
        // three stacks of parameters, attributes and flashVars
        for (policy in policies) {

            // Set just the policy object in case of single-level policy.
            if (global.policies[policy] instanceof Array) {
                value = options[policies[policy][0]];
                obj[policy] = value === undefined ? policies[policy][1] : value;

            } else {

                // Define objects that would hold parameters for swfobject. Also
                // populate with variables from the parameters
                if (typeof obj[policy] !== 'object') {
                    obj[policy] = {};
                }

                // Set every sub-object for two-level policy
                for (prop in policies[policy]) {
                    value = options[policies[policy][prop][0]];
                    obj[policy][prop] = value === undefined ?
                    policies[policy][prop][1] : value;
                }
            }
        }
    };

    /**
     * Parse commands (command interpretor) based on a specified interpreter
     * structure
     */
    global.parseCommands = function (obj, interpreter, args) {
        var i,
            l;

        if (typeof interpreter === 'string') {
            interpreter = interpreters[interpreter] || [];
        }

        // Iterate through the arguments template and add the keys to the
        // options object while fetching corresponding values from arguments
        // array.
        for (i = 0, l = interpreter.length; i < l; i++) {
            obj[interpreter[i]] = args[i];
        }

        return obj;
    };

    /**
     * Different types of extension registrations
     */
    global.registrars = {
        'module': function () {
            return global.core.apply(global.core, arguments);
        }
    };

    /**
     * Create new instances of charts, gauges and maps using this function.
     *
     * The preferred way to draw charts, gauges and maps using FusionCharts is to pass the chart configurations and data
     * to this constructor and call `render()` on the returned instance. You can provide all the properties, data and
     * event bindings of charts through the parameters passed to this function.
     *
     * You can call methods of the {@link FusionCharts} class on the returned instance. For all practical purposes, this
     * is the first step to creating a chart, gauges and maps using FusionCharts.
     *
     * __Accessing existing charts using `FusionCharts()` constructor:__
     *
     * The `FusionCharts` function has a dual behavior - other than creating new charts, it can also be used to access
     * already created charts. This is done by dropping the `new` operator and passing only the chart `id` as a
     * parameter. For example, `var salesChart = FusionCharts('sales-chart');` will return the instance of the chart
     * with the `id` "sales-chart". The previous code snippet is equivalent to
     * `var salesChart = FusionCharts.items['sales-chart'];`. Refer to {@link FusionCharts.items} to know more.
     *
     * @constructor
     * @global
     *
     * @param {object} options - While creating a new instance of FusionCharts, you can pass
     * an `options` object with all configuration parameters for that instance. All configurations passed through this
     * object are referred to as "construction parameters". Through these parameters, you can customize the look and
     * feel of a chart, pass data to the chart, configure its dimensions and bind to events.
     *
     * Each of this object's properties correspond to a configuration option.
     *
     * @param {!string=} [options.type] - Provide the name of the chart type to be rendered. Full list of charts is
     * available at {@tutorial setup-list-of-charts}.
     *
     * This parameter controls what chart will be rendered. The data passed to the chart has to be compatible with the
     * chart type specified here.
     *
     * Alternatively, you can also call {@link FusionCharts#chartType} on the chart instance to provide the chart type.
     *
     * @param {!string=} [options.id] - This name is used to refer to the current instance after the
     * chart has been created. The chart instance is available under this name in {@link FusionCharts.items}. If no `id`
     * is provided, FusionCharts automatically generates an `id` for each chart.
     *
     * @param {numeric=|percent=} [options.width="400"] - Set the width in pixels or percent such as `640` or
     * `'50%'`. If width is in pixels, there is no need to provide the `px` unit suffix. You can call
     * {@link FusionCharts#resizeTo} function on the chart instance to set the width later on.
     *
     * @param {numeric=|percent=} [options.height="300"] - Set the height in pixels or percent such as `640` or
     * `'50%'`. If height is in pixels, there is no need to provide the `px` unit suffix. You can call
     * {@link FusionCharts#resizeTo} function on the chart instance to set the height later on.
     *
     * @param {string=|DOMElement=} [options.renderAt] - A chart needs reference to a DOM element on the page where
     * it will be rendered. You can provide the HTML ID of the element as a string to this option, or you can pass a
     * reference of the DOMElement itself where the chart needs to be rendered.
     *
     * For example, if you have a DOMElement like `<div class='chart-1' id='chart-container'></div>`, you can provide
     * the value of the `div`'s `id` attribute to this option as a string. Alternatively, you can pass direct reference
     * to the DOMElement like: `renderAt: document.getElementByClassName("chart-1")`.
     *
     * Instead of providing the DOMElement here, it can also be passed as the first parameter to the
     * {@link FusionCharts.render} function. Setting the DOMElement in {@link FusionCharts.render} function overrides
     * the value set here.
     *
     * @param {FusionCharts~dataFormats=} [options.dataFormat] - This is the name of the format of data passed to the
     * `dataSource` option below. Currently, FusionCharts accepts only JSON and XML data. The value for this option is
     * one of the formats specified in {@link FusionCharts~dataFormats}.
     *
     * @param {string=|object=} [options.dataSource] - Provide the source of data and configuration of the chart.
     * FusionCharts accepts data in the formats specified in {@link FusionCharts~dataFormats}.
     *
     * This is the preferred way to set data and configuration of the chart. The data and configuration can also be
     * updated or set using the functions {@link FusionCharts#setChartData} and {@link FusionCharts#setChartDataUrl}.
     *
     * @param {object=} [options.events] - You can bind multiple events to this particular chart instance through
     * this option. You need to pass an object to this option, where each key is an event name fired by FusionCharts and
     * value for that key is a callback in the format of {@link FusionCharts~eventListener}.
     *
     * To bind multiple charts to the same event, you need to use {@link FusionCharts#addEventListener} function
     * instead.
     *
     * @param {object=} [options.link] - Provide LinkedCharts configuration. See {@link FusionCharts#configureLink}
     * for details.
     *
     * @param {boolean=} [options.showDataLoadingMessage=false] - FusionCharts shows a message while it is retrieving
     * data from a `url` provided as `dataSource`. While displaying the message the chart is grayed out and interaction
     * on it is blocked. This can be prevented by setting this option to `false`.
     *
     * @param {boolean=} [options.showChartLoadingMessage=true] - Shows `Loading chart...` message in `renderAt`
     * container if the chart needs to load additional resource/JS files. This can be turned off by setting this option
     * to `false`.
     *
     * @param {string=} [options.baseChartMessageFont='Verdana'] - Allows to set the common custom font face for all
     * chart messages.
     *
     * @param {string=} [options.baseChartMessageFontSize='10'] - Allows to set the common custom font size for all
     * chart messages.
     *
     * @param {hexcolor=} [options.baseChartMessageColor='#666666'] - Allows to set the common custom font color for
     * all chart messages.
     *
     * @param {string=} [options.dataLoadStartMessage='Retrieving data. Please wait.'] - Allows to set the message to
     * be displayed before the chart data begins loading. Additional properties like the font face, size, and color can
     * be set by suffixing the property name with the corresponding message key, e.g. dataLoadStartMessageFont,
     * dataLoadStartMessageFontSize, dataLoadStartMessageColor. If message keys are not specified, base cosmetics are
     * used.
     *
     * @param {string=} [options.dataLoadErrorMessage='Error in loading data.'] - Allows to set the message to be
     * displayed when there is an error loading the chart data. Additional properties like the font face, size, and
     * color can be set by suffixing the property name with the corresponding message key, e.g.
     * dataLoadStartMessageFont, dataLoadStartMessageFontSize, dataLoadStartMessageColor. If message keys are not
     * specified, base cosmetics are used.
     *
     * @param {string=} [options.dataInvalidMessage='Invalid data.'] - Allows to set the message to be displayed when
     * the data loaded for the chart is invalid. Additional properties like the font face, size, and color can be
     * set by suffixing the property name with the corresponding message key, e.g. dataLoadStartMessageFont,
     * dataLoadStartMessageFontSize, dataLoadStartMessageColor. If message keys are not specified, base cosmetics are
     * used.
     *
     * @param {string=} [options.dataEmptyMessage='No data to display.'] - Allows to set the message to be displayed if
     * data loaded for the chart is empty. Additional properties like the font face, size, and color can be
     * set by suffixing the property name with the corresponding message key, e.g. dataLoadStartMessageFont,
     * dataLoadStartMessageFontSize, dataLoadStartMessageColor. If message keys are not specified, base cosmetics are
     * used.
     *
     * @param {string=} [options.typeNotSupportedMessage='Chart type not supported.'] - Allows to set the message to be
     * displayed if specified chart type is not supported. Additional properties like the font face, size, and color
     * can be set by suffixing the property name with the corresponding message key, e.g. dataLoadStartMessageFont,
     * dataLoadStartMessageFontSize, dataLoadStartMessageColor. If message keys are not specified, base cosmetics are
     * used.
     *
     * @param {string=} [options.loadMessage='Loading chart. Please wait.'] - Allows to set the message to be displayed
     * when the chart begins to load. Additional properties like the font face, size, and color can be set by
     * suffixing the property name with the corresponding message key, e.g. dataLoadStartMessageFont,
     * dataLoadStartMessageFontSize, dataLoadStartMessageColor. If message keys are not specified, base cosmetics are
     * used.
     *
     * @param {string=} [options.renderErrorMessage='Unable to render chart.'] - Allows to set the message to be
     * displayed if there was an error while rendering the chart. Additional properties like the font face, size, and
     * color can be set by suffixing the property name with the corresponding message key, e.g.
     * dataLoadStartMessageFont, dataLoadStartMessageFontSize, dataLoadStartMessageColor. If message keys are not
     * specified, base cosmetics are used.
     *
     * @param {hexcolor=} [options.containerBackgroundColor="#ffffff"] - Sets the background color of the chart's
     * container HTML DOM element. It is not same as `bgColor` chart attribute. To see this background color, a chart's
     * own background alpha must be set to `0` by setting `bgAlpha` attribute to `"0"` in chart attributes.
     *
     * @param {opacity=} [options.containerBackgroundOpacity=1] - Sets the opacity of the container element. Useful
     * if the chart has underlying HTML elements or background image that needs to be made visible. If opacity is
     * reduced, you need to configure the chart itself to be transparent by setting the `bgAlpha` chart attribute.
     *
     * @param {string=} [options.containerClassName] - Sets the CSS class that will be set on the container DOM element
     * of the rendered chart. Default is `fusioncharts-container`.
     *
     * @example
     * <html>
     * <head>
     * <script type="text/javascript" src="js/fusioncharts.js"></script>
     * <script type="text/javascript">
     * FusionCharts.ready(function () {
     *     // Create a new instance of FusionCharts for rendering inside an HTML
     *     // `&lt;div&gt;` element with id `my-chart-container`.
     *     var myChart = new FusionCharts({
     *         type: 'column2d',
     *         renderAt: 'chart-container',
     *
     *         dataFormat: 'json',
     *         dataSource: {
     *             chart: {
     *                 caption: "Harry's SuperMart",
     *                 subCaption: "Top 5 stores in last month by revenue",
     *             },
     *             data:[{
     *                 label: "Bakersfield Central",
     *                 value: "880000"
     *             },
     *             {
     *                 label: "Garden Groove harbour",
     *                 value: "730000"
     *             },
     *             {
     *                 label: "Los Angeles Topanga",
     *                 value: "590000"
     *             },
     *             {
     *                 label: "Compton-Rancho Dom",
     *                 value: "520000"
     *             },
     *             {
     *                 label: "Daly City Serramonte",
     *                 value: "330000"
     *             }]
     *         }
     *     });
     *
     *     // Render the chart.
     *     myChart.render();
     * });
     * </script>
     * <body>
     *     <div id="chart-container">FusionCharts will load here...</div>
     * </body>
     * </html>
     */
    FusionCharts = function (options) {
        // This point onwards, we must check whether this is being used as a
        // constructor or not
        if (!(this instanceof global.core)) {
            // Allow private communication with modules. In case FusionCharts is
            // not called as constructor and it is passed an array that is marked
            // to do private communication, then share the global variable.
            if (arguments.length === 1 &&
                    options instanceof Array && options[0] === 'private') {
                // Prevent overwriting and duplicate execution of modules.
                if (modules[options[1]]) {
                    return undefined;
                }
                modules[options[1]] = {};

                // Check for module-specific information
                if (options[3] instanceof Array) {
                    global.core.version[options[1]] = options[3];
                }

                // Execute module function
                if (typeof options[2] === 'function') {
                    return options[2].call(global, modules[options[1]]);
                }
                else {
                    return global;
                }
            }

            // Allow using FusionCharts object to directly access its new items
            if (arguments.length === 1 && typeof options === 'string') {
                return global.core.items[options];
            }
            /**
             * This error occurs when the `FusionCharts` constructor is called without the `new` keyword and also
             * without passing a reference chart id as the parameter. In case you are rendering a new chart, ensure you
             * do a `new FusionCharts({});` or in case you are using the constructor as a getter, ensure you pass the
             * chart Id (string) as first parameter.
             *
             * @typedef {RuntimeException} Error-25081840
             * @memberOf FusionCharts.debugger
             * @group debugger-error
             */
            global.raiseError && global.raiseError(this, '25081840', 'run', '',
                new SyntaxError('Use the "new" keyword while creating a new FusionCharts object'));
        }

        // Define a variable for iterative key in various loops and the
        // object variable that stores the options.
        var opts = {};

        /**
         * @var {object} __state maintains internal state related information.
         * @private
         */
        this.__state = {};

        // Check whether linear arguments are sent and convert it to object.
        if (arguments.length === 1 && typeof arguments[0] === 'object') {
            // If the above condition matches, then we can safely assume that
            // the first parameter is the options object.
            opts = arguments[0];
        }
        else {
            // Parse command interpreter policies
            global.parseCommands(opts, interpreters.stat, arguments);
        }

        // Incorporate the trailing object parameter as object-style
        // parameter input overrides.
        if (arguments.length > 1 && typeof arguments[arguments.length - 1] === 'object') {
            delete opts[interpreters.stat[arguments.length - 1]];
            global.extend(opts, arguments[arguments.length - 1]);
        }

        // Set autogenerated chart-id in case one is not specified
        this.id = (typeof opts.id === 'undefined') ? this.id = global.uniqueId() : opts.id;

        // Set dimension passed by user and subsequently validate the options.
        // - Remove trailing 'px'
        this.args = opts;

        // If an item is created with same id, the previous item is disposed.
        if (global.core.items[this.id] instanceof global.core) {
            /**
             * This error occurs when a new chart is created (instantiated) with the an `id` that has been already
             * assigned to an existing chart. Change the chart Id or dispose the other chart with the duplicate id.
             *
             * @typedef {ParameterException} Error-06091847
             * @memberOf FusionCharts.debugger
             * @group debugger-error
             */
            global.raiseWarning(this, '06091847', 'param', '',
                new Error('A FusionChart oject with the specified id \"' + this.id +
                    '\" already exists. Renaming it to ' + (this.id = global.uniqueId())));
        }

        // Parse global policies.
        global.parsePolicies(this, global.policies, opts);

        // Copy chart id to attributes
        this.attributes.id = this.id;

        // Set initial dimension of charts
        this.resizeTo && this.resizeTo(opts.width, opts.height, true);

        // Set initial chart type of charts
        this.chartType && this.chartType(opts.type || opts.swfUrl, true);

        /**
         * Whenever a new instance of {@link FusionCharts} is created (as in `new FusionCharts(...)`, this pre
         * initialization event is raised. This event triggers a number of modules that needs to be setup on every
         * instance of FusionCharts. One can listen to this event perform actions that, on similar grounds, requires
         * to be setup upn initialization of each chart.
         *
         * Since this event is fired upon instantiating a new FusionCharts object, it is virtually impossible to listen
         * to this event by adding event listener to that individual chart. That is because, by the time one's event
         * listener is attached using {@link FusionCharts#addEventListener} on the subsequent lines post doing `new
         * FusionCharts(...)`, this event would have been already fired. Thus, the alternate ways to listen to this
         * event are:
         *
         * 1. Listen to FusionCharts global events using {@link FusionCharts.addEventListener} before even creating a
         *    new instance. (The required instance can be identified by the `id` of the chart using
         *    `eventObject.sender.id`.)
         *
         * 2. Pass the event listener as the FusionCharts constructor parameter itself.
         *
         * @event FusionCharts.beforeInitialize
         * @group chart
         *
         * @example
         * // Listening using global events
         * FusionCharts.addEventListener('beforeInitialize', function (opts) {
         *     // Prints id of the chart being rendered
         *     console.log("Chart with id " + opts.sender.id + " is about to be initialized.");
         *  });
         *
         * // Pass event listener in the FusionCharts constructor
         * var mychart = new FusionCharts({
         *     "type": "column2d",
         *     "dataFormat": "json",
         *     "dataSource": {
         *          ...
         *     },
         *     // Attach event handlers
         *     "events": {
         *         // Attach to beforeInitialize
         *         "beforeInitialize": function () {
         *             console.log("Initializing mychart...");
         *         }
         *     }
         * });
         *
         * @param {numeric|percent} height - Height of the chart in pixels or percentage.
         * @param {numeric|percent} width - Width of the chart in pixels or percentage.
         */
        global.raiseEvent('beforeInitialize', opts, this);

        // Add this object to the repository of objects within core object.
        global.core.items[this.id] = this;

        // Create alias for defaultOptions
        global.core.defaultOptions = global.core.options;

        /**
         * Once a new instance of {@link FusionCharts} is created and is ready to be operated upon, this `initialized`
         * event is fired. Note that initialization does not indicate that the chart has been rendered. It denotes that
         * the JavaScript object instance of FusionCharts is created (as in `new FusionCharts(...)` done) and is now
         * ready to be operated upon (like data being passed onto it, it being rendered, etc.)
         *
         * @event FusionCharts.initialized
         * @group chart
         *
         * @param {numeric|percent} height - height of the chart in pixels or percentage .
         * @param {numeric|percent} width - width of the chart in pixels or percentage .
         *
         * @example
         * // Listening using global events
         * FusionCharts.addEventListener('initialized', function (opts) {
         *     // Prints id of the chart that has initialized
         *     console.log("Chart with id " + opts.sender.id + " has been initialized.");
         *  });
         *
         * // Pass event listener in the FusionCharts constructor
         * var mychart = new FusionCharts({
         *     "type": "column2d",
         *     "dataFormat": "json",
         *     "dataSource": {
         *          ...
         *     },
         *     // Attach event handlers
         *     "events": {
         *         // Attach to beforeInitialize
         *         "initialized": function () {
         *             console.log("Initialized mychart...");
         *         }
         *     }
         * });
         */
        global.raiseEvent('initialized', opts, this);

        return this;
    };

    // Set FusionCharts as the primary core.
    global.core = FusionCharts;

    // Make the core extensible and reset the constructor of the object
    // for maintaining correct prototype chain.
    global.core.prototype = {};
    // Reset constructor.
    global.core.prototype.constructor = global.core;

    global.extend(global.core, /** @lends FusionCharts */ {
        id: 'FusionCharts',

        /**
         * Specifies the framework version of {@link FusionCharts}. In the format
         * `[major, minor, revision, nature, build]`
         * @type {array}
         */
        version: ['3', '5', '0'],

        /**
         * The reference to every new instance of FusionCharts is maintained in this object with the chart `ID` as the
         * key. Upon {@link FusionCharts#dispose} of the instance, the key is removed from this. One can iterate through
         * all instances of {@link FusionCharts} using this object.
         *
         * A short-hand approach to accessing a single chart by its `id` is to use {@link FusionCharts} function itself
         * but without the `new` operator and by passing the chart id as the first parameter.
         * @type {object}
         *
         * @group framework
         *
         * @example
         * // Assuming a page has many instances of {@link FusionCharts}, but
         * // none of them are rendered, we are going to iterate through all and
         * // render them.
         * for (var item in FusionCharts.items) {
         *     FusionCharts.items[item].render();
         * }
         *
         * @example
         * // Alternate method to access the charts using FusionCharts function to retrieve the chart from its id.
         * for (var item in FusionCharts.items) {
         *     FusionCharts(item).render();
         * }
         */
        items: {},

        // Add an object to store options
        options: {},

        /**
         * The function returns the `DOMElement` that is created inside chart container by FusionCharts. The returned
         * element is the same as accessing the {@link FusionCharts#ref} property. Note that this is the `<span>`
         * element created by FusionCharts to render the chart. It is not the container element that was specified
         * during rendering the chart as the `renderAt` parameter.
         *
         * @param {string} id - The ID of the chart, whose `DOMElement` is to be referenced.
         *
         * @group framework
         * @since 3.1.1
         * @deprecated 3.2.0 - This method has been deprecated as direct access to `DOMElement` of the chart has become
         * redundant. {@link FusionCharts#ref} property can be used in the rare case where such access to the
         * `DOMElement` of a chart is required.
         *
         * @returns {DOMElement}
         *
         * @example
         * // Iterate on all charts rendered on a page and move them to a common location
         * var sidebar = document.getElementById('sidebar-html-div'), // assuming that your common container is this
         *     chart;
         *
         * for (chart in FusionCharts.items) {
         *     sidebar.appendChild(FusionCharts.getObjectReference(chart).parentNode);
         * }
         *
         * // The above can be done without using this deprecated getObjectReference method.
         * for (chart in FusionCharts.items) {
         *     chart = FusionCharts.items[chart];
         *     chart.ref && sidebar.appendChild(chart.ref.parentNode);
         * }
         */
        getObjectReference: function (id) {
            return global.core.items[id].ref;
        },

        /**
         * Extend FusionCharts functionalities by adding modules and other items.
         * @private
         *
         * @param {string} what - The type of extension that can be done. The possible values can be `"module"`,
         * `"theme"`, etc.
         * @param {...*} args - Depending upon what you want to register, supply the relevant registration items.
         */
        register: function (what) {
            return global.registrars[(what = (what && what.toString && what.toString().toLowerCase()))] &&
                global.registrars[what].apply(global.core, Array.prototype.slice.call(arguments, 1));
        }
    });

    // Expose the core to the global scope.
    win.FusionCharts = global.core;

    // Check whether legacy FusionMaps already exists at this point in execution
    // time. If yes, then we need to perform routines to assimilate it.
    if (win.FusionMaps && win.FusionMaps.legacy) {
        global.core(['private', 'modules.core.geo',
            win.FusionMaps.legacy, win.FusionMaps.version]);
        mapLegacyDiscovered = true;
    }
    // If FusionMaps legacy was not discovered, we give it another shot after
    // the page has loaded.
    if (!(hasLoaded.test(doc.readyState) || doc.loaded)) {
        (function () {

            var _timer, script;

            function init() {
                /* jshint noarg: false */
                // quit if this function has already been called
                if (arguments.callee.done){return;}

                // flag this function so we don't do the same thing twice
                arguments.callee.done = true;

                // kill the timer
                if (_timer){clearTimeout(_timer);}

                if (!mapLegacyDiscovered) {
                    if (win.FusionMaps && win.FusionMaps.legacy) {
                        global.core(['private', 'modules.core.geo',
                            win.FusionMaps.legacy, win.FusionMaps.version]);
                    }
                    win.FusionMaps = global.core;
                }

                // Notify that library is ready for consumption.
                setTimeout(notifyLibraryInit, 1);
            }

            function checkInit () {
                if (hasLoaded.test(doc.readyState)) {
                    init(); // call the onload handler
                }
                else {
                    _timer = setTimeout(checkInit, 10);
                }
            }

            if (doc.addEventListener) {
                doc.addEventListener('DOMContentLoaded', init, false);
            }
            else if (doc.attachEvent) {
                win.attachEvent('onLoad', init);
            }

            if (isIE) {
                try {
                    if (win.location.protocol === 'https:') {
                        doc.write('<script id="__ie_onload_fusioncharts" defer="defer" src="//:"><\/script>');
                    }
                    else {
                        doc.write('<script id="__ie_onload_fusioncharts" defer="defer" ' +
                            'src="javascript:void(0)"><\/script>');
                    }
                    script = doc.getElementById('__ie_onload_fusioncharts');
                    script.onreadystatechange = function() {
                        if (this.readyState == 'complete') {
                            init(); // call the onload handler
                        }
                    };
                } catch (e) {}
            }

            if (/WebKit/i.test(nav.userAgent)) { // sniff
                _timer = setTimeout(checkInit, 10);
            }

            win.onload = (function (callback) {
                return function () {
                    init();
                    callback && callback.call && callback.call(win);
                };
            })(win.onload);
        }());
    }
    else {
        // already marking it ready means that notifier will let know that page
        // has already been loaded.
        global.ready = true;
        setTimeout(notifyLibraryInit, 1);
    }

    // In any case, we expose the latest core. If legacy overrides it on page
    // load, that would be handled
    win.FusionMaps = global.core;
}());
/**
 * This module allows other FusionCharts JavaScript Library modules to raise
 * error and warning messages.
 * @private
 *
 * @module fusioncharts.debugger
 * @requires fusioncharts.constructor
 */
FusionCharts.register('module', ['private', 'modules.mantle.errormanager', function () {

    var global = this,
        win = global.window,
        /**
         * Set the default options for the default output helper
         * @constant
         * @type String
         */
        DEFAULT_OUTPUT_HELPER = 'text',
        DEBUGGER = 'debugger',

        /**
         * The debugging events {@link FusionCharts.debugger#event:error} and
         * {@link FusionCharts.debugger#event:warning} pass on the "nature" of the error/warning as its argument. The
         * value of this argument is one from the following list - giving a summary of the category of the error/warning
         * raised.
         *
         * <table>
         * <thead><tr><th>Name</th><th>Description</th></tr></thead>
         * <tbody>
         * <tr><td>`TypeException`</td>
         *     <td>Type mismatch of an input being processed. For example, `null` or `undefined` has been found in an
         *         operation where only `string` type of data is expected.</td>
         * </tr>
         * <tr><td>`ValueRangeException`</td>
         *     <td>The error or warning event was caused due to a critical value involved during an operation is outside
         *         the acceptable range.</td>
         * </tr>
         * <tr><td>`ParameterException`</td>
         *     <td>This exception is caused when a parameter passed on to a function is missing or is in an unacceptable
         *         format.</td>
         * </tr>
         * <tr><td>`RuntimeException`</td>
         *     <td>When a specific combination of inputs caused a process to reach a computational error such as
         *         division by zero, mathematical operation on non-numeric values, etc - this nature of warning or error
         *         is raised.</td>
         * </tr>
         * <tr><td>`DesignTimeException`</td>
         *     <td>Specific implementations of FusionCharts library may cause issues on
         *         specific browsers. Such issues (wherever detected) is notified as `DesignTimeException`. An example
         *         for the same would be having a chart's variable name exposed globally and also be similar to the
         *         chart's Id - this causes issue on older versions of Internet Explorer browser.</td>
         * </tr>
         * <tr><td>`NotImplementedException`</td>
         *     <td>You've hit a jackpot! The operation  that caused this error or wanning is planned, but not yet
         *         implemented. Welcome to the future!</td>
         * </tr>
         * <tr><td>`UnspecifiedException`</td>
         *     <td>Exceptions that were trapped but specific cause of the same is not ascertained.</td>
         * </tr>
         * </tbody>
         * </table>
         *
         * @name FusionCharts.debugger~errorNatures
         */
        errorNatures = {
            type: 'TypeException',
            range: 'ValueRangeException',
            impl: 'NotImplementedException',
            param: 'ParameterException',
            run: 'RuntimeException',
            comp: 'DesignTimeError',
            'undefined': 'UnspecifiedException'
        },

        /**
         * This function raises the error event after appropriately formatting the parameters.
         *
         * @param {FusionCharts} sender
         * @param {string} id Is the error reference id.
         * @param {string} nature Is a cue as to what category of error is this. The value of this param must be same as
         * one of the "keys" within the "errorNatures" collection.
         * @param {string} source Is a cue as to which object/module caused this error.
         * @param {Error} err
         * @param {string} level Indicates whether this error event is an error or warning event. Its values can be
         * "Error" or "Warning".
         */
        raiseEWEvent = function (sender, id, nature, source, err, level) {

            // We create a human-readable message for this error.
            var message = '#' + id + ' ' + (sender ? sender.id : 'unknown-source') +
                source + ' ' + level + ' >> ',
                args;

            // If err is sent as error object, we input more details to the error
            // object
            if (err instanceof Error) {
                err.name = errorNatures[nature];
                err.module = 'FusionCharts' + source;
                err.level = level;

                // Update the error message.
                err.message = message + err.message;
                message = err.message;

                // Throw error in a separate scope so that the execution of this script
                // is not blocked. Do this only when debugger is enabled
                win.setTimeout(function () {
                    throw err;
                }, 0);

            }
            else {
                // Append the message string to the error message and sync with err.
                message = message + err;
            }

            // Prepare the event argument object.
            args = {
                id: id,
                nature: errorNatures[nature],
                source: 'FusionCharts' + source,
                message: message
            };

            global.raiseEvent(level, args, sender);

            // Raise legacy events
            if (typeof win['FC_' + level] === 'function') {
                win['FC_' + level](args);
            }

        },

        logger; // namespace

    /**
     * This function raises an "Error" event based upon the parameters passed to it.
     *
     * @param {FusionCharts} sender
     * @param {string} id Is the error reference id.
     * @param {string} nature Is a cue as to what category of error is this. The value of this param must be same as one
     * of the "keys" within the "errorNatures" collection.
     * @param {string} source Is a cue as to which object/module caused this error.
     * @param {string} message
     */
    global.raiseError = function (sender, id, nature, source, message) {
        /**
         * FusionCharts framework is designed to be non disruptive in execution. This means that in case of an error,
         * the library would attempt recovery or graceful fallback or not render a chart. It should ideally not raise
         * a JavaScript runtime error unless at places that is intended to raise error or when unexpected runtime errors
         * occur.
         *
         * For known error causing situations, this `error` event is raised with an error code and a message guiding to
         * the possible cause of error. In situtations where charts behave unexpectedly, this event can be subscribed
         * to discover possible errors.
         *
         * Furthermore, these events are forwarded to the {@link FusionCharts.debugger} output and when `debugger` is
         * enabled, any such error event would be visible.
         *
         * @event FusionCharts.debugger#error
         * @param {string} id - Reference ID of the error being raised.
         * @param {FusionCharts.debugger~errorNatures} nature - Is a cue as to what category of error is this.
         * The value of this param must be same as one from within  the {@link FusionCharts.debugger~errorNatures}
         * collection.
         * @param {string} source - source is a cue as to which object/module caused this error.
         * @param {string} message - The content of this argument is generally a human comprehensible message denoting
         * the cause of the error being raised.
         */
        raiseEWEvent(sender, id, nature, source, message, 'Error');
    };

    /**
     * This function raises an "Warning" event based upon the parameters passed to it.
     *
     * @param {FusionCharts} sender
     * @param {string} id Is the error reference id.
     * @param {string} nature Is a cue as to what category of error is this. The value of this param must be same as one
     * of the "keys" within the "errorNatures" collection.
     * @param {string} source Is a cue as to which object/module caused this error.
     * @param {string} message
     */
    global.raiseWarning = function (sender, id, nature, source, message) {
        /**
         * Certain implementation setup, browser or combination of the both cause unexpected scenarios during the
         * rendering process of a chart. Whenever such situations are encountered that "may" cause issue but,
         * during the propagation of the event, has been compensated for. FusionCharts keeps the developer in the loop
         * by issuing this warning event.
         *
         * @event FusionCharts.debugger#warning
         *
         * @param {string} id - Reference ID of the warning being raised.
         * @param {FusionCharts.debugger~errorNatures} nature - Is a cue as to what category of warning is this.
         * The value of this param must be same as one from within  the {@link FusionCharts.debugger~errorNatures}
         * collection.
         * @param {string} source - source is a cue as to which object/module caused this error.
         * @param {string} message - The content of this argument is generally a human comprehensible cause of the error
         * being raised.
         */
        raiseEWEvent(sender, id, nature, source, message, 'Warning');
    };

    /**
     * ~var {object} logger Conatins all routines pertaining to logging a debug
     * outout.
     */
    logger = {
        /**
         * When debugger is enabled, it forwards its output to a callback function as explained in
         * {@link FusionCharts.debugger~debuggerCallback}. The parameters that can be forwarded to this callback
         * function can be adjusted based on the `outputFormat` set on the debugger. The `outputFormat`
         * can be configured using the function {@link FusionCharts.debugger.outputFormat} or by passing a format to
         * the third parameter of the function {@link FusionCharts.debugger.enable}.
         *
         * The different output formats that the debugger provides are:
         *
         * 1. `text` - (default) Meant for simple text output from the debugger
         * 2. `event` - Outputs the debugger messages in an event-like format, similar to
         *    {@link FusionCharts.eventListener}.
         * 3. `verbose` - Forwards all debugger messages and its associated arrguments as separate parameters.
         *
         * @name FusionCharts.debugger~outputFormats
         * @enum
         *
         * @property {string} text - With `text` set as the output format of debugger, the debugger callback function
         * receives only a single string parameter that contains details regarding the activities going on within the
         * FusionCharts framework.
         * @property {string} text.message - The single parameter that is passed on to the
         * {@link FusionCharts.debugger~debuggerCallback} function is the error message in a pre-formatted form
         * `#<event-id> fired "<event-name>" event.`
         *
         * @property {string} event - Function that calls the debugger method in typical FusionCharts events argument
         * format as specified in {@link FusionCharts~eventListener}. In this format, the output callback function
         * receives two arguments - the `eventObject` and the `eventArgument`.
         * @property {object} event.eventObject - This contains details regarding the event itself - such us the name
         * of the event, reference to the chart that raised this event, etc. More details regarding the properties of
         * this object is at {@link FusionCharts~eventListener}.
         * @property {object} event.eventArgument - This parameter is an object that contains information relevant to
         * the particular event being triggered. They are specific to each event.
         *
         * @property {string} verbose - This function formats outputs with all details, and still maintains a human
         * readable format. It is best used in conjunction with an advanced JavaScript console.
         * @property {number} verbose.eventId - This parameter is the incremental `id` that is associated to every new
         * event being fired. Even if the events are not received in order, their sequence of trigger can be inferred
         * from the event Id.
         * @property {string} verbose.senderId - The reference to the object that has triggered the debugger event.
         * @property {object} verbose.eventArguments - This parameter is an object that contains information relevant to
         * the particular event being triggered. They are specific to each event.
         */
        outputHelpers: {
            'text': function (e, a) {
                var sender = (e.sender.id || e.sender).toString();
                logger.outputTo('#' + e.eventId + ' [' + sender + '] fired "' +
                    e.eventType + '" event. ' + (e.eventType === 'error' ||
                    e.eventType === 'warning' ? a.message : ''));
            },

            'event': function (e, a) {
                this.outputTo(e, a);
            },

            'verbose': function (e, a) {
                logger.outputTo(e.eventId, e.sender.id, e.eventType, a);
            }
        },

        /**
         * ~var {object} outputHandler Is the eventHandler that indirectly calls
         * the output function via output helpers whenever any event is raised.
         */
        outputHandler: function (e, a) {
            // Verify whether the output function exists or not.
            if (typeof logger.outputTo !== 'function') {
                global.core[DEBUGGER].outputFailed = true;
                return;
            }
            // Clear flag of data load fail upon reaching this line.
            global.core[DEBUGGER].outputFailed = false;
            // Call the current outputHelper in order to invoke the
            // required function.
            logger.currentOutputHelper(e, a);
        },

        /**
         * ~var {function} currentOutputHelper Is the function that formats the
         * debug output if event format to different formats as arguments.
         * ~var {function} outputTo Is the reference to the function that is
         * called when a debug event is raised.
         * ~var {boolean} keeps a track whether the logger is enabled or not.
         */
        currentOutputHelper: undefined,

        outputTo: undefined,

        enabled: false
    };

    // Set the initial default output helper to the one specified as default.
    logger.currentOutputHelper = logger.outputHelpers[DEFAULT_OUTPUT_HELPER];

    // Add debugger API to FusionCharts core object, so that it can be accessed
    // by users globally.

    global.extend(global.core, {
        /**
         * The `debugger` is used to trace errors within charts and verify the flow of events for a chart in case of
         * unexpected behaviors. The `debugger` logs all activities resulting from firing of all events in the
         * framwork.
         *
         * __For more information on how to enable the debugger, refer to {@link FusionCharts.debugger.enable}.__
         *
         * > The `debugger` should not be used in a production environment. It is intended only to be used in
         * > development or staging.
         * >
         * > To ensure compatibility with older versions of Internet Explorer, the `debugger` object should be called as
         * > `FusionCharts['debugger']` instead of `FusionCharts.debugger`.
         *
         * @namespace FusionCharts.debugger
         *
         * @example
         * // Use the debugger to output the debugger messages to JavaScript console.
         * FusionCharts["debugger"].enable(true, function (message) {
         *     console.log(message);
         * });
         */
        'debugger': /** @lends FusionCharts.debugger */{
            /**
             * Useful for Flash renderer to toggle isolated debug-modes of individual charts.
             * @ignore
             */
            syncStateWithCharts: true,

            /**
             * Specifies how to format the output of the function that will accept output from the debugger.
             *
             * @param {FusionCharts.debugger~outputFormats} format - Can be one of the accepted format names such as
             * `text`, `verbose`, `event` as available in {@link FusionCharts.debugger~outputFormats}.
             */
            outputFormat: function (format) {
                // Validate the parameter.
                if (format && typeof format.toLowerCase === 'function' &&
                    typeof logger.outputHelpers[format = format.toLowerCase()] === 'function') {
                    // set the current output helper function to the one specified
                    // in parameter
                    logger.currentOutputHelper = logger.outputHelpers[format];
                    // Return "true" to users, indicating, output format
                    // successfully updated.
                    return true;
                }
                // In case validation fails, notify user that it failed by
                // returning false;
                return false;
            },

            /**
             * The debugger of FusionCharts framework is cabaple of receiving all messages, logs and events that occur
             * internally within the framework. However, the debugger has no way to output these messages. So, the
             * {@link FusionCharts.debugger~debuggerCallback} function needs to be attached to the debugger to which all
             * such debug messages get forwarded. This lets to output a custom function to output the message at a
             * desired location.
             *
             * This method allows specifying the function to which the debugger output will be redirected, i.e., the
             * activities of the debgger will be forwarded to a function provided through this method.
             *
             * @param {FusionCharts.debugger~debuggerCallback} debuggerCallback - This is the function to which the
             * debugger output will be passed on. Sending the value as `null` removes (detaches) the `debuggerCallback`
             * and subsequently disables the debugger.
             *
             * @example
             * <!-- In this example we will render a chart and output the debugger
             *      messages to an area within the page. -->
             * <html>
             * <head>
             * <script type="text/javascript" src="fusioncharts.js"></script>
             * <script type="text/javascript">
             * FusionCharts["debugger"].outputTo(function (message) {
             *     document.getElementById('debugger-output').innerHTML += '<p>' +
             *         message + '</p>';
             * });
             * FusionCharts["debugger"].enable(true);
             *
             * // Render a chart
             * FusionCharts.ready(function () {
             *     FusionCharts.render({
             *         type: 'pie2d',
             *         renderAt: 'chart-container',
             *         dataSource: {
             *             chart: {
             *                 caption: 'Sales Summary',
             *                 numberPrefix: '$'
             *             },
             *             data: [
             *                 { value: 234, label: 'Q1' },
             *                 { value: 167, label: 'Q2' },
             *                 { value: 110, label: 'Q3' },
             *                 { value: 36, label: 'Q4' }
             *             ]
             *         }
             *     });
             * });
             * </script>
             *
             * <!-- Style the debugger output to fix it in top right cormer of the page -->
             * <style type="text/css">
             * #debugger-output {
             *     position: absolute;
             *     top: 0;
             *     right:0;
             *     width: 300px;
             *     height: 125px;
             *     overflow: auto;
             * }
             * </style>
             * </head>
             * <body>
             *     <!-- we create a div element and position it in top
             *          right corner of the page -->
             *     <div id="debugger-output"></div>
             *     <div id="chart-container"></div>
             *  </body>
             *  </html>
             */
            outputTo: function (debuggerCallback) {
                // Check whether the logger is a function or not. If it is a
                // function, we set a reference to it to be used later as the
                // logger function.
                if (typeof debuggerCallback === 'function') {
                    /**
                     * The parameters passed on to the debugger callback function is in line with the value of
                     * {@link FusionCharts.debugger~outputFormats} specified via {@link FusionCharts.debugger.outputTo}.
                     * @callback FusionCharts.debugger~debuggerCallback
                     *
                     * @param {...*} outputFormatParameters - The parameters passed to the callback depend upon the
                     * debugger output format set. The details regarding the different variants of parameter is at
                     * {@link FusionCharts.debugger~outFormats}.
                     */
                    logger.outputTo = debuggerCallback;
                }

                // In case user sends 'null' as the value of the logger function,
                // we can assume that user wants not to log any output.
                else if (debuggerCallback === null) {
                    global.core[DEBUGGER].enable(false);
                    delete logger.outputTo;
                }
            },

            /**
             * The FusionCharts debugger is not enabled by default. This method allows us to enable the debugger and
             * also optionally provide basic debugger configuration.
             *
             * The debugger works in conjunction with the browser's JavaScript console or any other special console-like
             * implementation that you may have. To enable the debugger, call this function and pass a callback that
             * outputs the message to the JavaScript console. The code would log the activities of every chart and the
             * entire framework.
             *
             * ```
             * FusionCharts['debugger'].enable(true, function (message) {
             *     console.log(message);
             * });
             * ```
             *
             * If you have added this code right after including the `fusioncharts.js` script in a page that renders a
             * single chart with id "myChart", your output would look somewhat like:
             *
             * ```
             * #1 [FusionCharts] fired "ready" event.
             * #2 [myChart] fired "beforeinitialize" event.
             * #3 [myChart] fired "beforedataupdate" event.
             * #4 [myChart] fired "dataupdated" event.
             * #5 [myChart] fired "initialized" event.
             * #6 [myChart] fired "beforerender" event.
             * #7 [myChart] fired "internal.loaded" event.
             * #8 [myChart] fired "internal.drawstart" event.
             * #9 [myChart] fired "dataloaded" event.
             * #10 [myChart] fired "internal.domelementcreated" event.
             * #11 [myChart] fired "loaded" event.
             * #12 [myChart] fired "drawcomplete" event.
             * #13 [myChart] fired "rendercomplete" event.
             * ```
             *
             * The output clearly shows that FusionCharts declared itself as `ready` and then the chart followed the
             * routine of initialising itself, loading data, loading dependencies and then completing the rendering
             * process. Had there been any error, it would have reflected in the output.
             *
             * > The debugger is not intended to be kept enabled on a production server since it has performance and
             * > memory requirement overhead. It is meant for pre-production debugging only.
             *
             * @param {boolean} state - Specifies whether to enable logging of debug information.
             *
             * @param {FusionCharts.debugger~debuggerCallback=} [outputTo] - The function to which the debugger output
             * will be passed on.
             *
             * @param {FusionCharts.debugger~outputFormats=} [outputFormat="text"] - Can be one of the accepted format
             * names such as "text", "verbose", "event".
             *
             * @returns {boolean} The current 'enable' state of the debugger.
             */
            enable: function (state, outputTo, outputFormat) {

                // Allow object to be sent as configuration parameter.
                var config;
                // In case the first parameter is object and the only parameter,
                // we copy its contents to various linear parameters and save
                // a copy of the object for later use.
                if (typeof state === 'object' && arguments.length === 1) {
                    config = state;
                    state = config.state;
                    outputTo = config.outputTo;
                    outputFormat = config.outputFormat;
                }

                // In case user send in only one parameter and that too a
                // function, we can assume that he wants to use it as a logger
                // function and also enable logging.
                if (typeof state === 'function') {
                    if (typeof outputTo === 'string' && (arguments.length === 2 || config)) {
                        outputFormat = outputTo;
                    }
                    outputTo = state;
                    state = true;
                }

                // In case user sends in a valid parameter to change the current
                // state of the debugger, we update the debugger state.
                if (typeof state === 'boolean' && state !== logger.enabled) {
                    global.core[(logger.enabled = state) ? 'addEventListener'
                        : 'removeEventListener']('*', logger.outputHandler);
                }

                // If user sends in a parameter for the logger parameter, we
                // set it to the logger function reference.
                if (typeof outputTo === 'function') {
                    logger.outputTo = outputTo;
                }

                // Set output format if needed.
                global.core[DEBUGGER].outputFormat(outputFormat);

                // Finally send the current debugger state to the user.
                return logger.enabled;
            },

            /**
             * *(experimental)* This method fetches FirebugLite component's code and adds it to current page.
             * Subsequently, on load of the script it enables advanced console logging to it. This is very useful for
             * debugging on older Internet Explorer browsers and on mobile device browsers that do not have a JavaScript
             * debugging console.
             *
             * Visit http://getfirebug.com/firebuglite for more information on this very popular component. This
             * function fetches the script from their latest stable release channel as mentioned in
             * http://getfirebug.com/firebuglite#Stable
             */
            enableFirebugLite: function () {
                var htmlTags;

                // Check whether firebug already exists.
                /*jslint devel:true */
                if (win.console && win.console.firebug) {
                    // If firebug already exists, we do not need to include any
                    // script for firebu-lite and we simply enable logging to
                    //console.
                    global.core[DEBUGGER].enable(win.console.log, 'verbose');
                    return;
                }
                /*jslint devel:false */

                // Install firebug-lite within page by creating new 'script' element and appending to page head.
                htmlTags = win.document.getElementsByTagName('html');
                htmlTags && htmlTags[0].setAttribute('debug', 'true');
                global.loadScript('https://getfirebug.com/firebug-lite.js#overrideConsole=false,startOpened=true',
                        function () {
                    global.core[DEBUGGER].enable(win.console.log, 'verbose');
                }, '{ startOpened: true }', true, true);

            }
        },

        /**
         * @deprecated 3.4.0 - Please use FusionCharts.debugger.enable instead
         * @private
         */
        debugMode: {
            enabled: function () {
                win.setTimeout(function() {
                    throw new Error('Deprecated! Please use FusionCharts.debugger.enable instead.');
                }, 0);
                return global.core[DEBUGGER].enable.apply(global.core[DEBUGGER], arguments);
            }
        }
    }, false);
}]);
/**
 * This module allows FusionCharts to work with W3C Level 2 style events for
 * allowing multiple handlers per event and also to do event driven development
 * on a global or per-chart basis.
 * @private
 *
 * @module fusioncharts.events
 * @requires fusioncharts.constructor
 * @requires fusioncharts.debugger
 */
FusionCharts.register('module', ['private', 'modules.mantle.eventmanager', function () {

    var global = this,
        win = global.window,
        core = global.core,

        objectProtoToString = win.Object.prototype.toString,
        arrayToStringIdentifier = objectProtoToString.call([]),
        isArray = function(obj) {
            return objectProtoToString.call(obj) === arrayToStringIdentifier;
        },

        // A function to create an abstraction layer so that the try-catch /
        // error suppression of flash can be avoided while raising events.
        managedFnCall = function (item, scope, event, args) {
            // We change the scope of the function with respect to the
            // object that raised the event.
            try {
                item[0].call(scope, event, args || {});
            }
            catch (e) {
                // Call error in a separate thread to avoid stopping
                // of chart load.
                setTimeout(function () {
                    throw e;
                }, 0);
            }
        },

        // Function that executes all functions that are to be invoked upon trigger
        // of an event.
        slotLoader = function (slot, event, args) {
            // If slot does not have a queue, we assume that the listener
            // was never added and halt method.
            if (!(slot instanceof Array)) {
                // Statutory W3C NOT preventDefault flag
                return;
            }

            // Initialize variables.
            var i = 0, scope;

            // Iterate through the slot and look for match with respect to
            // type and binding.
            for (; i < slot.length; i += 1) {

                // If there is a match found w.r.t. type and bind, we fire it.
                if (slot[i][1] === event.sender || slot[i][1] === undefined) {

                    // Determine the sender of the event for global events.
                    // The choice of scope differes depending on whether a
                    // global or a local event is being raised.
                    scope = slot[i][1] === event.sender ?
                        event.sender : global.core;

                    managedFnCall(slot[i], scope, event, args);

                    // Check if the user wanted to detach the event
                    if (event.detached === true) {
                        slot.splice(i, 1);
                        i -= 1;
                        event.detached = false;
                    }
                }

                // Check whether propagation flag is set to false and discontnue
                // iteration if needed.
                if (event.cancelled === true) {
                    break;
                }
            }
        },

        EventTarget = {

            unpropagator: function () {
                return (this.cancelled = true) === false;
            },
            detacher: function () {
                return (this.detached = true) === false;
            },
            undefaulter: function () {
                return (this.prevented = true) === false;
            },

            // Entire collection of listeners.
            listeners: {},

            // The last raised event id. Allows to calculate the next event id.
            lastEventId: 0,

            addListener: function (type, listener, bind) {

                var recurseReturn,
                    i;
                // In case type is sent as array, we recurse this function.
                if (isArray(type)) {
                    recurseReturn = [];
                    // We look into each item of the 'type' parameter and send it,
                    // along with other parameters to a recursed addListener
                    // method.
                    for (i = 0; i < type.length; i += 1) {
                        recurseReturn.push(EventTarget.addListener(type[i], listener, bind));
                    }
                    return recurseReturn;
                }

                // Validate the type parameter. Listener cannot be added without
                // valid type.
                if (typeof type !== 'string') {
                    /**
                     * The event name has not been provided while adding an event listener. Ensure that you pass a
                     * `string` to the first parameter of {@link FusionCharts.addEventListener}.
                     *
                     * @typedef {ParameterException} Error-03091549
                     * @memberOf FusionCharts.debugger
                     * @group debugger-error
                     */
                    global.raiseError(bind || global.core, '03091549', 'param', '::EventTarget.addListener',
                        new Error('Unspecified Event Type'));
                    return;
                }

                // Listener must be a function. It will not eval a string.
                if (typeof listener !== 'function') {
                    /**
                     * The event listener passed to {@link FusionCharts.addEventListener} needs to be a function.
                     *
                     * @typedef {ParameterException} Error-03091550
                     * @memberOf FusionCharts.debugger
                     * @group debugger-error
                     */
                    global.raiseError(bind || global.core, '03091550', 'param', '::EventTarget.addListener',
                        new Error('Invalid Event Listener'));
                    return;
                }

                // Desensitize the type case for user accessability.
                type = type.toLowerCase();

                // If the insertion position does not have a queue, then create one.
                if (!(EventTarget.listeners[type] instanceof Array)) {
                    EventTarget.listeners[type] = [];
                }

                // Add the listener to the queue.
                EventTarget.listeners[type].push([listener, bind]);

                return listener;
            },

            removeListener: function (type, listener, bind) {

                var slot,
                    i;

                // Listener must be a function. Else we have nothing to remove!
                if (typeof listener !== 'function') {
                    /**
                     * The event listener passed to {@link FusionCharts.removeEventListener} needs to be a function.
                     * Otherwise, the event listener function has no way to know which function is to be removed.
                     *
                     * @typedef {ParameterException} Error-03091560
                     * @memberOf FusionCharts.debugger
                     * @group debugger-error
                     */
                    global.raiseError(bind || global.core, '03091560', 'param', '::EventTarget.removeListener',
                        new Error('Invalid Event Listener'));
                    return;
                }

                // In case type is sent as array, we recurse this function.
                if (type instanceof Array) {
                    // We look into each item of the 'type' parameter and send it,
                    // along with other parameters to a recursed addListener
                    // method.
                    for (i = 0; i < type.length; i += 1) {
                        EventTarget.removeListener(type[i], listener, bind);
                    }
                    return;
                }

                // Validate the type parameter. Listener cannot be removed without
                // valid type.
                if (typeof type !== 'string') {
                    /**
                     * The event name passed to {@link FusionCharts.removeEventListener} needs to be a string.
                     *
                     * @typedef {ParameterException} Error-03091559
                     * @memberOf FusionCharts.debugger
                     * @group debugger-error
                     */
                    global.raiseError(bind || global.core, '03091559', 'param', '::EventTarget.removeListener',
                        new Error('Unspecified Event Type'));
                    return;
                }

                // Desensitize the type case for user accessability.
                type = type.toLowerCase();

                // Create a reference to the slot for easy lookup in this method.
                slot = EventTarget.listeners[type];

                // If slot does not have a queue, we assume that the listener
                // was never added and halt method.
                if (!(slot instanceof Array)) {
                    return;
                }

                // Iterate through the slot and remove every instance of the
                // event handler.
                for (i = 0; i < slot.length; i += 1) {
                    // Remove all instances of the listener found in the queue.
                    if (slot[i][0] === listener && slot[i][1] === bind) {
                        slot.splice(i, 1);
                        i -= 1;
                    }
                }
            },

            // opts can have { async:true, omni:true }
            triggerEvent: function (type, sender, args, eventScope, defaultFn, cancelFn) {

                // In case, event type is missing, dispatch cannot proceed.
                if (typeof type !== 'string') {
                    /**
                     * The event name passed to {@link FusionCharts.removeEventListener} needs to be a string.
                     * @private
                     *
                     * @typedef {ParameterException} Error-03091602
                     * @memberOf FusionCharts.debugger
                     * @group debugger-error
                     */
                    global.raiseError(sender, '03091602', 'param', '::EventTarget.dispatchEvent',
                        new Error('Invalid Event Type'));
                    return undefined;
                }

                // Desensitize the type case for user accessability.
                type = type.toLowerCase();

                // Model the event as per W3C standards. Add the function to cancel
                // event propagation by user handlers. Also append an incremental
                // event id.
                var eventObject = {
                    eventType: type,
                    eventId: (EventTarget.lastEventId += 1),
                    sender: sender || new Error('Orphan Event'),
                    cancelled: false,
                    stopPropagation: this.unpropagator,
                    prevented: false,
                    preventDefault: this.undefaulter,
                    detached: false,
                    detachHandler: this.detacher
                };

                /**
                 * Event listeners are used to tap into different stages of creating, updating, rendering or removing
                 * charts. A FusionCharts instance fires specific events based on what stage it is in. For example, the
                 * `renderComplete` event is fired each time a chart has finished rendering. You can listen to any such
                 * event using {@link FusionCharts.addEventListener} or {@link FusionCharts#addEventListener} and bind
                 * your own functions to that event.
                 *
                 * These functions are known as "listeners" and are passed on to the second argument (`listener`) of the
                 * {@link FusionCharts.addEventListener} and {@link FusionCharts#addEventListener} functions.
                 *
                 * @callback FusionCharts~eventListener
                 * @see FusionCharts.addEventListener
                 * @see FusionCharts.removeEventListener
                 *
                 * @param {object} eventObject - The first parameter passed to the listener function is an event object
                 * that contains all information pertaining to a particular event.
                 *
                 * @param {string} eventObject.type - The name of the event.
                 *
                 * @param {number} eventObject.eventId - A unique ID associated with the event. Internally it is an
                 * incrementing counter and as such can be indirectly used to verify the order in which  the event was
                 * fired.
                 *
                 * @param {FusionCharts} eventObject.sender - The instance of FusionCharts object that fired this event.
                 * Occassionally, for events that are not fired by individual charts, but are fired by the framework,
                 * will have the framework as this property.
                 *
                 * @param {boolean} eventObject.cancelled - Shows whether an  event's propagation was cancelled or not.
                 * It is set to `true` when `.stopPropagation()` is called.
                 *
                 * @param {function} eventObject.stopPropagation - Call this function from within a listener to prevent
                 * subsequent listeners from being executed.
                 *
                 * @param {boolean} eventObject.prevented - Shows whether the default action of this event has been
                 * prevented. It is set to `true` when `.preventDefault()` is called.
                 *
                 * @param {function} eventObject.preventDefault - Call this function to prevent the default action of an
                 * event. For example, for the event {@link FusionCharts#event:beforeResize}, if you do
                 * `.preventDefault()`, the resize will never take place and instead
                 * {@link FusionCharts#event:resizeCancelled} will be fired.
                 *
                 * @param {boolean} eventObject.detached - Denotes whether a listener has been detached and no longer
                 * gets executed for any subsequent event of this particular `type`.
                 *
                 * @param {function} eventObject.detachHandler - Allows the listener to remove itself rather than being
                 * called externally by {@link FusionCharts.removeEventListener}. This is very useful for one-time event
                 * listening or for special situations when the event is no longer required to be listened when the
                 * event has been fired with a specific condition.
                 *
                 * @param {object} eventArgs - Every event has an argument object as second parameter that contains
                 * information relevant to that particular event.
                 */
                slotLoader(EventTarget.listeners[type], eventObject, args);

                // Facilitate the call of a global event listener.
                slotLoader(EventTarget.listeners['*'], eventObject, args);

                // Execute default action
                switch (eventObject.prevented) {
                    case true:
                        if (typeof cancelFn === 'function') {
                            try {
                                cancelFn.call(eventScope || sender || win, eventObject,
                                    args || {});
                            }
                            catch (err) {
                                // Call error in a separate thread to avoid stopping
                                // of chart load.
                                setTimeout(function () {
                                    throw err;
                                }, 0);
                            }
                        }
                        break;
                    default:
                        if (typeof defaultFn === 'function') {
                            try {
                                defaultFn.call(eventScope || sender || win, eventObject,
                                    args || {});
                            }
                            catch (err) {
                                // Call error in a separate thread to avoid stopping
                                // of chart load.
                                setTimeout(function () {
                                    throw err;
                                }, 0);
                            }
                        }
                }

                // Statutory W3C NOT preventDefault flag
                return true;
            }
        },

        // Facilitate for raising events internally.
        raiseEvent = global.raiseEvent = function (type, args, obj, eventScope,
                defaultFn, cancelledFn) {
            return EventTarget.triggerEvent(type, obj, args, eventScope,
                defaultFn, cancelledFn);
        },

        /**
         * List of events that has an equivalent legacy event. Used by the
         * raiseEvent method to check whether a particular event raised
         * has any corresponding legacy event.
         *
         * @type object
         */
        legacyEventList = global.legacyEventList = {},

        /**
         * Maintains a list of recently raised conditional events
         * @type object
         */
        conditionChecks = {};

    global.disposeEvents = function (target) {
        var type, i;
        // Iterate through all events in the collection of listeners
        for (type in EventTarget.listeners) {
            for (i = 0; i < EventTarget.listeners[type].length; i += 1) {
                // When a match is found, delete the listener from the
                // collection.
                if (EventTarget.listeners[type][i][1] === target) {
                    EventTarget.listeners[type].splice(i, 1);
                }
            }
        }
    };
    /**
     * This method allows to uniformly raise events of FusionCharts
     * Framework.
     *
     * @param {string} name specifies the name of the event to be raised.
     * @param {object} args allows to provide an arguments object to be
     * passed on to the event listeners.
     * @param {core} obj is the FusionCharts instance object on
     * behalf of which the event would be raised.
     * @param {array} legacyArgs is an array of arguments to be passed on
     * to the equivalent legacy event.
     * @param {Event} source
     * @param {function} defaultFn
     * @param {function} cancelFn
     *
     * @type undefined
     */
    global.raiseEventWithLegacy = function (name, args, obj, legacyArgs,
            eventScope, defaultFn, cancelledFn) {
        var legacy = legacyEventList[name];
        raiseEvent(name, args, obj, eventScope, defaultFn, cancelledFn);
        if (legacy && typeof win[legacy] === 'function') {
            setTimeout(function () {
                win[legacy].apply(eventScope || win, legacyArgs);
            }, 0);
        }
    };

    /**
     * This allows one to raise related events that are grouped together and
     * raised by multiple sources. Usually this is used where a congregation
     * of successive events need to cancel out each other and behave like a
     * unified entity.
     *
     * @param {string} check is used to identify event groups. Provide same value
     * for all events that you want to group together from multiple sources.
     * @param {string} name specifies the name of the event to be raised.
     * @param {object} args allows to provide an arguments object to be
     * passed on to the event listeners.
     * @param {core} obj is the FusionCharts instance object on
     * behalf of which the event would be raised.
     * @param {object} eventScope
     * @param {function} defaultFn
     * @param {function} cancelledFn
     *
     * @returns {undefined}
     */
    global.raiseEventGroup = function (check, name, args, obj, eventScope,
            defaultFn, cancelledFn) {
        var id = obj.id,
            hash = check + id;

        if (conditionChecks[hash]) {
            clearTimeout(conditionChecks[hash]);
            delete conditionChecks[hash];
        }
        else {
            if (id && hash) {
                conditionChecks[hash] = setTimeout(function () {
                    raiseEvent(name, args, obj, eventScope, defaultFn, cancelledFn);
                    delete conditionChecks[hash];
                }, 0);
            }
            else {
                raiseEvent(name, args, obj, eventScope, defaultFn, cancelledFn);
            }
        }
    };

    // Extend the eventlisteners to internal global.
    global.addEventListener = function (type, listener) {
        return EventTarget.addListener(type, listener);
    };
    global.removeEventListener = function (type, listener) {
        return EventTarget.removeListener(type, listener);
    };

    global.extend(core, /** @lends FusionCharts */ {
        /**
         * Bind callbacks to events fired throughout FusionCharts. This method can be used to listen to events across
         * all FusionCharts instances on a page.
         *
         * An event listener is used to execute custom functions when an event is fired. FusionCharts fires events at
         * all stages of creating, updating, rendering or removing a chart. This function lets you tap into any of these
         * events and provide your own functions which will be called when those events are triggered.
         *
         * An alternative to this function is to use {@link FusionCharts#addEventListener} method on a chart instance to
         * bind to an event fired by a specific chart.
         *
         * @param {string|array} type - The event name to listen to. The event name is not case sensitive. In case you
         * want to register an event to multiple events in the same registration call, provide them as an array of event
         * names.
         * @param {FusionCharts~eventListener} listener - Pass the function that is to be executed when the event is
         * fired. Upon an event, the listeners for that event are executed sequentially with arguments that are specific
         * to that event. See {@link FusionCharts~eventListener} for more details on the arguments.
         *
         * @group event-handling:add
         * @example
         * // Show a message when a number of charts have been rendered on a page.
         * FusionCharts.ready(function {
         *     var counter = 0,
         *         threshold = 3;
         *
         *     FusionCharts.addEventListener("rendered", function (eventObject) {
         *         counter++;
         *         if (counter > threshold) {
         *             alert("More than " + threshold + "charts rendered!");
         *         }
         *     });
         * });
         */
        addEventListener: function (type, listener) {
            return EventTarget.addListener(type, listener);
        },
        /**
         * Removes an event that was originally added using {@link FusionCharts.addEventListener}.
         * @param {string} type - The event name whose listener needs to be removed/detached.
         * @param {function} listener - The listener function that needs to be removed.
         *
         * @group event-handling:remove
         */
        removeEventListener: function (type, listener) {
            return EventTarget.removeListener(type, listener);
        },

        /**
         * This function allows to register callback functions to be executed when FusionCharts library is ready to be
         * used. In general, the framework is ready after `DOMContentLoaded` browser event has been fired and all the
         * initial dependent files/modules are available. One can attach multiple callbacks by calling this function any
         * number of time.
         *
         * The callback function is executed even when attached after FusionCharts is already ready! Thus, it is
         * recommended that all entry-point and initialization codes are written within this block. This also helps in
         * neatly organizing all codes within a script file or the page `<head>` and as such contextually separating
         * code from HTML blocks.
         *
         * @param {FusionCharts~readyCallback} readyCallback - Pass a function that would be executed as callback when
         * FusionCharts framework is ready.
         * @param {*} [args={@link FusionCharts}] - Argument to be passed on to the callback function.
         * @param {function=} [context={@link FusionCharts}] - In the situation where the function passed via `fn`
         * parameter needs to be executed in a different scope than the default {@link FusionCharts} scope, pass the
         * appropriate class object here.
         *
         * @example
         * // Render a chart within a chart container `div` element.
         * FusionCharts.ready(function (FusionCharts) {
         *     var chart = new FusionCharts({
         *         type: "column2d",
         *         renderAt: "chart-container-div",
         *         dataSource: "my-chart-data.json",
         *         dataFormat: "jsonurl"
         *     });
         *     // Since we are in the `ready` block, the `chart-container-div`
         *     // element should be available by now.
         *     chart.render();
         * });
         */
        ready: function (readyCallback, args, context) {
            // Check if core is already ready or not. If not ready then we need  to attach the function to the ready
            // event listener.
            if (global.ready) {
                // If it is already ready, we do not need to check for readiness subsequently as this state cannot ever
                // rollback. Thus we redefine the function for performant consumption post readiness.
                core.ready = function (readyCallback, context) {
                    (typeof readyCallback === 'function') && setTimeout(function () {
                        /**
                         * The function passed as ready callback is executed when FusionCharts library is ready. Use
                         * {@link FusionCharts.ready} to request executing of your callback function.
                         * @callback FusionCharts~readyCallback
                         * @param {FusionCharts|*} args - By default, the parameter passed to the callback function is
                         * the FusionCharts library class unless specified otherwise in the `args` parameter of
                         * {@link FusionCharts.ready}
                         */
                        readyCallback.call(context || core, args || core);
                    }, 0);
                };
                core.ready(readyCallback, context);
            }
            else if (typeof readyCallback === 'function') {
                core.addEventListener('ready', function () {
                    core.ready(readyCallback, args, context);
                });
            }

            return this;
        }
    });
    core.on = core.addEventListener; // alias

    // Add eventListener extensibility to FusionCharts prototype so that individual FusionCharts objects can use
    // per-chart events.
    global.extend(core.prototype, /** @lends FusionCharts# */ {
        /**
         * Listen to events fired by an individual chart. For more information on the available events, refer to the
         * events section.
         *
         * @param {string|string[]} type - The event name that needs to be listened to. The event name is not case
         * sensitive. In case you want to register an event to multiple events in the same registration call, provide
         * them as an array of event names.
         * @param {FusionCharts~eventListener} listener - Pass the function that is to be executed when the event is
         * fired. Upon an event, the listeners for that event are executed sequentially with arguments that are
         * specific to that event. See {@link FusionCharts~eventListener} for more details on the arguments.
         *
         * @group event-handling:add
         */
        addEventListener: function (type, listener) {
            return EventTarget.addListener(type, listener, this);
        },
        /**
         * Removes an event that was originally added using {@link FusionCharts#addEventListener}.
         * @param {string} type - The event name whose listener needs to be removed/detached.
         * @param {function} listener - The listener function that needs to be removed.
         *
         * @group event-handling:remove
         */
        removeEventListener: function (type, listener) {
            return EventTarget.removeListener(type, listener, this);
        }
    });
    core.prototype.on = core.prototype.addEventListener; // alias

    // Add ability to parse events sent via core constructor.
    global.policies.options.events = ['events', {}];

    global.addEventListener('beforeInitialize', function (e) {
        var chart = e.sender,
            events = chart.options.events,
            key;

        if (events) {
            for (key in events) {
                if (typeof events[key] === 'function') {
                    chart.addEventListener(key, events[key]);
                }
            }
        }

    });

    // Raise library initialization event, if not already done.

    if (global.ready && !global.readyNotified) {
        global.readyNotified = true;
        /**
         * @fires FusionCharts#ready
         */
        global.raiseEvent('ready', {
            version: global.core.version,
            now: global.readyNow
        }, global.core);
    }

}]);
/**
 * This module handles all XMLHttpRequests by exposing a managed AJAX module.
 * @private
 *
 * @module fusioncharts.ajax
 * @requires fusioncharts.constructor
 */
FusionCharts.register('module', ['private', 'modules.mantle.ajax', function () {

    var global = this,
        // define constants for future use.
        FUNCTION = 'function',
        MSXMLHTTP = 'Microsoft.XMLHTTP',
        MSXMLHTTP2 = 'Msxml2.XMLHTTP',
        GET = 'GET',
        POST = 'POST',
        XHREQERROR = 'XmlHttprequest Error',
        RUN = 'run',
        ERRNO = '1110111515A',
        win = global.window, // keep a local reference of window scope

        // Probe IE version
        version = parseFloat(win.navigator.appVersion.split('MSIE')[1]),
        ielt8 = (version >= 5.5 && version <= 7) ? true : false,
        //
        // Calculate flags.
        // Check whether the page is on file protocol.
        fileProtocol = win.location.protocol === 'file:',
        AXObject = win.ActiveXObject,

        // Check if native xhr is present
        XHRNative = (!AXObject || !fileProtocol) && win.XMLHttpRequest,

        // stats
        /**
         * These counters keep a track of various http requests sent by FusionCharts. These can be retrieved using
         * {@link FusionCharts.ajax.stats}
         * @memberOf FusionCharts.ajax~
         *
         * @property {number} objects - The number of internal `Ajax` objects created by FusionCharts. This is not same
         * as `XMLHttpRequest` object since one `Ajax` object can have a number of `XMLHttpRequest` objects.
         * @property {number} xhr - A count of all `XMLHttpRequest` objects created.
         * @property {number} requests - Sum of all requests sent to server (both GET and POST.)
         * @property {number} success - The total number of requests that had a successful return from server.
         * @property {number} failure - The total number of requests that failed to communicate with server due to
         * various factors.
         * @property {number} idle - `XMLHttpRequest` objects that are idle for later use or has not been disposed yet.
         */
        counters = {
            objects: 0,
            xhr: 0,
            requests: 0,
            success: 0,
            failure: 0,
            idle: 0
        },

        // Prepare function to retrieve compatible xmlhttprequest.
        newXmlHttpRequest = function() {
            var xmlhttp;

            // if xmlhttprequest is present as native, use it.
            if (XHRNative) {
                newXmlHttpRequest = function () {
                    counters.xhr++;
                    return new XHRNative();
                };
                return newXmlHttpRequest();
            }

            // Use activeX for IE
            try {
                xmlhttp = new AXObject(MSXMLHTTP2);
                newXmlHttpRequest = function () {
                    counters.xhr++;
                    return new AXObject(MSXMLHTTP2);
                };
            }
            catch (e) {
                try {
                    xmlhttp = new AXObject(MSXMLHTTP);
                    newXmlHttpRequest = function () {
                        counters.xhr++;
                        return new AXObject(MSXMLHTTP);
                    };
                }
                catch (e) {
                    xmlhttp = false;
                }
            }
            return xmlhttp;
        },

        // Ajax class.
        Ajax;

    /**
     * @namespace FusionCharts.ajax
     */
    global.core.ajax = /** @lends FusionCharts.ajax */ {
        /**
         * Returns the statistics of AJAX requests sent by FusionCharts.
         *
         * @param {string} [type] - Optionally, one can request a specific type of statistic by providing the type as
         * one of the property-name of {@link FusionCharts.ajax~counters}.
         *
         * @returns {FusionCharts.ajax~counters} If no specific nature of statistics is passed to the `type`
         * parameter, this function would return an object containing all counters, otherwise it returns a specific
         * counter as in {@link FusionCharts.ajax~counters}.
         */
        stats: function (type) {
            return type ? counters[type] : global.extend({}, counters);
        },

        /**
         * The default `http-headers` that are sent with every AJAX request to the server. More can be added
         * and existing items can be modified.
         * @enum
         * @group framework
         */
        headers: {
            /**
             * Prevents cacheing of AJAX requests.
             * @type {string}
             */
            'If-Modified-Since': 'Sat, 29 Oct 1994 19:43:31 GMT',
            /**
             * Lets the server know that this is an AJAX request.
             * @type {string}
             */
            'X-Requested-With': 'XMLHttpRequest',
            /**
             * Lets server know which web application is sending requests.
             * @type {string}
             */
            'X-Requested-By': 'FusionCharts',
            /**
             * Mentions content-types that are acceptable for the response. Some servers require this for Ajax
             * communication.
             * @type {string}
             */
            'Accept': 'text/plain, */*',
            /**
             * The MIME type of the body of the request along with its charset.
             * @type {string}
             */
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
        }
    };

    Ajax = global.ajax = function (success, error) {
        this.onSuccess = success;
        this.onError = error;
        this.open = false;
        counters.objects++;
        counters.idle++;
    };

    global.extend(Ajax.prototype, {
        headers: global.core.ajax.headers,

        transact: function (method, url, data, callbackArgs) {
            var wrapper = this,
                xmlhttp = wrapper.xmlhttp,
                headers = wrapper.headers,
                errorCallback = wrapper.onError,
                successCallback = wrapper.onSuccess,
                isPost = (method === POST),
                postData,
                i;

            if (!xmlhttp || ielt8) {
                xmlhttp = newXmlHttpRequest();
                wrapper.xmlhttp = xmlhttp;
            }

            xmlhttp.onreadystatechange = function () {
                try {
                    if (xmlhttp.readyState === 4) {
                        if ((!xmlhttp.status && fileProtocol) || (xmlhttp.status >= 200 &&
                                xmlhttp.status < 300) || xmlhttp.status === 304 ||
                                xmlhttp.status === 1223 || xmlhttp.status === 0) {
                            successCallback &&
                                successCallback(xmlhttp.responseText, wrapper,
                                callbackArgs, url);
                            counters.success++;
                        }
                        else if (errorCallback) {
                            errorCallback(new Error(XHREQERROR), wrapper, callbackArgs, url);
                            counters.failure++;
                        }
                        counters.idle--;
                        wrapper.open = false;
                    }
                }
                catch (error) {
                    if (errorCallback) {
                        errorCallback(error, wrapper, callbackArgs, url);
                    }
                    if (win.FC_DEV_ENVIRONMENT) {
                        setTimeout(function () {
                            throw error;
                        }, 0);
                    }
                    counters.failure++;
                }
            };

            try {
                xmlhttp.open((isPost ? POST : GET), url, true);

                if (xmlhttp.overrideMimeType) {
                    xmlhttp.overrideMimeType('text/plain');
                }

                if (isPost) {
                    if (typeof data === 'string') {
                        postData = data;
                    }
                    else {
                        postData = [];
                        for (i in data) {
                            postData.push(i + '=' + (data[i] + '')
                                    .replace(/\=/g, '%3D').replace(/\&/g, '%26'));
                        }
                        postData = postData.join('&');
                    }
                }
                else {
                    postData = null;
                }
                for (i in headers) {
                    xmlhttp.setRequestHeader(i, headers[i]);
                }

                xmlhttp.send(postData);
                counters.requests++;
                counters.idle++;
                wrapper.open = true;
            }
            catch (e) {
                /**
                 * AJAX runtime error. Raised when AJAX transactions raise error (security or others). The error
                 * message describes the nature of the error.
                 *
                 * @typedef {RuntimeException} Error-1110111515A
                 * @memberOf FusionCharts.debugger
                 * @group debugger-error
                 */
                global.raiseError(global.core, ERRNO, RUN, XHREQERROR, e.message);
            }

            return xmlhttp;
        },

        get: function (url, callbackArgs) {
            return this.transact(GET, url, undefined, callbackArgs);
        },

        post: function (url, data, callbackArgs) {
            return this.transact(POST, url, data, callbackArgs);
        },

        abort: function () {
            var instance = this,
                xmlhttp = instance.xmlhttp;

            instance.open = false;
            return xmlhttp && typeof xmlhttp.abort === FUNCTION && xmlhttp.readyState &&
                    xmlhttp.readyState !== 0 && xmlhttp.abort();
        },

        dispose: function () {
            var instance = this;
            instance.open && instance.abort();

            delete instance.onError;
            delete instance.onSuccess;
            delete instance.xmlhttp;
            delete instance.open;

            counters.objects--;
            return (instance = null);
        }
    });

}]);
/**
 * Generic Runtime Module
 * @private
 *
 * @module fusioncharts.runtime
 * @requires fusioncharts.constructor
 * @requires fusioncharts.events
 * @requires fusioncharts.debugger
 */
FusionCharts.register('module', ['private', 'modules.mantle.runtime;1.1', function () {


    var global = this,
        win = global.window,

        // Set the FusionCharts filename possibilities as regular expression.
        SCRIPT_NAME_REGEX = /(^|[\/\\])(fusioncharts\.js)([\?#].*)?$/ig, // jshint ignore:line
        BLOCK_EXTERNAL_SCRIPT_LOADING = false,
        DISALLOW_CROSSDOMAIN_RESOURCE = false,
        SCRIPT_LOAD_TIMEOUTMS = 15000,

        checkBadChars = /[\\\"<>;&]/,
        hasProtocolDef = /^[^\S]*?(sf|f|ht)(tp|tps):\/\//i,
        FUNCTION = 'function',

        /**
         * Regular Expressions that helps to check XSS security loops.
         */
        LOAD_EVENTNAME = 'externalresourceload',

        /**
         * To keep a track of scripts requested.
         * @type Object
         */
        scriptsRequested = {},

        /**
         * To keep a track of loaded script tags
         */
        scriptTags = {},

        /**
         * To keep a track of scripts loaded.
         * @type Object
         */
        scriptsLoaded = {},

        /**
         * Keep a track of load failure check
         * @type object
         */
        scriptLoadFailureTimeout = {},

        /**
         * Function that safely deletes all items in a DOM element.
         */
        purgeDOM = global.purgeDOM = function (d) {
            var a = d.attributes, i, l, n;
            if (a) {
                for (i = a.length - 1; i >= 0; i -= 1) {
                    n = a[i].name;
                    if (typeof d[n] === 'function') {
                        d[n] = null;
                    }
                }
            }
            a = d.childNodes;
            if (a) {
                l = a.length;
                for (i = 0; i < l; i += 1) {
                    purgeDOM(d.childNodes[i]);
                }
            }
        },

        // Deconstruct policies.
        // Update the arguments with latest copy of all variables by
        // reverse engineering the policies.
        deconstructPolicySet = function (policies, options, obj) {
            var policy,
                prop;

            for (policy in policies) {

                // Set just the policy object in case of single-level policy.
                if (policies[policy] instanceof Array) {
                    options[policies[policy][0]] = obj[policy];
                } else {
                    // Copy the source of multi-level policies
                    for (prop in policies[policy]) {
                        options[policies[policy][prop][0]] = obj[policy][prop];
                    }
                }
            }
        },
        signatureMatchRegex = /^(FusionCharts|FusionWidgets|FusionMaps)/;

    /**
     * Function to determine the script base uri for a script name
     */
    global.getScriptBaseUri = function (scriptNameRegex) {
        // Get a collection of all script nodes.
        var scripts = win.document.getElementsByTagName('script'),
        l = scripts.length,
        src,
        i;

        // Iterate through the script node collection and match whether its
        // 'src' attribute contains fusioncharts file name.
        for (i = 0; i < l; i += 1) {
            src = scripts[i].getAttribute('src');
            if (!(src === undefined || src === null ||
                src.match(scriptNameRegex) === null)) {
                return src.replace(scriptNameRegex, '$1');
            }
        }
        return undefined;
    };

    // Get the script base uri. (Regexp has been updated)
    global.core.options.scriptBaseUri = (function () {
        var baseUri = global.getScriptBaseUri(SCRIPT_NAME_REGEX);

        if (baseUri === undefined) {
            /**
             * FusionCharts JavaScript Library automatically determines the location where it was loaded from within
             * the server. This it does by probing the `<script>` tag that has `fusioncharts.js` as a part of its `src`
             * attribute. In case, this `baseUri` cannot be determined, this error is raised. Usually, this occurs when
             *
             * 1. `fusioncharts.js` has been loaded by a script / resource loader like requireJS or jQuery
             * 2. `fusioncharts.js` has been renamed to something else and then loaded
             * 3. `fusioncharts.js` is loaded from an external domain and as search browser has enforced cross-domain
             *    security restrictions.
             *
             * @typedef {RuntimeException} Error-1603111624
             * @memberOf FusionCharts.debugger
             * @group debugger-error
             */
            global.raiseError(FusionCharts, '1603111624', 'run', '>GenericRuntime~scriptBaseUri',
                'Unable to locate FusionCharts script source location (URL).');
            return '';
        }
        return baseUri;
    }());

    /**
     * Function that allows users to verify whether a string contains any XSS
     * unsafe code. This is used while setting various urls.
     * @param {string} str The string that has to be checked for XSS
     * @param {boolean} proto Specify whether to test any protocol definition
     */
    global.isXSSSafe = function (str, proto) {
        if (proto && hasProtocolDef.exec(str) !== null) {
            return false;
        }
        return (checkBadChars.exec(str) === null);
    };

    global.xssEncode = function (s) {
        if (s === null || s === undefined || typeof s.toString !== FUNCTION) {
            return '';
        }

        // do we convert to numerical or html entity?
        s = s.toString()
            .replace(/&/g, '&amp;')
            .replace(/\'/g, '&#39;') //no HTML equivalent as &apos is not cross browser supported
            .replace(/\"/g, '&quot;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');

        return s;
    },

    /**
     * Loads a JS using head script attach method
     */
    global.loadScript = function (file, callback, scriptText, includeOnce, pathInFile) {

        // If file is not specified, we exit
        if (!file) {
            return false;
        }

        // Check security block.
        if (BLOCK_EXTERNAL_SCRIPT_LOADING === true) {
            /**
             * FusionCharts can be configured to block loading of external JavaScript files by setting the internal
             * constant `BLOCK_EXTERNAL_SCRIPT_LOADING=true;`. When this has been done, and some chart still needs
             * external resource (script) that has not been manually loaded, this warning is issued. Ensure that the
             * relevant files, such as, `fusioncharts.charts.js`, `fusioncharts.widgets.js` or other such files are
             * already included in page before rendering the chart.
             *
             * @typedef {RuntimeException} Warning-04031935
             * @memberOf FusionCharts.debugger
             * @group debugger-warning
             */
            global.raiseWarning(global.core, '04031935', 'run', '>genericRuntime~loadScript',
                'External Script loading has been blocked');
            return false;
        }

        var script,
            success = callback && callback.success || callback,
            failure = callback && callback.failure,
            path,
            src,
            eventArgs = {
                type: 'script',
                success: false
            },
            notify = function () {
                // clear stalled 404 check
                scriptLoadFailureTimeout[src] =
                        clearTimeout(scriptLoadFailureTimeout[src]);

                // execute callbacks
                eventArgs.success ? (success && success(file, src)) :
                        (failure && failure(file, src));
                /**
                 * This event is fired when other dependencies like jquery are being
                 * loaded via HTTP GET along with the chart library.
                 * @event FusionCharts#externalResourceLoad
                 * @private
                 *
                 * @param {string} file Contains the name of the external file that is
                 * being included on runtime. Example: "jquery.min.js".
                 * @param {string} path Contains relative directory location of the external file.
                 * Example: "../FusionCharts/Charts/"
                 * @param {string} src Contains the relative path of the location of the external
                 * file. Example:"../FusionCharts/Charts/jquery.min.js"
                 * @param {boolean} success Is set to true if the file is found otherwise false.
                 */
                global.raiseEvent(LOAD_EVENTNAME, eventArgs, global.core);
            };

        // Prepare path.
        if (pathInFile) {
            path = '';
        }
        else {
            path = global.core.options.scriptBaseUri;
        }

        // Prepare the full src
        src = path + file;

        // we do not allow XSS unsafe string
        if (!global.isXSSSafe(src, DISALLOW_CROSSDOMAIN_RESOURCE)) {
            src = typeof win.encodeURIComponent === 'function' ?
            win.encodeURIComponent(src) : win.escape(src);
        }

        // Update event arguments
        eventArgs.path = path;
        eventArgs.src = src;
        eventArgs.file = file;

        // Do not reload the script once loaded.
        if (scriptsLoaded[src] === true && includeOnce) {
            eventArgs.success = true;
            eventArgs.notReloaded = true;
            if (typeof callback === 'function') {
                callback();
                global.raiseEvent(LOAD_EVENTNAME, eventArgs, global.core);
            }
            return true;
        }

        // Check whether this script has been already loaded once and whether
        // multiple inclusion is prevented.
        if (scriptsRequested[src] && includeOnce) {
            return false;
        }
        // Add the src to the lists of scripts loaded.
        scriptsRequested[src] = true;

        // If a script tag with same src exists, then we need to delete the
        // previous one
        if (scriptTags[src] && scriptTags[src].parentNode) {
            scriptTags[src].parentNode.removeChild(scriptTags[src]);
        }

        // Create the script element with its attributes.
        script = scriptTags[src] = win.document.createElement('script');
        // Set the script type to javaScript
        script.type = 'text/javascript';
        // Set the prepared src as the script's src.
        script.src = src;
        // Set script inner text to what user passed as parameter.
        if (scriptText) {
            script[('\v' === 'v' ? 'text' : 'innerHTML')] = scriptText;
        }

        // Execute callback function when the script was loaded.
        if (typeof success === 'function') {
            scriptsLoaded[src] = false;
            scriptLoadFailureTimeout[src] =
                    clearTimeout(scriptLoadFailureTimeout[src]);

            script.onload = function () {
                scriptsLoaded[src] = true;
                eventArgs.success = true;

                notify();
            };

            script.onerror = function () {
                scriptsLoaded[src] = false;
                scriptsRequested[src] = false; // in case of error cancel request
                notify();
            };

            script.onreadystatechange = function () {
                if (this.readyState === 'complete' || this.readyState === 'loaded') {
                    scriptsLoaded[src] = true;
                    eventArgs.success = true;

                    notify();
                }
            };
        }

        // Append the script to the head of this page.
        win.document.getElementsByTagName('head')[0].appendChild(script);

        // Prepare the timeout check for script load failure
        if (typeof failure === 'function') {
            scriptLoadFailureTimeout[src]= setTimeout(function () {
                if (scriptsLoaded[src]) {
                    return;
                }
                notify();
            }, global.core.options.html5ResourceLoadTimeout || SCRIPT_LOAD_TIMEOUTMS);
        }

        return true;
    };

    /**
     * Capitalizes first letter of a word
     */
    global.capitalizeString = function (str, all) {
        return str ? str.replace(all ? (/(^|\s)([a-z])/g) : (/(^|\s)([a-z])/), function(m,p1,p2){
            return p1 + p2.toUpperCase();
        }) : str;
    };


    global.extend(global.core, /** @lends FusionCharts# */ {
        /**
         * Use this function to create a copy of a chart instance. Cloning a chart object results in creation of a new
         * chart with identical construction properties of the chart being cloned. A cloned chart is not rendered by
         * default and needs to be provided a container DOM element to be rendered into. A cloned chart gets one
         * auto-generated chart Id assigned.
         *
         * @group chart
         *
         * @param {?object=} [overrides] - This parameter can be very useful in instructing what changes needs to be
         * done while cloning a chart. It accepts all the construction parameters of a new {@link FusionCharts}
         * instance.
         *
         * For example, passing `pieChart.clone({type: 'column2d'});` will clone the pie chart, but set its chart-type
         * as `column2d`.
         * @param {boolean=} [argsOnly=false] - Setting this to `true` does not return a new FusionCharts object.
         * Instead, it causes the function to return a serializable object that can be later passed on while creating a
         * new FusionCharts and as such create a clone.
         *
         * @returns {FusionCharts|object}
         */
        clone: function (overrides, argsOnly) {

            // Create a copy of arguments of this object.
            var typeofParams = (typeof overrides),
                crcObjects = {},
                options = global.extend({}, this.args, false, false);

            // Recreate construction parameters by reverse calculating the global
            // policies.
            deconstructPolicySet(global.policies, options, this);
            // Also deconstruct the rendere specific policies.
            deconstructPolicySet(global.renderer.getRendererPolicy(this.options.renderer),
                options, this);

            // Remove any specific parameters that if cloned will create issues.
            delete options.id;
            delete options.animate;
            delete options.stallLoad;
            crcObjects.link = options.link; // link was removed as it prevents deep cloning

            // Now, deep clone the entire object to separate both instances
            options = global.extend({}, options, false, false);

            // restore crc Objects
            options.link = crcObjects.link;

            switch (typeofParams) {
                // Override any of the options by parameters sent by user
                case 'object':
                    global.extend(options, overrides);
                    break;

                // In case user sends only one boolean param marking not to
                // create new chart.
                case 'boolean':
                    argsOnly = overrides;
                    break;
            }

            // Create new FusionCharts object from the computed options
            return argsOnly ? options: new global.core(options);

        },

        /**
         * Denotes whether a chart is "active" or not after being rendered. This is primarily relevant for Flash variant
         * of the charts since they tend to loose functionality when hidden or scrolled away as a measure to save system
         * resources.
         *
         * For JavaScript charts, this returns `false` when a chart has not been rendered. As such, using the function
         * {@linkFusionCharts#hasRendered} is more relevant.
         *
         * @group chart
         * @deprecated 3.4.0 - The removal of Flash variant of the charts discards the use of this function since
         * JavaScript are always "active" and does not loose its functionalities when out of viewport of the browser.
         *
         * @returns {boolean} - Returns `true` if a Flash chart is visible and can communicate with the rest of the
         * page using its internal JavaScript API. For JavaScript charts, this returns `false` when a chart has not been
         * rendered.
         */
        isActive: function () {
            if (!this.ref || win.document.getElementById(this.id) !== this.ref) {
                return false;
            }

            try {
                return signatureMatchRegex.test(this.ref.signature());
            } catch (e) {
                return false;
            }
        },

        /**
         * Gets or sets the chart type of an instance of FusionCharts.
         *
         * To change the chart type, pass the new chart type as the first parameter to this function. The chart is
         * automatically re-rendered when a new chart type is set. To get the current
         * chart type, call this function without any parameters.
         *
         * When the chart type is changed using this method, the chart is re-rendered and the
         * {@link FusionCharts#event:chartTypeChanged} event is fired.
         *
         * @since 3.4.0
         * @group chart
         *
         * @param {string=} value - Sets the new chart type.
         *
         * @param {object=} options - During modifying the chart type using this method, additional options can be
         * passed on to update chart data and re-render the chart at the same time. Note that these options are ignored
         * if you do not provide a `value` (first) parameter.
         *
         * @param {string|object=} options.dataSource - Provide a new source of data during the change of chart type.
         * @param {FusionCharts~dataFormats=} options.dataFormat - Specify the data format of the new `dataSource`
         * provided during chart-type update. If this is not provded, then it is assumed that the `dataSource` provided
         * is same as the existing or default `dataFormat`. If `dataSource` is not provided, this parameter is ignored.
         *
         * @returns {string} The current chart type is returned.
         *
         * @fires FusionCharts#chartTypeChanged
         * @see FusionCharts.render
         *
         * @example
         * // Render a column chart and on click of a button toggle it from column to pie and vice versa.
         * FusionCharts.ready(function () {
         *     var chart = new FusionCharts({
         *         type: 'column2d',
         *         renderAt: 'chart-container',
         *         dataSource: 'weekly-sales.json',
         *         dataFormat: 'jsonurl'
         *     }).render();
         *
         *     // Assign the functionality of toggling chart type when clicked on
         *     // a button (with an id toggle-chart-type).
         *     document.getElementById('toggle-chart-type').onclick = function () {
         *         if (chart.chartType() === 'column2d') {
         *             chart.chartType('pie2d');
         *         }
         *         else {
         *             chart.chartType('column2d');
         *         }
         *     };
         * });
         */
        chartType: function (value, options) {
            var chartObj = this,
                src = chartObj.src,
                silent = (options === true),
                opts = chartObj.options,
                legacy;

            if (typeof value === 'string') {
                options = (typeof options === 'object') ? options : {};

                // We remove query string from `src` and also possible .swf (legacy) extension
                // Similar processing is in core
                src = value.replace(/[\?\#][\s\S]*$/g, '');

                // Before replacing legacy swf extension, keep a flag to note its existence.
                legacy = (src.match(/\.swf\s*?$/ig) !== null);

                // Replace legacy swf extension.
                src = src.replace(/\.swf\s*?$/ig, '');

                // remove path for type and remove fcMap (legacy)
                opts.chartType = src.replace(/^[\s\S]*\//ig, '').replace(/^fcmap_/i, '');
                opts.chartTypeSourcePath = (src.indexOf('/') === -1) ? (options.chartTypeSourcePath ||
                    chartObj.options.chartTypeSourcePath || global.core.options.chartTypeSourcePath || '') :
                        src.replace(/[^\/]*?$/ig, '');

                // Handling for legacy flash.
                chartObj.src = ((global.core.options.scriptBaseUri || '') +
                (opts.chartTypeSourcePath || global.core.options.chartTypeSourcePath || '')).replace(/\/\s*$/g, '') +
                    '/' + opts.chartType.replace(/\.swf\s*?$/ig, '') + '.swf';

                // In case chart type has .swf the drop the sourcepath calculation for legacy
                if (legacy) {
                    /**
                     * Since FusionCharts 3.4.0, the use of `.swf` suffix in chart types is deprecated since, Flash
                     * variant of charts are no longer supported. As such, a warning message is issued to notify
                     * developers to follow steps specified in '3.4.0 Migration Guide" to upgrade to the newest API.
                     *
                     * @typedef {DesignTimeException} Warning-08101320181
                     * @memberOf FusionCharts.debugger
                     * @group debugger-warning
                     *
                     * @since 3.4.0
                     */
                    global.raiseWarning(chartObj, '08101320181', 'comp', 'FusionCharts#chartType',
                        'Chart type has ".swf" in alias and as such has been deprecated. Please use chart type alias.');
                    opts.chartTypeSourcePath = global.core.options.chartTypeSourcePath || '';
                }

                // handle special internal case of setting chart type without rendering.
                if (options.dataSource !== undefined && options.dataSource !== null) {
                    chartObj.setChartData(options.dataSource, options.dataFormat, options.dataConfiguration);
                }
                else if (chartObj.isActive() && !silent) {
                    chartObj.render();
                }
            }

            return (opts.chartType || '').toLowerCase();
        }

    }, true);

    /**
     * This function gives access to the HTMLDOMElement that has been created inside the chart container by
     * FusionCharts. Note that this does not return the container element specified during FusionCharts#render of the
     * chart. It is rather the element inside the container element that is created by FusionCharts to hold a chart.
     * @global
     *
     * @deprecated Since 3.2.0 there is no need to directly interact with charts' DOM element. As such, this becomes
     * redundant.
     *
     * @param {string} id The chart Id whose internal DOM element is needed.
     * @returns {FusionCharts}
     */
    win.getChartFromId = function (id) {
        /**
         * Use of deprecated getChartFromId() or getMapFromId() global objects detected. Developer needs to upgrade
         * to usage of the latest API and access chart instances using {@link FusionCharts.items} or
         * `FusionCharts("chart-id")`.
         *
         * @typedef {DesignTimeException} Warning-11133001041
         * @memberOf FusionCharts.debugger
         * @group debugger-warning
         *
         * @since 3.4.0
         */
        global.raiseWarning(this, '11133001041', 'comp', 'GenericRuntime~getObjectFromId()',
            'Use of deprecated getChartFromId() or getMapFromId(). Replace ' +
            'with "FusionCharts()" or FusionCharts.items[].');
        return global.core.items[id] instanceof global.core ?
            global.core.items[id].ref : (win.swfobject && win.swfobject.getObjectById(id));
    };

    /**
     * This function gives access to the HTMLDOMElement that has been created inside the chart container by
     * FusionCharts. Note that this does not return the container element specified during FusionCharts#render of the
     * chart. It is rather the element inside the container element that is created by FusionCharts to hold a chart.
     * @global
     * @function
     *
     * @deprecated Since 3.2.0 there is no need to directly interact with charts' DOM element. As such, this becomes
     * redundant.
     *
     * @param {string} id The chart Id whose internal DOM element is needed.
     * @returns {FusionCharts}
     */
    win.getMapFromId = win.getChartFromId;

}]);



/**
 * FusionCharts Print Manager Module
 * @private
 * @deprecated since 3.4.0
 *
 * @module fusioncharts.managedprint
 */
FusionCharts.register('module', ['private', 'api.printmanager', function () {

    var global = this;

    global.extend(global.core, /** @lends FusionCharts */ {
        /**
         *
         * @deprecated 3.4.0 - The removal of Flash variant of the charts discards the use of this function since.
         *
         * FusionCharts XT provides advanced print management using JavaScript for Mozilla/WebKit/Gecko based browsers
         * like Firefox, Safari etc. Even though displayed properly on screen, printed output had been not proper in
         * these browsers. So long! FusionCharts JavaScript class offers a separate Print Manger class to take care of
         * this. The implementation of Print Manager is fairly simple. You will just need to add a single line of code
         * in JavaScript which enables Print Manager for all charts present in a web page. Once enabled, all the charts
         * present in a page are prepared to print correctly. Once the charts are ready, which can be tracked by
         * listening to an event raised by the Print Manager, you can use browser's File ??Print menu, JavaScript's
         * native window.print() function or Print Manager's advanced function - managedPrint(). In any of these
         * actions, the charts will come-up properly in the print media
         *
         * @namespace FusionCharts.printManager
         */
        printManager: {
            /**
             * @deprecated 3.4.0 - The removal of Flash variant of the charts discards the use of this function since.
             *
             * This method allows users to confiure and reconfigure the configuration of PrintManager!
             * @param {object.<string>} configuration
             */
            configure: function () {
                global.raiseWarning(global.core, '28141714', 'impl', '.printManager.configure',
                    'PrintManager is deprecated');
            },

            /**
             * @deprecated 3.4.0 - The removal of Flash variant of the charts discards the use of this function since.
             *
             * Check whether print manager is ready with all the charts rendered on page and can safely print them.
             * @returns {boolean}
             */
            isReady: function () {
                global.raiseWarning(global.core, '28141714', 'impl', '.printManager.isReady',
                    'PrintManager is deprecated');
                // since printmanager doesnt check the render status of the charts now
                return false;
            },

            /**
             * @deprecated 3.4.0 - The removal of Flash variant of the charts discards the use of this function since.
             *
             * Enable or disable canvas print manager. In case browser is not supported, enabling will not take place.
             * @param {boolean} state
             * @returns {boolean} status
             */
            enabled: function () {
                global.raiseWarning(global.core, '28141714', 'impl', '.printManager.enabled',
                'PrintManager is deprecated');

                // since printmanager is deprecated, disable it
                return false;
            },
            /**
             * @deprecated 3.4.0 - The removal of Flash variant of the charts discards the use of this function since.
             *
             */
            managedPrint: function () {
                global.raiseWarning(global.core, '28141714', 'impl', '.printManager.managedPrint',
                    'PrintManager is deprecated');
            }
        }
    }, false);

}]);
/**
 * Renderer Abstraction Framework
 * This module allows developers to abstract the entire rendering engine. This helps in multiple implementations of
 * FusionCharts in various technologies such as flash, HTML5, etc.
 * @private
 *
 * @module fusioncharts.renderer
 * @requires fusioncharts.events
 * @requires fusioncharts.runtime
 * @requires fusioncharts.managedprint
 */
FusionCharts.register('module', ['private', 'modules.interface.renderer', function () {

    var global = this,

        func = 'function',
        undef,

        win = global.window,
        doc = win.document,

        notDefined = function () {
            /**
             * @private
             *
             * @typedef {RuntimeException} Error-25081845
             * @memberOf FusionCharts.debugger
             * @group debugger-error
             */
            global.raiseError(this, '25081845', 'run', '::RendererManager', new Error('No active renderer'));
            return;
        },

        /**
         * When a chart is rendered within a DOM element on a page, the chart by default clears its contents and
         * replaces them with the chart. However, this behavior can be changed by specifying the `insertMode` of the
         * chart during construction of a chart or while calling {@link FusionCharts#render}.
         * @memberOf FusionCharts~
         * @group framework
         *
         * @alias DOMInsertModes
         * @enum {string}
         */
        FusionChartsDOMInsertModes = global.FusionChartsDOMInsertModes = {
            /**
             * Replaces - default.
             */
            REPLACE: 'replace',
            /**
             * Appends
             */
            APPEND: 'append',
            /**
             * prepends
             */
            PREPEND: 'prepend'
        },

        renderers = {
            'undefined': {
                render: notDefined,
                remove: notDefined,
                update: notDefined,
                resize: notDefined,
                config: notDefined,
                policies: {}
            }
        },
        store = {}, // store which chart has what renderer

        // This function allows users to make a generic call to external interface
        // of the chart via the FusionCharts object
        eiCall = function (method) {
            return function () {
                var callee = this,
                    ref = callee.ref;
                // Verify whether the chart is valid object and then proceed.
                if (ref === undef  || ref === null  || typeof ref[method] !== func) {
                    /**
                     * Every instance of FusionCharts has a set of functions that are specific to a chart type and set
                     * of functions that are available only after a chart has been rendered. In case a call to such
                     * functions are made before the chart has been completely rendered, this error is raised. The error
                     * message includes the name of the function in question.
                     *
                     * Ensure you programmatically interact with a chart (with respect to the function involved,) after
                     * the {@link FusionCharts#event:renderComplete} event has been fired.
                     *
                     * @typedef {RuntimeException} Error-25081617
                     * @memberOf FusionCharts.debugger
                     * @group debugger-error
                     */
                    global.raiseError(this, '25081617', 'run', '#' + method + '()',
                        'ExternalInterface call failed. Check whether chart has been rendered.');
                    return undef;
                }

                return ref[method].apply(ref, arguments);
            };
        },

        // This function allows users to make a generic call from renderer
        // of the chart to main FusionCharts object.
        jsCall = function (obj, prop) {
            // Check whether me
            if (typeof obj[prop] === func) {
                return function () {
                    return obj[prop].apply(obj, arguments);
                };
            }
            return obj[prop];
        },

        // Function that checks duplicate id in page.
        isDuplicateId = function (lookupId, container) {
            // Get the lookup element from the ID sent via parameter.
            var lookupElement = doc.getElementById(lookupId),
                // Get the ID of the container element.
                containerId = container.id || container.getAttribute('id'),
                children,
                i,
                ii;

            // Check whether the element exists or not. If it does not exist, it
            // implies that there cannot be any duplicate.
            if (lookupElement === null) {
                return false;
            }

            // In case chart's Id and container's Id is same then is duplicate.
            if (lookupId === containerId) {
                return true;
            }

            // Check whether the lookup element returned before is actually
            // inside container or not.
            children = container.getElementsByTagName('*');
            for (i = 0, ii = children.length; i < ii; i++) {
                if (children[i] === lookupElement) {
                    return false;
                }
            }
            // If the lookupElement is outside/before the container, it implies
            // that it is a duplicate.
            return true;
        },
        lengthCleanupRegex = /[^\%\d]*$/ig,

        // API to add renderer and also to set/get the current renderer.
        renderer;

    // Allow FusionCharts to accept parameter to specify where to render the
    // chart.
    global.policies.options.containerElementId = ['renderAt', undef];
    global.policies.options.renderer = ['renderer', undef];

    // Function to normalize dimension for style setting
    global.normalizeCSSDimension = function (width, height, container) {
        // optimize dimensions
            var w = width === undef ? (container.offsetWidth || parseFloat(container.style.width)) : width,
                h = height === undef ? (container.offsetHeight || parseFloat(container.style.height)) : height,
                o = {},
                s = container.style,
                p;

            // Do initial testing by setting dimensions
            s.width = w = w.toString ? w.toString() : '0';
            s.height = h = h.toString ? h.toString() : '0';

            if ((o.widthIsRelative = (w.match(/^\s*\d*\.?\d*\%\s*$/) &&
                    !w.match(/^\s*0\%\s*$/))) && container.offsetWidth === 0) {
                p = container;
                while ((p = p.offsetParent)) {
                    if (p.offsetWidth > 0) {
                        w = (p.offsetWidth * parseFloat(w.match(/\d*/)[0]) / 100).toString();
                        break;
                    }
                }
            }

            if ((o.heightIsRelative = (h.match(/^\s*\d*\.?\d*\%\s*$/) &&
                    !h.match(/^\s*0\%\s*$/))) && container.offsetHeight <= 20) {
                p = container;
                while ((p = p.offsetParent)) {
                    if (p.offsetHeight > 0) {
                        h = (p.offsetHeight * parseFloat(h.match(/\d*/)[0]) / 100).toString();
                        break;
                    }
                }
            }

            o.width = (w.replace ? w.replace(/^\s*(\d*\.?\d*)\s*$/ig, '$1px') : w);
            o.height = (h.replace ? h.replace(/^\s*(\d*\.?\d*)\s*$/ig, '$1px') : h);

            // Finally apply the dimensions
            s.width = o.width;
            s.height = o.height;

            o.pixelWidth = o.widthIsRelative ?
                container.offsetWidth : parseInt(o.width, 10) || 0;
            o.pixelHeight = o.heightIsRelative ?
                container.offsetHeight : parseInt(o.height, 10) || 0;

            return o;
        };

    // Collection of renderers.
    renderer = global.renderer = {
        register: function (name, obj) {
            // Validate parameters
            if (!name || typeof name.toString !== func) {
                throw new Error('#03091436 ~renderer.register() Invalid value for renderer name.');
            }

            // Desensitize character case for renderer name
            name = name.toString().toLowerCase();

            // Prevent addition of duplicate renderer
            if (renderers[name] !== undef) {
                /**
                 * @private
                 *
                 * @typedef {ParameterException} Error-03091438
                 * @memberOf FusionCharts.debugger
                 * @group debugger-error
                 */
                global.raiseError(global.core, '03091438', 'param', '::RendererManager>register',
                    'Duplicate renderer name specified in "name"');
                return false;
            }

            // Add renderer to the collection of renderers.
            renderers[name] = obj;
            // Return true when a new renderer is successfully added.
            return true;
        },

        // Flag that tracks whether user has updated the default value.
        userSetDefault: false,

        // Set the current renderer
        setDefault: function (name) {
            // Validate parameters
            if (!name || typeof name.toString !== func) {
                /**
                 * @private
                 *
                 * @typedef {ParameterException} Error-25081731
                 * @memberOf FusionCharts.debugger
                 * @group debugger-error
                 */
                global.raiseError(global.core, '25081731', 'param', '::RendererManager>setDefault',
                    'Invalid renderer name specified in "name"');
                return false;
            }

            // Validate the renderer name and see whether the parameter refers to a valid renderer.
            // ALSO: Desensitize character case for renderer name.
            if (renderers[name = name.toString().toLowerCase()] === undef) {
                /**
                 * @private
                 *
                 * @typedef {RangeException} Error-25081733
                 * @memberOf FusionCharts.debugger
                 * @group debugger-error
                 */
                global.raiseError(global.core, '25081733', 'range', '::RendererManager>setDefault',
                    'The specified renderer does not exist.');
                return false;
            }

            // Mark auto-set default renderer. When user specifically sets
            // renderer, this flag needs to be overwritten.
            this.userSetDefault = false;

            // Set reference to the current renderer.
            global.policies.options.renderer = ['renderer', name];
            return true;
        },

        // Define a function that saves the reference to the embedded object
        // after it has been rendered.
        notifyRender: function (status) {
            // Lookup corresponding chartObject for the renderer notif.
            var chartObj = global.core.items[(status && status.id)];

            // Check whether the render was successful.
            if (!chartObj || (status.success === false && !status.silent)) {
                /**
                 * This is an error that occurs when FusionCharts failed to render the chart. When
                 * {@link FusionCharts#render} is called, it expects the rendering process to complete and a
                 * corresponding chart be available on the browser `DOM` having the same `id` as the chart id.
                 *
                 * - Check whether the chart being rendered has a unique ID.
                 * - Ensure that the chart container being rendered in is not within a `frame` or `iframe`.
                 * - Ensure that the container being rendered in is not deleted or manipulated during the rendering
                 *   process. Avoid updating the `innerHTML` of the container once a chart has been rendered within it;
                 *   use standard DOM append, prepend, insert, remove functions.
                 * - Check whether any third-party JavaScript or JavaScript UI library is not interfering with the
                 *   rendering process.
                 *
                 * @typedef {RuntimeException} Error-25081850
                 * @memberOf FusionCharts.debugger
                 * @group debugger-error
                 */
                global.raiseError(global.core.items[status.id], '25081850', 'run', '::RendererManager',
                    new Error('There was an error rendering the chart. ' +
                        'Enable FusionCharts JS debugger for more information.'));
            }

            /**
             * Every instance of FusionCharts, when rendered within a container element (provided by the `renderAt`
             * parameter,) creates a `<span>` element within which a chart is rendered. As such, the user-provided
             * container element is not polluted by the DOM elements created by a chart.
             *
             * @deprecated 3.4.0 - This method has been deprecated as direct access to `DOMElement` of the chart has
             * become redundant.
             *
             * @group chart
             * @since 3.2.0
             * @type {DOMElement}
             * @name ref
             * @memberOf FusionCharts.prototype
             *
             * @example
             * // Iterate on all charts rendered on a page and move them to a common location
             * var sidebar = document.getElementById('sidebar-html-div'), // assuming that your common container is this
             *     chart;
             *
             * for (chart in FusionCharts.items) {
             *     chart = FusionCharts.items[chart];
             *     chart.ref && sidebar.appendChild(chart.ref.parentNode);
             * }
             */
            chartObj.ref = status.ref;

            // If the ref has been created, create a reverse reference.
            if (status.ref) {
                status.ref.FusionCharts = global.core.items[status.id];
            }

            /**
             * This event is fired when the `HTMLDOMElement` (generally a <span>) is created within which the chart is
             * rendered.
             * @event FusionCharts#internal\.DOMElementCreated
             * @group chart
             * @private
             */
            global.raiseEvent('internal.DOMElementCreated', {}, chartObj);

        },

        protectedMethods: {
            options: true,
            attributes: true,
            src: true,
            ref: true,
            constructor: true,
            signature: true,
            link: true,
            addEventListener: true,
            removeEventListener: true
        },

        getRenderer: function (name) {
            return renderers[name];
        },

        getRendererPolicy: function (name) {
            var policies = renderers[name].policies;
            return typeof policies === 'object' ? policies : {};
        },

        currentRendererName: function () {
            return global.policies.options.renderer[1];
        },

        update: function (obj) {
            store[obj.id].update.apply(obj,
                Array.prototype.slice.call(arguments, 1));
        },

        render: function (obj) {
            store[obj.id].render.apply(obj,
                Array.prototype.slice.call(arguments, 1));
        },

        remove: function (obj) {
            store[obj.id].remove.apply(obj,
                Array.prototype.slice.call(arguments, 1));
        },

        resize: function (obj) {
            store[obj.id].resize.apply(obj,
                Array.prototype.slice.call(arguments, 1));
        },

        config: function (obj) {
            store[obj.id].config.apply(obj,
                Array.prototype.slice.call(arguments, 1));
        },

        dispose: function (obj) {
            store[obj.id].dispose.apply(obj,
                Array.prototype.slice.call(arguments, 1));
        }
    };

    // Constructor to add renderer functions
    global.addEventListener('beforeInitialize', function (event) {
        // Reference to event sender.
        var obj = event.sender,
            rendererName = obj.options.renderer.toLowerCase(),
            item;

        // Check if construction has the default renderer name saved.
        if (typeof obj.options.renderer === 'string' &&
                renderers[rendererName] === undef) {
            obj.options.renderer = global.policies.options.renderer[1];
        }
        // Desensitize the case of the parameter.
        obj.options.renderer = rendererName;

        // Keep a reference
        store[obj.id] = renderers[obj.options.renderer];

        // Check whether this particular renderer has been rendered.
        if (store[obj.id].initialized !== true &&
            typeof store[obj.id].init === func) {
            // Call the 'init' function on the renderer and set a flag.
            store[obj.id].init();
            store[obj.id].initialized = true;
        }

        // Parse construction policies specific to this renderer.
        global.parsePolicies(obj, store[obj.id].policies || {}, obj.args);

        // Copy the prototype of the renderer specified in constructor to the
        // main object.
        for (item in store[obj.id].prototype) {
            obj[item] = store[obj.id].prototype[item];
        }

        // Attach event liseners of the renderer to this object.
        for (item in store[obj.id].events) {
            obj.addEventListener(item, store[obj.id].events[item]);
        }

    });

    global.addEventListener(['rendered', 'dataloaderror', 'nodatatodisplay', 'rendercancelled'], function (e, a) {
        var sender = e.sender;
        // Clear the flag that keeps a track whether the chart is presently
        // in a 'rendering' state
        if (sender instanceof global.core && sender.__state.rendering) {
            global.raiseEvent('internal.rendered', a, sender);
            delete sender.__state.rendering;
        }
    });

    global.addEventListener('loaded', function (e) {

        // Store a reference to the chart swf HTML Node.
        var obj = e.sender,
            chartObj = e.sender.ref,
            eiItems,
            ignore1,
            ignore2,
            item,
            i;

        // Validate whether the chart swf node exists and that it has
        // the prerequisite externalInterface functions.
        if (chartObj === undef || chartObj === null || typeof
            chartObj.getExternalInterfaceMethods !== func) {
            return;
        }

        // The externalInterfaceMethods names are parsed from CSV to
        // Array.
        // Check whether the external interface methods are being called or not.
        // If not, then there is an error (probably cross-domain).
        try {
            eiItems = chartObj.getExternalInterfaceMethods();
            eiItems = typeof eiItems === 'string' ? eiItems.split(',') : [];
        }
        catch (err) {
            eiItems = [];
            /**
             * This error is raised when the chart cannot internally access the DOM functions of the rendered chart.
             * The likely cause of this issue is an internal failure to enumerate the basic DOM functions that are
             * needed for the chart to render. Ensure that your browser has not enforced cross-domain script security
             * restrictions that was intended.
             *
             * @typedef {RuntimeException} Error-13111126041
             * @memberOf FusionCharts.debugger
             * @group debugger-error
             */
            global.raiseError(obj, '13111126041', 'run', 'RendererManager^Loaded',
                new Error('Error while retrieving data from the chart-object.' + (err.message &&
                    err.message.indexOf('NPObject') >= 0 ? ' Possible cross-domain security restriction.' : '')));

        }

        // We iterate through all the externalInterface method names and
        // create an extensible API object that is added to main
        // FusionCharts object as reference.
        for (i = 0; i < eiItems.length; i += 1) {
            item = eiItems[i];
            // Copy method from renderer only when a local method does not exist
            if (obj[item] === undef) {
                obj[item] = eiCall(item);
            }
        }

        // Extend FusionCharts capabilities to swf HTMLNode object
        // Check whether the object was added to DOM or not.
        if (obj.ref) {
            ignore1 = renderer.protectedMethods,
            ignore2 = renderer.getRenderer(obj.options.renderer).protectedMethods;


            // Iterate through the FusionCharts object and add its variables to the
            // HTMLNode object.
            for (item in obj) {
                // Discontinue adding this object in case the property is marked to
                // be ignored.
                if (ignore2 && !(ignore1[item] || ignore2[item] || obj.ref[item] !== undef)) {
                    try {
                        obj.ref[item] = jsCall(obj, item);
                    } catch (e) { }
                }
            }
        }
    });

    // Add resize in the legacy event list.
    global.legacyEventList.resized = 'FC_Resized';

    global.extend(global.core.prototype, /** @lends FusionCharts# */ {
        /**
         * Creating a chart using `new FusionCharts()` merely creates a JavaScript instance of the chart. The chart is
         * not yet made visible on the page. In order to render it in a location on the page, this function needs to be
         * called. Usually, when the chart is instantiated, the `renderAt` construction parameter specifies the element
         * on the page inside which the chart will be rendered. If the `renderAt` parameter is not provided during
         * construction of the page, then the same can be provided as the first parameter of this function.
         *
         * This function renders a chart inside a container element on a page. If a chart is already rendered, it can be
         * re-rendered inside the same container DOM element or some other element.
         *
         * @group chart
         *
         * @param {string|DOMElement=} [containerElement] - A reference or `id` of the `DOMElement` inside which the
         * chart is to be rendered. If this argument is not provided, it is assumed that the `renderAt` option is
         * provided during creation of the chart.
         *
         * @param {FusionCharts~DOMInsertModes} [insertMode=replace] - This parameter specifies the method using which
         * the chart's DOM element will be inserted within the `containerElement`. For more information regarding DOM
         * insert modes, see {@link FusionCharts~DOMInsertModes}
         *
         * @param {FusionCharts~renderCallback=} [callback] - This parameter is a callback function that is called after
         * the chart is successfully rendered. The last parameter to `render()` is always treated as a callback if it is
         * a function.
         *
         * @fires FusionCharts#beforeRender
         * @fires FusionCharts#rendered
         * @fires FusionCharts#renderComplete
         * @fires FusionCharts#renderCancelled
         */
        render: function (containerElement, insertMode, callback) {

            // Dispose the renderer in case of re-render. This checks whether there
            // is any previous DOM element in case the chart is re-rendered and
            // correspondingly deletes it. (B#565)
            var that = this,
                alt,
                eventArgs,
                ref,
                size,
                s;

            if ((ref = win[this.id]) && ref.FusionCharts && ref.FusionCharts === this ||
                (ref = this.ref) && ref.FusionCharts && ref.FusionCharts === this) {
                global.renderer.dispose(this);
                // For some browsers, the DOM element reference is still retained
                // in window scope and that has to be cleared.
                if (ref === win[this.id]) {
                    win[this.id] = undefined;
                }
            }

            // Check IE-Safe variable name collision within Global Scope
            if (win[this.id] !== undef) {
                /**
                 * FusionCharts raises this error to ensure that the charts function reliably on older Internet Explorer
                 * browsers (IE 8 and below.) Ensure that you have unique name for your chart id and that it does not
                 * correspond to any global variable, DOM element id or frame name.
                 *
                 * @typedef {CompilationException} Error-25081843
                 * @memberOf FusionCharts.debugger
                 * @group debugger-error
                 */
                global.raiseError(this, '25081843', 'comp', '.render', new Error('#25081843:IECompatibility() Chart ' +
                    'Id is same as a JavaScript variable name. Variable naming error. Please use unique name for' +
                    'chart JS variable, chart-id and container id.'));
            }

            // Validate parameters for retrieving callback. The last parameter can be a callback
            if (!callback) {
                if (typeof insertMode === 'function') {
                    callback = insertMode;
                    insertMode = undefined;
                }
                else if (!insertMode && typeof containerElement === 'function') {
                    callback = containerElement;
                    containerElement = undefined;
                }
            }
            else if (typeof callback !== 'function') {
                callback = undefined;
            }

            // Create a blank element inside to mimic alternativecontent
            insertMode = (insertMode || this.options.insertMode).toLowerCase() || FusionChartsDOMInsertModes.REPLACE;

            // Procure containerElement from internal object options that has
            // been passed via parameters.
            if (containerElement === undef) {
                containerElement = this.options.containerElementId;
            }

            // In case user sends the element id, we get the object from it
            if (typeof containerElement === 'string') {
                containerElement = doc.getElementById(containerElement);
            }
            if (containerElement === undef || containerElement === null) {
                /**
                 * FusionCharts could not find the container DOM element while rendering chart. Ensure that a DOM
                 * element exists which has an `id` attribute same as the one provided in `renderAt` construction
                 * parameter or when passed to the {@link FusionCharts#render} function.
                 *
                 * @typedef {CompilationException} Error-03091456
                 * @memberOf FusionCharts.debugger
                 * @group debugger-error
                 */
                global.raiseError(this, '03091456', 'run', '.render()',
                    new Error('Unable to find the container DOM element.'));
                return this;
            }

            // Check duplicate rendering with same id
            if (isDuplicateId(this.id, containerElement)) {
                /**
                 * The `id` of the container element provided has more than one element with the same id. This would
                 * cause problems in referring to the correct chart during its operation.
                 *
                 * Ensure that no other DOM element exists on the page with the same `id` attribute as of the container
                 * element where the chart is supposed to be rendered.
                 *
                 * @typedef {CompilationException} Error-05102109
                 * @memberOf FusionCharts.debugger
                 * @group debugger-error
                 */
                global.raiseError(this, '05102109', 'run', '.render()',
                    new Error('A duplicate object already exists with the specific Id: ' + this.id));
                return this;
            }

            // Set the attribute of this element that will be replaced by swfobject
            alt = doc.createElement(this.options.containerElementType || 'span');
            alt.setAttribute('id', this.id);

            // Clear the contents of the containerElement and subsequently
            // append the new alt content.
            if (insertMode !== 'append' && insertMode !== 'prepend') {
                while (containerElement.hasChildNodes()) {
                    containerElement.removeChild(containerElement.firstChild);
                }
            }
            // Check whether we are to prepend this item or append.
            if (insertMode === 'prepend' && containerElement.firstChild) {
                containerElement.insertBefore(alt, containerElement.firstChild);
            }
            else {
                containerElement.appendChild(alt);
            }

            // Update the present container details in object.
            this.options.containerElement = containerElement;
            this.options.containerElementId = containerElement.id;

            // Set the chart element style property to make it display as an
            // inline-block element.
            if ((s = alt.style)) {
                s.position = 'relative';
                s.textAlign = 'left';
                s.lineHeight = 'normal';
                s.display = 'inline-block';
                s.zoom = '1';
                s.fontWeight = 'normal';
                s.fontVariant = 'normal';
                s.fontStyle = 'normal';
                s.textDecoration = 'none';
                s['*DISPLAY'] = 'inline';
                s.padding = '0';
                s.margin = '0';
                s.border = 'none';
            }
            this.options.containerClassName && (alt.className = this.options.containerClassName);

            // Fix percentage width issues
            size = global.normalizeCSSDimension(this.width, this.height, alt);

            // Record the render-time dimensions within state. This will be used
            // for reference calculations wrt original render-time dimensions in
            // other modules (such as annotations.)
            this.__state.renderedWidth = size.pixelWidth;
            this.__state.renderedHeight = size.pixelHeight;

            // Set state that the chart is rendering
            this.__state.rendering = true;

            /**
             * This event is raised before a chart is to be rendered. Doing an `eventObject.preventDefault()` on this
             * event will cancel the rendering process. The rendering process is triggered when
             * {@link FusionCharts#render} is called on the chart instance.
             *
             * @param {DOMElement} container - This contains the reference to the container `HTMLDOMElement` within
             * which the chart is to be rendered.
             * @param {numeric|percent} width - Width of the chart in percent or pixels.
             * @param {numeric|percent} height - Height of the chart in percent or pixels.
             *
             * @event FusionCharts#beforeRender
             * @group chart
             * @see FusionCharts#render
             * @see FusionCharts#hasRendered
             * @see FusionCharts#event:renderComplete
             * @see FusionCharts#event:renderCancelled
             * @see FusionCharts#event:rendered
             *
             * @example
             * // Listening using global events
             * FusionCharts.addEventListener('beforeRender', function (eventObj, argsObj) {
             *     // Prints id of the chart being rendered
             *     console.log("Chart with id " + eventObj.sender.id + " is about to be rendered.");
             *  });
             *
             * // Pass event listener in the FusionCharts constructor
             * var mychart = new FusionCharts({
             *     "type": "column2d",
             *     "dataFormat": "json",
             *     "dataSource": {
             *          ...
             *     },
             *     // Attach event handlers
             *     "events": {
             *         // Attach to beforeRender
             *         "beforeRender": function (eventObj, argsObj) {
             *             console.log("Beginning render of " + eventObj.sender.id);
             *         }
             *     }
             * });
             */
            global.raiseEvent('beforeRender', (eventArgs = {
                container: containerElement,
                width: this.width,
                height: this.height,
                renderer: this.options.renderer
            }), this, undefined, function (event, args) {
                // Call the current renderer.
                global.renderer.render(that, alt, function (/* status */) {
                    global.renderer.notifyRender.apply(this, arguments);

                    // Sandbox the error from causing script to break. Throw error on a different thread.
                    if (callback) {
                        try {
                            /**
                             * This callback is part of {@link FusionCharts#render} function. When a function is passed
                             * as a parameter of {@link FusionCharts#render}, it is executed when the rendering process
                             * is complete (along with {@link FusionCharts#event:renderComplete} event.) This callback
                             * is executed with the scope of the instance of `FusionCharts` and as such the `this`
                             * variable within this function refers to the chart whose rendering process is complete.
                             *
                             * @callback FusionCharts~renderCallback
                             *
                             * @this FusionCharts
                             *
                             * @param {DOMElement} container - This parameter returns a reference to the container
                             * element within which the chart, gauge or map has been rendered.
                             *
                             * @example
                             * // In this example, we are going to use the render callback
                             * // function to activate a set of buttons that are needed only
                             * // after a chart has been rendered (say, exporting the chart.)
                             * FusionCharts.ready(function () {
                             *     var chart = new FusionCharts({
                             *         type: "Column2D",
                             *         dataFormat: "jsonurl",
                             *         dataSource: "sample-data-source.json",
                             *         renderAt: "chart-container" // assuming an element with this id exists
                             *     }).render(function () {
                             *         // Assuming a disabled button with a specific id already exists.
                             *         var button = document.getElementById("export-button");
                             *         button.removeAttribute("disabled");
                             *     });
                             * });
                             */
                            callback.call(event.sender, args.container);
                        }
                        catch (e) {
                            setTimeout(function () {
                                throw e;
                            });
                        }
                    }

                });
            }, function () {
                /**
                 * This event as a result of cancellation of default behavior of
                 * {@link FusionCharts#event:beforeRender} event via it's `eventObject.preventDefault()` method.
                 *
                 * @see FusionCharts#render
                 * @see FusionCharts#hasRendered
                 * @see FusionCharts#event:beforeRender
                 * @see FusionCharts#event:renderComplete
                 * @see FusionCharts#event:rendered
                 *
                 * @event FusionCharts#renderCancelled
                 * @group chart
                 *
                 * @example
                 * // Listening using global events
                 * FusionCharts.addEventListener('renderCancelled', function (eventObj, argsObj) {
                 *     // Prints id of the chart whose rendering was cancelled
                 *     console.log("Rendering of chart with id " + eventObj.sender.id + " was cancelled.");
                 *  });
                 *
                 * // Pass event listener in the FusionCharts constructor
                 * var mychart = new FusionCharts({
                 *     "type": "column2d",
                 *     "dataFormat": "json",
                 *     "dataSource": {
                 *          ...
                 *     },
                 *     // Attach event handlers
                 *     "events": {
                 *         // Attach to renderCancelled
                 *         "renderCancelled": function (eventObj, argsObj) {
                 *             console.log("Cancelled rendering of " + eventObj.sender.id);
                 *         }
                 *     }
                 * });
                 *
                 * @param {DOMElement} container - This contains the refernce to the container `HTMLDOMElement` whithin
                 * which the chart is to be rendered.
                 * @param {numeric|percent} width - Width of the chart in percent or pixels.
                 * @param {numeric|percent} height - Height of the chart in percent or pixels.
                 */
                global.raiseEvent('renderCancelled', eventArgs, that);
            });

            return this;
        },

        /**
         * Removes a chart from the DOM where it was previously rendered. This retains the chart object and as such it
         * can be re-rendered inside the same DOM element or be rendered in some other element by calling
         * {@link FusionCharts#render}.
         *
         * @group chart
         * @since  3.4.0
         * @private
         */
        remove: function () {
            global.renderer.remove(this);
            return this; // chain
        },

        /**
         * Calling this function on a chart instance resizes the chart to the specified width or height. This function
         * is only available for charts that have already rendered.
         *
         * Similar to setting the width and height of a chart through the `new FusionCharts()` constructor, the values
         * for width and height can be passed in number or percentage for this function. Setting a percentage causes the
         * chart to partially redraw itself when chart container is resized.
         *
         * Calling this function without a value for either width or height will return the current value of the width
         * or height respectively.
         *
         * For example, this function is useful in controlling the dimension of chart based on the change in dimension
         * of a resizable dialog box. It is also useful in resizing charts for responsive layouts, based on device
         * orientation change.
         *
         * > When dimension is set in percentage, the charts use a very low-profile polling at an interval of `300ms` to
         * check whether the chart container has effectively resized. It ignores repeated resizes.
         *
         * @group chart:resize
         *
         * @param {numeric|percent=} [width] - Set the width of the chart in pixels or percent.
         * @param {numeric|percent=} [height] - Set the height of the chart in pixels or percent.
         *
         * @fires FusionCharts#beforeResize
         * @fires FusionCharts#resized
         * @fires FusionCharts#resizeCancelled
         */
        resizeTo: function (width, height, silent) {
            var chart = this,
                prevW = chart.width,
                prevH = chart.height,
                state = chart.__state;

            if (typeof width === 'object') {
                silent = height;
                height = width.h;
                width = width.w;
            }

            width = (width === null || width === undefined) ? prevW : width.toString().replace(lengthCleanupRegex, '');
            height = (height === null || height === undefined) ? prevH :
                height.toString().replace(lengthCleanupRegex, '');

            if (silent !== true) {
                /**
                 * This event is fired before a chart is to be resized. It is fired either from
                 * {@link FusionCharts#resizeTo} or fired due to change in dimension of the chart's container element
                 * while the dimensions were in percentage format.
                 *
                 * @see FusionCharts#event:resized
                 * @see FusionCharts#resizeTo
                 * @see FusionCharts#event:resizeCancelled
                 * @event FusionCharts#beforeResize
                 * @group chart:resize
                 *
                 * @param {numeric|percent} currentWidth - Current width of the chart in pixels or percentage
                 * @param {numeric|percent} currentHeight Current height of the chart in pixels or percentage
                 * @param {numeric|percent} newWidth - new width of the chart in pixels or percentage
                 * @param {numeric|percent} newHeight - new height of the chart in pixels or percentage
                 */
                global.raiseEvent('beforeresize', {
                    currentWidth: prevW,
                    currentHeight: prevH,
                    newWidth: width,
                    newHeight: height
                }, chart, undef, function () {
                    chart.width = width;
                    chart.height = height;
                    global.renderer.resize(chart, {width: width, height: height});
                    /**
                     * Denotes when the chart has been resized either from calling {@link FusionCharts#resizeTo} or
                     * caused due to change in dimension of the chart's container element while the dimensions were in
                     * percentage format.
                     *
                     * @see FusionCharts#event:beforeResize
                     * @see FusionCharts#resizeTo
                     * @event FusionCharts#resized
                     * @group chart:resize
                     *
                     * @param {numeric|percent} width - Width of the chart after being resized
                     * @param {numeric|percent} height - Height of the chart after being resized
                     * @param {numeric|percent} prevWidth - The width of the chart previous to being resized
                     * @param {numeric|percent} prevHeight - The height of the chart previous to being resized
                     * @param {number} originalWidth - Width of the chart in pixels provided when chart was rendered
                     * using {@link FusionCharts#render}.
                     * @param {number} originalHeight - Original render-time height of the chart in pixels.
                     */
                    global.raiseEventWithLegacy('resized', {
                        width: chart.width,
                        height: chart.height,
                        prevWidth: prevW,
                        prevHeight: prevH,
                        pixelWidth: chart.ref && chart.ref.offsetWidth || 0,
                        pixelHeight: chart.ref && chart.ref.offsetHeight || 0,
                        originalWidth: state.renderedWidth,
                        originalHeight: state.renderedHeight
                    }, chart, [chart.id, chart.width, chart.height]);
                }, function () {
                    /**
                     * This event is triggered when `event.preventDefault()` is called from
                     * {@link FusionCharts#event:beforeResize}. This resuls in cancelling of instructions received from
                     * the {@link FusionCharts#resizeTo} function.
                     *
                     * @see FusionCharts#event:beforeResize
                     * @see FusionCharts#resizeTo
                     * @event FusionCharts#resizeCancelled
                     * @group chart:resize
                     *
                     * @param {numeric|percent} currentWidth - Current width of the chart in pixels or percentage.
                     * @param {numeric|percent} currentHeight - Current height of the chart in pixels or percentage.
                     * @param {numeric|percent} cancelledTargetWidth - The width of the chart that was requested to be
                     * set, but was cancelled.
                     * @param {numeric|percent} cancelledTargetHeight - The height of the chart that was requested to be
                     * set, but was cancelled.
                     */
                    global.raiseEvent('resizecancelled', {
                        currentWidth: prevW,
                        currentHeight: prevH,
                        cancelledTargetWidth: width,
                        cancelledTargetHeight: height
                    }, chart);
                });
            }
            else {
                chart.width = width;
                chart.height = height;
            }
            return this; // chain
        },

        /**
         * Calling this function on an instance of FusionCharts disposes the chart completely. This removes it from the
         * DOM tree and also clears the entire chart object. Upon successful disposal, `chartInstance.disposed` is set
         * to `true`.
         *
         * > It is recommended that you dispose unused charts to save memory and avoid memory leaks in your application
         * or dashboard.
         * @group chart:dispose
         *
         * @fires FusionCharts#beforeDispose
         * @fires FusionCharts#disposed
         * @fires FusionCharts#disposeCancelled
         */
        dispose: function () {
            var chart = this,
                eventArgs = {};

            /**
             * This event is raised when a chart is about to be disposed, i.e., deleted and cleaned from memory.
             * Usually, this event is triggered by {@link FusionCharts#dispose}. It can also be internally raised when
             * an already rendered chart is forced to re-render or if a child chart in a chain of *LinkedCharts* is
             * about to be closed.
             *
             * @see FusionCharts#dispose
             * @see FusionCharts#event:disposed
             * @see FusionCharts#event:disposeCancelled
             * @event FusionCharts#beforeDispose
             * @group chart:dispose
             */
            global.raiseEvent('beforeDispose', eventArgs, chart, undefined, function () {

                // Call dispose on the renderer. Renderer should dispose between
                // the beforeDispose and disposed event.
                global.renderer.dispose(chart);

                /**
                 * This event is raised when a chart has been disposed, i.e., deleted and cleaned from memory.
                 *
                 * Usually, this event is triggered by {@link FusionCharts#dispose}. It can also be internally raised
                 * when an already rendered chart has been forced to re-render  or if a child chart in a chain of
                 * *LinkedCharts* is closed.
                 *
                 * > You should dispose unused charts to avoid memory-leaks within your application or dashboard.
                 *
                 * @see FusionCharts#dispose
                 * @see FusionCharts#event:beforeDispose
                 * @event FusionCharts#disposed
                 * @group chart:dispose
                 */
                global.raiseEvent('disposed', eventArgs, chart);

                // Dispose all local events
                global.disposeEvents(chart);

                // Delete the reference of the item
                delete global.core.items[chart.id];

                // Remove all variables within this object, making this variable not
                // usable.
                for (var prop in chart) {
                    if (chart.hasOwnProperty(prop)) {
                        delete chart[prop];
                    }
                }

                // Flag it as disposed
                chart.disposed = true;
            }, function () {
                /**
                 * This event is cancelled when `eventObject.preventDefault()` is on the event
                 * {@link FusionCharts#event:beforeDispose}. This results in cancelling of dispose of charts, which is
                 * usually issued by {@link FusionCharts#dispose}.
                 *
                 * @see FusionCharts#dispose
                 * @see FusionCharts#event:beforeDispose
                 * @event FusionCharts#disposeCancelled
                 * @group chart:dispose
                 */
                global.raiseEvent('disposeCancelled', eventArgs, chart);
            });
        },

        /**
         * FusionCharts displays various status messages while rendering a chart. For example, while a chart's data
         * is being fetched from a remote URL, the chart will display "Retrieving data. Please wait." These messages
         * can be configured using this function.
         *
         * @since 3.2.0
         * @group chart
         *
         * @param {FusionCharts~chartStatusMessages} option - The option can either be a string specifying the property
         * that is to be configured, in which case, the second parameter must be provided. Otherwise, this can be an
         * object having key-value pair of all configuration options.
         *
         * @param {string=} [value] - In case the first parameter is a single key as string, this parameter must be
         * provided as value of that configuration key.
         */
        configure: function (option, value) {
            var hash;
            if (!option) {
                return;
            }
            else if (typeof option === 'string') {
                hash = {};
                hash[option] = value;
            }
            else {
                hash = option;
            }
            global.renderer.config(this, hash);
        }
    });

    global.extend(global.core, /** @lends FusionCharts */ {
        /**
         * Sets the default renderer for all the charts that are subsequently instantiated. The renderer changes
         * depending upon the variant of charts being rendered (example: `flash`, `javascript`)
         *
         * @group renderer
         * @deprecated 3.4.0 - This has been deprecated since JavaScript variant is the only renderer supported.
         *
         * @param {string} name - The name of the renderer (variant of chart rendering method) that is used.
         */
        setCurrentRenderer: function (/* name */) {
            var ret = renderer.setDefault.apply(renderer, arguments);
            renderer.userSetDefault = true; // Mark this renderer as user set.
            return ret;
        },

        /**
         * Gets the current renderer that will be used during instantiation of new charts.
         *
         * @group renderer
         * @deprecated 3.4.0 - This has been deprecated since JavaScript variant is the only renderer supported.
         *
         * @returns {string} The name of the current renderer being used - `flash` or `javascript`.
         */
        getCurrentRenderer: function () {
            return renderer.currentRendererName.apply(renderer, arguments);
        },

        /**
         * Render FusionCharts directly using the simplest one-line argument parameter. This function directly renders
         * FusionCharts into the container specified in arguments.
         *
         * Calling this function directly is same as creating a new instance of `FusionCharts` and calling `.render()`
         * on it, i.e., `var chart = FusionCharts.render({...});` is same as
         * `var chart = new FusionCharts({...}); chart.render();`.
         *
         * @group chart
         *
         * @param {object} options - Options required to create FusionCharts. The option must have the `renderAt`
         * parameter for the render to happen instantly.
         *
         * @param {FusionCharts~renderCallback=} [callback]  - Upon successful render of a chart, a function passed to
         * this parameter is called.
         *
         * @fires FusionCharts#beforeRender
         * @fires FusionCharts#rendered
         * @fires FusionCharts#renderComplete
         * @fires FusionCharts#renderCancelled
         *
         * @return {FusionCharts} - Returns the newly created instance of {@link FusionCharts} object.
         *
         * @example
         * FusionCharts.ready(function () {
         *     var chart = FusionCharts.render({
         *         type: "column2d",
         *         renderAt: "chart-container-div",
         *         dataSource: "data.json",
         *         dataFormat: "jsonurl"
         *     });
         * });
         */
        render: function (options, callback) {
            // If a FusionCharts object is sent to it, it calls render method of it.
            if (options instanceof global.core) {
                options.render(callback);
                return options;
            }

            // Render a new FusionCharts out of the parameters and return the object.
            return new global.core(options).render(callback);

        }
    }, false);
}]);
/**
 * Data-Handler Abstraction Framework
 * This allows developers to dynamically integrate a data transcoder so that
 * FusionCharts core can seamlessly work with multiple formats for data
 * provisioning.
 * @private
 *
 * @module fusioncharts.transcoder
 * @requires fusioncharts.events
 * @requires fusioncharts.ajax
 * @requires fusioncharts.renderer
 */
FusionCharts.register('module', ['private', 'modules.interface.transcoder', function () {

    var global = this,
        win = global.window,

        SOURCENAME = 'XmlHttpRequest',
        handlers = global.transcoders = {},
        dataStore = {}, // original data cache
        cache = {}, // per-chart data cache
        isUrl =  /url$/i,

        // Enumeration of charts that has exceptional implementation of 'getXMLData'
        // method. The value [dynamicDatRouter, dynamicAttributeRouter]
        // A reference of this enum is stored at global._interactiveCharts so that
        // it can be accessed by ChartAttributes module. This is done so that for
        // interactive charts, when data is fetched, we fetch the updated data and not
        // the initial data state.
        interactiveCharts = global._interactiveCharts = {
            'selectscatter': [true, false],
            'dragcolumn2d': [true, true],
            'dragarea': [true, true],
            'dragline': [true, true],
            'dragnode': [true, true]
        },

        /**
         * The event callback function on successful AJAX request completion
         * when requested by setChartDataUrl function.
         *
         * @param {type} responseText is the AJAX responseText passed to it by
         * the AJAX wrapper class
         * @param {type} wrapper is the Ajax wrapper class that is calling this
         * function
         * @param {type} data is the additional data that is passed on to this
         * function via Ajax Wrapper class. This generally contains the relevant
         * variables that this function needs from the original setChartDataUrl
         * function
         * @param {type} url is the URL to load!
         *
         * @returns {undefined}
         */
        xmlhttpSuccess = function (responseText, wrapper, data, url) {
            // Allow cancellation of data loaing
            var obj = data.obj,
                args = data.args;

            args.dataSource = responseText;
            args.xmlHttpRequestObject = wrapper;
            args.source = SOURCENAME;
            args.url = url;

            /**
             * Sometimes, the data to the Fusion charts object is loaded from a `URL` instead of a static file(*XML* or
             * *JSON*) on the client environment. The {@link FusionCharts#event:dataLoadRequested} event is fired when
             * the data is to be loaded from a *url*. Once the data is successfully loaded form the *url*, the
             * `dataLoadRequestCompleted` event is fired.
             *
             * The arguments object of this event contains the :
             *
             * * `URL` from which the data is loaded.
             * * `Data` loaded to the Fusion Charts object.
             * * `DataFormat` fo the data loaded from the URL.
             *
             * @event FusionCharts#dataLoadRequestCompleted
             *
             * @param {string} url - The Url of the data source from where the data was fetched.
             * @param {string} dataSource - The content of the dataSource as fetched from the `url`.
             * @param {FusionCharts~dataFormats} dataFormat Type of data format that was provided to be expected from
             * the `dataSource`.
             */
            global.raiseEvent('dataLoadRequestCompleted', args, obj, undefined, onDataLoadComplete, onDataLoadCancel);
        },

        /**
         * Callback function executed by AJAX wrapper class upon failure to
         * complete data load request (from setChartDataUrl)
         *
         * @param {type} resp The response from server (usually meaningless!)
         * @param {type} wrapper Reference to the callee
         * @param {type} data  is the additional data that is passed on to this
         * function via Ajax Wrapper class. This generally contains the relevant
         * variables that this function needs from the original setChartDataUrl
         * function
         * @param {type} url is the URL that could not be loaded!
         *
         * @returns {undefined}
         */
        xmlhttpFailure =  function (resp, wrapper, data/*, url*/) {
            // Compile argument for event.
            var obj = data.obj,
                args = data.args;

            args.error = resp;
            args.httpStatus = (wrapper.xhr && wrapper.xhr.status) ? wrapper.xhr.status : -1;
            args.xmlHttpRequestObject = wrapper;

            /**
             * The `dataLoadError` event is raised when there is an error loading data to the chart object from the
             * specified `URL`.It informs the user of :
             *
             * * The `URL` from which the data could not be fetched.
             * * The `dataFormat` of the *dataSource*.
             * * The `error object` which is useful for debugging purposes.
             * * The `httpStatus` to identify the server communication issues
             *
             * This information can be used to show an error message to the user or to take a corrective measure so that
             *  the data is loaded successfully.
             * @event FusionCharts#dataLoadError
             *
             * @param {string} url - The Url that could not be successfully loaded.
             * @param {FusionCharts~dataFormats} dataFormat - The format of the data that was expected from the Url.
             * @param {string} error - In case any aspect of loading data results in a JavaScript error, the error
             * object is passed on to this event for debugging purposes.
             * @param {number} httpStatus - In case of an error, this parameter is useful to identify server
             * communication issues - such as `404` status returned when the `url` provided is not found.
             */
            global.raiseEvent('dataLoadError', args, obj);

            // Call legacy event handler.
            if (typeof win.FC_DataLoadError === 'function') { // jshint ignore:line
                win.FC_DataLoadError(obj.id, args); // jshint ignore:line
            }
        },

        /**
         * Default action of DataLoadRequestCompleted event. Upon request completion
         * the data needs to be set to the chart.
         *
         * @param {type} event DataLoadRequestCompleted event object
         * @param {type} args DataLoadRequestCompleted event arguments
         *
         * @note This function is expected to be executed from `xmlhttpSuccess`
         * function
         */
        onDataLoadComplete = function (event, args) {
            // Update the chart's dataStore with data received
            // from url
            event.sender.setChartData(args.dataSource, args.dataFormat, args.config, args.successcallback, args.silent);
        },

        /**
         * Prevented action of DataLoadRequestCompleted event. Upon request
         * prevention, ongoing XHR needs aborting and a subsequent cancel event
         * to be raised.
         *
         * @param {type} event DataLoadRequestCompleted event object
         * @param {type} args DataLoadRequestCompleted event arguments
         *
         * @note This function is expected to be executed from `xmlhttpSuccess`
         * function
         */
        onDataLoadCancel = function (event, args) {
            /**
             * When the default action of {@link FusionCharts#event:dataLoadRequested} event is cancelled using
             * `eventObject.preventDefault()`, this event is raised. Subsequently, the associated AJAX requests are
             * aborted.
             * @event FusionCharts#dataLoadCancelled
             *
             * @param {string} url - Url of the requested data source.
             * @param {FusionCharts~dataFormats} dataFormat - The data format that was specified to be expected from the
             * contents of the `url`.
             */
            global.raiseEvent('dataLoadCancelled', args, event.sender);
            args.xmlHttpRequestObject.abort();
        },

        onDataLoadRequest = function (event, args) {
            var chart = event.sender,
                state = chart.__state,
                url = args.url;

            // Update reference to data-source.
            chart.options.dataSource = args.url;

            // Create an XMLHttpRequest object if it is not already
            if (!state.dhmXhrObj) {
                state.dhmXhrObj = new global.ajax(xmlhttpSuccess,
                    xmlhttpFailure);
            }

            // Initiate XmlHttpRequest.
            state.dhmXhrObj.get(typeof win.decodeURIComponent === 'function' ?
                    win.decodeURIComponent(url) : win.unescape(url), {
                obj: chart,
                args: args
            });
        },

        onDataLoadRequestCancel = function (event, args) {
            var chart = event.sender,
                state = chart.__state;
            /**
             * This event is raised when the data load process is cancelled by calling the
             * `eventObject.preventDefault()` of {@link FusionCharts#event:dataLoadRequested} event. In cases where the
             * data source is a local path or if the `URL` fails internal security checks, the
             * `dataLoadRequestCancelled` event  is internally fired.
             * @event FusionCharts#dataLoadRequestCancelled
             *
             * @param {string} url - `URL` of the data source.
             * @param {FusionCharts~dataFormats} dataFormat - The data format that was specified to be expected from the
             * contents of the `url`.
             */
            global.raiseEvent('dataLoadRequestCancelled', args, chart);
            // In case cancel was hit even before this function reached here,
            // we then do not proceed.
            if (state && state.dhmXhrObj) {
                state.dhmXhrObj.abort();
            }
        },

        onDataUpdateSuccess = function (event, args) {
            var chart = event.sender,
                state = chart.__state,
                chartId = chart.id;

            // Save data within dataStore
            dataStore[chartId] = args;
            // Clear cache
            if (cache[chartId]) {
                delete cache[chartId];
            }
            cache[chartId] = {};

            // Clear any decision flag whether data is ready for chart to be
            // rendered.
            state.dataReady = undefined;
            state.dataAvailable = true;

            // Raise data updation event if it is not marked as silent data
            // updating.
            if (args.silent !== true) {
                // stall this update if this is stuck in between a render and loading
                if (chart.options.safeMode === true &&
                    state.rendering === true && !chart.isActive()) {
                    state.updatePending = args;
                    /**
                     * This warning is issued when a chart's rendering process and the process of data being fetched
                     * from an URL has happened simultaneously. FusionCharts delays the rendering of the chart in
                     * anticipation of the arrival of data and in the process reduces redundant re-rendering of the
                     * charts.
                     *
                     * This warning is for information purpose only and does not require any action.
                     *
                     * @typedef {RuntimeException} Warning-23091255
                     * @memberOf FusionCharts.debugger
                     * @group debugger-warning
                     */
                    global.raiseWarning(chart, '23091255', 'run', '::DataHandler~update',
                        'Renderer update was postponed due to async loading.');
                }
                else {
                    delete state.args;
                    global.renderer.update(chart, args);
                }
            }

            /**
             * On updating the data of a chart, the chart is *re-drawn*. The
             * {@link FusionCharts#event:drawCompleteEvent} gets fired as soon the necessary elements of the chart are
             * re-drawn.This event is followed by the `dataUpdated` event which is raised when the data is loaded into
             * *FusionCharts JavaScript class* and is ready to be passed to the chart to maintain integrity and timing
             * of related codes.
             * @event FusionCharts#dataUpdated
             *
             * @param {string|object} data - The data in one of the formats as in {@link FusionCharts~dataFormats}, that
             * has been passed on to the chart.
             * @param {FusionCharts~dataFormats} format - The format in which the data has been finally passed on to the
             * chart. It is not that the original format in which data has been provided will be the final format passed
             * on to the data. For instance, JavaScript variant of chart when renderer (as can be retrieved from
             * {@link FusionCharts.getCurrentRenderer}) is `javascript`, the data format is `JSON`.
             * @param {string} dataSource - The original/source data as specified using data setter functions such as
             * {@link FusionCharts#setChartData}.
             * @param {FusionCharts~dataFormats} dataFormat - The data format of the original/source data.
             * @param {string} error During the process of fetching and updating data, if there was any error, the same
             * is passed on for debug purposes.
             */
            global.raiseEvent('dataUpdated', args, chart, undefined, args.successcallback);
        },

        onDataUpdateCancel = function (event, args) {
            /** @todo Implement failurecallback */
            /**
             * Cancelling the default behavior of {@link FusionCharts#event:beforeDataUpdate} causes the
             * `dataUpdateCancelled` event to be raised .This event can used to notify the user that the update of data
             * was cancelled.
             * @event FusionCharts#dataUpdateCancelled
             *
             * @param {string|object} data - The data in one of the formats as in {@link FusionCharts~dataFormats}, that
             * was supposed to be passed on to the chart.
             * @param {FusionCharts~dataFormats} format - The format in which the data was to be passed on for
             * rendering.
             * @param {string} dataSource - The original/source data as specified using data setter functions such as
             * {@link FusionCharts#setChartData}.
             * @param {FusionCharts~dataFormats} dataFormat - The data format of the original/source data.
             * @param {string} error During the process of fetching and cancellation of data, if there was any error,
             * the same is passed on for debug purposes.
             */
            global.raiseEvent('dataUpdateCancelled', args, event.sender, undefined, args.failurecallback);
        };

    /**
     * The list of data formats that can be passed over to {@link FusionCharts#setChartData} or
     * {@link FusionCharts#setChartDataUrl} or during creating a new instance of {@link FusionCharts}. The parameters
     * that accept data format should have one of the values from this enumeration.
     * @enum
     * @memberOf FusionCharts~
     * @name dataFormats
     * @group data
     *
     * @property {string}  json - This denotes that the data being passed on to the chart or returned by the chart is in
     * standard `JSON` format. The JSON format can be a string containg JSON data or it can also be a JavaScript object.
     * @property {string}  jsonurl - Specifying the data format as `jsonurl` indicates that the data is not `JSON` data
     * by itself but rather the data being passed is a `URL` pointing to a file that contains `JSON` data.
     * @property {string}  csv - FusionCharts supports data in comma separated value format. However, this is presently
     * supported to retrieve data set in one of the other formats and data cannot be passed on to chart in `CSV` format.
     * @property {string}  xml - Specifies that the data passed on to the chart is in `XML` format. As such the data
     * is expected to be a string containing XML data.
     * @property {string}  xmlurl - The `xml` data format is transportable by nature. This means that specifying the
     * data as an `URL` to a file that contains XML is a valid option.
     */
    global.dataFormats = {};

    // Allow data-related parameters to be passed in constructor
    global.policies.options.dataSource = ['dataSource', undefined];
    global.policies.options.dataFormat = ['dataFormat', undefined];
    global.policies.options.dataConfiguration = ['dataConfiguration', undefined];
    global.policies.options.showDataLoadingMessage = ['showDataLoadingMessage', false];

    // Expose Data handler and related management API.
    global.addDataHandler = function (name, obj) {
        if (typeof name !== 'string' || handlers[name.toLowerCase()] !== undefined) {
            /**
             * Invalid data handler has been registered. Check whether `global.addHandler` receives a string as the
             * first parameter and that the data handler is not a duplicate one.
             * @private
             *
             * @typedef {RuntimeException} Error-03091606
             * @memberOf FusionCharts.debugger
             * @group debugger-error
             */
            global.raiseError(global.core, '03091606', 'param', '::DataManager.addDataHandler',
                new Error('Invalid Data Handler Name'));
            return;
        }
        var api = {}, lcaseName = name.toLowerCase();

        // Add handler to collection
        handlers[lcaseName] = obj;
        obj.name = name;

        // Create Handler Direct Access API. This adds common fuctions for the
        // handler.
        api['set' + name + 'Data'] = function (data, config, callback) {
            return this.setChartData(data, name, config, callback);
        };

        // add network transport of data
        if (obj.transportable) {
            api['set' + name + 'Url'] = function (url, config, callback) { // unused param: [1]config
                return this.setChartDataUrl(url, name, config, callback);
            };
            global.dataFormats[name + 'URL'] = lcaseName + 'Url';
        }

        api['get' + name + 'Data'] = function () {
            return this.getChartData(name);
        };

        // Add data formats to global formats collection
        global.dataFormats[name] = lcaseName;

        // Extend FusionCharts objects
        global.extend(global.core, api, true);
    };

    // Add getter and setter to FusionCharts Objects
    global.extend(global.core.prototype, /** @lends FusionCharts# */ {

        /**
         * Update the data of a chart by fetching contents from a URL. The URL can point to either a JSON or a XML
         * file. The data format of the URL needs to be  specified in the `format` parameter.
         *
         * This function fetches content from the URL provided and passes the result to
         * {@link FusionCharts#setChartData}  to update chart data. So, if the chart is already rendered, it is updated
         * with the new data as soon as it is fetched from the URL. If the  chart is not rendered, data from the URL is
         * fetched and stored locally till the chart is rendered.
         *
         * If the data format of the URL is already known, an alternative to this function is to use either
         * {@link FusionCharts#setJSONUrl} or {@link FusionCharts#setXMLUrl} to specify JSON or XML data URL
         * respectively.
         *
         * It is not recommended to use this function to set data to a new chart. Instead, it is preferred to pass the
         * URL as `dataSource` in the FusionCharts constructor.
         *
         * > FusionCharts uses `AJAX` to transport data. So, ensure that the chart is running from a web-server in
         * > order to prevent browser's security restrictions of fetching local (`file://`) files.
         *
         * @group data
         *
         * @see FusionCharts#setJSONUrl
         * @see FusionCharts#setXMLUrl
         *
         * @param {string} url - The URL from where to fetch the data of the chart.
         * @param {FusionCharts~dataFormats=} [format] - The format of data that is expected to contain in the `url`
         * provided. If this parameter is not provided or is not a valid member of {@link FusionCharts~dataFormats} then
         * the current default or previously set data format is assumed.
         *
         * @fires FusionCharts#dataLoadRequested
         * @fires FusionCharts#dataLoadRequestCompleted
         * @fires FusionCharts#dataLoadRequestCancelled
         *
         * @example
         * // Render a chart and fetch data from a JSON file and then when a button is pressed, change the data.
         * FusionCharts.ready(function () {
         *     var chart = new FusionCharts({
         *         type: "column2d",
         *         renderAt: "chart-container",
         *         dataSource: "weekly-sales.json",
         *         dataFormat: "jsonurl"
         *     }).render();
         *
         *     // Assign the functionality of updating data to a button which already
         *     // exists in page body and has a specific Id.
         *     document.getElementById("data-update-button").onclick = function () {
         *         // Specify the new Url to fetch data from.
         *         chart.setChartDataUrl("average-employee-sales.json", "json");
         *     };
         * });
         */
        setChartDataUrl: function (url, format, config, callback, silent) {
            var baseFormat;

            if (format === undefined || format === null || typeof format.toString !== 'function') {
                format = this.options.dataFormat;
                /**
                 * When an invalid data format has been passed to {@link FusionCharts#setChartDataUrl} or other data-
                 * url-setter functions, this warnig is raised. The chart continues to use the last used data format in
                 * this situation. Ensure that you are using one of the data `url` prefixed formats specified in
                 * {@link FusionCharts~dataFormats}.
                 *
                 * @typedef {ParameterException} Warning-03091609
                 * @memberOf FusionCharts.debugger
                 * @group debugger-warning
                 */
                global.raiseWarning(this, '03091609', 'param', 'FusionCharts#setChartDataUrl',
                    'Invalid Data Format. Reverting to current data format - ' + format);
            }

            // Desensitize case of parameter.
            format = format.toString().toLowerCase();

            // Check whether the data-format has "url" at the end of it.
            // We compute the base format and update the format accordingly so
            // that format always ends with 'url' and the baseFormat contains real
            // format name.
            if (isUrl.test(format)) {
                baseFormat = format.slice(0, -3);
            }
            else {
                baseFormat = format;
                format = format + 'url';
            }
            /**
             * If the chart loads data from a URL instead of a static file(*XML* or *JSON*) on the system, then the
             * `dataLoadRequested` event is fired before the data is loaded to the Fusion Charts class object.
             *
             * This event can be used to obtain the *data source* name, the *data format*, the *url*,
             * @event FusionCharts#dataLoadRequested
             * @param {string} source Nature of data load request. Presently its value is "XmlHttpRequest"
             * @param {string} url URL of the data source
             * @param {FusionCharts~dataFormats} dataFormat  Type of Data format. It can be either xml or json
             * @param {boolean} silent Save the silent instruction to arguments.
             * @param {function} callback This the callback function called once the event is fired.
             */
            global.raiseEvent('dataLoadRequested', {
                source: SOURCENAME,
                url: url,
                dataFormat: baseFormat,
                silent: !!silent,
                config: config,
                successcallback: callback
            }, this, undefined, onDataLoadRequest, onDataLoadRequestCancel);
        },

        /**
         * Update the data of a chart in the format specified in by the `format` parameter. The data passed as the
         * `format` parameter should be in one of the {@link FusionCharts~dataFormats}. When this function is called on
         * a chart which has already rendered, the chart is instantly updated with the new data.
         *
         * This function can also be used to set data of a chart before it has rendered. In that case, the data being
         * set is stored internally and passed on to the chart when it is rendered. However, this is not the preferred
         * way to set chart data. Instead, initial chart data should be passed in the FusionCharts constructor.
         *
         * If the data format is already known, an alternative to this function is to use either
         * {@link FusionCharts#setXMLData} or {@link FusionCharts#setJSONData} to set XML or JSON data respectively.
         *
         * @group data
         *
         * @see FusionCharts#setXMLData
         * @see FusionCharts#setJSONData
         *
         * @param {string|object} data - The data to be passed on to the chart in one of the available data formats as
         * specified by the `format` parameter.
         * @param {FusionCharts~dataFormats=} [format] - The format of the data being passed on to the chart. If this
         * parameter is not provided or is not a valid member of {@link FusionCharts~dataFormats} then the current
         * default or previously set data format is assumed.
         *
         * @fires FusionCharts#beforeDataUpdate
         * @fires FusionCharts#dataUpdated
         * @fires FusionCharts#dataUpdateCancelled
         *
         * @example
         * // Create a chart in a page and pass data to it in `JSON` format and on click of a
         * // button update it with newer data.
         * FusionCharts.ready(function () {
         *     var chart = new FusionCharts({
         *         type: "pie2d",
         *         renderAt: "chart-container",
         *
                   dataSource: {
         *             chart: {
         *                 caption: "Market Share",
         *                 showPercentage: "1"
         *             },
         *             data: [
         *                 { label: "Current Prototype", value: "30" },
         *                 { label: "Revised Prototype", value: "35" },
         *                 { label: "Previous Prototype", value: "25" },
         *                 { label: "Recalled Prototype", value: "10" }
         *             ]
         *         },
         *         dataFormat: "json"
         *     }).render();
         *
         *     // Set data on the chart using the setChartData function when a button is clicked.
         *     document.getElementById("update-data").onclick = function () {
         *         chart.setChartData({
         *             chart: {
         *                 caption: "Market Share Impact",
         *                 numberPrefix: "USD"
         *             },
         *             data: [
         *                 { label: "Current Prototype", value: "13773" },
         *                 { label: "Revised Prototype", value: "16069" },
         *                 { label: "Previous Prototype", value: "11477" },
         *                 { label: "Recalled Prototype", value: "4591" }
         *             ]
         *         }, "json");
         *     };
         * });
         */
        setChartData: function (data, format, config, callback, silent) {
            // The base format is set by truncating fetching method from the format-string and then stored in
            // 'baseFormat' variable.
            var chartObj = this,
                chartOptions = chartObj.options,
                currentRenderer,
                baseFormat,
                nativeFormat,
                handler,
                parseArgs;

            // In case format is not a string, we raise a warning
            if (format === undefined || format === null || typeof format.toString !== 'function') {
                format = chartOptions.dataFormat;
                /**
                 * When an invalid data format has been passed to {@link FusionCharts#setChartData} or other data-
                 * setter functions, this warnig is raised. The chart continues to use the last used data format in this
                 * situation. Ensure that you are using one of the data formats specified in
                 * {@link FusionCharts~dataFormats}.
                 *
                 * @typedef {ParameterException} Warning-03091610
                 * @memberOf FusionCharts.debugger
                 * @group debugger-warning
                 */
                global.raiseWarning(this, '03091610', 'param', 'FusionCharts#setChartData',
                    'Invalid Data Format. Reverting to current data format - ' + format);

            }
            // Desensitize case of parameter.
            format = format.toString().toLowerCase();

            // Check whether the data-format has "url" at the end of it. If true,
            // then we call the setChartDataUrl method and that in turn calls this
            // method as callback (marked as _recursed.)
            if (isUrl.test(format)) {
                chartObj.setChartDataUrl(data, format, config, callback, silent);
                return;
            }
            else {
                // When there is no trailing "url" in data-format, we assume that
                // the format provided is baseFormat itself.
                // Update the dataSource here only when we know that this call
                // was not recursed for dataurl purpose
                chartOptions.dataSource = data;
                baseFormat = format;
            }
            // Update chart's internal data-format options
            chartOptions.dataFormat = format;

            // Fetch the data-handler function from the dataHandler collection.
            handler = handlers[baseFormat];

            // If the handler has been successfully fetched, execute it.
            if (typeof handler === 'undefined') {
                /**
                 * This error is raised when FusionCharts data setter functions receive a
                 * {@link FusionCharts~dataFormats} that is not internally registered successfully. It is very less
                 * likely that this error will be raised unless the implementation of FusionCharts is done using a
                 * non-standard way (e.g. directly `chart.options.dataFormat` has been changed.)
                 *
                 * @typedef {ParameterException} Error-03091611
                 * @memberOf FusionCharts.debugger
                 * @group debugger-error
                 */
                global.raiseError(global.core, '03091611', 'param', 'FusionCharts#setChartData',
                    new Error('Data Format not recognized'));
                return;
            }

            // Determine the native data format of the renderer if it is available
            currentRenderer = global.renderer &&
                    global.renderer.getRenderer(chartOptions.renderer ||
                    global.renderer.currentRendererName());
            nativeFormat = currentRenderer && currentRenderer.dataFormat;

            // If native format is equal to baseFormat, then we do not pass it
            // through encoder otherwise, we keep a native format encoded
            // Execute the parser and fetch the parsing result. Also check whether
            // the parser returns a valid object, if not, use a blank object.
            parseArgs = (nativeFormat === baseFormat) ? (handler.passthrough ? handler.passthrough(data, config) :{
                data: data
            }) : (handler.encode(data, chartObj, config || chartOptions.dataConfiguration) || {});

            // Updated the result so that it can be passed as event argument.
            // Closure compiler gives error when using obj.native. Hence using
            // different notation.
            /* jshint ignore:start */
            parseArgs['native'] = (nativeFormat === baseFormat);
            parseArgs.format = parseArgs['native'] ? nativeFormat : 'xml';
            /* jshint ignore:end */
            parseArgs.dataFormat = baseFormat;
            // Add additional argument for events in parser result
            parseArgs.dataSource = data;
            // Save the silent instruction to arguments
            parseArgs.silent = !!silent;

            if (typeof callback === 'function') {
                parseArgs.successcallback = callback;
            }

            /**
             * This event is raised before data provided by user is made ready to be passed on to the chart. This is a
             * very useful event in a way where one can listen to this event and perform various operations on the data
             * before it is applied to the chart.
             * @event FusionCharts#beforeDataUpdate
             *
             * @param {string} data - URL of the data source.
             * @param {FusionCharts~dataFormats} format - URL of the data source.
             * @param {string|object} dataSource - The original data source provided. In case the data-source was
             * provided as a URL, this property will reflect the content retrieved from that Url. If data is provided in
             * any format other than `JSON`, it eventually gets converted to `JSON`. However, this property helps one to
             * access the original data.
             * @param {FusionCharts~dataFormats} dataFormat - The original format in which the data was provided to the
             * chart. Similar to the `dataSource` parameter, one will retain access to the original source data even
             * though it was converted to `JSON`.
             * However, this property helps one to know what was the original format in which the data was set.
             * @param {Error} error - In case parsing or retrieving of the data had resulted in an error, the error
             * object is forwarded in this property. Most of data parsing errors are trapped and raised in separate
             *
             * @example
             * // Show data of a single-series column chart in an
             * // ascending sorted order.
             * FusionCharts.ready(function () {
             *     var chart = new FusionCharts({
             *         type: "column2d",
             *         renderAt: "chart-container"
             *     });
             *
             *     // Add the data handler to intercept incoming
             *     // data and sort it.
             *     chart.addEventListener("beforeDataUpdate", function (event, args) {
             *         var data = args.data,
             *             values;
             *
             *         // If incoming data is not JSON then convert it to JSON
             *         if (args.format !== 'json') {
             *             data = FusionCharts.transcodeData(data, args.format, 'json');
             *         }
             *
             *         // Get hold of the data array
             *         values = data.data;
             *         if (values && values.length) { // Check whether data exists
             *             // Sort the data by passing a comparison function to the
             *             // sort function of the array of values.
             *             values.sort(function (a, b) {
             *                  return (a && a.value) - (b && b.value);
             *             });
             *         }
             *
             *         // Convert data back to original format in case it wasn't
             *         // originally JSON
             *         if (args.format !== 'json') {
             *             data = FusionCharts.transcodeData(data, 'json', args.format);
             *         }
             *
             *         // Replace the data with updated data.
             *         args.data = data;
             *     });
             * });
             */
            global.raiseEvent('beforeDataUpdate', parseArgs, chartObj, undefined,
                onDataUpdateSuccess, onDataUpdateCancel);
        },

        /**
         * Fetch data that has been set on a chart in one of the formats specified in {@link FusionCharts~dataFormats}.
         *
         * This function needs to be called on an existing chart. If this function is called on a chart which has no
         * data set, it returns an empty object for `json`, an empty `<chart />` element for `xml` and an empty string
         * for `csv`.
         *
         * @group data
         * @see FusionCharts#getJSONData
         * @see FusionCharts#getXMLData
         * @see FusionCharts#getCSVData
         *
         * @param {FusionCharts~dataFormats} format - The format in which the data is to be retrieved from the chart.
         * @returns {object|string}
         * @example
         * // Render a chart and upon click of a button alert the chart's data in
         * // CSV format.
         * FusionCharts.ready(function () {
         *     var chart = new FusionCharts({
         *         type: "column2d",
         *         renderAt: "chart-container",
         *         dataSource: "weekly-sales.json",
         *         dataFormat: "jsonurl"
         *     }).render();
         *
         *     // Assign the functionality of retrieving and alerting CSV data to
         *     // click event of a button
         *     document.getElementById("alert-csv-data").onclick = function () {
         *         alert(chart.getChartData("csv"));
         *     };
         * });
         */
        getChartData: function (format, advanced) {

            // Variable to store a reference to the data-handler.
            var chartObj = this,
                chartOptions = chartObj.options,
                id = this.id,
                handler,
                parseResult;
            // Desensitize case of parameter and fetch the data-handler
            // function from the dataHandler collection within the validation
            // check itself.

            if (format === undefined || typeof format.toString !== 'function' || (handler = handlers[format =
                format.toString().toLowerCase()]) === undefined) {
                /**
                 * When an invalid data format has been passed to {@link FusionCharts#getChartData} or other data-
                 * getter functions, this error is raised. Ensure that you are using one of the data formats specified
                 * in {@link FusionCharts~dataFormats}.
                 *
                 * @typedef {ParameterException} Error-25081543
                 * @memberOf FusionCharts.debugger
                 * @group debugger-error
                 */
                global.raiseError(this, '25081543', 'param', '::transcoder~getChartData()',
                    new Error('Unrecognized data-format specified in "format"'));
                return undefined;
            }

            // Check presence of cached data or call the decoder routine of
            // the data-handler and return the decoded data.
            if (cache[id][format]) {
                parseResult = cache[id][format];
            }
            else if (dataStore[id]) {
                // In case data is not cached, we check if native data can be
                // returned
                if (format === dataStore[id].format) {
                    cache[id][format] = dataStore[id];
                }
                else {
                    // At this point, we know that the data requires transcoding
                    // and as such we keep the base encoding format prepared
                    if (!cache[id].xml) {
                        cache[id].xml = (dataStore[id].format === 'xml') ?
                            dataStore[id] : handlers[dataStore[id].format].encode(dataStore[id].data,
                                chartObj, chartOptions.dataConfiguration);
                    }
                    // Now we transcode to other formats if needed.
                    if (!cache[id][format]) {
                        cache[id][format] = handler.decode(cache[id].xml.data,
                            chartObj, chartOptions.dataConfiguration);
                    }
                }
                // At this point, there must be cached data!
                parseResult = cache[id][format];
            }
            else {
                parseResult = {
                    error: new Error('Data not defined')
                };
            }
            // Return the eminent data (in advanced mode if needed.
            return Boolean(advanced) === true ? parseResult : parseResult.data;
        },

        /**
         * This function is used to determine whether a chart will render properly with the data set on it. This
         * includes data that are set using functions like {@link FusionCharts#setChartData} or
         * {@link FusionCharts#setChartDataUrl}.
         *
         * If the function is not able to determine whether the data is ready or not, it returns `undefined`. It will
         * return `true` or `false` only after a chart has completed rendering, that is, the after the `renderComplete`
         * event has fired.
         *
         * The function will return `false` if no data is set on the chart, or the data is faulty. Also, it will return
         * `false` if the data provided is incompatible with the current chart type, for example, if single-series data
         * has been set for multi-series charts.
         *
         * @group data
         *
         * @param {boolean=} [available=false] - Setting the `available` parameter to `true` returns the status of the
         * data irrespective of its compatibility with chart-type. In that case, this function will return `false`
         * if data provided to the chart causes {@link FusionCharts#event:dataLoadError} or
         * {@link FusionCharts#event:dataInvalid} to be fired
         *
         * @returns {boolean|undefined} The returned boolean denotes whether data is ready or not. In case the status of
         * data-readiness is unknown, this function returns `undefined`.
         */
        dataReady: function (available) {
            return available ? this.__state.dataAvailable : this.__state.dataReady;
        }
    });

    global.extend(global.core, /** @lends FusionCharts */ {
        /**
         * FusionCharts supports a number of formats in which data can be provided. The default list is mentioned at
         * {@link FusionCharts~dataFormats}. This function allows data to be transcoded from one supported format to
         * another.
         *
         * The primary use of this function is to convert data in one format to another without initializing a new
         * instance of FusionCharts. It is very useful when you already have a set of data stored or prepared in a
         * particular FusionCharts data format and you would like to convert it to another format. The fact that we
         * do not need to instantiate a new instance of `FusionCharts` makes the conversion process very fast.
         *
         * @group data
         *
         * @param {string|object} data The data that needs to be transcoded from one format to another.
         * @param {FusionCharts~dataFormats} source - The data format of the `data` provided.
         * @param {FusionCharts~dataFormats} target - The desired data format in which the `data` needs to be converted.
         * @param {boolean=} [advanced=false] - Request the transcoding to return data in a verbose format where it
         * returns the conversion result along with additional transocing information. In advanced mode, the returned
         * data of this function is in the following format:
         *
         * |Property    |Type              |Description                                                         |
         * |------------|------------------|--------------------------------------------------------------------|
         * |`data`      |object | string   |The result of the transcoding process                               |
         * |`error`     |Error | undefined |In case the transcoding process failed, the error is passed here    |
         *
         * @returns {string|object} - The transcoded data is returned in the data type as associated with the target
         * data format. The return-type depends upon the {@link FusionCharts~dataFormats} specified as the `target`
         * parameter.
         *
         * @example
         * // We would convert JSON data that is already in FusionCharts data format into CSV data format.
         * FusionCharts.ready(function () {
         *     var salesData = {
         *         chart: {
         *             caption: "Harry's SuperMart",
         *             subCaption: "Top 5 stores in last month by revenue",
         *         },
         *         data:[{
         *             label: "Bakersfield Central",
         *             value: "880000"
         *         },
         *         {
         *             label: "Garden Groove harbour",
         *             value: "730000"
         *         },
         *         {
         *             label: "Los Angeles Topanga",
         *             value: "590000"
         *         },
         *         {
         *             label: "Compton-Rancho Dom",
         *             value: "520000"
         *         },
         *         {
         *             label: "Daly City Serramonte",
         *             value: "330000"
         *         }]
         *     };
         *
         *     // Alert the data after converting it to CSV data format.
         *     alert(FusionCharts.transcodeData(salesData, 'json', 'csv'));
         * });
         */
        transcodeData: function (data, source, target, advanced, configuration) {

            // Validate parameters.
            if (!source || typeof source.toString !== 'function' || !target || typeof target.toString !== 'function' ||
                handlers[(target = target.toString().toLowerCase())] === undefined ||
                handlers[(source = source.toString().toLowerCase())] === undefined) {
                /**
                 * This error is encountered when either the `source` or the `target` parameter of
                 * {@link FusionCharts.transcodeData} receives a value that is not part of the list of data formats in
                 * {@link FusionCharts~dataFormats}. Note that url-prefixed data formats are not intended to be supplied
                 * to the transcoder function.
                 *
                 * @typedef {ParameterException} Error-14090217
                 * @memberOf FusionCharts.debugger
                 * @group debugger-error
                 */
                global.raiseError(this, '14090217', 'param', '.transcodeData()',
                    new Error('Unrecognized data-format specified during transcoding.'));
                return undefined;
            }

            // Chain the decoder and encoder.
            var l1 = handlers[source].encode(data, this, configuration),
            l2 = handlers[target].decode(l1.data, this, configuration);

            // Carry the error.
            if (!(l2.error instanceof Error)) {
                l2.error = l1.error;
            }
            return advanced ? l2 : l2.data;
        }
    }, false);

    // This is an out-of architecture implementation to specifically
    // look for FlashRenderer specific instruction.
    if (!global.getRenderer || (global.getRenderer('flash'))) {
        global.addEventListener('DataLoadRequested', function (event) {
            var obj = event.sender;
            if ((obj.options && (obj.options.renderer === 'flash') &&
                    obj.options.useLegacyXMLTransport) || false) {
                event.preventDefault();
            }
        });
    }

    // Add constructor to initialize datastore or to clear any garbage.
    global.addEventListener('beforeInitialize', function (event) {

        // Get short reference to the event sender.
        var obj = event.sender,
            options = obj.options,
            dataSource = options.dataSource,
            renderer = global.renderer && global.renderer.getRenderer(options.renderer);

        // Clear the dataStore, cache and xStore when new chart is created.
        delete dataStore[obj.id];
        cache[obj.id] = {};


        // Set intitial data if present
        if (dataSource !== undefined && dataSource !== null) {
            obj.__state.dataSetDuringConstruction = true;

            // If data formay was not specified during construction, try
            // auto-detection.
            if (typeof options.dataFormat !== 'string') {
                switch (typeof dataSource) {
                    case 'function':
                        dataSource = options.dataSource = dataSource.call(obj, options.dataConfiguration);
                        options.dataFormat = 'JSON';
                        break;
                    case 'string':
                        options.dataFormat =
                            /^\s*?\{[\s\S]*\}\s*?$/g.test(obj.options.dataFormat) ?
                            'JSON' : 'XML';
                        break;
                    case 'object':
                        options.dataFormat = 'JSON';
                        break;
                }
            }

            if (options.dataFormat && options.dataFormat.toString) {
                obj.__state.dataFetchDuringConstruction = isUrl.test(options.dataFormat.toString());
            }

            obj.setChartData(dataSource, options.dataFormat, undefined, undefined, true);
        }
        // In case dataSource is not present during construction, we silently set it to rendere's default
        else if (renderer) {
            obj.__state.dataSetDuringConstruction = false;
            /**
             * FusionCharts supports construction parameters to have `dataSource` and `dataFormat` to be provided. As
             * such charts render with the data provided during construction. However, if a chart has been rendered by
             * calling {@link FusionCharts#render}, but no data has been provided to the chart, this warning is raised.
             *
             * Unless this is intentionally implemented, try furnishing the chart with data before `.render()` is
             * called.
             *
             * @typedef {ParameterException} Warning-1810131922A
             * @memberOf FusionCharts.debugger
             * @group debugger-warning
             */
            global.raiseWarning(obj, '1810131922A', 'param', ':dataHandler~event:beforeInitialize',
                        'Data source was not defined during construction, hence set to blank renderer default - ' +
                                renderer.dataFormat);
            obj.setChartData('', renderer.dataFormat, undefined, undefined, true);
            obj.__state.dataAvailable = false;
        }
    });

    // Add method to make sure to delete all fusioncharts objects when
    // dispose method is invoked
    global.addEventListener('beforeDispose', function (e) {
        var obj = e.sender;
        delete dataStore[e.sender.id];
        delete cache[e.sender.id];
        if (obj && obj.__state && obj.__state.dhmXhrObj) {
            obj.__state.dhmXhrObj.abort();
        }
    });

    // Attach an event handler to clear the data cache when chart is disposed.
    global.addEventListener('disposed', function (e) {
        delete cache[e.sender.id];
    });

    // Check for pending data updates
    global.addEventListener('loaded', function (e) {
        var obj = e.sender,
            pendingArgs = obj.__state.updatePending;

        if (obj instanceof global.core && pendingArgs !== undefined) {
            delete obj.__state.updatePending;
            global.renderer.update(obj, pendingArgs);
        }
    });

    global.addEventListener('dataUpdated', function (event, args) {
        var obj = event.sender,
            state = obj.__state;

        if (state.rendering && (state.dataFetchDuringConstruction || state.updatePending)) {
            delete state.dataFetchDuringConstruction; // flags must be unset before update to avoid recursion
            delete state.updatePending;
            global.renderer.update(obj, args);
        }
    });

    global.addEventListener(['dataLoadError', 'dataInvalid'], function (e) {
        e.sender.__state.dataAvailable = false;
    });

    global.addEventListener('loaded', function (event) {
        var obj = event.sender,
            state = obj.__state,
            transcoder,
            dataGetterName,
            transcoderName,
            newDataGetter; // function

        newDataGetter = function (format, protoHandler) {
            return function (fresh) {
                // obj redefined here so that on chart change, old obj
                // is not reused.
                var obj = this;

                if (fresh === false) { // check false positive
                    return protoHandler.apply(obj);
                }
                else if (obj.ref.getUpdatedXMLData) { // for flash
                    return global.core.transcodeData(obj.ref.getUpdatedXMLData(),
                            'xml', format);
                }
                else if (obj.getData) { // for js charts
                    return obj.getData(format);
                }
                else { // if all fail, return stale data
                    return protoHandler.apply(obj);
                }
            };
        };

        // We specially address the getXMLData function of PowerCharts.
        // We check whether the loaded chart is one of the listed charts that
        // are known to have the anomalous implementation.
        if (obj.chartType && interactiveCharts[obj.chartType()] &&
            interactiveCharts[obj.chartType()][0]) {
            // We set a modified getXXXData method that allows users to bypass
            // the JS method and use the flash method instead.
            for (transcoder in global.transcoders) {
                transcoderName = global.transcoders[transcoder].name;
                dataGetterName = 'get' + transcoderName + 'Data';

                obj[dataGetterName] = newDataGetter(transcoder, obj.constructor.prototype[dataGetterName]);
                obj[dataGetterName]._dynamicdatarouter = true; // flag
            }

            state.dynamicDataRoutingEnabled = true; // flag
        }
        // Remove for other chart types if it was earlier inserted.
        else if (state.dynamicDataRoutingEnabled){
            for (transcoder in global.transcoders) {
                transcoderName = global.transcoders[transcoder].name;
                dataGetterName = 'get' + transcoderName + 'Data';
                if (obj.hasOwnProperty(dataGetterName) &&
                        obj[dataGetterName]._dynamicdatarouter) {
                    delete obj[dataGetterName];
                }
            }
            state.dynamicDataRoutingEnabled = false;
        }

    });

}]);


/*
    json2.js
    2013-05-26

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (typeof JSON !== 'object') {
    JSON = {};
}

(function () {
    'use strict';

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function () {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear()     + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z'
                : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function () {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());
/**
 * JSON Data-Handler Module
 * This module performs the routines involved to transcode FusionCharts XML and
 * JSON. The module depends upon json2.js component from json.org and the same
 * has been included
 * @private
 *
 * @module fusioncharts.transcoder.json
 * @requires ../../../vendors/json2/json2.js
 * @requires fusioncharts.transcoder
 */
FusionCharts.register('module', ['private', 'modules.data.json', function () {

    var global = this,
        win = global.window,
        doc = win.document,

        COMPACTDATAMODE = 'compactdatamode',
        STRING = 'string',
        FUNCTION = 'function',
        OBJECT = 'object',
        QUOT = '\"',
        QUOTCOLON = '\":',
        /**
         * Trims a long string at lightning fast speed of less than an ms!
         * @param {string} str is the string to be trimmed.
         * @type string
         */
        fastTrim = function (str) {
            str = str.replace(/^\s\s*/, '');
            var ws = /\s/, i = str.length;
            while (ws.test(str.charAt(i -= 1))) { /* jshint noempty:false */ }
            return str.slice(0, i + 1);
        },

        xssEncode = global.xssEncode,

        xml2json, // function
        json2xml, // function
        json2json; // function

    if (win.JSON === undefined) {
        /**
         * When browser lacks native support for `JSON`, FusionCharts uses internal JSON parser. This error is raised
         * when even the internal parser fails to initialise. The application or implementation needs to be debugged to
         * identify the cause of this issue.
         *
         * @typedef {RuntimeException} Error-1113062012
         * @memberOf FusionCharts.debugger
         * @group debugger-error
         */
        global.raiseError(this, '1113062012', 'run', 'JSONDataHandler',
            new Error('Could not find library support for JSON parsing.'));
    }

    // Add policy to allow safe XML parsing in IE using XML Islands
    global.policies.options.allowIESafeXMLParsing = ['_allowIESafeXMLParsing', true];

    xml2json = (function () {

        var XML_CHILDNODE = 1,
            XML_TEXTNODE = 3,

            rules = {
                /*
                 * ~var {object} arr contains the nodeNames that are marked to be
                 * expanded as an array.
                 *
                 * There are two ways of defining the type:
                 * (a) in case the node is not constrained under a specific parent,
                 * we simply specify <code>nodeName: true</code>
                 *
                 */
                arr: {
                    set: true,
                    trendlines: true,
                    vtrendlines: true,
                    line: {
                        trendlines: true,
                        vtrendlines: true
                    },
                    data: true,
                    dataset: true,
                    lineset : true,
                    categories: true,
                    category: true,

                    //styles: true, // uncomment this to disable support for compact style syntax.
                    linkeddata: true,

                    // For application and definition, though we know that they are
                    // always under <styles>, yet we cannot specify that here as these
                    // two are in 'group' rule.
                    application: true,
                    definition: true,

                    // PowerCharts group of rules
                    axis: true,
                    connectors: true,
                    connector: {
                        connectors: true
                    },
                    trendset: true,
                    row: {
                        rows: true
                    },
                    column: {
                        columns: true
                    },
                    label: {
                        labels: true
                    },

                    // Widgets specific rules
                    color: {
                        colorrange: true // gauges + powercharts
                    },

                    dial: {
                        dials: true// gauge
                    },
                    pointer: {
                        pointers: true // gauge
                    },
                    point: {
                        trendpoints: true // gauge
                    },

                    // Gantt chart specific rules
                    process: {
                        processes: true // gantt
                    },
                    task: {
                        tasks: true // gantt
                    },
                    milestone: {
                        milestones: true // gantt
                    },
                    datacolumn: {
                        datatable: true // gantt
                    },
                    text: {
                        datacolumn: true // gantt
                    },
                    item: {
                        legend: true // gantt
                    },

                    // alert manager for realtime charts and gauges
                    alert: {
                        alerts: true
                    },

                    // annotation specific rules
                    groups: {
                        annotations: true
                    },
                    items: {
                        groups: true,
                        data: true // first for maps in 3.4
                    },

                    // geo renderer specific rules
                    shapes: true,
                    shape: {
                        shapes: true
                    },
                    entitydef: true, // map
                    entity: {
                        entitydef: true
                    }
                },

                /**
                 * ~var {object} tag contains nodeNames that are to be transformed
                 * to a different nodeName as specified within this rule's meta.
                 * note: supports comparison with base object.
                 */
                tag: {
                    chart: 'linkedchart',
                    map: 'linkedmap',
                    set: 'data',

                    vline: {
                        chart: 'data',
                        graph: 'data', // legacy
                        dataset: 'data',
                        categories: 'category',
                        linkedchart: 'data'
                    },
                    apply: {
                        application: 'application'
                    },
                    style: {
                        definition: 'definition'
                    },

                    marker: { // map
                        application: 'application', // deprecated 3.4
                        definition: 'definition', // deprecated 3.4
                        data: 'items' // new in 3.4
                    },

                    entity: { // map
                        entitydef: 'entitydef',
                        data: 'data'
                    },

                    shape: { // map and powercharts
                        shapes: 'shapes'
                    },

                    connector: { // map and powercharts
                        connectors: {
                            chart: 'connector',
                            linkedchart: 'connector',
                            map: 'connectors',
                            linkedmap: 'connectors'
                        }
                    },

                    // annotations
                    annotationgroup: {
                        annotations: 'groups'
                    },
                    annotation: {
                        groups: 'items'
                    }
                },

                /**
                 * ~var {object} attr is the rule that defines the default
                 * JSON variables to add in case a particular XML nodeName is found
                 */
                attr: {
                    vline: {
                        vline: 'true'
                    }
                },

                /**
                 * ~var {object} ins contains nodeNames, that are treated as source
                 * of attributes for a grand-child with same name as that of the
                 * child.
                 */
                ins: {
                    chart: true,
                    map: true,
                    graph: true
                },

                /**
                 * ~var {object} dsv contains nodeNames that are specially expected
                 * to be delimiter separated textnodes. Useful for "compactDataMode".
                 */
                dsv: {
                    dataset: 'data',
                    categories: 'category'
                },

                /**
                 * ~var {object} text rule specifies the nodes that are always
                 * treated as text node and appended to its parent with specified
                 * name.
                 *
                 * When specified as an array, it denotes that the text values are
                 * to be accumulated within a sibling array with specified name under
                 * a specified parent.
                 *
                 * When enclosed in an object it specifies the parent restriction.
                 *
                 * NOTE: That for allowing text rule to work, to append it parent
                 * we need to insert corresponding item in "group" rule.
                 *
                 * @example
                 * nodeName: equivalentJSONKey // simple key: 'value' result
                 */
                text: {
                    target: 'target',
                    value: 'value'
                },

                /**
                 * ~var {object} group specifies which are the tags that are to
                 * be promoted/inserted into its parent node (as in rule meta).
                 */
                group: {
                    styles: {
                        definition: true,
                        application: true
                    },
                    chart: {
                        value: true, // widgets
                        target: true // widgets
                    },
                    graph: { // legacy
                        value: true, // legacy widgets
                        target: true // legacy widgets
                    },
                    linkedchart: {
                        value: true, // widgets
                        target: true // widgets
                    },
                     // maps
                    markers: {
                        definition: true, // deprecated 3.4
                        application: true,  // deprecated 3.4
                        shapes: true,
                        connectors: true,
                        data: true
                    },
                    map: {
                        entitydef: true,
                        data: true
                    },
                    linkedmap: {
                        entitydef: true,
                        data: true
                    }
                }
            },

            parse, // namespace
            parser; // function

        parse = {
            append: function (childObj, obj, nodeName, parentNodeName) {
                // Before we append the childNode returned from the
                // previous recursion, we need to decide whether to
                // simply put that object with the nodeName as key, or
                // whether there is a qualification of 'arr' rule, by
                // which we push the data onto parent array.
                if (rules.arr[nodeName] && (rules.arr[nodeName] === true ||
                        rules.arr[nodeName][parentNodeName] === true)) {
                    if (!(obj[nodeName] instanceof Array)) {
                        obj[nodeName] = [];
                    }
                    obj[nodeName].push(childObj);
                }
                else {
                    obj[nodeName] = childObj;
                }
            },

            child: function (obj, children, parentNodeName, baseObj) {
                var i, nodeName, childNode, childObj, temp, rule;

                // Iterate through the children and parse it depending upon its
                // nodeType
                for (i = 0; i < children.length; i += 1) {

                    // Retain reference to the child node
                    childNode = children[i];

                    // Desensitize the case of the nodeName
                    nodeName = childNode.nodeName.toLowerCase();

                    // When the child object is a child node, we need to recurse
                    // onto it and also separately parse its attributes.
                    switch (childNode.nodeType) {
                        case XML_CHILDNODE:

                            // Parse the attributes of the XML Node.
                            childObj = parse.attr(childNode.attributes);

                            rule = rules.ins[nodeName];
                            if (rule === true) {
                                // In case 'ins' rule is matched, we transfer the
                                // parsed attributes to a grand-child having the node
                                // name of child and rename the child to the new name
                                // specified in the meta of 'tag' rule.
                                temp = childObj;
                                childObj = {};
                                childObj[nodeName] = temp;
                                temp = undefined;
                            }

                            // Apply the "attr" rule to add defalt flag variables.
                            rule = rules.attr[nodeName];
                            if (typeof rule === OBJECT) {
                                global.extend(childObj, rule);
                            }

                            // Parse the tag rule.
                            rule = rules.tag[nodeName];
                            if (rule) {
                                // Apply nodeName transformation 'tag' rule with
                                // base-parent-child relationship.
                                if (typeof rule === OBJECT &&
                                        typeof rule[parentNodeName] === OBJECT) {
                                    temp = undefined;
                                    for (temp in rule[parentNodeName]) {
                                        if (baseObj[temp]) {
                                            nodeName = rule[parentNodeName][temp];
                                            break;
                                        }
                                    }

                                }
                                // Apply nodeName transformation 'tag' rule with
                                // parent-child relationship.
                                else if (typeof rule === OBJECT &&
                                        typeof rule[parentNodeName] === STRING) {
                                    nodeName = rule[parentNodeName];

                                }

                                // Apply nodeName transformation 'tag' rule with parent
                                // independent relationship.
                                else if (typeof rule === STRING) {
                                    nodeName = rule;
                                }
                            }

                            // We now need to parse the rest of the childnodes as
                            // recursed into this function.
                            if (childNode.childNodes.length) {
                                // Match the group rule. To check whether we need to append
                                // the parsed children or treat the parsed children as siblings.
                                rule = rules.group[parentNodeName];
                                if (rule && rule[nodeName]) {
                                    parse.child(obj, childNode.childNodes,
                                        nodeName, baseObj);
                                }
                                else {
                                    parse.child(childObj, childNode.childNodes,
                                        nodeName, baseObj);
                                }
                            }

                            // Append the computed childObject to parent depending
                            // upon whether it has to be appended to an array or as
                            // a child object.
                            // Note: We append only when the "group" rule was not matched
                            rule = rules.group[parentNodeName];
                            if (!(rule && rule[nodeName])) {
                                parse.append(childObj, obj, nodeName, parentNodeName);
                            }

                            break;

                        // In case the child object is a text node and meets some
                        // other requirements, we parse it as textNode
                        case XML_TEXTNODE:

                            // Parse mandatory text-node rule.
                            rule = rules.text[parentNodeName];
                            if (rule) {
                                nodeName = rule;
                                childObj = childNode.data;

                                // Append the computed childObject to parent depending
                                // upon whether it has to be appended to an array or as
                                // a child object.
                                parse.append(childObj, obj, nodeName, parentNodeName);
                            }

                            // Parse compact-data mode / optional text-node rule
                            rule = rules.dsv[parentNodeName];
                            if (typeof rule === STRING && baseObj.chart &&
                                    parseInt(baseObj.chart[COMPACTDATAMODE], 10)) {
                                // Create text node
                                nodeName = rule;
                                childObj = childNode.data;

                                // Since this is DSV type text node, it is directly
                                // appended to the object.
                                obj[nodeName] = obj[nodeName] ?
                                        obj[nodeName] + childObj : childObj;
                            }
                            break;
                    } // end switching based on node-type
                }
            },

            attr: function (attrObj) {
                var i, obj = {};
                // Check whether a valid xml attr NamedNode is passed.
                if (!attrObj || !attrObj.length) {
                    return obj;
                }
                // Iterate through the attribute list and populate the return
                // object with the nodeValues.
                for (i = 0; i < attrObj.length; i += 1) {
                    obj[attrObj[i].nodeName.toLowerCase()] = attrObj[i].value || attrObj[i].nodeValue;
                }

                // Finally return the converted object.
                return obj;
            }

        };

        parser = function (xml) {
            var jsonObj = {},
                xmlDoc,
                xmlElem,
                root,
                rootName,
                newNode,
                nodeEle,
                rootAttrs,
                childNodes,
                i;

            // Validate parameters to check that xml can be converted into a string.
            if (typeof xml !== OBJECT && (xml && typeof xml.toString !== FUNCTION)) {
                parser.errorObject = new TypeError('xml2json.parse()');
                return jsonObj;
            }

            xml = xml.toString()
                .replace(/<\!--[\s\S]*?-->/g, '') // remove xml comments
                .replace(/<\?xml[\s\S]*?\?>/ig, '') // remove xml definition
                //.replace(/\<\!\[cdata[\s\S]*?\]\]\>/ig, '') // remove CDATA
                //.replace(/(=\s*?\"[\s\S]*?\")(\w)/ig, '$1 $2') // fix whitespace attr with quot
                //.replace(/(=\s*?\'[\s\S]*?\')(\w)/ig, '$1 $2') // fix whitespace attr with apos
                .replace(/&(?!([^;\n\r]+?;))/g, '&amp;$1'); // fix ampersand
            xml = fastTrim(xml);

            // Check whether unwanted data like undefined, null blank string etc.
            if (!xml) {
                //parser.errorObject = new TypeError('xml2json.parse()');
                return jsonObj;
            }
            // Get XML Parser object depending upon browser capability and
            // subsequently load xml string.
            try {
                if (win.DOMParser) {
                    xmlDoc = (new win.DOMParser()).parseFromString(xml, 'text/xml');
                }
                else { // Internet Explorer
                    if (doc.body && global.core.options.allowIESafeXMLParsing) { // Check if xml islands can be used
                        xmlElem = doc.createElement('xml');
                        xmlElem.innerHTML = xml;
                        doc.body.appendChild(xmlElem);
                        xmlDoc = xmlElem.XMLDocument;
                        doc.body.removeChild(xmlElem);
                        xmlElem = null;
                    }
                    else {
                        xmlDoc = new win.ActiveXObject('Microsoft.XMLDOM');
                        xmlDoc.async = 'false';
                        xmlDoc.loadXML(xml);
                    }
                }

                if (!(xmlDoc && xmlDoc.childNodes && xmlDoc.childNodes.length === 1 && (root = xmlDoc.childNodes[0]) &&
                    root.nodeName && (rootName = root.nodeName.toLowerCase()) && (rootName === 'chart' ||
                        rootName === 'map' || rootName === 'graph'))) {
                    parser.errorObject = new TypeError('xml2json.parse()');
                    return jsonObj;
                }
                else if (rootName === 'graph') {

                    newNode = xmlDoc.createElement('chart');
                    rootAttrs = root.attributes;
                    i = (rootAttrs && rootAttrs.length) || 0;
                    while (i--) {
                        newNode.setAttribute(rootAttrs[i].name, rootAttrs[i].value);
                        rootAttrs.removeNamedItem(rootAttrs[i].name);
                    }

                    childNodes = root.childNodes;
                    i = (childNodes && childNodes.length) || 0;

                    if (i) {
                        i -= 1;
                        nodeEle = root.removeChild(childNodes[i]);
                        newNode.appendChild(nodeEle);
                    }

                    while (i--) {
                        nodeEle = root.removeChild(childNodes[i]);
                        newNode.insertBefore(nodeEle, newNode.firstChild);
                    }

                    xmlDoc.replaceChild(newNode, root);
                    root = newNode;
                }
            }
            catch (e) {
                parser.errorObject = e;
            }

            if (root) {
                // Do initial attribute parsing
                if (root.attributes) {
                    jsonObj[rootName] = parse.attr(root.attributes);
                }

                // Parse all childNodes.
                if (root.childNodes) {
                    parse.child(jsonObj, root.childNodes, rootName, jsonObj);
                }

                // Delete error flag.
                delete parser.errorObject;
            }
            else {
                parser.errorObject = new TypeError('xml2json.parse()');
            }

            return jsonObj;
        };

        return function (xml) {
            // Clear error flags of parser.
            delete parser.errorObject;

            // Call JSON2XML parser to retrieve the parsed data.
            var jsonData = parser(xml);

            // Compile a return object for encoding function.
            return {
                data: jsonData,
                error: parser.errorObject
            };
        };
    }());

    /**
     * This function accepts a JSON string or object and converts it to
     * FusionCharts data XML.
     */
    json2xml = (function () {
        var rules, // namespace
            parser; // function

        rules = {
            /*
             * ~var {object} items Collection of rules that are required to convert
             * JSON to FusionCharts XML.
             *
             * note: The rules are in the form:
             *       ruleType: { namespace: { nodeName: ruleMeta } }
             */
            items: {
                /**
                 * ~var {object} explode Comprises of JSON attributes that needs to
                 * be converted to a particular set of nodes. Generally the value of
                 * such attributes/properties are an array of objects. Each object
                 * in these arrays are converted to a particular XML node specified
                 * within the rule meta.
                 *
                 * note: this rule is applied at the end, after all rules are applied
                 */
                explode: {
                    data: 'set',
                    groups: {
                        annotations: 'annotationgroup'
                    },
                    items: {
                        groups: 'annotation'
                    }
                },

                /**
                 * ~var {object} text Comprises of JSON keys that are to be
                 * always treated as text-node
                 */
                text: {
                    chart: {
                        target: 'target',
                        value: 'value'
                    },
                    graph: { // legacy
                        target: 'target',
                        value: 'value'
                    }
                },

                /**
                 * ~var {object} dsv contains nodeNames that are specially expected
                 * to be delimiter separated textnodes. Useful for "compactDataMode".
                 */
                dsv: {
                    dataset: {
                        data: 'dataset'
                    },
                    categories: {
                        category: 'categories'
                    }
                },

                /**
                 * ~var {object} attr Comprises of JSON attributes whose values are
                 * always added to the XML attributes of its namespace. Such nodes
                 * generally are object containing strings. The keys within them
                 * are to be converted to XML attributes and the values become XML
                 * attribute values.
                 *
                 */
                attr: {
                    chart: {
                        chart: 'chart'
                    },
                    graph: { // legacy
                        graph: 'graph'
                    },
                    map: {
                        map: 'map'
                    },
                    linkedmap: {
                        map: 'map'
                    },
                    linkedchart : {
                        chart: 'chart'
                    }

                },

                /**
                 * ~var {object} group Comprises of JSON attributes whose children
                 * are to be grouped under a particular node. The parentNode where
                 * it has to be grouped are specified in the rule meta.
                 *
                 * @example
                 * catch-object {
                 *     having-name: and-put-content-as
                 * }
                 * result:
                 * <catch-object>
                 *   <having-name>
                 *     <and-put-content-as />
                 *     <and-put-content-as />
                 *   </having-name>
                 * </catch-object>
                 *
                 * -- also --
                 * When this rule matches x for y:
                 * x: [a, b, c] is <y><x a /><x b /><x c/></y>
                 */
                group: {
                    styles: {
                        definition: 'style',
                        application: 'apply'
                    },
                    map: {
                        data: 'entity',
                        entitydef: 'entity'
                    },
                    markers: { // for maps
                        definition: 'marker',  // deprecated 3.4
                        application: 'marker',  // deprecated 3.4
                        shapes: 'shape',
                        connectors: 'connector',
                        items: 'marker'
                    }
                },

                /*
                 * ~var {object} Contains the rules for renaming tags (json keys)
                 * during parsing. Changes `item` of parser in case of group,
                 * attr, text. Note that explode rule also changes node name
                 */
                tag: {
                    markers: {
                        items: 'data'
                    }
                }
            },

            /**
             * This method verifies whether a name-item pair qualifies for a
             * rule or not. If so, it also returns the meta information of the
             * qualified rule.
             * @type string
             *
             * @param {string} rule is the name of the rule that you want to
             * verify. There must be a corresponding rule group in the items
             * object.
             * @param {variant} item
             * @param {variant} namespace
             */
            qualify: function (rule, item, namespace) {
                return typeof this.items[rule][namespace] === OBJECT ?
                    this.items[rule][namespace][item] :
                    this.items[rule][namespace];
            }
        };

        /**
         * This function accepts a JSON object and converts it to FusionCharts
         * data xml.
         *
         * @param obj {object} JSON object to be parsed.
         * @param namespace {string} is the parent/root namespace within which
         * the JSON object is contained.
         * @param {object} namespaceparent the parent namespace
         * @param {object} flags
         */
        parser = function (obj, namespace, namespaceparent, flags) {

            // Initialize variables that stores the current namespace's XML
            // construction parameters.
            /**
             * ~var {string} attrString The serialized set of attributes key:value
             *      pairs generated for this namespace.
             * ~var {string} innerXML The innerXML of the node generated in this NS.
             * ~var {string} nodeName The current node name devised from the NS.
             * ~var {string} outerXML The outer XML generated for this JSON tree.
             * ~var {string} item The current child being processed within an NS.
             * ~var {string} lcaseItem The case desensitized current node item.
             * ~var {string} lcaseNS The case desensitized namespace.
             */
            var attrString = '',
                innerXML = '',
                outerXML = '',
                trailXML = '',
                tagName,
                item,
                lowerItem,
                qualifier;

            // Desensitize case of namespace.
            if (namespace && typeof namespace.toLowerCase === 'function') {
                namespace = namespace.toLowerCase();
            }

            // Special root namespace flag setting
            if (namespaceparent === undefined && obj[namespace]) {
                for (item in obj[namespace]) {
                    lowerItem = item.toLowerCase();
                    if (lowerItem === COMPACTDATAMODE) {
                        flags.applyDSV = (obj[namespace][item] == 1);
                    }
                }
            }

            // In case the object is an array, apply explosion rule.
            if (obj instanceof Array) {
                // Iterate through every item within the array and expand it.
                for (item = 0; item < obj.length; item += 1) {
                    // If the value of the node is string we expand its contents
                    // into the content of the node for COMPACT_MODE data
                    if (typeof obj[item] === STRING) {
                        outerXML += xssEncode(obj[item]);
                    }
                    // If the node is not string, we process its contents as
                    // another node.
                    else {
                        outerXML += parser(obj[item], namespace,
                            namespaceparent, flags);
                    }
                }
            }
            // For any other data-type other than Array we iterate through the
            // contents of the variable and parse each node.
            else {
                for (item in obj) {

                    // Store a lower-case version of this
                    lowerItem = item.toLowerCase();

                    // Parse "group" rule. Here, we test whether we are to group
                    // a JSON Array under a particular XML node.
                    // @example where this rule matches x for y:
                    // x: [a, b, c] is <y><x a /><x b /><x c/></y>
                    if (obj[item] instanceof Array &&
                            (qualifier = rules.qualify('group', lowerItem, namespace))) {
                        tagName = rules.qualify('tag', lowerItem, namespace) || lowerItem;
                        innerXML += '<' + tagName + '>' + parser(obj[item],
                            qualifier, namespace, flags) + '</' + tagName + '>';
                    }

                    // Parse "attr" rule. Here we test whether to use the items
                    // within a particular item as the XML attributes of the
                    // parent namespace.
                    else if (typeof obj[item] === OBJECT) {

                        // Check whether there is a qualifying rule for using
                        // an OBJECT as source of attributes of a namespace.
                        if ((qualifier = rules.qualify('attr', lowerItem, namespace))) {
                            trailXML = parser(obj[item], qualifier, namespace, flags)
                                .replace(/\s*\/\>/ig, '');
                            namespace = lowerItem;
                        }
                        // Otherwise, recurse the parser to process the object
                        // as a child JSON object.
                        else {
                            innerXML += parser(obj[item], lowerItem, namespace, flags);
                        }
                    }
                    // Parse "vLine" and other static rules.
                    else {

                        if (flags.applyDSV && (qualifier = rules.qualify('dsv', lowerItem, namespace)) ) {
                            innerXML += obj[item];
                        }// Check for text qualifier
                        else if ((qualifier = rules.qualify('text', lowerItem, namespace))) {
                            tagName = rules.qualify('tag', lowerItem, namespace) || qualifier;
                            innerXML += '<' + tagName + '>' + obj[item] +
                                '</' + tagName + '>';
                        }
                        else if (lowerItem === 'vline' && Boolean(obj[item])) {
                            namespace = 'vline';
                        }
                        else {
                            attrString += ' ' + lowerItem + '=\"' + xssEncode(obj[item])
                            .toString().replace(/\"/ig, '&quot;') + '\"';
                        }
                    }
                }

                // When parsing completes, we need to check whether we have any
                // namespace adjustments or not.
                // Explode rule.
                if ((qualifier = rules.qualify('explode', namespaceparent, namespace))) {
                    namespace = qualifier;
                }
                // this tagname  is not influenced by rule since the explode rule
                // is the one doing the job here.
                tagName = namespace;

                // Build the final XML node string.
                outerXML = (trailXML !== '' ? trailXML : '<' + tagName) +
                    attrString + (innerXML !== '' ? '>' + innerXML + '</' +
                    tagName + '>' : ' />');
            }

            return outerXML;
        };

        return function (jsonData) {
            // Clear error flags of parser.
            delete parser.errorObject;

            // In case user sends the JSON data as STRING, we need to parse
            // it and convert to JSON object.
            if (jsonData && typeof jsonData === STRING) {
                // Parse the data within atry block in order to receive all
                // errors.
                try {
                    jsonData = JSON.parse(jsonData);
                }
                catch (e) {
                    parser.errorObject = e;
                }
            }

            // Call JSON2XML parser to retrieve the parsed data.
            var rootNS = jsonData && jsonData.graph ? 'graph' :
                    (jsonData && jsonData.map ? 'map' : 'chart'),
                xmlData = parser(jsonData, rootNS, undefined, {});

            // Compile a return object for encoding function.
            return {
                data: xmlData,
                error: parser.errorObject
            };
        };
    }());

    json2json = function (input) {
        var out = {
                data: {}
            };

        if (!input) {
            return out;
        }

        if (typeof input !== 'string') {
            try {
                input = JSON.stringify(input);
            }
            catch (err) {
                out.error = err;
                return out;
            }
        }
        try {
            out.data = JSON.parse(input.replace(/"([^"]+)":/g, function ($0, $1) {
                return (QUOT + $1.toLowerCase() + QUOTCOLON);
            }));
        }
        catch (err) {
            out.error = err;
        }

        return out;
    };

    /**
     * Fetch data that has been set on a chart in JSON format. This function is shorthand of using
     * `chart.getChartData('json')`.
     *
     * This function needs to be called on an existing chart. If this function is called on a chart which has no data
     * set on it, it returns an empty `{ }` object.
     *
     * @function getJSONData
     * @memberOf FusionCharts#
     * @group data
     * @see FusionCharts#getChartData
     *
     * @returns {object}
     */
    /**
     * This function is used to update data of a chart using data in JSON format as defined in
     * {@link FusionCharts~dataFormats}.
     *
     * It is a shorthand of the function {@link FusionCharts#setChartData} where the data format is always JSON. So,
     * calling `chart.setXMLData({'chart': ...})` is the same as calling
     * `chart.setChartData({'chart': ...}, 'json')`.
     *
     * Similar to {@link FusionCharts#setChartData}, if this function is called on a chart that has already rendered,
     * the chart is immediately updated with the new data. But it can also be used to set data to a chart that has not
     * yet rendered. However, using this function to set data of a chart is not recommended. The initial data of a chart
     * is preferred to be set in the FusionCharts constructor.
     *
     * @see FusionCharts#setChartData
     *
     * @function setJSONData
     * @memberOf FusionCharts#
     * @group data
     *
     * @param {string|object} data - This parameter accepts the `JSON` data to be passed on to the chart string or as
     * JavaScript object.
     */
    /**
     * This function is used to update data of a chart using data from a URL in JSON format.
     *
     * It is a shorthand of the function {@link FusionCharts#setChartDataUrl} where the data format of the URL is always
     * JSON (`jsonurl`). So, calling `chart.setJSONUrl('data.json')` is the same as calling
     * `chart.setChartDataUrl('data.json', 'jsonurl')`.
     *
     * Similar to {@link FusionCharts#setChartDataUrl}, if this function is called on a chart that has already rendered,
     * the chart is immediately updated with the new data as soon as it is fetched from the URL. If the chart has not
     * yet rendered But it can also be used to set data to a chart that has not yet rendered. However, using this
     * function to set data of a chart is not recommended. The initial data of a chart is preferred to be set in the
     * FusionCharts constructor.
     *
     * @see FusionCharts#setChartDataUrl
     *
     * @function setJSONUrl
     * @memberOf FusionCharts#
     * @group data
     *
     * @param {string} url - Path to JSON data file.
     */
    // Add the data-handler to FusionCharts collection of data-handlers
    global.addDataHandler('JSON', {
        encode: json2xml,
        decode: xml2json,
        passthrough: json2json,
        transportable: true
    });

}]);
/**
 * This module contains the XML transcoder. This module adds the 'XML' data
 * handler.
 * @private
 *
 * @module fusioncharts.transcoder.xml
 * @requires fusioncharts.transcoder
 */
FusionCharts.register('module', ['private', 'modules.data.xml', function () {

    var global = this,
        /**
         * Function to convert a variable into a FusionCharts data-handler API
         * compatible object.
         *
         * @param {variant} data can be anything.
         * @type object
         */
        stubCoder = function (data) {
            // We do not need to normalize the data while encoding as because
            // the data is saved in JS scope and is now not sent via flashVars.
            return {
                data: data,
                error: undefined
            };
        };

    /**
     * Fetch data that has been set on a chart in XML format. This function is shorthand of using
     * `chart.getChartData('xml')`.
     *
     * This function needs to be called on an existing chart. If this function is called on a chart which has no data
     * set on it, it returns an empty `<chart />` element as string.
     *
     * @function getXMLData
     * @memberOf FusionCharts#
     * @group data
     * @see FusionCharts#getChartData
     *
     * @returns {string}
     */
    /**
     * This function is used to update data of a chart using data in XML format as defined in
     * {@link FusionCharts~dataFormats}.
     *
     * It is a shorthand of the function {@link FusionCharts#setChartData} where the data format is always XML. So,
     * calling `chart.setXMLData('<chart>...</chart')` is the same as calling
     * `chart.setChartData('<chart>...</chart>', 'xml')`.
     *
     * Similar to {@link FusionCharts#setChartData}, if this function is called on a chart that has already rendered,
     * the chart is immediately updated with the new data. But it can also be used to set data to a chart that has not
     * yet rendered. However, using this function to set data of a chart is not recommended. The initial data of a chart
     * is preferred to be set in the FusionCharts constructor.
     *
     * @see FusionCharts#setChartData
     *
     * @function setXMLData
     * @memberOf FusionCharts#
     * @group data
     *
     * @param {string} data - This parameter accepts valid `XML` as a string to be passed on to the chart as data
     * source.
     */
    /**
     * This function is used to update data of a chart using data from a URL in XML format.
     *
     * It is a shorthand of the function {@link FusionCharts#setChartDataUrl} where the data format of the URL is always
     * XML (`xmlurl`). So, calling `chart.setXMLUrl('data.xml')` is the same as calling
     * `chart.setChartDataUrl('data.xml', 'xmlurl')`.
     *
     * Similar to {@link FusionCharts#setChartDataUrl}, if this function is called on a chart that has already rendered,
     * the chart is immediately updated with the new data as soon as it is fetched from the URL. If the chart has not
     * yet rendered But it can also be used to set data to a chart that has not yet rendered. However, using this
     * function to set data of a chart is not recommended. The initial data of a chart is preferred to be set in the
     * FusionCharts constructor.
     *
     * @function setXMLUrl
     * @memberOf FusionCharts#
     * @group data
     *
     * @see FusionCharts#setChartDataUrl
     *
     * @param {string} url - Path to XML data file.
     */
    // Add Abstract data handler as because when the primary data-type is XML,
    // it requires a transparent transcoder that has nothing to do.
    global.addDataHandler('XML', {
        encode: stubCoder,
        decode: stubCoder,
        transportable: true
    });

}]);



/**
 * This module contains the CSV transcoder. This module adds the 'CSV' data
 * handler.
 * @private
 *
 * @module fusioncharts.transcoder.csv
 * @requires fusioncharts.transcoder
 */
FusionCharts.register('module', ['private', 'modules.data.csv', function () {

    var global = this,
        win = global.window,
        core = global.core,

        COMMA = ',',
        QUOTE = '\"',
        APOS = '\'',
        TAB = '\t',
        CRLF = '\r\n',
        LIT_QUOT = '{quot}',
        LIT_TAB = '{tab}',
        LIT_APOS = '{apos}',

        toInt = win.parseInt,
        toFloat = win.parseFloat,

        returnFirstArgument = function (x) {
            return x;
        },

        DSV, // constructor
        decoder;

    DSV = function (config) {
        this.data = [];
        this.rowCount = 0;
        this.columnCount = 0;
        this.configure(config);
    };

    DSV.decodeLiterals = function (str, defaultValue) {
        if (str === undefined || str === null || !str.toString) {
            return defaultValue;
        }
        return str.replace(LIT_TAB, TAB).replace(LIT_QUOT, QUOTE)
            .replace(LIT_APOS, APOS);
    };

    DSV.prototype.set = function (row, col, value) {

        var i; // Initialize a counter

        // In case data is being set to a row that does not exist, we pad those
        // many empty spaces with a blank array. So that, there is no error
        // while setting data anywhere between them.
        if (this.rowCount <= row) {
            for (i = this.rowCount; i <= row; i += 1) {
                this.data[i] = [];
            }
            // Increment rowCount
            this.rowCount = row + 1;
        }

        // Increment columnCount
        if (this.columnCount <= col) {
            this.columnCount = col + 1;
        }

        // Set the value
        this.data[row][col] = value;
    };

    DSV.prototype.setRow = function (row, value) {
        var i;

        // In case data is being set to a row that does not exist, we pad those
        // many empty spaces with a blank array. So that, there is no error
        // while setting data anywhere between them.
        if (this.rowCount <= row) {
            for (i = this.rowCount; i <= row; i += 1) {
                this.data[i] = [];
            }
            // Increment rowCount
            this.rowCount = row + 1;
        }

        // Increment columnCount
        if (this.columnCount < value.length) {
            this.columnCount = value.length;
        }
        // Set column.
        this.data[row] = value;
    };

    DSV.prototype.get = function (row, col) {
        var data = this.data;
        return data[row] && data[row][col];
    };

    DSV.prototype.configure = function (config) {
        var decodeLiterals = DSV.decodeLiterals;
        this.delimiter = decodeLiterals(config.delimiter, COMMA);
        this.qualifier = decodeLiterals(config.qualifier, QUOTE);
        this.eolCharacter = decodeLiterals(config.eolCharacter, CRLF);
        this.numberFormatted = !!toInt(config.numberFormatted, 0);
    };

    DSV.prototype.clear = function () {
        this.data = [];
        this.rowCount = 0;
        this.columnCount = 0;
    };

    DSV.prototype.toString = function () {
        var row, col, str = '';

        // Iterate through all rows and generate the string structure
        for (row = 0; row < this.rowCount; row += 1) {
            col = this.qualifier + this.data[row].join(this.qualifier + this.delimiter +
                this.qualifier) + this.qualifier;
            str += (col === '\"\"' ? this.eolCharacter : col + this.eolCharacter);
        }

        // Truncate extra line-break generated while forming the CSV.
        if (this.rowCount > 0) {
            str = str.slice(0, str.length - 2);
        }

        return str;
    };

    /**
     * Function to convert a variable into a FusionCharts data-handler API
     * compatible object.
     *
     * @param {variant} data is the dataSource passed on to the decoder.
     *
     * @param {FusionCharts} obj is the FusionCharts object for which the
     * decoding will take place.
     * @param {object} options are the dataOptions passed to this data handler.
     *
     * @type object
     */
    decoder = function (data, chart) {

        var jsondata = core.transcodeData(data, 'xml', 'json') || {},
            jsVars = chart.jsVars,
            csv,
            row,
            column,
            g,
            i,
            j,
            k,
            l,
            chartAttrs = jsondata.chart || jsondata.map || jsondata.graph || {},
            forceErrorColumns = Boolean(chartAttrs.exporterrorcolumns || 0),
            categories = (jsondata.categories && jsondata.categories[0] &&
                jsondata.categories[0].category) || [],
            isGeoPlot = jsondata.map && !jsondata.chart || (jsVars && jsVars.instanceAPI &&
                jsVars.instanceAPI.defaultSeriesType === 'geo'),
            isXYPlot = false,
            isErrorPlot = false,
            isMapPlot = false,
            isOHLC = false,
            hasSum = false,
            compactDataMode = false,
            doFormat = returnFirstArgument,
            predictedFormat = {},
            datasets,
            lineset,
            axisset,
            dataCollectionLength,
            categoryLength,
            datasetLength,
            categoryItem,
            dataCollection, // for ms stacked
            datasetItem,
            dataLength,
            dataItem,
            dataValue,
            errorValue,
            bumpColumnCount,
            summation = 0,
            // for map plots
            mapRows,
            mapColumns,
            entities,
            entityId,
            entity,
            options,
            value;

        // Create a CSV based Delimiter data store
        csv = new DSV({
            separator: chartAttrs.exportdataseparator,
            qualifier: chartAttrs.exportdataqualifier,
            numberFormatted: chartAttrs.exportdataformattedval
        });

        // verify whether number formatting needs and can be done or not and
        // based on that update the doFirmat function
        if (core.formatNumber && csv.numberFormatted) {
            doFormat = function (x) {
                return core.formatNumber(x, chartAttrs);
            };
        }

        // Try probe maps. For GEO plot, getDataAsCSV exists on chart API.
        if (isGeoPlot) {
            predictedFormat.geo = true;

            entities = jsVars.hcObj && jsVars.hcObj.entities && jsVars.hcObj.entities.items || [];
            csv.setRow(0, ['Id', ' Short Name', 'Long Name', 'Value',
                'Formatted Value']);
            i = 0;
            for (entityId in entities) {
                entity = entities[entityId];
                options = entity.eJSON;
                value = entity.value;
                csv.setRow(++i, [entityId, options.shortLabel, options.label, value === undefined ? '' : value,
                    entity.formattedValue]);
            }

        }
        // Probe widgets.
        else if ((datasets = (jsondata.dials && jsondata.dials.dial) ||
                (jsondata.pointers && jsondata.pointers.pointer) ||
                jsondata.value) !== undefined) {
            predictedFormat.gauge = true;
            // Prepare CSV for single-value input.
            if (typeof datasets === 'string') {
                csv.set(0, 0, doFormat(datasets));
                predictedFormat.singlevalue = true;
                // Separate single-value for bullet graphs "target" tag
                if (typeof jsondata.target === 'string') {
                    csv.set(0,1, doFormat(jsondata.target));
                    predictedFormat.bullet = true;
                }
            }
            // For multi-value gauges having dials or pointers.
            else {
                // Set column headers.
                csv.setRow(0, ['Id', 'Value']);
                predictedFormat.multivalue = true;
                for (i = 0, k = 1, j = datasets.length; i < j; i += 1, k += 1) {
                    csv.setRow(k, [k, doFormat(datasets[i].value)]);
                }
            }
        }

        // Take multi-series decision here.
        else if ((datasets = jsondata.dataset ||
                (!(jsondata.data instanceof Array) && []))) {
            predictedFormat.multiseries = true;
            column = 1;

            // Merge lineset with dataset for easy algorithm (will be separated
            // later.)
            lineset = jsondata.lineset;
            if (lineset) {
                datasets = datasets.concat(lineset);
                predictedFormat.lineset = true;
            }

            // Merge axis for multi-axis data
            axisset = jsondata.axis;
            if (axisset) {
                datasets = datasets.concat(axisset);
                predictedFormat.multiaxis = true;
            }

            datasetLength = datasets.length;
            categoryLength = categories.length;

            // Add only category rows in case no dataset has been found.
            if (!(datasetLength = datasets.length)) {
                for (i = 0; i < categoryLength; i += 1) {
                    categoryItem = categories[i];
                    csv.set(i+1, 0, categoryItem.label || categoryItem.name);
                }
                predictedFormat.multilevel = true;
            }

            for (i = 0; i < datasetLength; i += 1) {

                dataCollection = datasets;
                if (dataCollection[i].dataset) {
                    dataCollection = dataCollection[i].dataset;
                    g = 0;
                    dataCollectionLength = dataCollection.length;
                }
                else {
                    dataCollection = datasets;
                    g = i;
                    dataCollectionLength = g + 1;
                }

                for (; g < dataCollectionLength && !isXYPlot && !isMapPlot;
                        g += 1, column += 1) {
                    // Refer to the dataset item that contains the data and
                    // forms a column.
                    datasetItem = dataCollection[g];

                    // Set the column header equalling to series name
                    csv.set(0, column, datasetItem.seriesname);

                    if (typeof datasetItem.data === 'string') {
                        compactDataMode = predictedFormat.compactdata = true;
                        datasetItem.data =
                            datasetItem.data.split(chartAttrs.dataseparator || '|');
                    }

                    // Loop through categories and fill the values of each column
                    // with its values
                    for (j = 0, k = 0, dataLength = datasetItem.data && datasetItem.data.length || 0;
                            j < dataLength || j < categoryLength; j += 1) {
                        categoryItem = categories[j];
                        row = k + 1;

                        dataItem = datasetItem.data && datasetItem.data[k] || {};

                        // Keep checking for scatter chart. If present then
                        // raise a flag and exit processing.
                        if (dataItem.x !== undefined && dataItem.y !== undefined) {
                            isXYPlot = predictedFormat.xy = true;
                            break;
                        }

                        // Keep checking for OHLC
                        if (dataItem.open !== undefined || dataItem.high !== undefined ||
                            dataItem.close !== undefined || dataItem.low !== undefined) {
                            isOHLC = predictedFormat.ohlc = true;
                            break;
                        }

                        // Keep checking for HeatMap chart
                        if (dataItem.rowid !== undefined && dataItem.columnid !== undefined) {
                            isMapPlot = predictedFormat.heatmap = true;
                            break;
                        }

                        // trap surplus data here
                        if (j < categoryLength && !categoryItem.vline) {
                            csv.set(row, 0, categoryItem.label || categoryItem.name);
                            dataValue = toFloat(dataItem ? dataItem.value : '');
                            dataValue = isNaN(dataValue) ? '' : doFormat(dataValue);

                            csv.set(row, column, dataValue);

                            // Perform check for errorValue on error charts
                            if (isErrorPlot || forceErrorColumns || dataItem.errorvalue) {
                                // Set the next column header and flag that this
                                // dataset has error values.
                                if (!isErrorPlot) {
                                    csv.set(0, column + 1, 'Error');
                                }
                                bumpColumnCount = 1;
                                csv.set(row, column + 1, doFormat(dataItem.errorvalue));
                            }

                            // Increment the auxilliary counter to ensure sync with
                            // dataset count even after ignoring of vline in category.
                            k += 1;
                        }
                    }

                    // Reset flag for checking error value in set and
                    // bump a column to accomodate error.
                    if (bumpColumnCount) {
                        column += bumpColumnCount;
                        bumpColumnCount = 0;
                    }
                }
            }

            // Split the previously merged lineset and axisset
            if (lineset) {
                datasets = datasets.slice(0, -lineset.length);
            }

            if (axisset) {
                datasets = datasets.slice(0, -axisset.length);
            }
        }
        // for non-ms data.
        else if ((datasets = jsondata.data)) {
            csv.set(0, 1, chartAttrs.yaxisname || 'Value');
            predictedFormat.singleseries = true;

            hasSum = (chartAttrs.showsumatend == '1');

            for (i = 0, categoryLength = datasets.length;
                    i < categoryLength; i += 1) {
                dataItem = datasets[i];
                // Ignore vLines
                if (!dataItem.vline) {
                    // Set the row value.
                    dataValue = toFloat(dataItem.value ? dataItem.value : '');
                    csv.setRow(i + 1, [dataItem.label || dataItem.name,
                        isNaN(dataValue) ? '' : ((summation += dataValue),
                            doFormat(dataValue))]);
                }
            }

            // Check for summation of Waterfall
            if (hasSum) {
                predictedFormat.summation = true;
                csv.setRow(i + 1, [chartAttrs.sumlabel || 'Total', doFormat(summation)]);
            }
        }

        // Special processing for OHLC
        /** @todo implement volume calculation of OHLC chart */
        if (isOHLC) {
            csv.clear();
            // Set new column headers.
            csv.setRow(0, ['Open', 'Close', 'High', 'Low']);

            // Iterate through all datasets.
            for (i = 0, row = 1, datasets = jsondata.dataset,
                    dataCollectionLength = datasets.length;
                    i < dataCollectionLength; i += 1) {
                for (j = 0, datasetItem = datasets[i] && datasets[i].data || [],
                        datasetLength = datasetItem.length; j < datasetLength;
                        j += 1, row += 1) {
                    dataItem = datasetItem[j] || {};
                    csv.setRow(j+1, [doFormat(dataItem.open),
                        doFormat(dataItem.close),
                        doFormat(dataItem.high),
                        doFormat(dataItem.low)]);
                }

            }
        }
        // Special processing for x-y plot data.
        else if (isXYPlot) {
            // Reset any processing done earlier.
            csv.clear();
            isErrorPlot = false;
            bumpColumnCount = 0;

            // Set new column headers.
            csv.setRow(0, ['Series', 'x', 'y']);

            // Iterate through all datasets.
            for (i = 0, row = 1, datasets = jsondata.dataset,
                    dataCollectionLength = datasets.length;
                    i < dataCollectionLength; i += 1) {
                for (j = 0, datasetItem = datasets[i] && datasets[i].data || [],
                        datasetLength = datasetItem.length; j < datasetLength;
                        j += 1, row += 1) {
                    dataItem = datasetItem[j] || {};
                    dataValue = [datasets[i].seriesname, doFormat(dataItem.x),
                        doFormat(dataItem.y)];

                    // check z index value for bubble charts
                    if (dataItem.z !== undefined) {
                        dataValue.push(doFormat(dataItem.z));
                        // Set flag for z by using bump column flag. Later
                        // when error values will be set, it would detect whether
                        // z was added from this value.
                        if (!bumpColumnCount) {
                            csv.set(0, 3, 'z');
                            bumpColumnCount = 1;
                        }
                    }
                    // Set values for error charts after probing presense of
                    // error values. Note that after one errorvalue has been
                    // probed, it will no longer need to compute so many logic
                    // operations since isErrorPlot flag will then be true.
                    if (isErrorPlot || forceErrorColumns ||
                            dataItem.errorvalue !== undefined ||
                            dataItem.horizontalerrorvalue !== undefined ||
                            dataItem.verticalerrorvalue !== undefined) {

                        // Keep this preformatted since horiz and vert error
                        // values take this up as default.
                        errorValue = doFormat(dataItem.errorvalue);

                        dataValue.push(dataItem.errorvalue,
                            dataItem.horizontalerrorvalue === undefined ?
                                errorValue : doFormat(dataItem.horizontalerrorvalue),
                            dataItem.verticalerrorvalue === undefined ?
                                errorValue : doFormat(dataItem.verticalerrorvalue));

                        // Set column headers.
                        if (!isErrorPlot) {
                            csv.set(0, bumpColumnCount + 3, 'Error');
                            csv.set(0, bumpColumnCount + 4, 'Horizontal Error');
                            csv.set(0, bumpColumnCount + 5, 'Vertical Error');
                        }
                        isErrorPlot = predictedFormat.error = true;
                    }

                    // Now set the entire row of data
                    csv.setRow(row, dataValue);
                }
            }
        }
        else if (isMapPlot) {
            // reset parsing;
            csv.clear();

            mapRows = {};
            mapColumns = {};

            // Iterate through all rows and create a reverse map of id to row
            // index.
            for (i = 0, j = 1, categories = jsondata.rows && jsondata.rows.row || [],
                    l = categories.length; i < l; i += 1, j += 1) {
                categoryItem = categories[i];
                if (categoryItem.id) {
                    mapRows[categoryItem.id.toLowerCase()] = j; // desensitize
                    csv.set(j, 0, categoryItem.label || categoryItem.id);
                }
            }
            // Iterate through all columns and reverse map id to column index.
            for (i = 0, j = 1, categories = jsondata.columns && jsondata.columns.column || [],
                    l = categories.length; i < l; i += 1, j += 1) {
                categoryItem = categories[i];
                if (categoryItem.id) {
                    mapColumns[categoryItem.id.toLowerCase()] = j; // desensitize
                    csv.set(0, j, categoryItem.label || categoryItem.id);
                }
            }

            // Select first dataset
            datasetItem = jsondata.dataset && jsondata.dataset[0] &&
                jsondata.dataset[0].data || [];

            // Iterate through data and based on row and col id of the values,
            // use the reverseMap to place them on csv.
            for (i = 0, l = datasetItem.length; i < l; i += 1) {
                dataItem = datasetItem[i];
                row = dataItem.rowid.toLowerCase();
                column = dataItem.columnid.toLowerCase();

                // If a row is not found on the map, append one.
                if (!mapRows[row]) {
                    mapRows[row] = csv.rowCount;
                    csv.set(csv.rowCount, 0, dataItem.rowid); // add header
                }
                // If a column is not found on the map, append one.
                if (!mapColumns[column]) {
                    mapColumns[column] = csv.columnCount;
                    csv.set(0, csv.columnCount, dataItem.columnid); // add header
                }

                csv.set(mapRows[row], mapColumns[column], doFormat(dataItem.value));
            }

        }

        // cleanup
        axisset = null;
        lineset = null;
        categories = null;
        datasets = null;

        if (csv.rowCount > 0 && csv.get(0, 0) === undefined) {
            csv.set(0, 0, chartAttrs.xaxisname || 'Label');
        }

        return {
            data: csv.toString(),
            error: undefined,
            predictedFormat: predictedFormat
        };
    };

    /**
     * Fetch data that has been set on a chart in CSV format. This function is shorthand of using
     *`chart.getChartData('csv')`.
     *
     * The data returned is the closest possible comma-separated value representation that has been provided to the
     * chart. The exported data does not contain any functional or cosmetic attribute that was set on the chart.
     * However, the following chart attributes can be set to customise the CSV output.
     *
     * | Chart Attribute          | Type        | Description  |
     * | -------------------------|-------------|--------------|
     * | `exportDataSeparator`    | string      | Sets the CSV delimiter string. Default is `,` (comma) |
     * | `exportDataQualifier`    | string      | Sets the CSV qualifier string. Default is `{quot}` |
     * | `exportDataFormattedVal` | boolean     | Sets whether the output will be a formatted string or pure number|
     * | `exportErrorColumns`     | boolean     | Forces error output on ErrorColumn, ErrorLine and ErrorScatter charts|
     *
     * For `exportDataSeparator` and `exportDataQualifier`, one can provide quotation mark, apostrophe and tab character
     * in form of {quot}, {apos} and {tab} short-codes, respectivey.
     *
     * This function needs to be called on an existing chart that has been loaded and has a valid data. If this function
     * is called on a chart which has no data set on it, it returns an empty string.
     *
     * > As of now, the CSV data generator uses heuristics heuristic methods to determine the nature of the output
     * > since, the method does not internaly have access to the chart-type being used. As such, when a specific chart
     * > type cannot determined from the data itself, this method falls back to a generic output format.
     *
     * @function getCSVData
     * @memberOf FusionCharts#
     * @group data
     * @see FusionCharts#getChartData
     *
     * @returns {string}
     */
    global.addDataHandler('CSV', {
        encode: function (data, obj) {
            /**
             * @private
             *
             * @typedef {RuntimeException} Error-0604111215
             * @memberOf FusionCharts.debugger
             * @group debugger-error
             */
            global.raiseError(obj, '0604111215', 'run', '::CSVDataHandler.encode()',
                'FusionCharts CSV data-handler only supports encoding of data.');
            throw new Error('FeatureNotSupportedException()');
        },
        decode: decoder,
        transportable: false
    });

    // Add the function reference to getDataAsCSV for JS charts.
    core.addEventListener('Loaded', function (event) {
        var obj = event.sender;

        // Execute this event for JS charts only.
        if (obj.options.renderer !== 'javascript') {
            return;
        }

        // Override the getDataAsCSV
        if (!obj.getDataAsCSV) {
            /**
             * Fetch the data set to the chart in comma separated values format. The delimiter can be changed by passing
             * relevant chart attributes.
             *
             * @function getDataAsCSV
             * @memberOf FusionCharts#
             * @group data
             * @deprecated 3.3.0 - In favour of {@link FusionCharts#getCSVData}
             *
             * @returns {string}
             */
            obj.getDataAsCSV = obj.ref.getDataAsCSV = obj.getCSVData;
        }
    });

}]);
/**
 * This is the JavaScript Renderer bootstrap. Its basic functionalities are to
 * create interfaces between FusionCharts JS Renderer Manager and the renderer.
 * @private
 *
 * @module fusioncharts.renderer.javascript
 * @requires fusioncharts.renderer
 */

FusionCharts.register('module', ['private', 'modules.renderer.js', function () {

    var
    global = this,
    win = global.window,
    doc = win.document,
    coreOptions = global.core.options,
    extendedCoreOptions = {
        html5ScriptNameSuffix:  '.js',
        html5ScriptNamePrefix: 'fusioncharts.'
    },

    /**
     * This flag sets whether the JavaScript renderer will be used primarily or
     * Flash renderer would be given priority if player exists.
     * @id SET_AS_PRIMARY_RENDERER
     * @type boolean
     * @const
     */
    SET_AS_PRIMARY_RENDERER = true,

    LOADER_CSS_TEXT = 'display: inline-block; *zoom:1; *display:inline; width: 100%; ' +
        'font-family: Verdana,sans; font-size: 10px; color: #666666; text-align: center;',
    MODULE_NAME_BASE = 'modules.renderer.js-',

    isIE = /msie/i.test(win.navigator.userAgent) && !win.opera,
    hasSVG = Boolean(win.SVGAngle || doc.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure',
        '1.1')),

    // Create the renderer object.
    renderer = function () {},

    // Create an object in global that would store Renderer Library
    lib = global.hcLib = {
        cmdQueue: []
    },

    moduleCmdQueue = lib.moduleCmdQueue = {
        base: [],
        charts: [],
        powercharts: [],
        widgets: [],
        maps: []
    },

    moduleDependencies = lib.moduleDependencies = {},

    /**
     * The enumeration of default filenames for each of the dependent
     * modules.
     * @type object
     * @constant
     */
    moduleMeta = lib.moduleMeta = {
        base: 'fusioncharts.js',
        charts: 'fusioncharts.charts.js',
        powercharts: 'fusioncharts.powercharts.js',
        widgets: 'fusioncharts.widgets.js',
        maps: 'fusioncharts.maps.js'
    },

    /**
     * Stores a list of modules that are blocked from loading.
     */
    blockedModules = {},

    getMetaSentence = lib.getMetaSentence = (function () {
        var cache = {};
        return function (composite) {
            composite = composite && composite.replace(/(^\s*)|(\s*$)/g, '') || '';
            return cache[composite] || (cache[composite] = {
                key: composite,
                subject: composite.replace(/[^\/]*?$/ig, ''),
                predicate: composite.replace(/^.*\//ig, '')
            });
        };
    })(),

    /**
     * Find the relevant required module names from a given chart type.
     *
     * @param {string} type depermines the chart type (alias) that needs to
     * be looked up for dependent module names
     *
     * @type Array
     */
    getDependentModuleName = lib.getDependentModuleName = function (type) {
        var modules = [],
            i,
            j;

        type = getMetaSentence(type).predicate;
        for (i in moduleDependencies) {
            if ((j = moduleDependencies[i][type]) === undefined) {
                continue;
            }
            modules[j] = i;
        }

        return modules;
    },

    // Function that checks whether a particular module is loaded.
    hasModule = lib.hasModule = function (name) {
        var i,
            l;

        // In case we check presense of multiple modules.
        if (name instanceof Array) {
            for (i = 0, l = name.length; i < l; i += 1) {
                if (!Boolean(global.modules[MODULE_NAME_BASE + getMetaSentence(name[i]).predicate])) {
                    return false;
                }
            }
            return true;
        }

        return Boolean(global.modules[MODULE_NAME_BASE + getMetaSentence(name).predicate]);
    },

    // Function to call the global loadScript function for loading an html5
    // module.
    loadModule = lib.loadModule = function (name, success, failure, source) {

        // convert single string to array of one string.
        if (!(name instanceof Array)) {
            name = [name];
        }


        var l = name.length,
            count = 0,
            loadFile; // fn

        loadFile = function () {

            // Proceed with callback when load completes.
            if (count >= l) {
                success && success();
                return;
            }

            var metaKey = name[count],
                metaPredicate = metaKey && metaKey.match(/[^\/]*$/i)[0], // actual alias
                meta = moduleMeta[metaKey],
                userSrc;

            // Increment counter.
            count += 1;

            if (!metaKey) {
                failure && failure(metaPredicate);
            }
            // Check if module already exists
            else if (hasModule(metaPredicate)) {
                loadFile();
                return;
            }
            // Check if loading has been blocked. If yes, then assume that
            // module exists.
            else if (blockedModules[metaPredicate]) {
                global.raiseError(source || global.core,
                '1112201445A', 'run', 'JavaScriptRenderer~loadModule() ',
                'required resources are absent or blocked from loading.');
                failure && failure(metaPredicate);
                return;
            }

            // If user has overridden file names.
            userSrc = global.core.options['html5' + global.capitalizeString(metaPredicate) + 'Src'];

            global.loadScript(userSrc === undefined ? meta : userSrc, {
                success: function () {
                    // Even after successful load, we should check whether it
                    // actually loaded the module.
                    if (hasModule(metaPredicate)) {
                        loadFile();
                    }
                    else {
                        failure && failure(metaPredicate);
                    }
                },

                failure: failure && function () {
                    failure(metaPredicate);
                }
            }, undefined, true);
        };

        loadFile();
    },

    /**
     * Execute renderer interface commands that are queued due to renderer
     * not being ready.
     */
    executeWaitingCommands = lib.executeWaitingCommands = function (queue) {
        var item;

        // Iterate through all FusionCharts objects
        while ((item = queue.shift())) {
            // Now we execute 'command' on all charts that are waiting
            // for the renderer to get ready.
            if (typeof item === 'object') {
                renderer[item.cmd].apply(item.obj, item.args);
            }
        }

    },

    clearStateEventHandler = function (event) {
        delete event.sender.jsVars._reflowData;
        event.sender.jsVars._reflowData = {};
        //delete reflowclean
        delete event.sender.jsVars._reflowClean;
    },


    ChartMessage = (function () {
        var api = function () {};
        /**
         * @name FusionCharts~chartStatusMessages
         * @enum
         * @type {string}
         */
        api.prototype = {
            'LoadDataErrorText': 'Error in loading data.',
            'XMLLoadingText': 'Retrieving data. Please wait',
            'InvalidXMLText': 'Invalid data.',
            'ChartNoDataText': 'No data to display.',
            'ReadingDataText': 'Reading data. Please wait',
            'ChartNotSupported': 'Chart type not supported.',
            'PBarLoadingText': '',
            'LoadingText': 'Loading chart. Please wait',
            'RenderChartErrorText': 'Unable to render chart.'
        };
        return api.prototype.constructor = api;
    })(),

    defined = function(obj) {
        return obj !== undefined && obj !== null;
    },

    getContainerBackgroundColor = lib.getContainerBackgroundColor = function (chart) {
        var color = chart.options.containerBackgroundColor,
            opacity = chart.options.containerBackgroundOpacity;

        if (defined(chart.jsVars.transparent)) {
            opacity = chart.jsVars.transparent ? 0 : 1;
        }
        else {
            opacity = parseFloat(opacity);
            if (opacity < 0) {
                opacity = 0;
            }
            else if (opacity > 1) {
                opacity = 1;
            }
        }

        if (!color) {
            color = '#ffffff';
        }

        if (isIE && !hasSVG) {
            return opacity ? color : 'transparent';
        }
        else {
            color = color.replace(/^#?([a-f0-9]+)/ig, '$1');
            color = lib.graphics.HEXtoRGB(color),
            color[3] = opacity.toString();
            return 'rgba(' + color.join(',') + ')';
        }

    },

    showLoadingMessage = function (chart, container) {
        var vars = chart.jsVars,
            msgs = vars.msgStore;

        if (container && chart.options.showChartLoadingMessage) {
            // Show loading message as HTML block since HTML5 renderer is not
            // loaded yet.
            container.innerHTML = '<small style="'+ LOADER_CSS_TEXT +
                ' padding-top: ' +
                ((parseInt(container.style.height, 10) / 2) - 5) +'px">' +
                (msgs.PBarLoadingText || msgs.LoadingText) + '</small>';

            // Set the container's background color only when transparent mode is not set.
            container.style.backgroundColor = getContainerBackgroundColor(chart);
        }
    };


    /**
     * Adds a dynamic dependency item
     */
    lib.injectModuleDependency = function (module, alias, order) {
        var isInjected = false,
            metaSubject = getMetaSentence(module).subject,
            metaPredicate = getMetaSentence(module).predicate;

        alias = (alias === undefined) ? metaPredicate : getMetaSentence(alias).predicate;

        if (!moduleDependencies[metaPredicate]) {
            moduleDependencies[metaPredicate] = {};
            if (!moduleCmdQueue[metaPredicate]) {
                moduleCmdQueue[metaPredicate] = [];

                lib.moduleMeta[metaPredicate] = metaSubject + coreOptions.html5ScriptNamePrefix +
                    (alias && alias.replace && alias
                        .replace(/^[\s\S]*\//ig, '') // do not allow path in alias
                        .replace(/\?/g, '%3F') // encode url destructive chars
                        .replace(/\#/g, '%23')
                        .replace(/\:/g, '%3A') || '') +
                    coreOptions.html5ScriptNameSuffix;
            }

            isInjected = true;
        }
        moduleDependencies[metaPredicate][alias] = order || 0;

        return isInjected; // indicate alias already injected
    };


    // Determine whether a chart-type needs a particular module.
    lib.needsModule = function (name, type) {
        name = getMetaSentence(name).predicate;
        type = getMetaSentence(type).predicate;
        return (lib.moduleDependencies[name] &&
                lib.moduleDependencies[name][type]) !== undefined;
    };

    /**
     * Remove all waiting commands for a specific chart-object
     */
    lib.cleanupWaitingCommands = function (chart) {
        var type = chart.chartType(),
            modules = getDependentModuleName(type),
            module,
            requeue = [],
            queue,
            item;

        // Iterate through all modules that this chart is dependent on.
        while ((module = modules.shift())) {
            queue = moduleCmdQueue[module] || [];
            while ((item = queue.shift())) {
                // Check whether the scope object matches the one passed in params.
                if (typeof item === 'object' && item.obj !== chart) {
                    requeue.push(item);
                }
            }
            // Restore re-queued items back in queue
            queue.concat(requeue);
            requeue = [];
        }
    };

    // Define default configuration options pertaining to HTML5 renderer.
    global.extend(global.core.options, extendedCoreOptions);

    // Create the renderer interface functions
    global.extend(renderer, {
        dataFormat: 'json',
        ready: false,

        policies: {
            jsVars: {
                // userModules: ['dependentModules', []] // enable if needed
            },
            options: {
                // Shows messages while chart is loading JS files.
                showChartLoadingMessage: ['showChartLoadingMessage', true]
            }
        },

        init: function () {

            // Now 'base' has to be loaded. Had
            // base been loaded, this function would not have had existed.
            if (!hasModule('base')) {
                loadModule('base', function () {
                    // All scripts are loaded, hence renderer is ready
                    renderer.ready = true;

                    // Clear any object that has been waiting for render
                    executeWaitingCommands(lib.cmdQueue);
                }, undefined, global.core);
                return;
            }

            // If code is here, implies renderer is ready
            renderer.ready = true;
        },

        // This is almost a stub render function as its job is to queue objects.
        render: function (container) {

            // Show message in HTML form
            showLoadingMessage(this, container);

            // As renderer is not ready, push it to queue
            lib.cmdQueue.push({
                cmd: 'render',
                obj: this,
                args: arguments
            });
        },

        update: function () {
            // As renderer is not ready, push it to queue
            lib.cmdQueue.push({
                cmd: 'update',
                obj: this,
                args: arguments
            });
        },

        resize: function () {
            lib.cmdQueue.push({
                cmd: 'resize',
                obj: this,
                args: arguments
            });
        },

        dispose: function () {
            var queue = lib.cmdQueue, i, l;
            // Since renderer is not ready, we clear the command queue
            for (i = 0, l = queue.length; i < l; i += 1) {
                // We remove commands specific to this particular object.
                if (queue[i].obj === this) {
                    queue.splice(i, 1);
                    l -= 1; // subtract length as item was removed
                    i -= 1;
                }
            }
        },

        load: function () {
            lib.cmdQueue.push({
                cmd: 'load',
                obj: this,
                args: arguments
            });
        },

        config: function (items, optionalValue) {
            var item,
                chart = this,
                vars = chart.jsVars,
                msgs = vars.msgStore,
                cfg = vars.cfgStore,
                options = chart.options,
                chartMessageOldNewMap;

            chartMessageOldNewMap = {
                LoadingText: 'loadMessage',
                ChartNotSupported: 'typeNotSupportedMessage',
                RenderChartErrorText: 'renderErrorMessage',
                XMLLoadingText: 'dataLoadStartMessage',
                ChartNoDataText: 'dataEmptyMessage',
                LoadDataErrorText: 'dataLoadErrorMessage',
                InvalidXMLText: 'dataInvalidMessage'
            };

            // If 'items' is not an object, convert it to object.
            if (typeof items === 'string' && arguments.length > 1) {
                item = items;
                items = {};
                items[item] = optionalValue;
            }

            // store data at respective places.
            for (item in items) {
                // if the config is part of chart messages, we store it there.
                if (msgs[item] !== undefined) {
                    msgs[item] = items[item];
                }
                // otherwise we store it to the config store.
                else {
                    cfg[item.toLowerCase()] = items[item];
                }

                // Update message in constructor parameter.
                if (chartMessageOldNewMap[item]) {
                    options[chartMessageOldNewMap[item]] = items[item];
                }
            }
        },

        protectedMethods: {
        },

        events: {
            beforeInitialize: function (event) {
                var sender = event.sender,
                    vars = sender.jsVars,
                    chartType, // set first time
                    userArg;

                vars.fcObj = sender;
                vars.msgStore = vars.msgStore || new ChartMessage();
                vars.cfgStore = vars.cfgStore || {};
                vars.previousDrawCount = -1;
                vars.drawCount = 0;
                vars._reflowData = {};

                // add one-time event listener for before-render to perform initialization actions
                sender.addEventListener('beforeRender', function (event) {
                    event.sender.jsVars.smartLabel =
                        (new lib.SmartLabelManager(sender.id, doc.body || doc.getElementsByTagName('body')[0]));

                    event.detachHandler();
                });

                // validate user-defined dependent module names
                if (!(vars.userModules instanceof Array)) {
                    userArg = vars.userModules;
                    vars.userModules = [];
                    if (typeof userArg === 'string') {
                        vars.userModules =
                            vars.userModules.concat(userArg.split(','));
                    }
                }

                // check presence of API
                if (!lib.chartAPI || !lib.chartAPI[chartType]) {
                    vars.needsLoaderCall = true;
                }
            },

            initialized: function (event) {
                var chart = event.sender,
                    vars = chart.jsVars;

                if (vars.needsLoaderCall) {
                    delete vars.needsLoaderCall;
                    // Request load of the specific chart module
                    renderer.load.call(chart);
                }
            },

            beforeDataUpdate: clearStateEventHandler,

            beforeDispose: function (event) {
                var chart = event.sender,
                    vars = chart.jsVars;

                vars.smartLabel && (!vars.smartLabel.disposed) && vars.smartLabel.dispose();

                clearStateEventHandler.apply(this, arguments);
                /** @todo paper-reuse */
                // vars.paper && (vars.paper.remove(), delete vars.paper);
            },

            beforeRender: function (event) {
                var chart = event.sender,
                    vars = chart.jsVars;

                delete vars.drLoadAttempted;
                delete vars.waitingModule;
                delete vars.waitingModuleError;
                /** @todo paper-reuse */
                //vars.paper && (vars.paper.remove(), delete vars.paper);

                clearStateEventHandler.apply(this, arguments);
            },

            dataLoadRequested: function (event) {

                // Reference to event sender.
                var obj = event.sender,
                    vars = obj.jsVars;

                delete vars.loadError;

                // In case we have an active chart, we show the loading
                // message in chart itself.
                if (obj.ref && obj.options.showDataLoadingMessage) {
                    if (vars.hcObj && !vars.hasNativeMessage &&
                            vars.hcObj.showLoading) {
                        vars.hcObj.showMessage(vars.msgStore.XMLLoadingText);
                    }
                    else if (obj.ref.showChartMessage) {
                        obj.ref.showChartMessage('XMLLoadingText');
                    }
                    else {
                        vars.stallLoad = true;
                    }
                }
                else {
                    vars.stallLoad = true;
                }
            },

            dataLoadRequestCompleted: function (event) {
                // Reference to event sender.
                var obj = event.sender,
                    vars = obj.jsVars;

                // Clear load prevention flags.
                delete vars.stallLoad;
            },

            dataLoadError: function (event) {

                // Reference to event sender.
                var obj = event.sender,
                    vars = obj.jsVars;

                // On data load error, one needs to display 'No Data To Display'
                // on charts.
                delete vars.stallLoad;
                vars.loadError = true;

                if (obj.ref && typeof obj.ref.showChartMessage === 'function') {
                    obj.ref.showChartMessage('LoadDataErrorText');
                }

                if (obj.__state.dataFetchDuringConstruction) {
                    delete obj.__state.dataFetchDuringConstruction;
                }

                clearStateEventHandler.apply(this, arguments);
            }

        },

        // Not required for interface, but needed for runtime definition of
        // chartAPI
        '_call': function (fn, args, scope) {
            fn.apply(scope || win, args || []);
        }
    });

    // Add functions that will be inherited by every chart instance created out
    // of this instance.
    global.extend(renderer.prototype, /** @lends FusionCharts# */ {

        /**
         * Gets the HTML of SWF
         * @deprecated 3.4.0 - This has been deprecated since JavaScript variant is the only renderer supported.
         * @group others
         * @returns {string}
         */
        getSWFHTML: function () {
            global.raiseWarning(this, '11090611381', 'run', 'JavaScriptRenderer~getSWFHTML()',
                'getSWFHTML() is not supported for JavaScript charts.');
        },

        /**
         * Adds variable to Flash chart. Equivalent to {@link FusionCharts#configure} for JavaScript charts
         * @deprecated 3.4.0 - Use the alternate function {@link FusionCharts#configure}
         * @group others
         * @see FusionCharts#configure
         */
        addVariable: function () {
            global.raiseWarning(this, '11090611381', 'run', 'JavaScriptRenderer~addVariable()',
                'Use of deprecated "addVariable()". Replace with "configure()".');

            global.core.prototype.configure.apply(this, arguments);
        },

        /**
         * This function returns the data and and configuration set on a chart in `XML` format. The function is
         * usable after the {@link FusionCharts#event:loaded} event of a chart has been fired. As such, it is
         * recommended to use the alternate function {@link FusionCharts#getXMLData}, which does not have this
         * limitation of being available only after the `loaded` event has been fired.
         *
         * @deprecated 3.2.0 - It is recommended that the alternate functions {@link FusionCharts#getXMLData} or
         * {@link FusionCharts#getChartData} be used instead of this.
         * @group data
         * @see FusionCharts#getXMLData
         *
         * @returns {string}
         */
        getXML: function () {
            global.raiseWarning(this, '11171116291', 'run', 'JavaScriptRenderer~getXML()',
                'Use of deprecated "getXML()". Replace with "getXMLData()".');
            return this.getXMLData.apply(this, arguments);
        },

        /**
         * Sets XML data set on chart. Equivalent to {@link FusionCharts#setXMLData} or
         * {@link FusionCharts#setChartData}. The function is
         * usable after the {@link FusionCharts#event:loaded} event of a chart has been fired. As such, it is
         * recommended to use the alternate function {@link FusionCharts#setXMLData}, which does not have this
         * limitation of being available only after the `loaded` event has been fired.
         *
         * @deprecated 3.2.0 - It is recommended that the alternate functions {@link FusionCharts#setXMLData} or
         * {@link FusionCharts#setChartData} be used instead of this.
         * @group data
         * @see FusionCharts#setXMLData
         */
        setDataXML: function () {
            global.raiseWarning(this, '11171116292', 'run', 'JavaScriptRenderer~setDataXML()',
                'Use of deprecated "setDataXML()". Replace with "setXMLData()".');
            return this.setXMLData.apply(this, arguments);
        },

        /**
         * Sets XML data URL set on chart. The function is
         * usable after the {@link FusionCharts#event:loaded} event of a chart has been fired. As such, it is
         * recommended to use the alternate function {@link FusionCharts#setXMLUrl}, which does not have this
         * limitation of being available only after the `loaded` event has been fired.
         *
         * @deprecated 3.2.0 - It is recommended that the alternate functions {@link FusionCharts#setXMLUrl} or
         * {@link FusionCharts#setChartDataUrl} be used instead of this.
         * @group data
         * @see  FusionCharts#setXMLUrl
         */
        setDataURL: function () {
            global.raiseWarning(this, '11171116293', 'run', 'JavaScriptRenderer~setDataURL()',
                'Use of deprecated "SetDataURL()". Replace with "setXMLUrl()".');
            return this.setXMLUrl.apply(this, arguments);
        },

        /**
         * Returns whether a chart has been successfully rendered or not.
         * @group chart
         * @see FusionCharts#render
         * @see FusionCharts#event:beforeRender
         * @see FusionCharts#event:renderComplete
         * @see FusionCharts#event:renderCancelled
         * @see FusionCharts#event:rendered
         * @returns {boolean}
         */
        hasRendered: function () {
            return !!(this.jsVars.hcObj && this.jsVars.hcObj.hasRendered);
        },

        /**
         * Sets the chart's container background color as transparent. This is not the chart's background. It is the
         * background of the container DOM element within which the chart has been rendered.
         *
         * @group chart
         * @deprecated 3.4.0 - The container transparency can now be controlled using the `containerBackgroundOpacity`
         * parameter while creating a new instance of {@link FusionCharts}.
         *
         * @param {boolean} transparency - Passing `true` implies that the chart is transparent.
         * @returns {boolean}
         */
        setTransparent: function (transparency) {
            var vars;

            if (!(vars = this.jsVars)) {
                return;
            }

            // Sets chart to transparent mode when isTransparent (wMode) is true
            // (default). When no parameter is passed, we assume transparent to
            // be true.
            if (typeof transparency !== 'boolean' && transparency !== null) {
                transparency = true;
            }

            // Set the property.
            vars.transparent = transparency === null ? false :
                (transparency === true ? true : false);
        }

    });



    global.extend(global.core, {
        /*
         * Provide API for auto fall-back to JS chart when no flash is installed.
         */
        _fallbackJSChartWhenNoFlash: function () {
            // Check flash version.
            if (!win.swfobject.hasFlashPlayerVersion(global.core.options.requiredFlashPlayerVersion)) {
                // If flash version is missing, we fallback to javascript
                global.renderer.setDefault('javascript');
            }
        },

        /*
         * Specify to enable JavaScript renderer as default, based on browser
         * userAgent.
         * ~param {string} str Is the regular expression used to detect browser
         * userAgent
         *
         * ~note: Regexp for Apple Devices: /\(iPhone;|\(iPod;|\(iPad;/i
         */
        _enableJSChartsForSelectedBrowsers: function (str) {
            // str is a required parameter. If not set, we exit this function.
            if (str === undefined || str === null) {
                return;
            }

            // Register the js renderer in case we have iPad or iPhone and flash
            // for rest.
            global.renderer.setDefault((new RegExp(str).test(win.navigator.userAgent)) ? 'javascript' : 'flash');
        },

        /*
         * Let user specify not to load specific external scripts.
         *~param {object} flags is the object that specifies which external
         * script is not to be loadd.
         *
         * ~example
         * // Prevent FusionCharts from loading its own jQuery
         * if (FusionCharts._doNotLoadHTML5ExternalScript) {
         * FusionCharts._doNotLoadHTML5ExternalScript({ jQuery: false })]
         * }
         */
        _doNotLoadExternalScript: function (flags) {
            var item, srcKey;
            for (item in flags) {
                srcKey = item.toLowerCase();
                if (moduleMeta[srcKey]) {
                    blockedModules[srcKey] = Boolean(flags[item]);
                }
            }
        },

        _preloadJSChartModule: function () {
            /** @todo  Implement preloading modules. */
            throw 'NotImplemented()';
        }
    });

    // Add the renderer to FusionCharts core repository
    global.renderer.register('javascript', renderer);

    // In case JavaScript is configured to be set as primary renderer, check for
    // SVG support or IE browser.
    if (SET_AS_PRIMARY_RENDERER && (hasSVG || isIE)) {
        global.renderer.setDefault('javascript');
    }
    // Otherwise check for Flash support and finally fall back to JavaScript.
    else if (win.swfobject && win.swfobject.hasFlashPlayerVersion &&
        !win.swfobject.hasFlashPlayerVersion(global.core.options.requiredFlashPlayerVersion)) {
        global.raiseWarning(global.core, '1204111846', 'run', 'JSRenderer',
            'Switched to JavaScript as default rendering due to absence of required Flash Player.');
        // If flash version is missing, we fallback to javascript
        global.renderer.setDefault('javascript');
    }

}]);
/**
 * @private
 * @module fusioncharts.renderer.javascript.lib
 * @requires fusioncharts.renderer.javascript
 */
FusionCharts.register('module', ['private', 'modules.renderer.js-lib', function () {
    var global = this,
        win = global.window,
        // Constants
        BLANKSTRINGPLACEHOLDER = '#BLANK#',
        BLANK = '',
        COLOR_BLACK = '000000',
        COLOR_GLASS = 'rgba(255, 255, 255, 0.3)',
        COLOR_WHITE = 'FFFFFF',
        COLOR_TRANSPARENT = 'rgba(0,0,0,0)',
        TESTSTR = 'Ag',
        HASHSTRING = '#',
        BREAKSTRING = '<br />',
        STRINGSTRING = 'string',
        OBJECTSTRING = 'object',
        COMMA = ',',
        HYPHEN = '-',
        COLON = ':',
        ZEROSTRING = '0',
        ONESTRING = '1',
        DECIMALSTRING = '.',
        STRINGUNDEFINED = 'undefined',
        UNDEFINED,
        POSITION_TOP = 'top',
        POSITION_RIGHT = 'right',
        POSITION_BOTTOM = 'bottom',
        POSITION_LEFT = 'left',
        POSITION_CENTER = 'center',
        POSITION_MIDDLE = 'middle',
        POSITION_START = 'start',
        POSITION_END = 'end',
        FC_CONFIG_STRING = '_FCconf',
        SHAPE_RECT = 'rect',
        TEXTANCHOR = 'text-anchor',
        // Strings that is being used rapidly
        HUNDREDSTRING = '100',
        PXSTRING = 'px',
        COMMASPACE = ', ',
        TOUCH_THRESHOLD_PIXELS = 15,
        CLICK_THRESHOLD_PIXELS = 5,
        doc = win.document,
        hasSVG = Boolean(win.SVGAngle || doc.implementation.hasFeature(
            'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1')),
        isIE = /msie/i.test(win.navigator.userAgent) && !win.opera,
        toFloat = win.parseFloat,
        // Regular Expressions
        stripWhitespace = /\s+/g,
        dropHash = /^#?/,
        startsRGBA = /^rgba/i,
        cleanColorCode = /[#\s]/ig,
        breakPlaceholder = /\{br\}/ig,
        hexcode = /^#?[0-9a-f]{6}/i,
        validhexcolor = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i,
        mathAbs = Math.abs,
        mathPow = Math.pow,
        mathRound = Math.round,
        EPSILON = mathPow(2, -24),
        objectToStrFn = Object.prototype.toString,
        hasTouch = doc.documentElement.ontouchstart !== undefined,
        CREDIT_HREF = 'http://www.fusioncharts.com?BS=FCHSEvalMark&utm_source=FCS_trial' +
            '&pver=' + win.escape(global.core.version),
        CREDIT_STRING = 'FusionCharts XT Trial' || '',
        creditLabel = false && !/fusioncharts\.com$/i.test(win.location.hostname),
        math = Math,
        mathMax = math.max,
        mathMin = math.min,
        stubEvent = {
            pageX: 0,
            pageY: 0
        },
    lib = global.hcLib || (global.hcLib = {}),
        createContextMenu = function(options) {

            var chart = options.chart,
                smartLabel = chart.smartLabel,
                roundedCorners = chart.logic.hcJSON && chart.logic.hcJSON.chart.useRoundEdges,
                R = lib.Raphael,
                chartAttrsForMenu = (function(options) {

                    var menuColor = options.menufillcolor && hashify(options.menufillcolor),
                        labelColor = options.menulabelcolor && hashify(options.menulabelcolor),
                        menuHoverColor = options.menufillhovercolor && hashify(options.menufillhovercolor),
                        labelHoverColor = options.menulabelhovercolor && hashify(options.menulabelhovercolor);

                    return {
                        attrs: {
                            backgroundColor: menuColor,
                            color: labelColor
                        },
                        hover: {
                            backgroundColor: menuHoverColor,
                            color: labelHoverColor
                        }
                    };
                }(chart.definition.chart)),
                boxHover = (function(defaultStyle, attrs, ca) {

                    attrs = attrs || {};

                    var dcolor = (defaultStyle && R.tintshade(defaultStyle.color, 0.7)),
                        bg = dcolor && R.getRGB(dcolor),
                        bgcolor = bg && 'rgb(' + [bg.r, bg.g, bg.b].join(',') + ')';

                    return {
                        backgroundColor: attrs.backgroundHoverColor || ca.backgroundColor || bgcolor ||
                            'rgb(64, 64, 64)',
                        color: attrs.hoverColor || ca.color || '#FFFFFF'
                    };
                }(options.basicStyle, options.hover, chartAttrsForMenu.hover)),
                boxAttrs = (function(defaultStyle, attrs, ca) {

                    attrs = extend2({}, attrs || {});
                    attrs = extend2(attrs, defaultStyle);

                    return {
                        fontFamily: attrs.fontFamily || 'Verdana,sans',
                        fontSize: attrs.fontSize || '10px',
                        color: attrs.color || ca.color || '#000000',
                        backgroundColor: attrs.backgroundColor || ca.backgroundColor || 'rgb(255, 255, 255)'
                    };
                }(options.basicStyle, options.attrs, chartAttrsForMenu.attrs)),
                itemBoxAttrs = {
                    textAlign: 'left',
                    align: 'left',
                    paddingLeft: '5px',
                    paddingRight: '5px',
                    paddingTop: '5px',
                    cursor: 'pointer',
                    borderWidth: '0px'
                },
            items = options.items,
                position = options.position,
                vPad = (options.verticalPadding || 3),
                hPad = (options.horizontalPadding || 6),
                menu = {},
                chartPos,
                hideTimer,
                menuContainer,
                drawFn,
                getMenuContainer,
                setHideTimer,
                resetHideTimer,
                calculateTopLeft,
                nonItemClick,
                mouseHandler,
                mouseOver,
                mouseOut,
                itemClick;

            if (!chart) {
                return false;
            }
            else {
                chartPos = getPosition(chart.container);
            }

            drawFn = function() {
                var paper = this,
                    items = menu.items,
                    i = items.length,
                    menuHeight = 0,
                    menuWidth = 0,
                    eachHeight = 0,
                    top = 0,
                    item,
                    ele,
                    ii,
                    key,
                    smartLabelObj;

                if (!menu.menuItems) {
                    menu.menuItems = [];
                }

                smartLabel.setStyle(boxAttrs);

                while (i--) {

                    item = items[i];
                    smartLabelObj = smartLabel.getOriSize(item.text);
                    if (!eachHeight) {
                        eachHeight = (smartLabelObj.height + (2 * vPad));
                    }
                    menuHeight += eachHeight;
                    menuWidth = mathMax(menuWidth, (smartLabelObj.width + (2 * hPad)));
                }

                menu.height = menuHeight;
                menu.width = menuWidth;
                menu.itemH = eachHeight;

                // set the dimensions to the paper.
                paper.style.width = menuWidth + PXSTRING;
                //paper.style.height = (menuHeight + 5) + PXSTRING;

                // create the outer rect.
                if (!menu.menuRect) {

                    ele = menu.menuRect = doc.createElement('div');
                    ele.style.border = '1px solid rgb(100, 100, 100)';

                    if (roundedCorners) {
                        ele.style.mozBorderRadius = '4px';
                        ele.style.webkitBorderRadius = '4px';
                        ele.style.borderRadius = '4px';
                        ele.style.overflow = 'hidden';
                    }

                    if (isIE && !hasSVG) {
                        ele.style.filter =
                            'progid:DXImageTransform.Microsoft.Shadow(Color=#999999,direction=135,strength=3)';
                    }
                    else {
                        ele.style.mozBoxShadow = '3px 3px 3px #999';
                        ele.style.webkitBoxShadow = '3px 3px 3px #999';
                        ele.style.boxShadow = '3px 3px 3px #999';
                    }

                    paper.appendChild(ele);
                }

                ii = items.length;

                for (i = 0; i < ii; i += 1) {
                    // create elements
                    item = items[i];
                    if (menu.menuItems[i]) {
                        menu.menuItems[i].label.innerHTML = item.text;
                    }
                    else {
                        menu.menuItems[i] = {};
                        ele = menu.menuItems[i].box = doc.createElement('div');

                        //ele.style.width = menuWidth + PXSTRING;
                        ele.style.height = eachHeight + PXSTRING;
                        ele.style.lineHeight = eachHeight + PXSTRING;

                        for (key in itemBoxAttrs) {
                            ele.style[key] = itemBoxAttrs[key];
                        }

                        for (key in boxAttrs) {
                            ele.style[key] = boxAttrs[key];
                        }

                        menu.menuRect.appendChild(ele);
                        ele.innerHTML = item.text;

                        lib.dem.listen(ele, 'click', itemClick);
                        lib.dem.listen(ele, 'pointerhover', mouseHandler);

                        menu.menuItems[i].box._itemIdx = i;
                        top += eachHeight;
                    }
                }

                while (menu.menuItems[i]) {
                    menu.menuItems[i].box.parentNode.removeChild(menu.menuItems[i].box);
                    menu.menuItems.splice(i, 1);
                }
            };
            getMenuContainer = function() {

                if (!menuContainer) {
                    menuContainer = doc.createElement('div');
                    menuContainer.style.position = 'absolute';
                    menuContainer.style.zIndex = '50';
                    menuContainer.style.display = 'none';

                    if (chart.container.appendChild) {
                        chart.container.appendChild(menuContainer);
                    }

                    return menuContainer;
                }
                else {
                    return menuContainer;
                }
            };
            setHideTimer = function() {
                hideTimer = setTimeout(menu.hide, 800);
            };
            resetHideTimer = function() {
                if (hideTimer) {
                    clearTimeout(hideTimer);
                }
            };
            calculateTopLeft = function(position) {
                var x = position.x,
                    y = position.y,
                    pos = {
                        x: x, //+ chartPos.left,
                        y: y //+ chartPos.top
                    },
                    width = menu.width,
                    height = menu.height,
                    cHeight = chart.chartHeight,
                    cWidth = chart.chartWidth;

                if (((x + width) > cWidth) && ((x - width) > 0)) {
                    pos.x -= width;
                }else if((x + width) > cWidth){
                    //when the export dialog box is greater than the chart width
                    //we should place the dialog such a way that only
                    //the extra part will go outside the chart. Aligning the dialog
                    //to extreme left.
                    pos.x = 0;
                }

                if (((y + height) > cHeight) && ((y - height) > 0)) {
                    pos.y -= height;
                }

                return pos;
            };
            nonItemClick = function() {
                menu.hide();
            };
            mouseHandler = function (e) {
                (e.target && e.target.parentNode) && (e.state === 'start' ? mouseOver : mouseOut).call(e.target);
            };
            mouseOver = function() {
                var rEle = this,
                    items = menu.menuItems,
                    i = rEle._itemIdx,
                    item = items[i],
                    key;

                resetHideTimer();

                for (key in boxHover) {
                    item.box.style[key] = boxHover[key];
                }
            };
            mouseOut = function() {
                var rEle = this,
                    items = menu.menuItems,
                    i = rEle._itemIdx,
                    item = items[i],
                    key;

                for (key in boxAttrs) {
                    item.box.style[key] = boxAttrs[key];
                }

                setHideTimer();
            };
            itemClick = function(e) {
                    var rEle = this,
                        items = menu.items,
                        i = rEle._itemIdx,
                        item = items[i];

                    if (item.onclick) {
                        item.onclick.call(item, e);
                    }

                    if (e.originalEvent.stopPropagation) {
                        e.originalEvent.stopPropagation();
                    }
                    else {
                        e.originalEvent.cancelBubble = true;
                    }

                    menu.hide();
                };

            menu.showItem = function(index) {

                var m = this,
                    item = m.menuItems[index],
                    menuH = m.height,
                    itemH = m.itemH,
                    posObj;

                if (item && item._isHidden) {

                    item.box.style.display = '';
                    m.height = (menuH + itemH);
                    item._isHidden = false;

                    posObj = calculateTopLeft(position);
                    m.left = posObj.x;
                    m.top = posObj.y;
                }

            };

            menu.hideItem = function(index) {
                var m = this,
                    item = m.menuItems[index],
                    menuH = m.height,
                    itemH = m.itemH,
                    posObj;

                if (item && !item._isHidden) {
                    item.box.style.display = 'none';

                    m.height = (menuH - itemH);
                    item._isHidden = true;

                    posObj = calculateTopLeft(position);
                    m.left = posObj.x;
                    m.top = posObj.y;
                }
            };

            menu.redraw = function() {
                var m = this,
                    paper = m.menuContainer,
                    posObj;

                m.items = items;

                if (!paper) {
                    if (position && position.x !== undefined && position.y !== undefined) {

                        m.menuContainer = getMenuContainer();
                        drawFn.call(m.menuContainer);

                        posObj = calculateTopLeft(position);
                        m.left = posObj.x;
                        m.top = posObj.y;
                        m.menuContainer.style.left = m.left + PXSTRING;
                        m.menuContainer.style.top = m.top + PXSTRING;
                    }
                    else {
                        m.menuContainer = getMenuContainer();
                        drawFn.call(m.menuContainer);
                    }
                }
                else {
                    drawFn.call(m.menuContainer);
                }
            };

            menu.show = function(showOptions) {
                var m = this,
                posObj;

                if (showOptions && showOptions.x !== undefined && showOptions.y !== undefined) {
                    posObj = calculateTopLeft(showOptions);
                    m.menuContainer.style.left = posObj.x + PXSTRING;
                    m.menuContainer.style.top = posObj.y + PXSTRING;
                }
                else {
                    m.menuContainer.style.left = m.left + PXSTRING;
                    m.menuContainer.style.top = m.top + PXSTRING;
                }

                m.menuContainer.style.display = '';

                setTimeout(function() {
                    m.visible = true;
                    R.click(nonItemClick);
                }, 400);
            };

            menu.hide = function() {

                if (this.visible) {
                    this.visible = false;
                }
                else {
                    return;
                }
                //menu.group.hide();
                //paper.setViewBox(0, 0, 0, 0);
                menu.menuContainer.style.display = 'none';
                menu.menuContainer.style.left = (-menu.width) + PXSTRING;
                menu.menuContainer.style.top = (-menu.height) + PXSTRING;

                R.unclick(nonItemClick);
            };

            menu.update = function(items) {
                var m = this;

                if (items && items.length) {
                    m.items = items;
                    m.redraw();
                }
            };

            menu.updatePosition = function(posObj) {
                var m = this,
                    oldChartPos = {
                        left: chartPos.left,
                        top: chartPos.top
                    },
                cPos;

                chartPos = getPosition(chart.container);
                if (posObj) {
                    position = posObj;
                    cPos = calculateTopLeft(posObj);
                    m.left = cPos.x;
                    m.top = cPos.y;
                }
                else {
                    m.left -= (oldChartPos.left - chartPos.left);
                    m.top -= (oldChartPos.top - chartPos.top);
                }
            };

            menu.add = function(item) {
                // create elements
                var m = this,
                    mItems = m.menuItems,
                    i = mItems.length,
                    key,
                    ele;

                smartLabel.setStyle(boxAttrs);

                m.width = mathMax(m.width, smartLabel.getOriSize(item.text).width);

                mItems[i] = {};

                ele = mItems[i].box = doc.createElement('div');

                ele.style.height = m.itemH + PXSTRING;
                ele.style.lineHeight = m.itemH + PXSTRING;

                for (key in itemBoxAttrs) {
                    ele.style[key] = itemBoxAttrs[key];
                }

                for (key in boxAttrs) {
                    ele.style[key] = boxAttrs[key];
                }

                menu.menuRect.appendChild(ele);
                ele.innerHTML = item.text;

                lib.dem.listen(ele, 'click', itemClick);
                lib.dem.listen(ele, 'pointerhover', mouseHandler);

                menu.menuItems[i].box._itemIdx = i;
                m.height += m.itemH;

            };

            menu.removeItems = function() {
                var m = this,
                    items = m.menuItems,
                    i = items && items.length,
                    item;

                while (i--) {
                    item = items[i];
                    lib.dem.unlisten(item.box, 'click', itemClick);
                    lib.dem.unlisten(item.box, 'pointerhover', mouseHandler);
                    item.box && (item.box.parentNode && item.box.parentNode.removeChild(item.box));
                }

                delete m.menuItems;
                delete m.items;

            };

            menu.setPosition = function(position) {
                var m = this;

                if (position.x !== undefined && position.y !== undefined) {
                    m.menuContainer.style.x = position.x;
                    m.menuContainer.style.y = position.y;
                }
            };

            menu.destroy = function() {
                var m = this;

                m.removeItems();
                m.menuContainer.parentNode.removeChild(m.menuContainer);

            };

            if (items && items.length) {
                menu.redraw();
                menu.hide();
            }

            return menu;
        },
        selectionEventHandler = function(evt) {

            var config = evt.data,
                chart = config.chart,
                paper = chart.paper,
                state = evt.state,
                event = getEventCoordinate(getTouchEvent(evt.originalEvent)),
                tgt = event.target || event.originalTarget || event.srcElement ||
                    event.relatedTarget || event.fromElement,
                resizeBox = chart.elements.resizeBox,
                layerX = config.layerX = event.pageX - config.chartPosLeft,
                layerY = config.layerY = event.pageY - config.chartPosTop,
                dx = layerX - config.ox,
                dy = layerY - config.oy,
                bBox = config.bBox,
                x = config.ox,
                y = config.oy,
                zoomX = config.zoomX,
                zoomY = config.zoomY,
                canvasY = config.canvasY,
                canvasX = config.canvasX,
                canvasW = config.canvasW,
                canvasH = config.canvasH,
                canvasX2 = config.canvasX2,
                canvasY2 = config.canvasY2,
                strokeWidth = config.strokeWidth,
                attr = config.attr,
                container = this,
                chartPosition,
                selectionData;

            switch (state) {
                case 'start' : // DragStart
                    // Recalculate the container position and store it in the conf.
                    chartPosition = getPosition(container);
                    config.chartPosLeft = chartPosition.left;
                    config.chartPosTop = chartPosition.top;
                    layerX = event.pageX - config.chartPosLeft;
                    layerY = event.pageY - config.chartPosTop;
                    config.oy = layerY;
                    config.ox = layerX;
                    config.allowMove = false;
                    // Create the resizable box
                    if (!resizeBox) {
                        resizeBox = chart.elements.resizeBox =
                            paper.rect(chart.layers.tracker)
                            .attr(attr);
                    }

                    if (layerX > canvasX && layerX < canvasX2 &&
                            layerY > canvasY && layerY < canvasY2) {
                        config.allowMove = true;
                    }
                    // do not receive event if the clicked target element is marked as
                    // hot
                    if (tgt && tgt.ishot) {
                        config.allowMove = false;
                    }

                    resizeBox.attr({
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }).show();
                    break;

                case 'end' :  // DragEnd
                    bBox = resizeBox.getBBox();
                    selectionData = {
                        chart: chart,
                        selectionLeft: bBox.x,
                        selectionTop: bBox.y,
                        selectionHeight: bBox.height,
                        selectionWidth: bBox.width,
                        originalEvent: evt.originalEvent
                    };
                    if (config.isDragged) {
                        config.selectionEnd && config.selectionEnd(selectionData);
                        config.isDragged = 0;
                    }
                    resizeBox.hide();

                    delete config.oy;
                    delete config.ox;
                    break;

                default: // DragMove
                    if (!config.allowMove) {
                        return;
                    }
                    dx = layerX - config.ox;
                    dy = layerY - config.oy;
                    bBox = config.bBox;
                    x = config.ox;
                    y = config.oy;

                    if (!config.isDragged) {
                        selectionData = {
                            chart: chart,
                            selectionLeft: (zoomX ? mathMin(x, x + dx) : canvasX) + strokeWidth * 0.5,
                            selectionTop: (zoomY ? mathMin(y, y + dy) : canvasY) + strokeWidth * 0.5,
                            selectionHeight: 0,
                            selectionWidth: 0,
                            originalEvent: evt.originalEvent
                        };
                        config.selectionStart && config.selectionStart(selectionData);
                        config.isDragged = 1;
                    }

                    dx = -(x - mathMin(x - (x - mathMax(x + dx, canvasX)), canvasX2));
                    dy = -(y - mathMin(y - (y - mathMax(y + dy, canvasY)), canvasY2));
                    resizeBox.attr({
                        x: (zoomX ? mathMin(x, x + dx) : canvasX) + strokeWidth * 0.5,
                        y: (zoomY ? mathMin(y, y + dy) : canvasY) + strokeWidth * 0.5,
                        width: zoomX ? mathAbs(dx) : canvasW,
                        height: zoomY ? mathAbs(dy) : canvasH
                    });

                    break;
            }
        },
        onXYCanvasClick = function(event) {

            var config = event.data,
                e = event.originalEvent,
                tgt = (e.target || e.originalTarget || e.srcElement ||
                    e.relatedTarget || e.fromElement),
                eventType = e.type,
                layerX = e.layerX,
                layerY = e.layerY;

            if (layerX === undefined) {
                layerX = e.pageX - config.chartPosLeft;
                layerY = e.pageY - config.chartPosTop;
            }


            if (eventType === 'mousedown') {
                tgt.ishot = (layerX > config.canvasX &&
                    layerX < config.canvasX2 && layerY > config.canvasY &&
                    layerY < config.canvasY2);
            }
            if (eventType === 'mouseup') {
                setTimeout(function() {
                    tgt.ishot = false;
                }, 1);
            }
        },
        bindSelectionEvent = function(chart, config) {
            config = config || {};
            var chartOptions = chart.options.chart,
                container = chart.container,
                zoomType = chartOptions.zoomType,
                attr = extend2({}, (config.attr || {})),
                strokeWidth = attr['stroke-width'] = pluckNumber(attr.strokeWidth,
                attr['stroke-width'], 1),
                chartPosition = getPosition(container),
                eventListeners = chart.eventListeners || (chart.eventListeners = []);

            config = extend2({
                chart: chart,
                zoomX: /x/.test(zoomType),
                zoomY: /y/.test(zoomType),
                canvasY: chart.canvasTop,
                canvasX: chart.canvasLeft,
                canvasW: chart.canvasWidth,
                canvasH: chart.canvasHeight,
                canvasX2: chart.canvasLeft + chart.canvasWidth,
                canvasY2: chart.canvasTop + chart.canvasHeight,
                strokeWidth: strokeWidth,
                chartPosLeft: chartPosition.left,
                chartPosTop: chartPosition.top,
                attr: attr
            }, config);

            attr.stroke = getFirstValue(attr.stroke, 'rgba(51,153,255,0.8)');
            attr.fill = getFirstValue(attr.fill, 'rgba(185,213,241,0.3)');
            attr.ishot = true;

            if (container) {
                removeEvent(container, 'pointerdrag', selectionEventHandler);
                eventListeners.push(addEvent(container, 'pointerdrag', selectionEventHandler, config));
            }

            if (chartOptions.link) {
                removeEvent(chart.container, 'mouseup mousedown', onXYCanvasClick);
                eventListeners.push(addEvent(chart.container, 'mouseup mousedown', onXYCanvasClick, config));
            }
        },
        getViewPortDimension = (function() {
            var pw = 'innerWidth',
                ph = 'innerHeight',
                docEl = doc.documentElement || doc.body,
                vpEl = docEl;

            if (!('innerWidth' in win)) {
                pw = 'clientWidth';
                ph = 'clientHeight';
            }
            else {
                vpEl = win;
            }

            return function() {
                return {
                    width: vpEl[pw],
                    height: vpEl[ph],
                    scrollTop: docEl.scrollTop,
                    scrollLeft: docEl.scrollLeft
                };
            };
        }()),
        getPosition = function(el, noscroll) {
            var p = {
                left: (el.offsetLeft || 0),
                top: (el.offsetTop || 0)
            };
            el = el.offsetParent;
            while (el) {
                p.left += (el.offsetLeft || 0);
                p.top += (el.offsetTop || 0);
                if (el !== doc.body && el !== doc.documentElement && !noscroll) {
                    p.left -= el.scrollLeft;
                    p.top -= el.scrollTop;
                }
                el = el.offsetParent;
            }
            return p;
        },
        regescape = function(text) {
            return text && text.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
        },
        regReplaceEscape = function(text) {
            return text && text.replace(/\$/g, '$$$$');
        },
        /**
         * Checks if a value sent as argument is 'valid' as per valid input
         * standards.
         * @param {object} arg
         * @param {object} value is the default value returned.
         */
        getValidValue = function(arg, value) {
            return !arg && arg !== false && arg !== 0 ? value : arg;
        },
        /**
         *  Return the defColor if color is undefined
         *  other wise always returns the color even if color is a blank string
         */
        getDefinedColor = function(color, defColor) {
            return (!color && color !== 0 && color !== BLANK) ? defColor : color;
        },
        /**
         * Returns the first argument that is a 'valid' value or a blank string.
         */
        getFirstValue = function() {
            var arg,
                i,
                l;
            for (i = 0, l = arguments.length; i < l; i += 1) {
                arg = arguments[i];
                if (!arg && arg !== false && arg !== 0) {
                    continue;
                }
                return arg;
            }
            return BLANK;
        },
        /**
         * Returns the first argument that is a 'valid' value or undefined.
         */
        pluck = function() {
            var arg, i, l;
            for (i = 0, l = arguments.length; i < l; i += 1) {
                arg = arguments[i];
                if (!arg && arg !== false && arg !== 0) {
                    continue;
                }
                return arg;
            }
            return undefined;
        },
        addEvent = function(el, event, fn, data) {
            /** @todo improve accessibility */
            return lib.dem.listen(el, event, fn, data);
        },
        /**
         * Remove event added with addEvent
         * @param {object} el The object
         * @param {string} eventType The event type. Leave blank to remove all events.
         * @param {function} handler The function to remove
         */
        removeEvent = function(el, eventType, handler) {
            /** @todo improve accessibility */
            return lib.dem.unlisten(el, eventType, handler);
        },
        /**
         * Fire an event on a custom object
         * @param {object} el
         * @param {string} type
         * @param {object} eventArguments
         * @param {function} defaultFunction
         */
        fireEvent = function(el, type, eventArguments, defaultFunction) {
            lib.dem.fire(el, type, eventArguments, defaultFunction);
        },
        getTouchEvent = function(event) {
            var e = event.sourceEvent || event.originalEvent || event;
            return (hasTouch && e && e.touches && e.touches[0]) || e || stubEvent;
        },
        /**
         * This function ensures that the event object always has pageX and pageY irrespective of the
         * browser. Older IE browsers do not support pageXY.
         *
         * @param {MouseEvent} event
         * @returns {MouseEvent} This function updates the events `pageX` and `pageY` properties when
         * they're missing and also returns the same event for the sexy programming styles.
         */
        getEventCoordinate = (function() {
            var body;

            return function(event) {
                // If `pageX` is undefined, it is certain that we need to fallback to `clientX`.
                // There is no point separately checking for `pageY`.
                if (event.pageX === UNDEFINED) {
                    // We store reference to body while accessing so that future references are fast.
                    event.pageX = event.clientX + (body || (body = win.document.body ||
                            win.document.documentElement)).scrollLeft;
                    event.pageY = event.clientY + body.scrollTop;
                }

                return event;
            };
        }()),
        /**
         * Returns x,y coordinate WRT chart and page of mouse or touch
         * @param {object} chart container ele
         * @param {object} event data
         */
        getMouseCoordinate = function(el, event) {
            event = getEventCoordinate(getTouchEvent(event));
            var pageX = event.pageX,
                pageY = event.pageY,
                pos = getPosition(el);

            return {
                chartX: pageX - pos.left,
                chartY: pageY - pos.top,
                pageX: pageX,
                pageY: pageY
            };
        },
        /**
         * Handle data plot click event
         * @param {object} chart
         * @param {object} event data
         * @param Sting event name
         */
        plotEventHandler = function(chart, event, eventName) {
            event = event || {};
            var eventType = event.type,
                coordinate = getMouseCoordinate(chart.container, event),
                args = extend2(coordinate, this.data('eventArgs')),
                fireGroupEvent = chart.logic.fireGroupEvent,
                id = this.data('groupId'),
                cancelHover = function(c, a) {
                    event.FusionChartsPreventEvent = true;
                    // Hack for IE as the global event object gets overwritten
                    // causing the FusionChartsPreventEvent to be undefined.
                    if (isIE && a.toolText && lib.toolTip) {
                        lib.toolTip.preventTooltip();
                    }
                };

            if ('index' in args && !('dataIndex' in args)) {
                args.dataIndex = args.index;
            }
            if ('value' in args && !('dataValue' in args)) {
                args.dataValue = args.value;
            }
            eventName = pluck(eventName, 'dataplotclick').toLowerCase();
            // preventDefault in DataPlotRollOver
            if (eventName === 'dataplotrollover') {
                event.FusionChartsPreventEvent = false;
                if (fireGroupEvent) {
                    /**
                     * @event FusionCharts#dataplotRollOver
                     *
                     * @param {number} chartX - x-coordinate of the pointer relative to the chart.
                     * @param {number} chartY - y-coordinate of the pointer relative to the chart.
                     * @param {number} pageX - x-coordinate of the pointer relative to the page.
                     * @param {number} pageY - y-coordinate of the pointer relative to the page.
                     * @param {number} datasetIndex - The position of the dataset in order of its definition in source
                     * data.
                     * @param {string} datasetName - The `seriesName` of the dataset.
                     * @param {number} dataIndex - The position of the data-plot in order of its definition in source
                     * dataset.
                     * @param {number} dataValue - The value of the data-plot that trigerred this event
                     * @param {string} dsplayValue - The `displayValue` attribute that has been set for the data-plot.
                     * @param {string} categoryLabel - The x-axis label that corresponds to the data-plot
                     * @param {string} toolText - The tooltext that is displayed when hovered over the data-plot
                     */
                    global.raiseEventGroup(id, eventName, args, chart.fusionCharts,
                        undefined, undefined, cancelHover);
                } else {
                    global.raiseEvent(eventName, args, chart.logic.chartInstance,
                        undefined, undefined, cancelHover);
                }
            } else {
                if (fireGroupEvent && eventName !== 'dataplotclick') {

                    /**
                     * @event FusionCharts#dataplotRollOut
                     *
                     * @param {number} chartX - x-coordinate of the pointer relative to the chart.
                     * @param {number} chartY - y-coordinate of the pointer relative to the chart.
                     * @param {number} pageX - x-coordinate of the pointer relative to the page.
                     * @param {number} pageY - y-coordinate of the pointer relative to the page.
                     * @param {number} datasetIndex - The position of the dataset in order of its definition in source
                     * data.
                     * @param {string} datasetName - The `seriesName` of the dataset.
                     * @param {number} dataIndex - The position of the data-plot in order of its definition in source
                     * dataset.
                     * @param {number} dataValue - The value of the data-plot that trigerred this event
                     * @param {string} dsplayValue - The `displayValue` attribute that has been set for the data-plot.
                     * @param {string} categoryLabel - The x-axis label that corresponds to the data-plot
                     * @param {string} toolText - The tooltext that is displayed when hovered over the data-plot
                     */
                    global.raiseEventGroup(id, eventName, args, chart.fusionCharts);
                } else {

                    /**
                     * @event FusionCharts#dataplotClick
                     *
                     * @param {number} chartX - x-coordinate of the pointer relative to the chart.
                     * @param {number} chartY - y-coordinate of the pointer relative to the chart.
                     * @param {number} pageX - x-coordinate of the pointer relative to the page.
                     * @param {number} pageY - y-coordinate of the pointer relative to the page.
                     * @param {number} datasetIndex - The position of the dataset in order of its definition in source
                     * data.
                     * @param {string} datasetName - The `seriesName` of the dataset.
                     * @param {number} dataIndex - The position of the data-plot in order of its definition in source
                     * dataset.
                     * @param {number} dataValue - The value of the data-plot that trigerred this event
                     * @param {string} dsplayValue - The `displayValue` attribute that has been set for the data-plot.
                     * @param {string} categoryLabel - The x-axis label that corresponds to the data-plot
                     * @param {string} toolText - The tooltext that is displayed when hovered over the data-plot
                     */
                    global.raiseEvent(eventName, args, chart.logic.chartInstance);
                }
            }

            if (eventType === 'click' || eventType === 'mouseup' || eventType === 'touchend' &&
                eventName === 'dataplotclick') {
                chart.linkClickFN.call({
                    link: args.link
                }, chart);
            }
        },
        /**
         * This function is used to create html DOM
         *
         * @param {string} tagName the name of the HTML tag
         * @param {object} attributes Object contain all attribute name and value
         * @param {DOMobject} parentElement parent node of the newly created element
         */
        createElement = function(tagName, attributes, parentElement) {
            var elem = doc.createElement(tagName),
                x;
            //apply all attribute
            for (x in attributes) {
                elem.setAttribute(x, attributes[x]);
            }
            //append in parent element
            parentElement && parentElement.appendChild && parentElement.appendChild(elem);
            return elem;
        },
        hashify = function(color) {
            return color && color.replace(/^#?([a-f0-9]+)/ig, '#$1') || 'none';
        },
        /**
         * Returns the first argument that is a 'valid' value even blankstring.
         */
        getFirstDefinedValue = function() {
            var arg, i, l;
            for (i = 0, l = arguments.length; i < l; i += 1) {
                arg = arguments[i];
                if (!arg && arg !== false && arg !== 0 && arg != BLANK) {
                    continue;
                }
                return arg;
            }
            return undefined;
        },
        /**
         * Returns the first number in the argument array.
         *
         * @note
         * The expression here is same as getValidValue with isNaN check
         * added to it.
         */
        pluckNumber = function() {
            var arg,
                i,
                l;

            for (i = 0, l = arguments.length; i < l; i += 1) {
                arg = arguments[i];
                if (!arg && arg !== false && arg !== 0) {
                    continue;
                }
                else if (isNaN(arg = Number(arg))) {
                    continue;
                }
                return arg;
            }
            return undefined;
        },
        pluckFontSize = function() {
            var arg,
                i,
                l;

            for (i = 0, l = arguments.length; i < l; i += 1) {
                arg = arguments[i];
                if (!arg && arg !== false && arg !== 0) {
                    continue;
                }
                else if (isNaN(arg = Number(arg))) {
                    continue;
                }
                return arg < 1 ? 1 : arg;
            }
            return 1;
        },
        parsePointValue = function(value, abs) {
            /** @todo optimize further. */
            value = !value && value !== false && value !== 0 ?
                NaN : Number(value);
            return isNaN(value) ? null : (abs ? mathAbs(value) : value);
        },
        parseUnsafeString = function(str) {
            /** @todo use to string method if its not a string */
            if (typeof str === STRINGSTRING) {
                return str.replace(breakPlaceholder, BREAKSTRING);
            }
            else {
                return BLANK;
            }
        },
        getFirstColor = function(color) {
            color = color.split(COMMA)[0];
            color = color.replace(stripWhitespace, BLANK);
            if (color == BLANK) {
                color = COLOR_BLACK;
            }
            return color.replace(dropHash, HASHSTRING);
        },
        getColorCodeString = function(color, fillString) {
            var returnString = '', colorEntry, len, i = 0, fillArray = fillString.split(COMMA);
            for (len = fillArray.length; i < len; i += 1) {
                colorEntry = fillArray[i].split('-');
                if (colorEntry.length === 2) {
                    if (colorEntry[0].indexOf('dark') !== '-1') {
                        returnString += (getLightColor(color, 100 - parseInt(colorEntry[1], 10)) + COMMA);
                    } else {
                        returnString += (getDarkColor(color, 100 - parseInt(colorEntry[1], 10)) + COMMA);
                    }
                } else {
                    returnString += (fillArray[i] + COMMA);
                }
            }
            return returnString.substring(0, returnString.length - 1);
        },
        pluckColor = function(color) {
            if (!getValidValue(color)) {
                return undefined;
            }
            color = color.split(COMMA)[0];
            color = color.replace(stripWhitespace, BLANK);
            if (color == BLANK) {
                color = COLOR_BLACK;
            }
            return color.replace(dropHash, HASHSTRING);
        },
        getFirstAlpha = function(alpha) {
            alpha = parseInt(alpha, 10);
            if (isNaN(alpha) || alpha > 100 || alpha < 0) {
                alpha = 100;
            }
            return alpha;
        },
        arrayToStr = '[object Array]',
        objectToStr = '[object Object]',
        getSentenceCase = function(name) {
            name = name || BLANK;
            return (name.charAt(0).toUpperCase() + name.substr(1));
        },
        getCrispValue = function(position, distance, borderthickness) {
            var normalizer = borderthickness % 2 / 2,
                newposition = mathRound(position + normalizer) - normalizer,
                newdistance = mathRound(position + distance + normalizer) - normalizer - newposition;
            return {position: newposition, distance: newdistance};
        },
        trimString = function(str) {
            str = str.replace(/^\s\s*/, '');
            var ws = /\s/, i = str.length;

            while (ws.test(str.charAt(i -= 1))) { /* jshint noempty:false */ }
            return str.slice(0, i + 1);
        },
        checkCyclicRef = function(obj, parentArr) {
            var i = parentArr.length,
                bIndex = -1;

            while (i--) {
                if (obj === parentArr[i]) {
                    bIndex = i;
                    return bIndex;
                }
            }

            return bIndex;
        },
        /**
         * Check whether an object is Array or not
         * @type Boolean
         * @param {object} subject is the variable that is
         * tested for Array identity check
         */
        isArray = (function() {
            // Use compiler's own isArray when available
            if (Array.isArray) {
                return Array.isArray;
            }

            // Retain references to variables for performance
            // optimization
            var objectToStringFn = Object.prototype.toString,
                arrayToStringResult = objectToStringFn.call([]);

            return function(subject) {
                return objectToStringFn.call(subject) === arrayToStringResult;
            };
        }()),
        merge = function(obj1, obj2, skipUndef, tgtArr, srcArr) {
            var item,
                srcVal,
                tgtVal,
                str,
                cRef;
            //check whether obj2 is an array
            //if array then iterate through it's index
            //**** MOOTOOLS precution

            if (!srcArr) {
                tgtArr = [obj1];
                srcArr = [obj2];
            }
            else {
                tgtArr.push(obj1);
                srcArr.push(obj2);
            }

            if (obj2 instanceof Array) {
                for (item = 0; item < obj2.length; item += 1) {
                    try {
                        srcVal = obj1[item];
                        tgtVal = obj2[item];
                    }
                    catch (e) {
                        continue;
                    }

                    if (typeof tgtVal !== OBJECTSTRING) {
                        if (!(skipUndef && tgtVal === undefined)) {
                            obj1[item] = tgtVal;
                        }
                    }
                    else {
                        if (srcVal === null || typeof srcVal !== OBJECTSTRING) {
                            srcVal = obj1[item] = tgtVal instanceof Array ? [] : {};
                        }
                        cRef = checkCyclicRef(tgtVal, srcArr);
                        if (cRef !== -1) {
                            srcVal = obj1[item] = tgtArr[cRef];
                        }
                        else {
                            merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
                        }
                    }
                }
            }
            else {
                for (item in obj2) {
                    try {
                        srcVal = obj1[item];
                        tgtVal = obj2[item];
                    }
                    catch (e) {
                        continue;
                    }

                    if (tgtVal !== null && typeof tgtVal === OBJECTSTRING) {
                        // Fix for issue BUG: FWXT-602
                        // IE < 9 Object.prototype.toString.call(null) gives
                        // '[object Object]' instead of '[object Null]'
                        // that's why null value becomes Object in IE < 9
                        str = objectToStrFn.call(tgtVal);
                        if (str === objectToStr) {
                            if (srcVal === null || typeof srcVal !== OBJECTSTRING) {
                                srcVal = obj1[item] = {};
                            }
                            cRef = checkCyclicRef(tgtVal, srcArr);
                            if (cRef !== -1) {
                                srcVal = obj1[item] = tgtArr[cRef];
                            }
                            else {
                                merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
                            }
                        }
                        else if (str === arrayToStr) {
                            if (srcVal === null || !(srcVal instanceof Array)) {
                                srcVal = obj1[item] = [];
                            }
                            cRef = checkCyclicRef(tgtVal, srcArr);
                            if (cRef !== -1) {
                                srcVal = obj1[item] = tgtArr[cRef];
                            }
                            else {
                                merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
                            }
                        }
                        else {
                            obj1[item] = tgtVal;
                        }
                    }
                    else {
                        obj1[item] = tgtVal;
                    }
                }
            }
            return obj1;
        },
        extend2 = function(obj1, obj2, skipUndef) {
            //if none of the arguments are object then return back
            if (typeof obj1 !== OBJECTSTRING && typeof obj2 !== OBJECTSTRING) {
                return null;
            }

            if (typeof obj2 !== OBJECTSTRING || obj2 === null) {
                return obj1;
            }

            if (typeof obj1 !== OBJECTSTRING) {
                obj1 = obj2 instanceof Array ? [] : {};
            }
            merge(obj1, obj2, skipUndef);
            return obj1;

        },
        //helper for deltend
        clean = function(obj1, obj2) {
            var item;
            //check whether obj2 is an array
            //if array then iterate through it's index
            //**** MOOTOOLS precution
            if (obj2 instanceof Array) {
                for (item = obj2.length - 1; item >= 0; item -= 1) {
                    if (typeof obj2[item] !== OBJECTSTRING) {
                        if (obj2[item] === true && obj1 && obj1.splice) {
                            obj1.splice(item, 1);
                        }
                    }
                    else {
                        if (objectToStrFn.call(obj2[item]) === objectToStrFn.call(obj1[item])) {
                            clean(obj1[item], obj2[item]);
                        }
                    }
                }
            }
            else {
                for (item in obj2) {
                    if (typeof obj2[item] !== OBJECTSTRING) {
                        if (obj2[item] === true && obj1 && obj1.splice) {
                            obj1.splice(item, 1);
                        }
                    }
                    else {
                        if (objectToStrFn.call(obj2[item]) === objectToStrFn.call(obj1[item])) {
                            clean(obj1[item], obj2[item]);
                        }
                    }
                }
            }
            return obj1;
        },
        //special function to perform deleted extend
        deltend = function(obj1, obj2) {
            //if any of the arguments is not object then return back
            if (typeof obj1 !== OBJECTSTRING || typeof obj2 !== OBJECTSTRING) {
                return null;
            }
            clean(obj1, obj2);
            return obj1;
        },
        imprint = function(obj1, obj2, ignoreNull) {
            var item;

            if (typeof obj1 !== OBJECTSTRING || obj1 === null) {
                obj1 = obj2;
                return obj2;
            }

            if (typeof obj2 !== OBJECTSTRING || obj2 === null) {
                return obj1;
            }

            for (item in obj2) {
                if (obj1[item] === undefined || (!ignoreNull && obj1[item] === null)) {
                    obj1[item] = obj2[item];
                }
            }

            return obj1;
        },
        getLinkedChartDataJSON = function(linkedDataId, FCDataObj) {
            var linkedDataJSON = {
                'chart': {}
            },
            index,
                FcJSON = FCDataObj;

            linkedDataId = linkedDataId.toLowerCase();
            if (FcJSON.linkeddata) {
                for (index = 0; index < FcJSON.linkeddata.length; index += 1) {
                    if (FcJSON.linkeddata[index].id.toLowerCase() === linkedDataId) {
                        linkedDataJSON = FcJSON.linkeddata[index].linkedchart ||
                            FcJSON.linkeddata[index].linkedmap;
                    }
                }
            }
            return linkedDataJSON;
        },
        /**
         * This function call multylevel js function given as STR
         */
        limitedEvalParser = (function() {

            var DOT = '.',
                windowPropIdentifier = /^@window_/g,
                FUNCTION = 'function';

            return function(expr, args) {
                var
                    pattern = expr.replace(/\[[\'\"]/g, DOT)
                    .replace(/[\'\"]\]/g, BLANK) // remove all quotations.
                    // replace all opening '[' with identifier that it is a
                    // variable in global scope.
                    .replace(/\[/g, '.@window_')
                    .replace(/\]/g, BLANK), // romove all closing ']'
                    tokens = pattern.split(DOT),
                    obj = win,
                    boxObj,
                    windowProp,
                    tokenEx = BLANK,
                    token,
                    l,
                    i;

                l = tokens.length;
                for (i = 0; i < l; i += 1) {
                    token = tokens[i];
                    boxObj = obj;
                    if (token.match(windowPropIdentifier)) {
                        windowProp = win[token.replace(windowPropIdentifier, BLANK)];
                        obj = obj[windowProp];
                    }
                    else if (obj === undefined || obj === null) {
                        throw (tokenEx || token).replace(windowPropIdentifier,
                            BLANK) + ' is not defined';
                    }
                    else {
                        obj = obj[token];
                    }
                    tokenEx = token;
                }

                if (obj && (typeof obj.call === FUNCTION || obj === win.alert)) {
                    if (obj === win.alert) { // for IE6 bug
                        obj(args);
                    }
                    else {
                        obj.call(boxObj, args);
                    }
                }
                else {
                    setTimeout(function() {
                        throw token.replace(windowPropIdentifier, BLANK) +
                            '() is not a function';
                    }, 0);
                }
            };
        })(),
        secureEval = (function() {
            var evalKey = 'FusionChartslinkEval' + parseInt(+new Date(), 10);
            return function(expr) {
                // put under trial so that effective error in data does
                // not stall chart.
                try {
                    /* jshint evil:true */
                    // Creating anonymous function and removing it
                    // from current scope and sending to global.
                    win[evalKey] = new Function(expr);
                    // Executing the banished function by
                    // impersonating global scope.
                    eval('window["' + evalKey + '"]();');
                }
                catch (err) {
                    // raise error asynchronously
                    setTimeout(function() {
                        // strip line number trace from error before
                        // throwing
                        throw err;
                    }, 0);
                }
                // remove delegate function
                if (hasSVG) {
                    delete win[evalKey];
                }
                else {
                    win[evalKey] = null;
                }
            };
        }()),
        getLinkAction = function(dataObj, chartInstance) {
            var secureLink = function(link) {
                return link;
            };

            return function() {
                var chartAttrs = dataObj.chart || dataObj.map || {},
                    unescapeLinks = pluckNumber(chartAttrs.unescapelinks, 1),
                    pointLink = getFirstValue(this.link, BLANK),
                    pointChartLink = (this.series && this.series.chart &&
                        this.series.chart.options &&
                        this.series.chart.options.chart &&
                        this.series.chart.options.chart.link) || BLANK,
                    chartLink = (this.options && this.options.chart &&
                        this.options.chart.link) || BLANK,
                    strLink = pluck(pointLink, chartLink, pointChartLink),
                    originalLink = strLink,
                    dashPos,
                    frameDetails,
                    commaPos,
                    linkURL,
                    delimiter,
                    linkType,
                    linkedDataId,
                    linkedData,
                    alias,
                    firstBreak;
                //We continue only if the link is not empty
                if (strLink !== undefined) {
                    // first we decode the link
                    // And we trim the link
                    if (unescapeLinks) {
                        strLink = win.decodeURIComponent ?
                            win.decodeURIComponent(strLink) : win.unescape(strLink);
                    }

                    strLink = strLink.replace(/^\s+/,
                        BLANK).replace(/\s+$/, BLANK);

                    if (strLink.search(/^[a-z]*\s*[\-\:]\s*/i) !== -1) {
                        delimiter = strLink.split(/\s*[\-\:]\s*/)[0].toLowerCase();
                        firstBreak = delimiter.length;
                    }

                    // Now based on what the first character in the link is (N, F, P, S, J)
                    // And (NEWCHART, JAVASCRIPT:)
                    // we invoke the link.
                    setTimeout(function() {

                        switch (delimiter) {
                            case 'j':
                                // We remove blank spaces between 'j' and '-' if any
                                strLink = strLink.replace(/^j\s*\-/i, 'j-');

                                dashPos = strLink.indexOf('-', 2);
                                //If no arguments, just call the link
                                if (dashPos === -1) {
                                    limitedEvalParser(strLink.slice(2));
                                }
                                // There could be multiple parameters.
                                // We just pass them as a single string to JS method.
                                else {
                                    limitedEvalParser(strLink.substr(2, dashPos - 2).replace(/\s/g, BLANK),
                                        strLink.slice(dashPos + 1));
                                }

                                break;

                            case 'javascript':
                                // remove 'javascript:' prefix and evaluate expression.
                                secureEval(strLink.replace(/^javascript\s*\:/i, BLANK));
                                break;

                            case 'n':
                                strLink.replace(/^n\s*\-/i, 'n-');
                                win.open(secureLink(strLink.slice(2), unescapeLinks));
                                break;

                            case 'f':
                                strLink = strLink.replace(/^f\s*\-/i, 'f-');

                                //strLink.slice(dashPos+1) indicates arguments if any
                                //strLink.substr(2, dashPos-2) indicates link
                                dashPos = strLink.indexOf('-', 2);
                                //If no arguments, just call the link
                                if (dashPos !== -1) {
                                    frameDetails = strLink.substr(2, dashPos - 2);
                                    if (frameDetails && win.frames[frameDetails]) {
                                        win.frames[frameDetails].location =
                                            secureLink(strLink.slice(dashPos + 1),
                                                unescapeLinks);
                                    } else {
                                        win.open(secureLink(strLink.slice(dashPos + 1),
                                            unescapeLinks), frameDetails);
                                    }
                                }
                                else {
                                    win.open(secureLink(strLink.slice(2), unescapeLinks));
                                }
                                break;

                            case 'p':
                                strLink = strLink.replace(/p\s*\-/i, 'p-');
                                dashPos = strLink.indexOf('-', 2);
                                commaPos = strLink.indexOf(COMMA, 2);
                                if (dashPos === -1) {
                                    dashPos = 1;
                                }

                                linkURL = secureLink(strLink.slice(dashPos + 1),
                                    unescapeLinks);
                                win.open(linkURL,
                                    strLink.substr(2, commaPos - 2),
                                    strLink.substr(commaPos + 1, dashPos - commaPos - 1))
                                    .focus();
                                break;

                            case 'newchart':
                            case 'newmap':
                                //Linked chart. if alias found
                                if (strLink.charAt(firstBreak) === ':') {
                                    //find next '-'
                                    dashPos = strLink.indexOf('-', firstBreak + 1);
                                    alias = strLink.substring(firstBreak + 1, dashPos);
                                    firstBreak = dashPos;
                                }

                                // Find the second dash position
                                dashPos = strLink.indexOf('-', firstBreak + 1);

                                // Figure out whether the sub-linked chart is xml or url
                                linkType = strLink.substring(firstBreak + 1,
                                    dashPos).toLowerCase();

                                switch (linkType) {
                                    case 'xmlurl':
                                    case 'jsonurl':
                                        linkedData = strLink.substring(dashPos + 1,
                                            strLink.length);
                                        break;
                                    case 'xml':
                                    case 'json':
                                        // Extract linked data identifier
                                        linkedDataId = strLink.substring(dashPos + 1,
                                            strLink.length);
                                        // Get the data for the linked chart
                                        linkedData = getLinkedChartDataJSON(linkedDataId,
                                            dataObj);
                                        // If linkedData is empty string, it means
                                        // data identifier or linked data was not found.
                                        linkType = 'json';
                                        break;
                                }
                                /**
                                 * Clicking the data plot of a parent chart opens the linked items associated with it.
                                 * `LinkedChartInvoked` event is triggered after the
                                 * {@link FusionCharts#event:linkedItemOpened}event.
                                 *
                                 * A parent chart may have more than one linked chart associated with it.
                                 * The child linked charts may have linked charts of their own. Clicking on the data
                                 * plot items of any of these child linked charts which have other linked charts
                                 * associated with them fires the `linkedChartInvoked` event.
                                 *
                                 * @event FusionCharts#linkedChartInvoked
                                 * @group linked-charts
                                 * @private
                                 *
                                 * @param {string} alias It is the type of the chart invoked.For example, a data plot
                                 * item in a column2d chart might invoke another column2d chart or a pie chart.
                                 * @param {string} linkType Indicates whether the linked data is in JSON or XML format.
                                 * @param {object} data  Contains the data related to the linkedchart to be opened.
                                 */
                                global.raiseEvent('linkedChartInvoked', {
                                    alias: alias,
                                    linkType: linkType.toUpperCase(),
                                    data: linkedData
                                }, chartInstance);
                                break;

                            default:
                                win.location.href = secureLink(strLink, unescapeLinks);
                                break;
                        }
                        /**
                         * FusionCharts  allows you to configure the data plot items to respond to user's click
                         * interaction by specifying the `link` attribute on the data item. You can configure it to
                         * perform various actions on click such as:
                         *
                         * - open an url
                         * - call a JavaScript function
                         * - drill-down to a new chart.
                         *
                         * Other than data-plots, links can be applied to the entire chart using the  attribute
                         * `clickUrl`, on chart external-logo and a number of other  objects.
                         *
                         * @event FusionCharts#linkClicked
                         * @group chart
                         *
                         * @param {string} linkProvided - This will contain the link which contains the newchart-xml-id
                         * of the XML of the linked chart item
                         * @param {string} linkInvoked - This will contain the link which contains the newchart-xml-id
                         * of the XML of the linked chart item
                         * @param {object} linkAction - Indicates what the link click will do. In case of opening a new
                         * chart it is 'newchart'.
                         */
                        global.raiseEvent('linkClicked', {
                            linkProvided: originalLink,
                            linkInvoked: strLink,
                            linkAction: delimiter && delimiter.toLowerCase()
                        }, chartInstance);
                    }, 0);
                }
            };
        },
        // GRAPHICS FUNCTION
        getAlpha = function(alpha, multiplyer) {
            alpha = Number(alpha);
            alpha = isNaN(alpha) ? 100 : alpha;
            if (multiplyer !== undefined) {
                alpha = alpha * multiplyer / 100;
            }
            return alpha % 101;
        },
        parseAlpha = function(alpha, length, multiplyer) {
            var alphaArr = alpha.split(COMMA), x;
            if (multiplyer !== undefined) {
                multiplyer = pluckNumber(multiplyer.split(COMMA)[0]);
            }
            alphaArr[0] = getAlpha(alphaArr[0], multiplyer);
            for (x = 1; x < length; x += 1) {
                alphaArr[x] = alphaArr[0] * getAlpha(alphaArr[x], multiplyer) / 100;
            }
            return alphaArr.join(COMMA);
        },
        //reduce gradient color take only first color
        //converts color to compatable color format
        //**** rgba must be rgbs(r,g,b,a) format
        /** @todo have to optimize
         Deprecated and may need reduction of logic. */
        convertColor = function(color, alpha, rgba) {
            var R = 0, G = 0, B = 0, colorStr, tempArr;

            if (rgba && rgba.match(startsRGBA)) {
                tempArr = rgba.split(COMMA);
                R = tempArr[0].slice(tempArr[0].indexOf('(') + 1);
                G = tempArr[1];
                B = tempArr[2];
                if (!alpha && alpha !== 0) {
                    alpha = parseInt((tempArr[3].slice(0, tempArr[3].indexOf(')')) * 100), 10);
                }
            }
            if (color) {
                if (color.match(startsRGBA)) {
                    tempArr = color.split(COMMA);
                    R = tempArr[0].slice(tempArr[0].indexOf('(') + 1);
                    G = tempArr[1];
                    B = tempArr[2];
                }
                else {
                    colorStr = color.replace(cleanColorCode, BLANK).split(COMMA)[0];
                    switch (colorStr.length) {
                        case 3:
                            colorStr = colorStr.charAt(0) + colorStr.charAt(0) + colorStr.charAt(1) +
                                colorStr.charAt(1) + colorStr.charAt(2) + colorStr.charAt(2);
                            break;
                        case 6:
                            break;
                        default:
                            colorStr = (colorStr + COLOR_WHITE).slice(0, 6);
                            break;
                    }
                    R = parseInt(colorStr.slice(0, 2), 16);
                    G = parseInt(colorStr.slice(2, 4), 16);
                    B = parseInt(colorStr.slice(4, 6), 16);
                }
            }

            if (!alpha && alpha !== 0) {
                alpha = 100;
            }
            if (typeof alpha === STRINGSTRING) {
                alpha = alpha.split(COMMA)[0];
            }
            alpha = parseInt(alpha, 10) / 100;
            return 'rgba(' + R + COMMA + G + COMMA + B + COMMA + alpha + ')';
        },
        toRaphaelColor = (function() {
            var cache = {};

            return function(obj) {
                obj = obj || this;
                var o = obj && obj.FCcolor || obj,
                    colors = o.color,
                    ratio = o.ratio,
                    angle = o.angle,
                    opacities = o.alpha,
                    r = o.r,
                    cx = o.cx,
                    cy = o.cy,
                    fx = o.fx,
                    fy = o.fy,
                    units = o.gradientUnits,
                    x1 = o.x1,
                    y1 = o.y1,
                    x2 = o.x2,
                    y2 = o.y2,
                    opacity = 1,
                    str,
                    i,
                    l,
                    color,
                    hash;

                if (typeof obj === 'string') {
                    return cache[(hash = '~' + obj)] ||
                        (cache[hash] = obj.replace(/^#?([a-f0-9]{3,6})/ig, '#$1'));
                }

                colors = colors || BLANK;

                if (!colors) {
                    return str;
                }

                hash = [colors, opacities, ratio, angle, r, cx, cy, units, fx, fy, x1, x2, y1, y2]
                    .join('_').replace(/[\(\)\s,\xb0#]/g, '_');
                if (cache[hash]) {
                    return cache[hash];
                }

                ratio = ratio && (ratio + BLANK).split(COMMA) || [];
                opacities = (opacities || opacities === 0) &&
                    (opacities + BLANK).split(COMMA) || [];

                if ((colors = colors.split(COMMA))) {
                    str = BLANK;
                    if (colors.length === 1) {
                        color = colors[0].replace(/^#?([a-f0-9]{3,6})/ig, '$1');
                        if (opacities.length) {
                            str = 'rgba(' + hexToRgb(color).join(COMMA) + ',' +
                                toFloat(opacities[0]) * 0.01 + ')';
                        }
                        else {
                            str = color.replace(/^#?([a-f0-9]{3,6})/ig, '#$1');
                        }
                    }
                    else {
                        for (i = 0, l = colors.length; i < l; i++) {
                            color = colors[i].replace(/^#?([a-f0-9]{3,6})/ig, '$1');
                            if (!isNaN(ratio[i])) {
                                ratio[i] = toFloat(ratio[i]);
                                color += COLON + ratio[i];
                                if (!isNaN(ratio[i + 1])) {
                                    ratio[i + 1] = toFloat(ratio[i + 1]) + ratio[i];
                                }
                            }
                            if (!isNaN(opacities[i]) && opacities[i] !== BLANK) {
                                opacity = opacities[i] * 0.01;
                            }
                            colors[i] = 'rgba(' + hexToRgb(color).join(COMMA) + ',' +
                                opacity + ')';
                            if (!isNaN(ratio[i])) {
                                colors[i] = colors[i] + COLON + ratio[i];
                            }
                        }
                        str += colors.join(HYPHEN);

                        if (r !== undefined || fx !== undefined || cx !== undefined || o.radialGradient) {
                            str = 'xr(' +
                                [fx, fy, r, cx, cy, units].join(',') + ')' + str;
                        }
                        else {
                            str = HYPHEN + str;
                            if (x1 !== undefined || y1 !== undefined || x2 !== undefined || y2 !== undefined) {
                                str = '(' + [x1, y1, x2, y2, units].join(',') + ')' + str;
                            }
                            if (angle === undefined) {
                                angle = 0;
                            }
                            str = (360 - toFloat(angle) % 360) + str;
                        }
                    }
                }
                return cache[hash] = str;
            };
        }()),
        gradientify = (function() {
            return function() {
                var attr = '';

                return attr;
            };

        }()),
        // Returns a color code including # before it
        parseColor = function(color) {
            return color.replace(cleanColorCode, BLANK).replace(dropHash, HASHSTRING);
        },
        // Returns a valid color or undefined
        getValidColor = function(color) {
            return validhexcolor.test(parseColor(color)) && color;
        },
        getDarkColor = function(color, offsetPercent) {
            offsetPercent = offsetPercent < 0 || offsetPercent > 100 ? 100 : offsetPercent;
            offsetPercent = offsetPercent / 100;
            // Removing spaces and # form color
            color = color.replace(cleanColorCode, BLANK);
            var sourceclrRGB = parseInt(color, 16),
                // Converting color in R B G
                R = Math.floor(sourceclrRGB / 65536),
                G = Math.floor((sourceclrRGB - R * 65536) / 256),
                B = sourceclrRGB - R * 65536 - G * 256;
            return (COLOR_BLACK + ((R * offsetPercent) << 16 | (G * offsetPercent) <<
                8 | (B * offsetPercent)).toString(16)).slice(-6);
        },
        getLightColor = function(color, offsetPercent) {
            offsetPercent = offsetPercent < 0 || offsetPercent > 100 ? 100 : offsetPercent;
            offsetPercent = offsetPercent / 100;
            // Removing spaces and # form color
            color = color.replace(cleanColorCode, BLANK);
            var sourceclrRGB = parseInt(color, 16),
                // Converting color in R B G
                R = Math.floor(sourceclrRGB / 65536),
                G = Math.floor((sourceclrRGB - R * 65536) / 256),
                B = sourceclrRGB - R * 65536 - G * 256;
            return (COLOR_BLACK + ((256 - ((256 - R) * offsetPercent)) << 16 | (256 - ((256 - G) * offsetPercent)) <<
                8 | (256 - ((256 - B) * offsetPercent))).toString(16)).slice(-6);
        },
        /**
         * HSBtoRGB methods takes an array of HSB color values and convert them
         * RGB color values and return an array conatining the Red,Green and
         * Blue color value of the provided HSB color.
         *
         * @param   hsb Array The array of Hue,Saturation and Brightness property
         * of a color.
         *
         * @return  Array The Array of RGB color value of the specified color.
         */

        HSBtoRGB = function(hsb) {
            var h = hsb[0], s = hsb[1], v = hsb[2],
                r = 0,
                g = 0,
                b = 0,
                rgb = [],
                tempS = s / 100,
                tempV = v / 100,
                hi = Math.floor(h / 60) % 6,
                f = h / 60 - Math.floor(h / 60),
                p = (tempV * (1 - tempS)),
                q = (tempV * (1 - f * tempS)),
                t = (tempV * (1 - (1 - f) * tempS));

            switch (hi) {
                case 0:
                    r = tempV;
                    g = t;
                    b = p;
                    break;
                case 1:
                    r = q;
                    g = tempV;
                    b = p;
                    break;
                case 2:
                    r = p;
                    g = tempV;
                    b = t;
                    break;
                case 3:
                    r = p;
                    g = q;
                    b = tempV;
                    break;
                case 4:
                    r = t;
                    g = p;
                    b = tempV;
                    break;
                case 5:
                    r = tempV;
                    g = p;
                    b = q;
                    break;
            }

            rgb = [mathRound(r * 255), mathRound(g * 255), mathRound(b * 255)];
            return rgb;
        },
        /**
         * RGBtoHSB methods takes an array of RGB color values and convert them
         * HSB color values and return an array conatining the Hue,Saturation and
         * Brightness of the specified RGB color.
         *
         * @param   rgb Array The array of RGB color values respective.The 0 index contains
         * Red color value, 1 index contains the Green color value and the
         * 2nd or the last index conatins the blue color value.
         *
         * @return  Array Color value array containing the Hue, Saturation and brightness of
         * The provided Color.
         */
        RGBtoHSB = function(rgb) {

            var r = rgb[0], g = rgb[1], b = rgb[2],
                max = Math.max(Math.max(r, g), b),
                min = Math.min(Math.min(r, g), b),
                hue = 0, saturation = 0;

            //get Hue
            if (max == min) {
                hue = 0;
            } else if (max == r) {
                hue = (60 * (g - b) / (max - min) + 360) % 360;
            } else if (max == g) {
                hue = (60 * (b - r) / (max - min) + 120);
            } else if (max == b) {
                hue = (60 * (r - g) / (max - min) + 240);
            }


            //get Saturation
            if (max === 0) {
                saturation = 0;
            } else {
                saturation = (max - min) / max;
            }

            return [mathRound(hue), mathRound(saturation * 100), mathRound(max / 255 * 100)];
        },
        /**
         * RGBtoHex methods takes an array of RGB color values and convert them to
         * a hexadecimal color value.And return the string.
         *
         * @param   rgb Array The array of RGB color values respective.The 0 index contains
         * Red color value, 1 index contains the Green color value and the
         * 2nd or the last index conatins the blue color value.
         *
         * @return  String The hexadecimal color string of the provided RGB value.
         */
        RGBtoHex = function(rgb) {
            return (COLOR_BLACK + (rgb[0] << 16 | rgb[1] << 8 | rgb[2]).toString(16)).slice(-6);
        },
        /**
         * hexToRgb method convert one hexColor string to HSB color
         * values.And return the value in an array, where the index value
         * containes Hue, saturaion and Brightness value of the provided
         * HexColor respectively.
         *
         * @param  sourceColor The hexadecimal Color string value.
         * @return  Array The HSB color values in respective order.
         */
        hexToRgb = function(sourceColor) {
            var sourceClrRGB = parseInt(sourceColor, 16),
                r = Math.floor(sourceClrRGB / 65536),
                g = Math.floor((sourceClrRGB - r * 65536) / 256),
                b = Math.floor((sourceClrRGB - r * 65536) - (g * 256));

            return [r, g, b];
        },
        symbolStr = {
            circle: 'circle',
            triangle: 'triangle',
            square: 'square',
            diamond: 'diamond',
            poly: 'poly_',
            spoke: 'spoke_'
        },
        //map FusionCharts anchor sides to HC anchor symbol
        //anchorside > 4 will show the down triangle
        mapSymbolName = function(num, isSpoke) {
            var x = symbolStr.circle;
            num = parsePointValue(num);
            if (num >= 3) {
                x = (isSpoke ? symbolStr.spoke : symbolStr.poly) + num;
            }
            return x;
        },
        // helper fnction for draw3Drect
        getAngle = function(width, height, type) {
            var angle = Math.atan(height / width) * 180 / Math.PI;
            if (type == 2) {
                angle = 180 - angle;
            }
            else if (type == 3) {
                angle += 180;
            }
            else if (type == 4) {
                angle = 360 - angle;
            }
            return angle;
        },
        /** @todo send the color and alpha as rray so that they don't need split */
        //this function create the column color depending upon the configuration
        getColumnColor = function(setColor, setAlpha, ratio, angle, isRoundEdges, bdColor, bdAlpha, isBar, is3d) {
            var bgColor, borderColor, colorArr, alphaArr, bdColorArr, color, alpha, bdAlphaArr;
            colorArr = setColor.split(COMMA);
            alphaArr = setAlpha.split(COMMA);
            bdColorArr = bdColor.split(COMMA);
            bdAlphaArr = bdAlpha.split(COMMA);
            // remove extra comma if there at the end.
            setColor = setColor.replace(/\s/g, BLANK).replace(/\,$/, BLANK);
            if (is3d) {
                bgColor = {
                    FCcolor: {
                        color: colorArr[0],
                        alpha: alphaArr[0]
                    }
                };
            }
            else if (isRoundEdges) {
                color = colorArr[0];
                alpha = alphaArr[0];
                bgColor = {
                    FCcolor: {
                        // [ColorExt.getDarkColor(this.color, 0.75),
                        // ColorExt.getLightColor(this.color, 0.25),
                        // ColorExt.getDarkColor(this.color, 0.8),
                        // ColorExt.getLightColor(this.color, 0.65),
                        // ColorExt.getDarkColor(this.color, 0.8)]
                        color: getDarkColor(color, 75) + COMMA + getLightColor(color, 10) + COMMA + getDarkColor(color,
                            90) + COMMA + getLightColor(color, 55) + COMMA + getDarkColor(color, 80),
                        alpha: alpha + COMMA + alpha + COMMA + alpha +
                            COMMA + alpha + COMMA + alpha,
                        ratio: '0,11,14,57,18',
                        angle: isBar ? '90' : '0'
                    }
                };
                bdColorArr = [getDarkColor(color, 70)];
            }
            else {
                setAlpha = parseAlpha(setAlpha, colorArr.length);
                bgColor = {
                    FCcolor: {
                        color: setColor,
                        alpha: setAlpha,
                        ratio: ratio,
                        angle: isBar ? -angle : angle
                    }
                };

            }
            borderColor = {
                FCcolor: {
                    color: bdColorArr[0],
                    alpha: bdAlphaArr[0]
                }
            };


            return [bgColor, borderColor];
        },
        toPrecision = function(obj, value) {
            var tenPow = mathPow(10, value);
            return mathRound(obj * tenPow) / tenPow;
        },

        supportedStyle = {
            font: 'font',
            fontFamily: 'font-family',
            'font-family': 'font-family',
            fontWeight: 'font-weight',
            'font-weight': 'font-weight',
            fontSize: 'font-size',
            'font-size': 'font-size',
            lineHeight: 'line-height',
            'line-height': 'line-height',
            textDecoration: 'text-decoration',
            'text-decoration': 'text-decoration',
            color: 'color',
            whiteSpace: 'white-space',
            'white-space': 'white-space',
            padding: 'padding',
            margin: 'margin',
            background: 'background',
            backgroundColor: 'background-color',
            'background-color': 'background-color',
            backgroundImage: 'background-image',
            'background-image': 'background-image',
            backgroundPosition: 'background-position',
            'background-position': 'background-position',
            backgroundPositionLeft: 'background-position-left',
            'background-position-left': 'background-position-left',
            backgroundPositionTop: 'background-position-top',
            'background-position-top': 'background-position-top',
            backgroundRepeat: 'background-repeat',
            'background-repeat': 'background-repeat',
            border: 'border',
            borderColor: 'border-color',
            'border-color': 'border-color',
            borderStyle: 'border-style',
            'border-style': 'border-style',
            borderThickness: 'border-thickness',
            'border-thickness': 'border-thickness',
            borderTop: 'border-top',
            'border-top': 'border-top',
            borderTopColor: 'border-top-color',
            'border-top-color': 'border-top-color',
            borderTopStyle: 'border-top-style',
            'border-top-style': 'border-top-style',
            borderTopThickness: 'border-top-thickness',
            'border-top-thickness': 'border-top-thickness',
            borderRight: 'border-right',
            'border-right': 'border-right',
            borderRightColor: 'border-right-color',
            'border-right-color': 'border-right-color',
            borderRightStyle: 'border-right-style',
            'border-right-style': 'border-right-style',
            borderRightThickness: 'border-right-thickness',
            'border-right-thickness': 'border-right-thickness',
            borderBottom: 'border-bottom',
            'border-bottom': 'border-bottom',
            borderBottomColor: 'border-bottom-color',
            'border-bottom-color': 'border-bottom-color',
            borderBottomStyle: 'border-bottom-style',
            'border-bottom-style': 'border-bottom-style',
            borderBottomThickness: 'border-bottom-thickness',
            'border-bottom-thickness': 'border-bottom-thickness',
            borderLeft: 'border-left',
            'border-left': 'border-left',
            borderLeftColor: 'border-left-color',
            'border-left-color': 'border-left-color',
            borderLeftStyle: 'border-left-style',
            'border-left-Style': 'border-left-style',
            borderLeftThickness: 'border-left-thickness',
            'border-left-thickness': 'border-left-thickness'
        },

        /**
         * Sets the line height of a style object based upon its font-size. The present method does not touch DOM and
         * hence not accurate.
         *
         * @param {object} styleObj
         * @param {number=} [baseFontSize]
         * @returns {string} The line height calculated from the style object.
         */
        setLineHeight = function (styleObj, baseFontSize) {
            if (typeof styleObj !== 'object') {
                return BLANK;
            }

            // When the font size is specified recalculate line height
            if (styleObj.fontSize || styleObj['font-size']) {
                // Detect line height from font-size
                if (!styleObj.fontSize && styleObj['font-size']) {
                    styleObj.fontSize = styleObj['font-size'];
                    delete styleObj['font-size'];
                }
                styleObj.lineHeight =
                    ((parseFloat(styleObj.fontSize) || baseFontSize || 10) * lib.lineHeightFactor) + 'px';

                // Delete hyphen notation line height
                delete styleObj['line-height'];
            }
            // In case the hyphen notation is used, move it to camelCase notation
            if (!styleObj.lineHeight && styleObj['line-height']) {
                styleObj.lineHeight = styleObj['line-height'];
                delete styleObj['line-height'];
            }

            return styleObj.lineHeight;
        },


        parsexAxisStyles = function (data, catObj, FCChartObj, style, dataColor) {
            // data label border color
            var fontBdrColor = getFirstValue(data.labelbordercolor, catObj.bordercolor,
                    FCChartObj.labelbordercolor, BLANK),
                bgColor = pluck(data.labelbgcolor, catObj.bgcolor,  FCChartObj.labelbgcolor),
                borderThickness = pluckNumber(data.labelborderthickness, catObj.borderthickness,
                    FCChartObj.labelborderthickness, 1),
                defColor = pluckNumber(FCChartObj.usedataplotcolorforlabels, 0) ? (dataColor || style.color) :
                    style.color,
                styleObj;

            fontBdrColor = fontBdrColor ? convertColor(fontBdrColor, pluckNumber(data.labelborderalpha,
                catObj.borderalpha, FCChartObj.labelborderalpha, data.labelalpha, catObj.alpha,
                FCChartObj.labelalpha, 100)) : BLANK;

            styleObj = {
                fontFamily: pluck(data.labelfont, catObj.font,  FCChartObj.labelfont, style.fontFamily),
                fontSize: pluck(data.labelfontsize, catObj.fontsize,  FCChartObj.labelfontsize,
                    parseInt(style.fontSize, 10)) + PXSTRING,
                color: convertColor(pluck(data.labelfontcolor, catObj.fontcolor,
                    FCChartObj.labelfontcolor, defColor),
                    pluckNumber(data.labelfontalpha, catObj.fontalpha,  FCChartObj.labelfontalpha,
                    data.labelalpha, catObj.alpha,  FCChartObj.labelalpha, 100)),
                fontWeight: pluckNumber(data.labelfontbold, catObj.fontbold,
                    FCChartObj.labelfontbold) ? 'bold' : 'normal',
                fontStyle: pluckNumber(data.labelfontitalic, catObj.fontitalic,
                    FCChartObj.labelfontitalic) ? 'italic' : 'normal',
                // Set border as empty string when not required,
                // since IE will stop js execution if it is undefined or null.
                border: fontBdrColor || bgColor ?
                    (borderThickness + 'px solid') : BLANK,
                borderColor: fontBdrColor,
                borderThickness: borderThickness,
                borderPadding: pluckNumber(data.labelborderpadding, catObj.borderpadding,
                    FCChartObj.labelborderpadding, 2),
                borderRadius: pluckNumber(data.labelborderradius, catObj.borderradius,
                    FCChartObj.labelborderradius, 0),
                backgroundColor: bgColor ? convertColor(bgColor, pluckNumber(data.labelbgalpha, catObj.bgalpha,
                     FCChartObj.labelbgalpha, data.labelalpha, catObj.alpha,
                     FCChartObj.labelalpha, 100)) : BLANK,
                borderDash: pluckNumber(data.labelborderdashed, catObj.borderdashed,
                    FCChartObj.labelborderdashed, 0) ?
                    getDashStyle(pluckNumber(data.labelborderdashlen, catObj.borderdashlen,
                    FCChartObj.labelborderdashlen, 4),
                    pluckNumber(data.labelborderdashgap, catObj.borderdashgap,
                    FCChartObj.labelborderdashgap, 2), borderThickness) : UNDEFINED
            };

            // set the line height
            styleObj.lineHeight = setLineHeight(styleObj);

            return styleObj;
        },

        /**
         * BG Image align attribute managing function
         */
        setImageDisplayMode = function(bgImageDisplayMode, bgImageVAlign,
            bgImageHAlign, bgImageScale, chartBorderWidth, chartWidth,
            chartHeight, imageEle) {
            var imageWidth = imageEle.width * (bgImageScale / 100),
                imageHeight = imageEle.height * (bgImageScale / 100),
                alignImage = {},
                imgAspectRatio, cAspectRatio, scaleFactor,
                xCount, yCount,
                //Consider the borderthickness and find out chart width and height
                cWidth = chartWidth - (chartBorderWidth * 2),
                cHeight = chartHeight - (chartBorderWidth * 2),
                alignObj,
                // Function to align the image
                // returns x y position of the image
                getImageAlignment = function(bgImageVAlign, bgImageHAlign, imageWidth, imageHeight, chartWidth,
                chartHeight) {
                    var alignObj = {};
                    switch (bgImageVAlign) {
                        case 'top':
                            alignObj.y = chartBorderWidth;
                            break;
                        case 'bottom':
                            alignObj.y = chartHeight - imageHeight - chartBorderWidth;
                            break;
                        case 'middle':
                            alignObj.y = (chartHeight - imageHeight) / 2;
                            break;
                    }


                    switch (bgImageHAlign) {
                        case 'left':
                            alignObj.x = chartBorderWidth;
                            break;
                        case 'right':
                            alignObj.x = chartWidth - imageWidth - chartBorderWidth;
                            break;
                        case 'middle':
                            alignObj.x = (chartWidth - imageWidth) / 2;
                            break;
                    }
                    return alignObj;
                };


            switch (bgImageDisplayMode) {
                case 'center':
                    alignImage.width = imageWidth;
                    alignImage.height = imageHeight;
                    alignImage.y = (chartHeight / 2) - (imageHeight / 2);
                    alignImage.x = (chartWidth / 2) - (imageWidth / 2);
                    break;

                case 'stretch'://Stretch Display Mode
                    alignImage.width = (chartWidth - chartBorderWidth * 2);
                    alignImage.height = (chartHeight - chartBorderWidth * 2);
                    alignImage.y = chartBorderWidth;
                    alignImage.x = chartBorderWidth;
                    break;

                case 'tile'://Tile Display Mode
                    alignImage.width = imageWidth;
                    alignImage.height = imageHeight;
                    alignImage.tileInfo = {};
                    alignImage.tileInfo.xCount = xCount = Math.ceil(cWidth / imageWidth);
                    alignImage.tileInfo.yCount = yCount = Math.ceil(cHeight / imageHeight);

                    alignObj = getImageAlignment(bgImageVAlign, bgImageHAlign,
                        imageWidth * xCount, imageHeight * yCount, chartWidth, chartHeight);

                    alignImage.y = alignObj.y;
                    alignImage.x = alignObj.x;
                    break;

                case 'fit'://Fit Display Mode

                    //Original image's aspect ratio.
                    imgAspectRatio = imageWidth / imageHeight;
                    //Chart's background aspect ratio
                    cAspectRatio = cWidth / cHeight;
                    scaleFactor = (imgAspectRatio > cAspectRatio) ? cWidth / imageWidth : cHeight / imageHeight;

                    alignImage.width = imageWidth * scaleFactor;
                    alignImage.height = imageHeight * scaleFactor;

                    alignObj = getImageAlignment(bgImageVAlign, bgImageHAlign,
                        alignImage.width, alignImage.height, chartWidth, chartHeight);

                    alignImage.y = alignObj.y;
                    alignImage.x = alignObj.x;
                    break;

                case 'fill'://Fill Display Mode

                    //Original image's aspect ratio.
                    imgAspectRatio = imageWidth / imageHeight;
                    //Chart's background aspect ratio
                    cAspectRatio = cWidth / cHeight;
                    //Find out scale factor
                    scaleFactor = (imgAspectRatio > cAspectRatio) ? cHeight / imageHeight : cWidth / imageWidth;

                    alignImage.width = imageWidth * scaleFactor;
                    alignImage.height = imageHeight * scaleFactor;

                    alignObj = getImageAlignment(bgImageVAlign, bgImageHAlign,
                        alignImage.width, alignImage.height, chartWidth, chartHeight);

                    alignImage.y = alignObj.y;
                    alignImage.x = alignObj.x;

                    break;

                default : // None
                    //In none mode image only need alignment.
                    alignObj = getImageAlignment(bgImageVAlign, bgImageHAlign,
                        imageWidth, imageHeight, chartWidth, chartHeight);

                    alignImage.width = imageWidth;
                    alignImage.height = imageHeight;
                    alignImage.y = alignObj.y;
                    alignImage.x = alignObj.x;
            }

            return alignImage;
        },
        /*
         *manager to add axis labels
         */
        axisLabelAdder = (function() {
            var TEXTPOSITION = {
                top: {
                    align: 'center',
                    verticalAlign: 'top',
                    textAlign: 'center'
                },
                right: {
                    align: 'right',
                    verticalAlign: 'middle',
                    textAlign: 'left'
                },
                bottom: {
                    align: 'center',
                    verticalAlign: 'bottom',
                    textAlign: 'center'
                },
                left: {
                    align: 'left',
                    verticalAlign: 'middle',
                    textAlign: 'right'
                }
            },
            alphaRetriveRegx = /([^\,^\s]+)\)$/g,
                labelAdder = function(defaultSeries, FCchartObj) {
                    var labelStep;
                    /** @todo add all series type for which the axis will be like bar(xChanged position) */
                    if (/^(bar|bar3d)$/.test(defaultSeries)) {
                        this.isBar = true;
                        this.yPos = 'bottom';
                        this.yOppPos = 'top';
                        this.xPos = 'left';
                        this.xOppPos = 'right';
                    }
                    //steping attr
                    labelStep = parseInt(FCchartObj.labelstep, 10);
                    this.labelStep = labelStep > 1 ? labelStep : 1;
                    this.showLabel = pluckNumber(FCchartObj.showlabels, FCchartObj.shownames, 1);
                    this.is3D = /3d$/.test(defaultSeries);
                };

            labelAdder.prototype = {
                isBar: false,
                yPos: 'left',
                yOppPos: 'right',
                xPos: 'bottom',
                xOppPos: 'top',
                //Note: linecolor must be in rgba str
                addAxisGridLine: function(axisObj, value, text, width, dashStyle, lineColor, zIndex, isXxis) {
                    var hasText = text === '' ? false : true, hasVisibleLine = width > 0 ||
                        lineColor.match(alphaRetriveRegx)[1] > 0 ? true : false, axisPos, textAttrs, gridLine;
                    if (hasText || hasVisibleLine) {
                        if (!hasVisibleLine) {
                            lineColor = COLOR_TRANSPARENT;
                            width = 0.1;
                        }
                        gridLine = {
                            isGrid: true,
                            width: width,
                            dashStyle: dashStyle,
                            color: lineColor,
                            value: value,
                            zIndex: zIndex === undefined ? 2 : zIndex
                        };
                        if (hasText) {
                            axisPos = axisObj.opposite ? (isXxis ? this.xOppPos : this.yOppPos) :
                                (isXxis ? this.xPos : this.yPos);
                            textAttrs = TEXTPOSITION[axisPos];
                            gridLine.label = {
                                text: text,
                                style: axisObj.labels.style,
                                textAlign: textAttrs.textAlign,
                                align: textAttrs.align,
                                verticalAlign: textAttrs.verticalAlign,
                                rotation: 0,
                                x: 0,
                                y: 0
                            };
                        }
                        axisObj.plotLines.push(gridLine);
                    }
                    return gridLine;
                },
                addAxisAltGrid: function(axisObj, currentValue) {
                    if (!this.is3D) {
                        var lastValue = pluckNumber(axisObj._lastValue, axisObj.min),
                            altGrid = pluck(axisObj._altGrid, false);
                        if (altGrid) {
                            axisObj.plotBands.push({
                                isGrid: true,
                                color: axisObj.alternateGridColor,
                                to: currentValue,
                                from: lastValue,
                                zIndex: 1
                            });
                        }
                        axisObj._lastValue = currentValue;
                        axisObj._altGrid = !altGrid;
                    }
                },
                addXaxisCat: function(axisObj, value, index, label, data, catObj, chartObj, dataColor) {
                    var axisPosition = axisObj.opposite ? this.xOppPos : this.xPos,
                        textAttrs = TEXTPOSITION[axisPosition],
                        gridLine = {
                            isGrid: true,
                            isDataLabel: true,
                            width: 0.1,
                            color: COLOR_TRANSPARENT,
                            value: value,
                            label: {
                                text: label,
                                link: pluck(data.labellink, catObj.link, chartObj.labellink),
                                style: parsexAxisStyles(data, catObj, chartObj, axisObj.labels.style, dataColor),
                                textAlign: textAttrs.textAlign,
                                align: textAttrs.align,
                                verticalAlign: textAttrs.verticalAlign,
                                rotation: 0,
                                x: 0,
                                y: 0
                            }
                        };

                    if (index % this.labelStep !== 0) {
                        gridLine.stepped = true;
                        gridLine.label.style = axisObj.steppedLabels.style;
                    }
                    axisObj.plotLines.push(gridLine);
                },
                addVline: function(axisObj, dataObj, index, hcObj) {
                    //Extract attributes
                    var conf = hcObj[FC_CONFIG_STRING],
                        isBar = conf.isBar,
                        divlineStyle = conf.divlineStyle,
                        label = parseUnsafeString(dataObj.label),
                        showLabelBorder = Boolean(pluckNumber(dataObj.showlabelborder, conf.showVLineLabelBorder, 1)),
                        showLabelBackground = Boolean(pluckNumber(dataObj.showlabelbackground, 1)),
                        labelHAlign = pluck(dataObj.labelhalign, isBar ? POSITION_LEFT : POSITION_CENTER),
                        labelVAlign = pluck(dataObj.labelvalign, isBar ? POSITION_MIDDLE :
                            POSITION_BOTTOM).toLowerCase(),
                        /** @todo need to calculate in px, to set y */
                        labelPosition = pluckNumber(dataObj.labelposition, 0),
                        linePosition = pluckNumber(dataObj.lineposition, 0.5),
                        showVLines = pluckNumber(dataObj.showvlines, conf.showVLines, 1),
                        alpha = pluckNumber(dataObj.alpha, conf.vLineAlpha, 80),
                        color = pluck(dataObj.color, conf.vLineColor).replace(/^#?/, '#'),
                        bgColor = showLabelBackground ? pluck(dataObj.labelbgcolor, conf.vLineLabelBgColor,
                            '333333').replace(/^#?/, '#') : BLANK,
                        labelColor = pluck(dataObj.labelcolor, conf.vLineLabelColor,
                            dataObj.color, conf.vLineColor).replace(/^#?/, '#'),
                        thickness = pluckNumber(dataObj.thickness, conf.vLineThickness, 1),
                        halfThickness = thickness * 0.5,
                        isDashed = Boolean(Number(pluck(dataObj.dashed, 0))),
                        dashLen = pluckNumber(dataObj.dashlen, 5),
                        dashGap = pluckNumber(dataObj.dashgap, 2),
                        smartLabel = conf.smartLabel,
                        fontSizeInt = parseInt(divlineStyle.fontSize, 10),
                        y = fontSizeInt + 2,
                        x = 0,
                        smartText,
                        labelRotation = pluckNumber(dataObj.rotatelabel,
                            conf.rotateVLineLabels) ? 270 : 0;

                    linePosition = (linePosition < 0 || linePosition > 1) ? 0.5 : linePosition;
                    labelPosition = (labelPosition < 0 || labelPosition > 1) ? 0 : labelPosition;
                    smartLabel.setStyle(divlineStyle);
                    smartText = smartLabel.getOriSize(label);

                    color = convertColor(color, showVLines ? alpha : '0');

                    if (!isBar) {
                        switch (labelVAlign) {
                            case POSITION_TOP:
                                y = (-smartText.height * 0.5) + 1;
                               /**
                                * @todo retain this line for future reference
                                y -= smartText.height + 2 + (plotBorderWidth || 1) *
                                    (1 - labelPosition) + labelPosition;
                                */
                                break;
                            case POSITION_MIDDLE:
                                y = 0;
                               /**
                                * @todo retain this line for future reference
                                y -= (smartText.height * 0.5) + plotBorderWidth * (1 - labelPosition * 2);
                                */
                                break;
                            default:
                                y = (smartText.height * 0.5);
                               /**
                                * @todo retain this line for future reference
                                y += (plotBorderWidth - pbwMod2) * labelPosition;
                                */

                        }
                        switch (labelHAlign) {
                            case POSITION_LEFT:
                                x += thickness;
                                break;
                            case POSITION_RIGHT:
                                x -= thickness + 1;
                                break;
                        }
                    }
                    else {
                        switch (labelVAlign) {
                            case POSITION_TOP:
                                y -= smartText.height + halfThickness + 2;
                                break;
                            case POSITION_MIDDLE:
                                y -= (smartText.height * 0.5) + 1;
                                break;
                            default:
                                y += halfThickness;
                        }

                        if (!dataObj.labelhalign) {
                            x -= smartText.width * labelPosition;
                        }
                    }

                    axisObj.plotLines.push({
                        isVline: true,
                        color: color,
                        width: thickness,
                        value: (index - 1) + linePosition,
                        zIndex: pluckNumber(dataObj.showontop, conf.showVLinesOnTop) ? 5 : 3, // extra for js charts
                        dashStyle: isDashed ? getDashStyle(dashLen, dashGap, thickness) : undefined,
                        label: {
                            text: label,
                            align: isBar ? POSITION_LEFT : POSITION_CENTER,
                            offsetScale: labelPosition,
                            rotation: labelRotation,
                            y: y,
                            x: x,
                            textAlign: labelHAlign,
                            backgroundColor: bgColor,
                            borderWidth: showVLines && showLabelBorder ? '1px' : BLANK,
                            borderType: showVLines && showLabelBorder ? 'solid' : BLANK,
                            borderColor: showVLines && showLabelBorder ? labelColor : BLANK,
                            backgroundOpacity: showVLines && showLabelBackground ?
                                pluck(dataObj.labelbgalpha, conf.vLineLabelBgAlpha) / 100 : 0,
                            style: {
                                color: showVLines ? labelColor : color,
                                fontSize: divlineStyle.fontSize,
                                fontFamily: divlineStyle.fontFamily,
                                lineHeight: divlineStyle.lineHeight,
                                backgroundColor: bgColor
                            }
                        }
                    });
                }
            };
            labelAdder.prototype.constructor = labelAdder;
            return labelAdder;
        })(),

        ///////// *********Linear Axis Min Max module****** ////////////


        getAxisLimits = (function() {

            var getDivisibleRange = function(yMin, yMax, numDivLines, interval, interceptRange)
            {
                //Get the range division for current yMin, yMax and numDivLines
                var range = Math.abs(yMax - yMin),
                    rangeDiv = range / (numDivLines + 1),
                    checkLimit;
                //Now, the range is not divisible
                if (!isRangeDivisible(range, numDivLines, interval))
                {
                    //We need to get new rangeDiv which can be equally distributed.
                    //If intercept range is set to true
                    if (interceptRange)
                    {
                        //Re-adjust interval so that gap is not much (conditional)
                        //Condition check limit based on value
                        checkLimit = (interval > 1) ? 2 : 0.5;
                        if ((Number(rangeDiv) / Number(interval)) < checkLimit)
                        {
                            //Decrease power of ten to get closer rounding
                            interval = interval / 10;
                        }
                    }
                    //Adjust range division based on new interval
                    rangeDiv = (Math.floor(rangeDiv / interval) + 1) * interval;
                    //Get new range
                    range = rangeDiv * (numDivLines + 1);
                }
                //Return range
                return range;
            },
                /**
                 * isRangeDivisible method helps us judge whether the given range is
                 * perfectly divisible for specified y-interval, numDivLines, yMin and yMax.
                 * To check that, we divide the given range into (numDivLines+1) section.
                 * If the decimal places of this division value is <= that of interval,
                 * that means, this range fits in our purpose. We return a boolean value
                 * accordingly.
                 * @param range  Range of y-axis (Max - Min). Absolute value
                 * @param numDivLines Number of div lines to be plotted.
                 * @param interval Y-axis Interval (power of ten).
                 * @return   Boolean value indicating whether this range is divisible
                 *      by the given number of div lines.
                 */
                isRangeDivisible = function(range, numDivLines, interval)
                {
                    //Get range division
                    var rangeDiv = range / (numDivLines + 1);
                    //Now, if the decimal places of rangeDiv and interval do not match,
                    //it's not divisible, else it's divisible
                    if (numDecimals(rangeDiv) > numDecimals(interval))
                    {
                        return false;
                    } else {
                        return true;
                    }
                },
                /**
                 * numDecimals method returns the number of decimal places provided
                 * in the given number.
                 * @param num Number for which we've to find the decimal places.
                 * @returns Number of decimal places found.
                 */
                numDecimals = function(num) {
                    //Absolute value (to avoid floor disparity for negative num)
                    num = Math.abs(num);
                    //Convert to string and find the position of dot.
                    var strNum = String(num),
                        decimals = 0,
                        dotPos = strNum.indexOf(DECIMALSTRING);
                    //See if the number has decimal at all
                    if (dotPos != -1) {
                        //Find the position of decimal.
                        decimals = strNum.length - dotPos - 1;
                    }
                    //Return the number of decimal digits
                    return decimals;
                };



            /**
             * getAxisLimits method helps calculate the axis limits based
             * on the given maximum and minimum value.
             * @param maxValue  Maximum numerical value present in data
             * @param minValue  Minimum numerical value present in data
             * @param stopMaxAtZero Flag indicating whether maximum value can
             *       be less than 0.
             * @param setMinAsZero Whether to set the lower limit as 0 or a greater
             * appropriate value (when dealing with positive numbers)
             */

            return function(maxValue, minValue, yAxisMaxValue, yAxisMinValue, stopMaxAtZero, setMinAsZero, numDivLines,
                adjustDiv) {
                //write the variable which are added as an param in as object
                var yMaxGiven, yMinGiven, yMax, yMin, range, interval, maxPowerOfTen, minPowerOfTen, powerOfTen,
                yInterval, rangePowerOfTen, rangeInterval, yTopBound, yLowerBound, deltaRange,
                found,
                adjInterval,
                rangeD,
                nextRange,
                rangeDiv,
                mf,
                smallArm,
                extSmallArm,
                i,
                adjRange,
                counter,
                multiplyFactor,
                divLines,
                bigArm,
                divInterval,
                extBigArm;
                //First check if both maxValue and minValue are proper numbers.
                //Else, set defaults as 90,0
                maxValue = (isNaN(maxValue) === true || maxValue === undefined) ? 0.1 : maxValue;
                minValue = (isNaN(minValue) === true || minValue === undefined) ? 0 : minValue;
                //Or, if only 0 data is supplied
                if ((maxValue === minValue) && (maxValue === 0))
                {
                    maxValue = 0.1;
                }
                //Defaults for stopMaxAtZero and setMinAsZero
                stopMaxAtZero = typeof stopMaxAtZero === undefined ? true : stopMaxAtZero;
                setMinAsZero = typeof setMinAsZero === undefined ? true : setMinAsZero;
                //Get the maximum power of 10 that is applicable to maxvalue
                //The Number = 10 to the power maxPowerOfTen + x (where x is another number)
                //For e.g., in 99 the maxPowerOfTen will be 1 = 10^1 + 89
                //And for 102, it will be 2 = 10^2 + 2
                maxPowerOfTen = Math.floor(Math.log(Math.abs(maxValue)) / Math.LN10);
                //Get the minimum power of 10 that is applicable to maxvalue
                minPowerOfTen = Math.floor(Math.log(Math.abs(minValue)) / Math.LN10);
                //Find which powerOfTen (the max power or the min power) is bigger
                //It is this which will be multiplied to get the y-interval
                powerOfTen = Math.max(minPowerOfTen, maxPowerOfTen);
                yInterval = Math.pow(10, powerOfTen);
                //For accomodating smaller range values (so that scale doesn't represent too large an interval
                if (Math.abs(maxValue) / yInterval < 2 && Math.abs(minValue) / yInterval < 2)
                {
                    powerOfTen--;
                    yInterval = Math.pow(10, powerOfTen);
                }
                //If the y_interval of min and max is way more than that of range.
                //We need to reset the y-interval as per range
                rangePowerOfTen = Math.floor(Math.log(maxValue - minValue) / Math.LN10);
                rangeInterval = Math.pow(10, rangePowerOfTen);
                //Now, if rangeInterval is 10 times less than y_interval, we need to re-set
                //the limits, as the range is too less to adjust the axis for max,min.
                //We do this only if range is greater than 0 (in case of 1 data on chart).
                if (((maxValue - minValue) > 0) && ((yInterval / rangeInterval) >= 10))
                {
                    yInterval = rangeInterval;
                    powerOfTen = rangePowerOfTen;
                }
                //Calculate the y-axis upper limit
                yTopBound = (Math.floor(maxValue / yInterval) + 1) * yInterval;
                //Calculate the y-axis lower limit
                //yLowerBound;
                //Delta in range
                //deltaRange;
                //If the min value is less than 0
                if (minValue < 0)
                {
                    //Then calculate by multiplying negative numbers with y-axis interval
                    yLowerBound = -1 * ((Math.floor(Math.abs(minValue / yInterval)) + 1) * yInterval);
                } else {
                    //Else, simply set it to 0.
                    if (setMinAsZero)
                    {
                        yLowerBound = 0;
                    }
                    else {
                        yLowerBound = Math.floor(Math.abs(minValue / yInterval) - 1) * yInterval;
                        //Now, if minValue>=0, we keep x_lowerBound to 0 - as for values like minValue 2
                        //lower bound goes negative, which is not required.
                        yLowerBound = (yLowerBound < 0) ? 0 : yLowerBound;
                    }
                }
                //MaxValue cannot be less than 0 if stopMaxAtZero is set to true
                if (stopMaxAtZero && maxValue <= 0) {
                    yTopBound = 0;
                }
                //Now, we need to make a check as to whether the user has provided an upper limit
                //and lower limit.
                //Code before JSlint: if (yAxisMaxValue == null || yAxisMaxValue == undefined || yAxisMaxValue == BLANK)
                if (!yAxisMaxValue && yAxisMaxValue !== 0)
                {
                    yMaxGiven = false;
                } else {
                    yMaxGiven = true;
                }
                if (!yAxisMinValue && yAxisMinValue !== 0) {
                    yMinGiven = false;
                } else {
                    yMinGiven = true;
                }
                //If he has provided it and it is valid, we leave it as the upper limit
                //Else, we enforced the value calculate by us as the upper limit.
                if (yMaxGiven === false || (yMaxGiven === true && Number(yAxisMaxValue) < maxValue && maxValue -
                    Number(yAxisMaxValue) > EPSILON))
                {
                    yMax = yTopBound;
                } else {
                    yMax = Number(yAxisMaxValue);
                }
                //Now, we do the same for y-axis lower limit
                if (yMinGiven === false || (yMinGiven === true && Number(yAxisMinValue) > minValue &&
                    Number(yAxisMinValue) - minValue > EPSILON))
                {
                    yMin = yLowerBound;
                } else {
                    yMin = Number(yAxisMinValue);
                }
                //Store axis range
                range = Math.abs(yMax - yMin);
                //Store interval
                interval = yInterval;
                //}




                /**
                 * calcDivs method calculates the best div line interval for the given/calculated
                 * yMin, yMax, specified numDivLines and adjustDiv.
                 * We re-set the y axis min and max value, if both were calculated by our
                 * us, so that we get a best value according to numDivLines. The idea is to have equal
                 * intervals on the axis, based on numDivLines specified. We do so, only if both yMin and
                 * yMax have been calculated as per our values. Else, we adjust the numDiv Lines.
                 */
                //function calcDivs ()
                //{
                /**
                 * There can be four cases of yMin, yMax.
                 * 1. User doesn't specify either. (our program calculates it).
                 * 2. User specifies both in XML. (which our program still validates)
                 * 3. User specifies only yMin. (we provide missing data)
                 * 4. User specifies only yMax. (we provide missing data)
                 *
                 * Apart from this, the user can specify numDivLines (which if not specified takes a
                 * default value of 4). Also, the user can specify adjustDiv (which can be 1 or 0).
                 * adjustDiv works in all four cases (1,2,3,4).
                 * Case 1 is modified to occur as under now: User doesn't specify either yMin or yMax
                 * and adjustDiv is set to true (by default). If the user doesn't specify either yMin or
                 * yMax, but adjustDiv is set to false, it doesn't appear as Case 1. However, if adjustDiv
                 * is set to true and yMin,yMax is automatically calculated by FusionCharts, we adjust the
                 * calculated yMin,yMax so that the given number of div lines can be well adjusted within.
                 *
                 * In case 2,3,4, we adjust numDivLines so that they space up equally based on the interval
                 * and decimals required.
                 *
                 * So, the difference between Case 1 and Case 2,3,4 is that in Case 1, we adjust limits
                 * to accomodate specified number of div lines. In Case 2,3,4, we adjust numDivLines to
                 * accomodate within the given limits (y-axis range).
                 *
                 * numDivLines is always our primary focus when calculating them in all cases. In Case 1,
                 * it's kept constant as center of calculation. In Case 2, it's modified to get a best
                 * value.
                 *
                 * Now, for case 1, we can have three sub cases:
                 * 1.1. yMax, yMin >=0
                 * 1.2. yMin, yMax <=0
                 * 1.3. yMax > 0 and yMin <0.
                 * Case 1.1 and 1.2 are simple, as we just need to adjust the range between two positive
                 * or two negative numbers such that the range can be equally divided into (numDivLines+1)
                 * division.
                 * Case 1.3 is tricky, as here, we additionally need to make sure that 0 plane is included
                 * as a division.
                 * We use two different methods to solved Case 1.1,1.2 and Case 1.3.
                 * Note that in all Cases (1.1, 1.2 & 1.3), we adjust the auto-calculated yMax and yMin
                 * to get best div line value. We do NOT adjust numDivLines here.
                 */
                //Check condition for case 1 first - limits not specified and adjustDiv is true
                if (yMinGiven === false && yMaxGiven === false && adjustDiv)
                {
                    //Means neither chart max value nor min value has been specified and adjustDiv is true
                    //Now, if it's case 1.3 (yMax > 0 & yMin <0)
                    if (yMax > 0 && yMin < 0)
                    {
                        //Case 1.3
                        /**
                         * Here, in this case, we start by generating the best fit range
                         * for the given yMin, yMax, numDivLines and interval. We generate
                         * range by adding sequential increments (rangeDiv * (ND+1) * interval).
                         * Interval has been adjusted to smaller interval for larger values.
                         * Now, for each divisible range generated by the program, we adjust the
                         * yMin and yMax to check if 0 can land as a division in between them on
                         * a proper distance.
                         * We divide the y-axis range into two parts - small arm and big arm.
                         * Say y-axis range is from 1 to -5. So, small arm is 1 and big arm is -5.
                         * Or, if its from 16 to -3, small arm is -3 and big arm is 16.
                         * Now, we try and get a value for extended small arm, which is multiple
                         * of rangeDiv. Say chart min,max is 16,-3. So range becomes 19.
                         * Let's assume numDivLines to be 2. So for 2 numDivLines, we get closest
                         * adjusted range value as 21. Delta range = 21 - 19 (original range) = 2
                         * Also, range division value = 21 / (ND + 1) = 21 / 3 = 7
                         * We now get values for extended small arm as i*range division, where i
                         * runs from 1 to (numDivLines+1)/2. We go only halfway as it's the smaller
                         * arm and so cannot extend to a division beyond half way - else it would have
                         * been the bigger arm.
                         * So, first extended small arm = -7 * 1 = -7.
                         * We get the difference between extended small arm and original small arm.
                         * In this case it's 7 - 3 = 4 (all absolute values now - to avoid sign disparities).
                         * We see that delta arm > delta range. So, we ignore this range and get a new range.
                         * So, next range comes as = prev Range (21) + (numDivLines + 1)*interval
                         * = 21 + (2+1)*1 = 24
                         * Since the increment is sequential as a multiplication factor of
                         * (numDivLines + 1)*interval, it is also a valid divisible range.
                         * So we again check whether 0 can appear as a division. In this case, we
                         * get rangeDiv as 8 and extended smaller arm as 8. For this extended smaller
                         * arm, we get bigger arm as 16. Both of these are divisible by rangeDiv. That
                         * means, this range can include 0 as division line. So, we store it and proceed.
                         */
                        //Flag to indicate whether we've found the perfect range or not.
                        found = false;
                        //We re-calculate the interval to get smaller increments for large values.
                        //For example, for 300 to -100 (with ND as 2), if we do not adjust interval, the min
                        //max come as -200, 400. But with adjusted intervals, it comes as -150, 300, which is
                        //more appropriate.
                        adjInterval = (interval > 10) ? (interval / 10) : interval;
                        //Get the first divisible range for the given yMin, yMax, numDivLines and interval.
                        //We do not intercept and adjust interval for this calculation here.
                        rangeD = getDivisibleRange(yMin, yMax, numDivLines, adjInterval, false);
                        //Now, deduct delta range from nextRange initially, so that in while loop,
                        //there's a unified statement for increment instead of 2 checks.
                        nextRange = rangeD - (numDivLines + 1) * (adjInterval);

                        //Now, we need to search for a range which is divisible in (numDivLines+1)
                        //segments including 0. Run a while loop till that is found.
                        while (found === false)
                        {
                            //Get range
                            nextRange = nextRange + (numDivLines + 1) * (adjInterval);
                            //If it's divisible for the given range and adjusted interval, proceed
                            if (isRangeDivisible(nextRange, numDivLines, adjInterval))
                            {
                                //Delta Range
                                deltaRange = nextRange - range;
                                //Range division
                                rangeDiv = nextRange / (numDivLines + 1);
                                //Get the smaller arm of axis
                                smallArm = Math.min(Math.abs(yMin), yMax);
                                //Bigger arm of axis.
                                bigArm = range - smallArm;
                                //Get the multiplication factor (if smaller arm is negative, set -1);
                                mf = (smallArm == Math.abs(yMin)) ? -1 : 1;
                                //If num div lines ==0, we do not calculate anything
                                if (numDivLines === 0)
                                {
                                    //Set flag to true to exit loop
                                    found = true;
                                } else {
                                    //Now, we need to make sure that the smaller arm of axis is a multiple
                                    //of rangeDiv and the multiplied result is greater than smallArm.
                                    for (i = 1; i <= Math.floor((numDivLines + 1) / 2); i++)
                                    {
                                        //Get extended small arm
                                        extSmallArm = rangeDiv * i;
                                        //If extension is more than original intended delta, we move to next
                                        //value of loop as this range is smaller than our intended range
                                        if ((extSmallArm - smallArm) > deltaRange)
                                        {
                                            //Iterate to next loop value
                                            continue;
                                        }
                                        //Else if extended arm is greater than smallArm, we do the 0 div test
                                        if (extSmallArm > smallArm)
                                        {
                                            //Get extended big arm
                                            extBigArm = nextRange - extSmallArm;
                                            //Check whether for this range, 0 can come as a div
                                            //By checking whether both extBigArm and extSmallArm
                                            //are perfectly divisible by rangeDiv
                                            if (((extBigArm / rangeDiv) == (Math.floor(extBigArm / rangeDiv))) &&
                                                ((extSmallArm / rangeDiv) == (Math.floor(extSmallArm / rangeDiv))))
                                            {
                                                //Store in global containers
                                                range = nextRange;
                                                yMax = (mf == -1) ? extBigArm : extSmallArm;
                                                yMin = (mf == -1) ? (-extSmallArm) : (-extBigArm);
                                                //Set found flag to true to exit loop
                                                found = true;
                                            }
                                        } else {
                                            //Iterate to next loop value, as we need the arm to be greater
                                            //than original value.
                                            continue;
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        //Case 1.1 or 1.2
                        /**
                         * In this case, we first get apt divisible range based on yMin, yMax,
                         * numDivLines and the calculated interval. Thereby, get the difference
                         * between original range and new range and store as delta.
                         * If yMax>0, add this delta to yMax. Else substract from yMin.
                         */
                        //Get the adjusted divisible range
                        adjRange = getDivisibleRange(yMin, yMax, numDivLines, interval, true);
                        //Get delta (Calculated range minus original range)
                        deltaRange = adjRange - range;
                        //Update global range storage
                        range = adjRange;
                        //Now, add the change in range to yMax, if yMax > 0, else deduct from yMin
                        if (yMax > 0)
                        {
                            yMax = yMax + deltaRange;
                        } else {
                            yMin = yMin - deltaRange;
                        }
                    }
                } else {
                    /**
                     * Here, we've to handle the following cases
                     * 2. User specifies both yMin, yMax in XML. (which our program still validates)
                     * 3. User specifies only yMin. (we provide yMax)
                     * 4. User specifies only yMax. (we provide yMin)
                     * Now, for each of these, there can be two cases. If the user has opted to
                     * adjust div lines or not. If he has opted to adjustDiv, we calculate the best
                     * possible number of div lines for the given range. If not, we simply divide
                     * the given (or semi-calculated) axis limits by the number of div lines.
                     */
                    if (adjustDiv)
                    {
                        //We iterate from given numDivLines to 0,
                        //Count helps us keep a counter of how many div lines we've checked
                        //For the sake of optimization, we check only 25 div lines values
                        //From (numDivLines to 0) and (numDivLines to (25-numDivLines))
                        //We do it in a yoyo order - i.e., if numDivLines is set as 5,
                        //we first check 6 and then 4. Next would be (8,3), (9,2), (10,1),
                        //(11, (no value here, as we do not check for 0), 12, 13, 14, 15, 16,
                        //17,18,19,20. So, in this way, we check for 25 possible numDivLines and
                        //see if any one them fit in. If yes, we store that value. Else, we set it
                        //as 0 (indicating no div line feasible for the given value).
                        //Perform only if numDivLines>0
                        if (numDivLines > 0)
                        {
                            counter = 0;
                            multiplyFactor = 1;
                            while (1)
                            {
                                //Increment,Decrement numDivLines
                                divLines = numDivLines + (counter * multiplyFactor);
                                //Cannot be 0
                                divLines = (divLines === 0) ? 1 : divLines;
                                //Check whether this number of numDivLines satisfy our requirement
                                if (isRangeDivisible(range, divLines, interval))
                                {
                                    //Exit loop
                                    break;
                                }
                                //Each counter comes twice: one for + count, one for - count
                                counter = (multiplyFactor == -1 || (counter > numDivLines)) ? (++counter) : (counter);
                                if (counter > 25)
                                {
                                    //We do not go beyond 25 count to optimize.
                                    //If the loop comes here, it means that divlines
                                    //counter is not able to achieve the target.
                                    //So, we assume no div lines are possible and exit.
                                    divLines = 0;
                                    break;
                                }
                                //Switch to increment/decrement mode. If counter
                                multiplyFactor = (counter <= numDivLines) ? (multiplyFactor * -1) : (1);
                            }
                            //Store the value in params
                            numDivLines = divLines;
                        }
                    } /*
                    else {
                        //Div lines intevals need to formatted to the given precision.
                    } */
                }
                /* //Set flags pertinent to zero plane
                 if (yMax > 0 && yMin < 0)
                 {
                 zeroPRequired = true;
                 } else
                 {
                 zeroPRequired = false;
                 }*/
                //Div interval
                divInterval = (yMax - yMin) / (numDivLines + 1);
                /* //Flag to keep a track whether zero plane is included
                 zeroPIncluded = false;
                 //We now need to store all the div line segments in the array this.divLines
                 //We include yMin and yMax too in div lines to render in a single loop
                 var divLineValue = yMin - divInterval;
                 //Keeping a count of div lines
                 var count = 0;
                 while (count <= (numDivLines + 1))
                 {
                 //Converting to string and back to number to avoid Flash's rounding problems.
                 divLineValue = Number (String (divLineValue + divInterval));
                 //Check whether zero plane is included
                 zeroPIncluded = (divLineValue == 0) ? true : zeroPIncluded;
                 //Add the div line to this.divLines
                 this.divLines [count] = this.returnDataAsDivLine (divLineValue);
                 //Based on yAxisValueStep, we need to hide required div line values
                 if (count % yAxisValuesStep == 0)
                 {
                 divLines [count].showValue = true;
                 } else
                 {
                 divLines [count].showValue = false;
                 }
                 //Increment counter
                 count ++;
                 }
                 //Now, the array this.divLines contains all the divisional values. But, it might
                 //not contain 0 value in Case 2,3,4 (i.e., when the user manually sets things).
                 //So, if zero plane is required but not included, we include it.
                 if (zeroPRequired == true && zeroPIncluded == false)
                 {
                 //Include zero plane at the right place in the array.
                 divLines.push (returnDataAsDivLine (0));
                 //Now, sort on value so that 0 automatically appears at right place
                 divLines.sortOn ('value', Array.NUMERIC);
                 //Also increase numDivLines
                 numDivLines ++;
                 }
                 //We finally have the sorted div lines in this.divLines  */

                //////fix of error in renderer for infinite loop
                divInterval = divInterval;

                return {
                    Max: yMax,
                    Min: yMin,
                    Range: range,
                    interval: interval,
                    divGap: divInterval
                };

            };
        })(),
        //HC compatiable JSON to Show a message in Chart
        //store blank Chart to show message
        ///special configuration
        /** @todo have to check whether style for text are applicable in FC or not
         //then we have to implement the font style also */
        createDialog = (function() {

            var api = function(container, text, chartObj) {
                var smartLabel = chartObj.jsVars && chartObj.jsVars.smartLabel,
                    chartWidth = container.offsetWidth,
                    chartHeight = container.offsetHeight,
                    smartText;

                this.title.y = chartHeight / 2;
                this.title.x = chartWidth / 2;

                this.title.style = chartObj._chartMessageStyle;

                delete chartObj._chartMessageStyle;

                if (text !== undefined) {
                    if (smartLabel) {
                        setLineHeight(this.title.style);
                        smartLabel.setStyle(this.title.style);
                        smartText = smartLabel.getSmartText(parseUnsafeString(text), chartWidth, chartHeight);
                        this.title.text = smartText.text;
                    }
                    else {
                        this.title.text = parseUnsafeString(text);
                    }
                    this.title.verticalAlign = 'middle';
                }
            };

            api.prototype = {//jsonstructutr for a blank chart which will be used to show a messege
                chart: {
                    events: {},
                    margin: [0, 0, 0, 0],
                    backgroundColor: {
                        FCcolor: {
                            alpha: 0
                        }
                    }
                },
                credits: {
                    href: CREDIT_HREF,
                    text: CREDIT_STRING,
                    enabled: creditLabel
                },
                legend: {
                    enabled: false
                },
                title: {
                    text: '',
                    style: {
                        fontFamily: 'Verdana,sans',
                        fontSize: '10px',
                        color: '#666666'
                    }
                },
                plotOptions: {
                    series: {}
                },
                series: [{}],
                exporting: {
                    enabled: false
                },
                nativeMessage: true
            };

            return api.prototype.constructor = api;
        })(),

        // [zone][!inverse][start < end]
        trendLineLabelPositionHoriz = {
            'true': {
                'true': {
                    'true': POSITION_CENTER,
                    'false': POSITION_CENTER
                },
                'false': {
                    'true': POSITION_CENTER,
                    'false': POSITION_CENTER
                }
            },
            'false': {
                // Relative value position: start < end
                'true': {
                    // Axis oppositality
                    'true': POSITION_RIGHT,
                    'false': POSITION_LEFT
                },
                'false': {
                    // Axis oppositality
                    'true': POSITION_LEFT,
                    'false': POSITION_RIGHT
                }
            }
        },
        //Function to insart trend Line
        /** @todo
         * - pading will be added as per axis label padding
         * - have to import style
         * - have to optimize
         * - implement tooltip on trendlines
         */
        createTrendLine = (function() {
            return function(trendObj, axis, hcConf, isDY, isBar, isVtrend, isInverse) {
                var x,
                    trendStyle = hcConf.trendStyle,
                    z,
                    l,
                    m,
                    trendLineObj,
                    isOpp,
                    isZone,
                    displayvalue,
                    trendLabelObj,
                    toolText,
                    labelColor,
                    axisObj,
                    width,
                    trendStartValue,
                    trendEndValue,
                    slopeDirection,
                    slopeDirectionHoriz,
                    max, min,
                    axisIndex,
                    trendLines,
                    NFMethodName = isVtrend ? 'xAxis' : 'dataLabels';

                if (isVtrend ? !hcConf.showVLines : !hcConf.showTrendlines) {
                    return;

                }
                for (x = 0, l = trendObj.length; x < l; x += 1) {
                    trendLines = trendObj[x];
                    if (trendLines && trendLines.line) {
                        for (z = 0, m = trendLines.line.length; z < m; z += 1) {

                            trendLineObj = trendLines.line[z];

                            trendStartValue = hcConf.numberFormatter.getCleanValue(pluck(trendLineObj.startvalue,
                                trendLineObj.value, 0));
                            trendEndValue = hcConf.numberFormatter.getCleanValue(pluck(trendLineObj.endvalue,
                                pluck(trendLineObj.startvalue, trendLineObj.value, 0)));

                            //check which axis object will be added
                            if (isVtrend) {
                                axisObj = axis;
                            }
                            else if (isDY && trendLineObj.parentyaxis && /^s$/i.test(trendLineObj.parentyaxis)) {
                                axisObj = axis[1];
                                axisIndex = 1;
                            }
                            else {
                                axisObj = axis[0];
                            }
                            max = axisObj.max;
                            min = axisObj.min;
                            //isOpp variable needs to be re-evaluated in each iteration
                            //as trendlines might be of different axis.
                            isOpp = false;
                            if (max >= trendStartValue && max >= trendEndValue && min <= trendStartValue && min <=
                                trendEndValue) {
                                //for secondary y axis we have to place its trendlines on right
                                //by default. attribute valueonleft for secondary y axis is not
                                //documented. So its usage at this moment will be a hack
                                if (isDY && trendLineObj.parentyaxis && /^s$/i.test(trendLineObj.parentyaxis)) {
                                    isOpp = pluck(trendLineObj.valueonleft, hcConf.trendlineValuesOnOpp) !== ONESTRING;
                                }
                                //But for any DY axis chart trendlines should not be placed on
                                //right.
                                else if (!isDY) {
                                    isOpp = pluck(trendLineObj.valueonright, hcConf.trendlineValuesOnOpp) === ONESTRING;
                                }

                                /*isOpp = (trendLineObj.valueonright === ONESTRING ||
                                 (trendLineObj.parentyaxis && /^s$/i.test(trendLineObj.parentyaxis))) ? true : false;*/

                                // Calculate from input values whether the object would
                                // be trendline or trendzone
                                isZone = Boolean(pluckNumber(trendLineObj.istrendzone, isVtrend ? 1 : 0));

                                //if there has a display value the create it
                                if (!(isVtrend ? hcConf.showVLineLabels : hcConf.showTrendlineLabels)) {
                                    displayvalue = BLANK;
                                }
                                else {
                                    displayvalue = parseUnsafeString(pluck(trendLineObj.displayvalue,
                                        hcConf.numberFormatter[NFMethodName](isOpp ? trendEndValue : trendStartValue,
                                        axisIndex)));
                                }


                                if (displayvalue) {
                                    slopeDirection = (trendStartValue > trendEndValue);
                                    slopeDirectionHoriz = (trendStartValue < trendEndValue);
                                    trendLabelObj = {
                                        text: displayvalue,
                                        textAlign: isBar ? POSITION_CENTER : (isOpp ? POSITION_LEFT : POSITION_RIGHT),
                                        align: isBar ? trendLineLabelPositionHoriz[isZone][!isInverse]
                                        [slopeDirectionHoriz] : (isOpp ? POSITION_RIGHT : POSITION_LEFT),
                                        /*verticalAlign: isBar ? POSITION_BOTTOM :
                                         trendLineLabelPosition[isZone][!isInverse][slopeDirection][isOpp],*/
                                        verticalAlign: isBar ? POSITION_BOTTOM : POSITION_MIDDLE,
                                        rotation: 0,
                                        x: 0,
                                        y: 0, //isBar ? halfFontSize : 2,
                                        style: trendStyle
                                    };
                                    labelColor = pluck(trendLineObj.color, hcConf.trendlineColor);
                                    trendLineObj.alwaysVisible = isZone; // always show zones (even if 0 width)
                                    if (labelColor) {
                                        trendLabelObj.style = extend2({}, trendStyle);
                                        trendLabelObj.style.color = labelColor.replace(dropHash, HASHSTRING);
                                    }
                                }
                                else {
                                    trendLabelObj = undefined;
                                }
                                //add options for tooltext
                                toolText = getValidValue(parseUnsafeString(pluck(trendLineObj.tooltext,
                                    trendLines.tooltext, hcConf.trendLineToolText)));
                                toolText = parseTooltext(toolText, [7, 15, 16, 17, 18, 19], {
                                    startValue: trendStartValue,
                                    startDataValue: hcConf.numberFormatter[NFMethodName](trendStartValue, axisIndex),
                                    endValue: trendEndValue,
                                    endDataValue: hcConf.numberFormatter[NFMethodName](trendEndValue, axisIndex),
                                    axisName: axisObj.title && axisObj.title.text
                                }, trendLineObj);

                                width = pluckNumber(trendLineObj.thickness, hcConf.trendlineThickness, 1);

                                if (isZone) {
                                    axisObj.plotBands.push({
                                        isTrend: true,
                                        color: convertColor(pluck(trendLineObj.color, hcConf.trendlineColor),
                                            pluck(trendLineObj.alpha, hcConf.trendlineAlpha, 40)),
                                        from: trendStartValue,
                                        to: trendEndValue,
                                        label: trendLabelObj,
                                        //for 3d series never will be on top
                                        zIndex: !hcConf.is3d && pluck(trendLineObj.showontop,
                                            hcConf.showTrendlinesOnTop) === ONESTRING ? 5 : 3,
                                        tooltext: toolText,
                                        alwaysVisible: trendLineObj.alwaysVisible
                                    });
                                }
                                else {
                                    axisObj.plotLines.push({
                                        isTrend: true,
                                        color: convertColor(pluck(trendLineObj.color, hcConf.trendlineColor,
                                        hcConf.trendlineColor), pluck(trendLineObj.alpha, hcConf.trendlineAlpha, 99)),
                                        value: trendStartValue,
                                        to: trendEndValue,
                                        width: width,
                                        dashStyle: pluck(trendLineObj.dashed, hcConf.trendlinesAreDashed) == ONESTRING ?
                                            getDashStyle(pluckNumber(trendLineObj.dashlen, hcConf.trendlinesDashLen),
                                            pluckNumber(trendLineObj.dashgap, hcConf.trendlinesDashGap), width) :
                                                undefined,
                                        label: trendLabelObj,
                                        //for 3d series never will be on top
                                        zIndex: !hcConf.is3d && pluck(trendLineObj.showontop,
                                            hcConf.showTrendlinesOnTop) === ONESTRING ? 5 : 3,
                                        tooltext: toolText
                                    });
                                }

                            }
                        }
                    }
                }
            };
        })(),
        //Function to convert FC dash style to HC dash style
        /** @todo hsve to do */
        getDashStyle = function(len, gap, thickness, apply) {
            return (apply || apply === undefined) ? [len, gap] : BLANK;

            /** @todo remove legacy code
             if (apply || apply === undefined) {
             thickness = thickness ? thickness : 1;
             return (pluckNumber(len, 5) / thickness) + COMMA + (pluckNumber(gap, 3) / thickness);
             }
             else {
             return undefined;
             }*/

        },
        /**
         * Internally used to create a chart api store. Creating chart api store in
         * this way (instead of just creating a new object,) allows us to easily
         * identify whether an object is part of chartAPI or not.
         * @constructor
         * @private
         */
        ChartAPIItem = function() {
        },
        /**
         * Function to define chart-api and configuration. This has to be used to
         * define the configuration of various chart types.
         *
         * @param {string} type specifies the name of the chart/series for which
         * the API has to be set.
         *
         * @param {object} api is the key-value pair that defines various object.
         *
         * @param {ChartAPIItem} parent refers to the possibility of inheriting this
         * new chart from an existing chart.
         *
         * @type object
         * @return The chartAPI created from the mapping api provided.
         *
         * @example
         * chartAPI('column', {
         *     series: {
         *         sample: function () { return 'column.series.sample'; }
         *     },
         *     point: function () {};
         * });
         * var column2d = chartAPI('column2d', {
         *     series: 'column'
         * });
         *
         * column2d.series.sample2 = function () {
         *     return 'column2d.series.sample2';
         * };
         *
         * // Also be accessed as:
         * chartAPI.column.point();
         */
        chartAPI = function(type, api, parent) {
            var item,
                typeAPI = chartAPI[type],
                ExtensibleTypeObject,
                IAPIInterface;

            // If the object that holds the chart API is not already defined,
            // then we set the api to a blank object.
            if (!typeAPI) {
                IAPIInterface = function() {
                };
                // If a parent APIItem is specified, we set the prototype of the new
                // item as the parent.
                IAPIInterface.prototype = parent instanceof ChartAPIItem ?
                    parent : new ChartAPIItem();
                IAPIInterface.prototype.constructor = IAPIInterface;
                typeAPI = chartAPI[type] = new IAPIInterface();
            }

            // Set the base api
            if (parent) {
                typeAPI.base = parent;
            }
            // Set the type name
            typeAPI.name = type;

            // Now we loop through the entire set of groups (immediate sibling)
            // in the API and depending upon its type, we perform various actions.
            for (item in api) {
                switch (typeof api[item]) {
                    // If the value is string, we know it is an instruction to
                    // inherit the object from the typeName specified as value.
                    case OBJECTSTRING:
                        if (api[item] instanceof ChartAPIItem) {
                            typeAPI[item] = api[item][item];
                            break;
                        }
                        // Otherwise we know that we are to simply set the API as
                        // provided.
                        /* falls through */
                    default:
                        typeAPI[item] = api[item];
                        break;

                        // In case the value is undefined, we know that the instruction
                        // is to delete that API item.
                    case STRINGUNDEFINED:
                        delete typeAPI[item];
                        break;

                }
            }

            // If a new instance is wanted, create one and return
            if (this instanceof chartAPI) {
                ExtensibleTypeObject = function() {};
                ExtensibleTypeObject.prototype = typeAPI;
                ExtensibleTypeObject.prototype.constructor = ExtensibleTypeObject;
                return new ExtensibleTypeObject();
            }
            else {
                // Return the resultant chart API created from the above algorithm.
                return typeAPI;
            }
        },
        /*
         * parser for tooltip macros
         *
         */
        parseTooltext = (function() {
            var macroList = [
                {//0- cleanValue
                    regex: /((^|[^\\])((\\)\\)*\$cleanvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$cleanvalue))/ig,
                    argIndex: 2,
                    argKey: 'cleanvalue'
                },
                {//1- dataValue
                    regex: /((^|[^\\])((\\)\\)*\$datavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$datavalue))/ig,
                    argIndex: 2,
                    argKey: 'formattedValue'
                },
                {//2- value
                    regex: /((^|[^\\])((\\)\\)*\$value)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$value))/ig,
                    argIndex: 3,
                    argKey: 'value'
                },
                {//3- label
                    regex: /((^|[^\\])((\\)\\)*\$label)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$label))/ig,
                    argIndex: 2,
                    argKey: 'label'
                },
                {//4- seriesName
                    regex: /((^|[^\\])((\\)\\)*\$seriesname)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$seriesname))/ig,
                    argIndex: 5,
                    argKey: 'seriesname'
                },
                {//5- yAxisName
                    regex: /((^|[^\\])((\\)\\)*\$yaxisname)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$yaxisname))/ig,
                    argIndex: 2,
                    argKey: 'yaxisName'
                },
                {//6- xAxisName
                    regex: /((^|[^\\])((\\)\\)*\$xaxisname)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$xaxisname))/ig,
                    argIndex: 2,
                    argKey: 'xaxisName'
                },
                {//7- displayValue
                    regex: /((^|[^\\])((\\)\\)*\$displayvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$displayvalue))/ig,
                    argIndex: 3,
                    argKey: 'displayvalue'
                },
                {//8- xDataValue
                    regex: /((^|[^\\])((\\)\\)*\$xdatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$xdatavalue))/ig,
                    argIndex: 2,
                    argKey: 'xDataValue'
                },
                {//9- yDataValue
                    regex: /((^|[^\\])((\\)\\)*\$ydatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$ydatavalue))/ig,
                    argIndex: 2,
                    argKey: 'yDataValue'
                },
                {//10- xValue
                    regex: /((^|[^\\])((\\)\\)*\$xvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$xvalue))/ig,
                    argIndex: 3,
                    argKey: 'x'
                },
                {//11- yValue
                    regex: /((^|[^\\])((\\)\\)*\$yvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$yvalue))/ig,
                    argIndex: 3,
                    argKey: 'y'
                },
                {//12- zValue
                    regex: /((^|[^\\])((\\)\\)*\$zvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$zvalue))/ig,
                    argIndex: 3,
                    argKey: 'z'
                },
                {//13- name
                    regex: /((^|[^\\])((\\)\\)*\$name)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$name))/ig,
                    argIndex: 3,
                    argKey: 'name'
                },
                {//14- percentValue
                    regex: /((^|[^\\])((\\)\\)*\$percentValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$percentValue))/ig,
                    argIndex: 2,
                    argKey: 'percentValue'
                },
                {//15- startValue
                    regex: /((^|[^\\])((\\)\\)*\$startValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$startValue))/ig,
                    argIndex: 2,
                    argKey: 'startValue'
                },
                {//16- startDataValue
                    regex: /((^|[^\\])((\\)\\)*\$startDataValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$startDataValue))/ig,
                    argIndex: 2,
                    argKey: 'startDataValue'
                },
                {//17- endValue
                    regex: /((^|[^\\])((\\)\\)*\$endValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$endValue))/ig,
                    argIndex: 2,
                    argKey: 'endValue'
                },
                {//18- endDataValue
                    regex: /((^|[^\\])((\\)\\)*\$endDataValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$endDataValue))/ig,
                    argIndex: 2,
                    argKey: 'endDataValue'
                },
                {//19- axisName
                    regex: /((^|[^\\])((\\)\\)*\$axisName)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$axisName))/ig,
                    argIndex: 2,
                    argKey: 'axisName'
                },
                {//20- cumulativeValue
                    regex: /((^|[^\\])((\\)\\)*\$cumulativevalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$cumulativevalue))/ig,
                    argIndex: 2,
                    argKey: 'cumulativeValue'
                },
                {//21- cumulativeDataValue
                    regex: /((^|[^\\])((\\)\\)*\$cumulativedatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$cumulativedatavalue))/ig,
                    argIndex: 2,
                    argKey: 'cumulativeDataValue'
                },
                {//22- cumulativePercentValue
                    regex: /((^|[^\\])((\\)\\)*\$cumulativePercentValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$cumulativePercentValue))/ig,
                    argIndex: 2,
                    argKey: 'cumulativePercentValue'
                },
                {//23- cumulativePercentDataValue
                    regex: /((^|[^\\])((\\)\\)*\$cumulativepercentdatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$cumulativepercentdatavalue))/ig,
                    argIndex: 2,
                    argKey: 'cumulativePercentDataValue'
                },
                {//24- sum
                    regex: /((^|[^\\])((\\)\\)*\$sum)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$sum))/ig,
                    argIndex: 2,
                    argKey: 'sum'
                },
                {//25- unformattedSum
                    regex: /((^|[^\\])((\\)\\)*\$unformattedsum)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedsum))/ig,
                    argIndex: 2,
                    argKey: 'unformattedSum'
                },
                //widgets
                {//26- targetValue
                    regex: /((^|[^\\])((\\)\\)*\$targetvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$targetvalue))/ig,
                    argIndex: 2,
                    argKey: 'targetValue'
                },
                {//27- targetDataValue
                    regex: /((^|[^\\])((\\)\\)*\$targetdatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$targetdatavalue))/ig,
                    argIndex: 2,
                    argKey: 'targetDataValue'
                },
                {//28- processName
                    regex: /((^|[^\\])((\\)\\)*\$processname)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$processname))/ig,
                    argIndex: 2,
                    argKey: 'processName'
                },
                {//29- start
                    regex: /((^|[^\\])((\\)\\)*\$start)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$start))/ig,
                    argIndex: 2,
                    argKey: 'start'
                },
                {//30- end
                    regex: /((^|[^\\])((\\)\\)*\$end)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$end))/ig,
                    argIndex: 2,
                    argKey: 'end'
                },
                {//31- percentComplete
                    regex: /((^|[^\\])((\\)\\)*\$percentcomplete)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$percentcomplete))/ig,
                    argIndex: 2,
                    argKey: 'percentComplete'
                },
                {//32- taskPercentComplete
                    regex: /((^|[^\\])((\\)\\)*\$taskpercentcomplete)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$taskpercentcomplete))/ig,
                    argIndex: 2,
                    argKey: 'taskPercentComplete'
                },
                {//33- taskStartDate
                    regex: /((^|[^\\])((\\)\\)*\$taskstartdate)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$taskstartdate))/ig,
                    argIndex: 2,
                    argKey: 'taskStartDate'
                },
                {//34- taskEndDate
                    regex: /((^|[^\\])((\\)\\)*\$taskenddate)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$taskenddate))/ig,
                    argIndex: 2,
                    argKey: 'taskEndDate'
                },
                {//35- taskLabel
                    regex: /((^|[^\\])((\\)\\)*\$tasklabel)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$tasklabel))/ig,
                    argIndex: 2,
                    argKey: 'taskLabel'
                },
                {//36- date
                    regex: /((^|[^\\])((\\)\\)*\$date)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$date))/ig,
                    argIndex: 2,
                    argKey: 'date'
                },
                {//37- percentOfPrevValue
                    regex: /((^|[^\\])((\\)\\)*\$percentofprevvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$percentofprevvalue))/ig,
                    argIndex: 2,
                    argKey: 'percentOfPrevValue'
                },
                //maps
                {//38- sName
                    regex: /((^|[^\\])((\\)\\)*\$sname)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$sname))/ig,
                    argIndex: 2,
                    argKey: 'sName'
                },
                {//39- lName
                    regex: /((^|[^\\])((\\)\\)*\$lname)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$lname))/ig,
                    argIndex: 2,
                    argKey: 'lName'
                },
                {//40- fromId
                    regex: /((^|[^\\])((\\)\\)*\$fromid)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromid))/ig,
                    argIndex: 2,
                    argKey: 'fromId'
                },
                {//41- fromLabel
                    regex: /((^|[^\\])((\\)\\)*\$fromlabel)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromlabel))/ig,
                    argIndex: 2,
                    argKey: 'fromLabel'
                },
                {//42- toId
                    regex: /((^|[^\\])((\\)\\)*\$toid)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toid))/ig,
                    argIndex: 2,
                    argKey: 'toId'
                },
                {//43- toLabel
                    regex: /((^|[^\\])((\\)\\)*\$tolabel)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$tolabel))/ig,
                    argIndex: 2,
                    argKey: 'toLabel'
                },
                //Power Charts
                {//44- fromXValue
                    regex: /((^|[^\\])((\\)\\)*\$fromxvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromxvalue))/ig,
                    argIndex: 2,
                    argKey: 'fromXValue'
                },
                {//45- fromYValue
                    regex: /((^|[^\\])((\\)\\)*\$fromyvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromyvalue))/ig,
                    argIndex: 2,
                    argKey: 'fromYValue'
                },
                {//46- fromXDataValue
                    regex: /((^|[^\\])((\\)\\)*\$fromxdatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromxdatavalue))/ig,
                    argIndex: 2,
                    argKey: 'fromXDataValue'
                },
                {//47- fromYDataValue
                    regex: /((^|[^\\])((\\)\\)*\$fromydatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromydatavalue))/ig,
                    argIndex: 2,
                    argKey: 'fromYDataValue'
                },
                {//48- fromLabel
                    regex: /((^|[^\\])((\\)\\)*\$fromlabel)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromlabel))/ig,
                    argIndex: 2,
                    argKey: 'fromLabel'
                },
                {//49- toXValue
                    regex: /((^|[^\\])((\\)\\)*\$toxvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toxvalue))/ig,
                    argIndex: 2,
                    argKey: 'toXValue'
                },
                {//50- toYValue
                    regex: /((^|[^\\])((\\)\\)*\$toyvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toyvalue))/ig,
                    argIndex: 2,
                    argKey: 'toYValue'
                },
                {//51- toXDataValue
                    regex: /((^|[^\\])((\\)\\)*\$toxdatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toxdatavalue))/ig,
                    argIndex: 2,
                    argKey: 'toXDataValue'
                },
                {//52- toYDataValue
                    regex: /((^|[^\\])((\\)\\)*\$toydatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toydatavalue))/ig,
                    argIndex: 2,
                    argKey: 'toYDataValue'
                },
                {//53- toLabel
                    regex: /((^|[^\\])((\\)\\)*\$tolabel)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$tolabel))/ig,
                    argIndex: 2,
                    argKey: 'toLabel'
                },
                // Spark Charts
                {//54- openValue
                    regex: /((^|[^\\])((\\)\\)*\$openvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$openvalue))/ig,
                    argIndex: 2,
                    argKey: 'openValue'
                },
                {//55- closeValue
                    regex: /((^|[^\\])((\\)\\)*\$closevalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$closevalue))/ig,
                    argIndex: 2,
                    argKey: 'closeValue'
                },
                {//56- highValue
                    regex: /((^|[^\\])((\\)\\)*\$highvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$highvalue))/ig,
                    argIndex: 2,
                    argKey: 'highValue'
                },
                {//57- lowValue
                    regex: /((^|[^\\])((\\)\\)*\$lowvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$lowvalue))/ig,
                    argIndex: 2,
                    argKey: 'lowValue'
                },
                {//58- openDataValue
                    regex: /((^|[^\\])((\\)\\)*\$opendatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$opendatavalue))/ig,
                    argIndex: 2,
                    argKey: 'openDataValue'
                },
                {//59- closeDataValue
                    regex: /((^|[^\\])((\\)\\)*\$closedatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$closedatavalue))/ig,
                    argIndex: 2,
                    argKey: 'closeDataValue'
                },
                {//60- highDataValue
                    regex: /((^|[^\\])((\\)\\)*\$highdatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$highdatavalue))/ig,
                    argIndex: 2,
                    argKey: 'highDataValue'
                },
                {//61- lowDataValue
                    regex: /((^|[^\\])((\\)\\)*\$lowdatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$lowdatavalue))/ig,
                    argIndex: 2,
                    argKey: 'lowDataValue'
                }, {// 62 - maxValue
                    regex: /((^|[^\\])((\\)\\)*\$maxvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$maxvalue))/ig,
                    argIndex: 2,
                    argKey: 'maxValue'
                }, {// 63 - maxDataValue
                    regex: /((^|[^\\])((\\)\\)*\$maxdatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$maxdatavalue))/ig,
                    argIndex: 2,
                    argKey: 'maxDataValue'
                }, {// 64 - minValue
                    regex: /((^|[^\\])((\\)\\)*\$minvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$minvalue))/ig,
                    argIndex: 2,
                    argKey: 'minValue'
                }, {// 65 - minDataValue
                    regex: /((^|[^\\])((\\)\\)*\$mindatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$mindatavalue))/ig,
                    argIndex: 2,
                    argKey: 'minDataValue'
                }, {// 66 - Q1
                    regex: /((^|[^\\])((\\)\\)*\$q1)/ig,
                    argIndex: 2,
                    argKey: 'Q1'
                }, {// 67 - unformattedQ1
                    regex: /((^|[^\\])((\\)\\)*\$unformattedQ1)/ig,
                    argIndex: 2,
                    argKey: 'unformattedQ1'
                }, {// 68 - Q3
                    regex: /((^|[^\\])((\\)\\)*\$q3)/ig,
                    argIndex: 2,
                    argKey: 'Q3'
                }, {// 69 - unformattedQ3
                    regex: /((^|[^\\])((\\)\\)*\$unformattedQ3)/ig,
                    argIndex: 2,
                    argKey: 'unformattedQ3'
                }, {// 70 - median
                    regex: /((^|[^\\])((\\)\\)*\$median)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$median))/ig,
                    argIndex: 2,
                    argKey: 'median'
                }, {// 71 - unformattedMedian
                    regex: /((^|[^\\])((\\)\\)*\$unformattedMedian)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedMedian))/ig,
                    argIndex: 2,
                    argKey: 'unformattedMedian'
                }, {// 72 - SD
                    regex: /((^|[^\\])((\\)\\)*\$SD)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$SD))/ig,
                    argIndex: 2,
                    argKey: 'SD'
                }, {// 73 - unformattedSD
                    regex: /((^|[^\\])((\\)\\)*\$unformattedsd)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedsd))/ig,
                    argIndex: 2,
                    argKey: 'unformattedsd'
                }, {// 74 - QD
                    regex: /((^|[^\\])((\\)\\)*\$QD)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$QD))/ig,
                    argIndex: 2,
                    argKey: 'QD'
                }, {// 75 - unformattedQD
                    regex: /((^|[^\\])((\\)\\)*\$unformattedQD)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedQD))/ig,
                    argIndex: 2,
                    argKey: 'unformattedQD'
                }, {// 76 - MD
                    regex: /((^|[^\\])((\\)\\)*\$MD)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$MD))/ig,
                    argIndex: 2,
                    argKey: 'MD'
                }, {// 77 - unformattedMD
                    regex: /((^|[^\\])((\\)\\)*\$unformattedMD)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedMD))/ig,
                    argIndex: 2,
                    argKey: 'unformattedMD'
                }, {// 78 - mean
                    regex: /((^|[^\\])((\\)\\)*\$mean)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$mean))/ig,
                    argIndex: 2,
                    argKey: 'mean'
                }, {// 79 - unformattedMean
                    regex: /((^|[^\\])((\\)\\)*\$unformattedMean)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedMean))/ig,
                    argIndex: 2,
                    argKey: 'unformattedMean'
                }, {// 80 - unformattedMean
                    regex: /((^|[^\\])((\\)\\)*\$unformattedMean)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$unformattedMean))/ig,
                    argIndex: 2,
                    argKey: 'unformattedMean'
                }, {// 81 - volumeValue
                    regex: /((^|[^\\])((\\)\\)*\$volumeValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$volumeValue))/ig,
                    argIndex: 2,
                    argKey: 'volumeValue'
                }, {// 82 - volumeDataValue
                    regex: /((^|[^\\])((\\)\\)*\$volumeDataValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$volumeDataValue))/ig,
                    argIndex: 2,
                    argKey: 'volumeDataValue'
                }, {// 83 - fromXValue
                    regex: /((^|[^\\])((\\)\\)*\$fromXValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromXValue))/ig,
                    argIndex: 2,
                    argKey: 'fromXValue'
                }, {// 84 - fromYValue
                    regex: /((^|[^\\])((\\)\\)*\$fromYValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromYValue))/ig,
                    argIndex: 2,
                    argKey: 'fromYValue'
                }, {// 85 - fromXDataValue
                    regex: /((^|[^\\])((\\)\\)*\$fromXDataValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromXDataValue))/ig,
                    argIndex: 2,
                    argKey: 'fromXDataValue'
                }, {// 86 - fromYDataValue
                    regex: /((^|[^\\])((\\)\\)*\$fromYDataValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromYDataValue))/ig,
                    argIndex: 2,
                    argKey: 'fromYDataValue'
                }, {// 87 - fromLabel
                    regex: /((^|[^\\])((\\)\\)*\$fromLabel)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$fromLabel))/ig,
                    argIndex: 2,
                    argKey: 'fromLabel'
                }, {// 88 - toXValue
                    regex: /((^|[^\\])((\\)\\)*\$toXValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toXValue))/ig,
                    argIndex: 2,
                    argKey: 'toXValue'
                }, {// 89 - toYValue
                    regex: /((^|[^\\])((\\)\\)*\$toYValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toYValue))/ig,
                    argIndex: 2,
                    argKey: 'toYValue'
                }, {// 90 - toXDataValue
                    regex: /((^|[^\\])((\\)\\)*\$toXDataValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toXDataValue))/ig,
                    argIndex: 2,
                    argKey: 'toXDataValue'
                }, {// 91 - toYDataValue
                    regex: /((^|[^\\])((\\)\\)*\$toYDataValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$toYDataValue))/ig,
                    argIndex: 2,
                    argKey: 'toYDataValue'
                }, {// 92 - toLabel
                    regex: /((^|[^\\])((\\)\\)*\$tolabel)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$tolabel))/ig,
                    argIndex: 2,
                    argKey: 'toLabel'
                }, {// 93 - tlLabel
                    regex: /((^|[^\\])((\\)\\)*\$tlLabel)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$tlLabel))/ig,
                    argIndex: 5,
                    argKey: 'tlLabel'
                }, {// 94 - trLabel
                    regex: /((^|[^\\])((\\)\\)*\$trlabel)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$trlabel))/ig,
                    argIndex: 5,
                    argKey: 'trLabel'
                }, {// 95 - blLabel
                    regex: /((^|[^\\])((\\)\\)*\$bllabel)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$bllabel))/ig,
                    argIndex: 5,
                    argKey: 'blLabel'
                }, {// 96 - brLabel
                    regex: /((^|[^\\])((\\)\\)*\$brlabel)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$brlabel))/ig,
                    argIndex: 5,
                    argKey: 'brLabel'
                }, {// 97 - rowLabel
                    regex: /((^|[^\\])((\\)\\)*\$rowlabel)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$rowlabel))/ig,
                    argIndex: 5,
                    argKey: 'rowLabel'
                }, {// 98 - columnLabel
                    regex: /((^|[^\\])((\\)\\)*\$columnlabel)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$columnlabel))/ig,
                    argIndex: 5,
                    argKey: 'columnLabel'
                }, {// 99 - errorValue
                    regex: /((^|[^\\])((\\)\\)*\$errorvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$errorvalue))/ig,
                    argIndex: 2,
                    argKey: 'errorValue'
                }, {// 100 - errorDataValue
                    regex: /((^|[^\\])((\\)\\)*\$errordatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$errordatavalue))/ig,
                    argIndex: 2,
                    argKey: 'errorDataValue'
                }, {// 101 - errorPercentValue
                    regex: /((^|[^\\])((\\)\\)*\$errorpercentvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$errorpercentvalue))/ig,
                    argIndex: 2,
                    argKey: 'errorPercentValue'
                }, {// 102 - errorPercentDataValue
                    regex: /((^|[^\\])((\\)\\)*\$errorpercentdatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$errorpercentdatavalue))/ig,
                    argIndex: 2,
                    argKey: 'errorPercentDataValue'
                }, {// 103 - horizontalErrorValue
                    regex: /((^|[^\\])((\\)\\)*\$horizontalErrorValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$horizontalErrorValue))/ig,
                    argIndex: 2,
                    argKey: 'horizontalErrorValue'
                }, {// 104 - horizontalErrorDataValue
                    regex: /((^|[^\\])((\\)\\)*\$horizontalErrorDataValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$horizontalErrorDataValue))/ig,
                    argIndex: 2,
                    argKey: 'horizontalErrorDataValue'
                }, {// 105 - verticalErrorValue
                    regex: /((^|[^\\])((\\)\\)*\$verticalErrorValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$verticalErrorValue))/ig,
                    argIndex: 2,
                    argKey: 'verticalErrorValue'
                }, {// 106 - verticalErrorDataValue
                    regex: /((^|[^\\])((\\)\\)*\$verticalErrorDataValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$verticalErrorDataValue))/ig,
                    argIndex: 2,
                    argKey: 'verticalErrorDataValue'
                }, {// 107 - horizontalErrorPercent
                    regex: /((^|[^\\])((\\)\\)*\$horizontalErrorPercent)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$horizontalErrorPercentValue))/ig,
                    argIndex: 2,
                    argKey: 'horizontalErrorPercentValue'
                }, {// 108 - horizontalErrorPercentDataValue
                    regex: /((^|[^\\])((\\)\\)*\$horizontalErrorPercentDataValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$horizontalErrorPercentDataValue))/ig,
                    argIndex: 2,
                    argKey: 'horizontalErrorPercentDataValue'
                }, {// 109 - verticalErrorPercent
                    regex: /((^|[^\\])((\\)\\)*\$verticalErrorPercent)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$verticalErrorPercentValue))/ig,
                    argIndex: 2,
                    argKey: 'verticalErrorPercentValue'
                }, {// 110 - verticalErrorPercentDataValue
                    regex: /((^|[^\\])((\\)\\)*\$verticalErrorPercentDataValue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$verticalErrorPercentDataValue))/ig,
                    argIndex: 2,
                    argKey: 'verticalErrorPercentDataValue'
                },
                //Mactros that are added later
                {//111- xAxisPercentValue
                    regex: /((^|[^\\])((\\)\\)*\$xaxispercentvalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$xaxispercentvalue))/ig,
                    argIndex: 2,
                    argKey: 'xAxisPercentValue'
                }, {//112- percentDataValue
                    regex: /((^|[^\\])((\\)\\)*\$percentdatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$percentdatavalue))/ig,
                    argIndex: 2,
                    argKey: 'percentDataValue'
                }, {//113- trType
                    regex: /((^|[^\\])((\\)\\)*\$trType)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$trType))/ig,
                    argIndex: 4,
                    argKey: 'trtype'
                }, {//114- tlType
                    regex: /((^|[^\\])((\\)\\)*\$tlType)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$tlType))/ig,
                    argIndex: 4,
                    argKey: 'tltype'
                }, {//115- brType
                    regex: /((^|[^\\])((\\)\\)*\$brType)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$brType))/ig,
                    argIndex: 4,
                    argKey: 'brtype'
                }, {//116- blType
                    regex: /((^|[^\\])((\\)\\)*\$blType)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$blType))/ig,
                    argIndex: 4,
                    argKey: 'bltype'
                }, {//117- colorRangeLabel
                    regex: /((^|[^\\])((\\)\\)*\$colorRangeLabel)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$colorRangeLabel))/ig,
                    argIndex: 5,
                    argKey: 'colorRangeLabel'
                }, {//118- zDataValue
                    regex: /((^|[^\\])((\\)\\)*\$zdatavalue)/ig,
                    escapeRegex: /((^|[^\\])((\\)\\)*\\(\$zdatavalue))/ig,
                    argIndex: 2,
                    argKey: 'zDataValue'
                }
            ],
                defAllMacroIndices = [],
                replaceConstant = '$2$4',
                escapeReplaceStr = '$2$4$5',
                i,
                l = macroList.length;

            //preaper defApplyAllArr
            for (i = 0; i < l; i += 1) {
                defAllMacroIndices.push(i);
            }

            return function() {
                var returnText = arguments[0],
                    ApplicableMacroIndices = arguments[1],
                    replaceStr,
                    argObj,
                    macroObj,
                    i,
                    l;
                if (!isArray(ApplicableMacroIndices)) {
                    ApplicableMacroIndices = defAllMacroIndices;
                }
                if (returnText) {
                    l = ApplicableMacroIndices.length;
                    for (i = 0; i < l; i += 1) {
                        macroObj = macroList[ApplicableMacroIndices[i]];
                        if (macroObj) {
                            replaceStr = regReplaceEscape(getValidValue((argObj = arguments[macroObj.argIndex]) &&
                                argObj[macroObj.argKey], BLANK) + BLANK);
                            returnText = returnText.replace(macroObj.regex,
                                replaceConstant + (macroObj.parsingMethod ? macroObj.parsingMethod(replaceStr) :
                                    replaceStr));
                            returnText = returnText.replace(macroObj.escapeRegex, escapeReplaceStr);

                        }
                    }
                }
                return returnText;
            };
        }());

    /**
     * Sets the internal line-height calculation factor
     * @param {number} factor
     * @memberOf FusionCharts~
     * @private
     */
    global.core._setLineHeightFactor = function (factor) {
        factor = toFloat(factor);

        if (!factor || factor < 0) {
            return;
        }
        lib.lineHeightFactor = factor;
    };

    // Add Renderer global library
    global.extend(lib, {
        BLANKSTRINGPLACEHOLDER: BLANKSTRINGPLACEHOLDER,
        BLANKSTRING: BLANK,
        COLOR_BLACK: COLOR_BLACK,
        COLOR_GLASS: COLOR_GLASS,
        COLOR_WHITE: COLOR_WHITE,
        COLOR_TRANSPARENT: COLOR_TRANSPARENT,
        HASHSTRING: HASHSTRING,
        BREAKSTRING: BREAKSTRING,
        STRINGSTRING: STRINGSTRING,
        OBJECTSTRING: OBJECTSTRING,
        COMMASTRING: COMMA,
        ZEROSTRING: ZEROSTRING,
        SAMPLESTRING: 'Ay0',
        TESTSTR: TESTSTR,
        ONESTRING: ONESTRING,
        DECIMALSTRING: DECIMALSTRING,
        STRINGUNDEFINED: STRINGUNDEFINED,
        POSITION_TOP: POSITION_TOP,
        POSITION_RIGHT: POSITION_RIGHT,
        POSITION_BOTTOM: POSITION_BOTTOM,
        POSITION_LEFT: POSITION_LEFT,
        POSITION_CENTER: POSITION_CENTER,
        POSITION_MIDDLE: POSITION_MIDDLE,
        POSITION_START: POSITION_START,
        POSITION_END: POSITION_END,
        FC_CONFIG_STRING: FC_CONFIG_STRING,
        SHAPE_RECT: SHAPE_RECT,
        HUNDREDSTRING: HUNDREDSTRING,
        PXSTRING: PXSTRING,
        COMMASPACE: COMMASPACE,
        TEXTANCHOR: TEXTANCHOR,
        TOUCH_THRESHOLD_PIXELS: TOUCH_THRESHOLD_PIXELS,
        CLICK_THRESHOLD_PIXELS: CLICK_THRESHOLD_PIXELS,
        regex: {
            stripWhitespace: stripWhitespace,
            dropHash: dropHash,
            startsRGBA: startsRGBA,
            cleanColorCode: cleanColorCode,
            breakPlaceholder: breakPlaceholder,
            hexcode: hexcode
        },
        fireEvent: fireEvent,
        plotEventHandler: plotEventHandler,
        getEventCoordinate: getEventCoordinate,
        getMouseCoordinate: getMouseCoordinate,
        addEvent: addEvent,
        removeEvent: removeEvent,
        getTouchEvent: getTouchEvent,
        extend2: extend2,
        deltend: deltend,
        imprint: imprint,
        pluck: pluck,
        pluckNumber: pluckNumber,
        getFirstDefinedValue: getFirstDefinedValue,
        createElement: createElement,
        hashify: hashify,
        pluckFontSize: pluckFontSize,
        getValidValue: getValidValue,
        getPosition: getPosition,
        getViewPortDimension: getViewPortDimension,
        bindSelectionEvent: bindSelectionEvent,
        createContextMenu: createContextMenu,
        getDefinedColor: getDefinedColor,
        getFirstValue: getFirstValue,
        getFirstColor: getFirstColor,
        getColorCodeString: getColorCodeString,
        pluckColor: pluckColor,
        toRaphaelColor: toRaphaelColor,
        gradientify: gradientify,
        trimString: trimString,
        getFirstAlpha: getFirstAlpha,
        parsePointValue: parsePointValue,
        parseUnsafeString: parseUnsafeString,
        parseTooltext: parseTooltext,
        toPrecision: toPrecision,
        hasTouch: hasTouch,
        CREDIT_HREF: CREDIT_HREF,
        CREDIT_STRING: CREDIT_STRING,
        getSentenceCase: getSentenceCase,
        getCrispValues: getCrispValue,
        regescape: regescape,
        regReplaceEscape: regReplaceEscape,
        isArray: isArray,
        stubFN: function() {
        },
        falseFN: function() {
            return false;
        },
        /*
         * Utility method that sorts an object array and keeping the order of equal items.
         * ECMA script standard does not specify the behavior when items are equal.
         */
        stableSort: function(arr, sortFunction) {
            var length = arr.length,
                i;

            // Add index to each item
            for (i = 0; i < length; i++) {
                arr[i].ssI = i; // stable sort index
            }

            arr.sort(function(a, b) {
                var sortValue = sortFunction(a, b);
                return sortValue === 0 ? a.ssI - b.ssI : sortValue;
            });

            // Remove index from items
            for (i = 0; i < length; i++) {
                delete arr[i].ssI; // stable sort index
            }
        },
        hasSVG: hasSVG,
        isIE: isIE,
        lineHeightFactor: 1.2,
        getLinkAction: getLinkAction,
        graphics: {
            parseAlpha: parseAlpha,
            convertColor: convertColor,
            getDarkColor: getDarkColor,
            getLightColor: getLightColor,
            mapSymbolName: mapSymbolName,
            getColumnColor: getColumnColor,
            getAngle: getAngle,
            parseColor: parseColor,
            getValidColor: getValidColor,
            HSBtoRGB: HSBtoRGB,
            RGBtoHSB: RGBtoHSB,
            RGBtoHex: RGBtoHex,
            HEXtoRGB: hexToRgb
        },
        setImageDisplayMode: setImageDisplayMode,
        setLineHeight: setLineHeight,
        parsexAxisStyles: parsexAxisStyles,
        supportedStyle: supportedStyle,
        getAxisLimits: getAxisLimits,
        createTrendLine: createTrendLine,
        getDashStyle: getDashStyle,
        axisLabelAdder: axisLabelAdder,
        chartAPI: chartAPI,
        createDialog: createDialog
    });
}]);



/**
 * FusionCharts module for RedRaphael integration
 * @private
 * @module fusioncharts.vendor.redraphael
 * @requires fusioncharts.renderer.javascript.lib
 */
window.FusionCharts && window.FusionCharts.register('module', ['private', 'vendor.redraphael', function () {
    var global = this,
        lib = global.hcLib,
        someRaphael = window.Raphael,
        eve,
        RedRaphael,
        optOutModulePattern = true;


    (function () {


/**!
 * RedRaphael 1.1.13 - JavaScript Vector Library
 * Copyright (c) 2012-2013 FusionCharts Technologies <http://www.fusioncharts.com>
 *
 * Raphael 2.1.0
 * Copyright (c) 2008-2012 Dmitry Baranovskiy <http://raphaeljs.com>
 * Copyright 짤 2008-2012 Sencha Labs <http://sencha.com>
 *
 * Licensed under the MIT license.
 */
// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ?뚢??????????????????????????????????????????????????????????????\\
// ??Eve 0.4.2 - JavaScript Events Library                      ??\\
// ?쒋??????????????????????????????????????????????????????????????\\
// ??Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) ??\\
// ?붴??????????????????????????????????????????????????????????????\\

(function (glob, optOutModulePattern) {
    var version = "0.4.2",
        has = "hasOwnProperty",
        separator = /[\.\/]/,
        wildcard = "*",
        fun = function () {},
        numsort = function (a, b) {
            return a - b;
        },
        current_event,
        stop,
        events = {n: {}},
    /*\
     * eve
     [ method ]

     * Fires event with given `name`, given scope and other parameters.

     > Arguments

     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
     - scope (object) context for the event handlers
     - varargs (...) the rest of arguments will be sent to event handlers

     = (object) array of returned values from the listeners
    \*/
        eve = function (name, scope) {
			name = String(name);
            var e = events,
                oldstop = stop,
                args = Array.prototype.slice.call(arguments, 2),
                listeners = eve.listeners(name),
                z = 0,
                f = false,
                l,
                indexed = [],
                queue = {},
                out = [],
                ce = current_event,
                errors = [];
            current_event = name;
            stop = 0;
            for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
                indexed.push(listeners[i].zIndex);
                if (listeners[i].zIndex < 0) {
                    queue[listeners[i].zIndex] = listeners[i];
                }
            }
            indexed.sort(numsort);
            while (indexed[z] < 0) {
                l = queue[indexed[z++]];
                out.push(l.apply(scope, args));
                if (stop) {
                    stop = oldstop;
                    return out;
                }
            }
            for (i = 0; i < ii; i++) {
                l = listeners[i];
                if ("zIndex" in l) {
                    if (l.zIndex == indexed[z]) {
                        out.push(l.apply(scope, args));
                        if (stop) {
                            break;
                        }
                        do {
                            z++;
                            l = queue[indexed[z]];
                            l && out.push(l.apply(scope, args));
                            if (stop) {
                                break;
                            }
                        } while (l)
                    } else {
                        queue[l.zIndex] = l;
                    }
                } else {
                    out.push(l.apply(scope, args));
                    if (stop) {
                        break;
                    }
                }
            }
            stop = oldstop;
            current_event = ce;
            return out.length ? out : null;
        };
		// Undocumented. Debug only.
		eve._events = events;
    /*\
     * eve.listeners
     [ method ]

     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

     > Arguments

     - name (string) name of the event, dot (`.`) or slash (`/`) separated

     = (array) array of event handlers
    \*/
    eve.listeners = function (name) {
        var names = name.split(separator),
            e = events,
            item,
            items,
            k,
            i,
            ii,
            j,
            jj,
            nes,
            es = [e],
            out = [];
        for (i = 0, ii = names.length; i < ii; i++) {
            nes = [];
            for (j = 0, jj = es.length; j < jj; j++) {
                e = es[j].n;
                items = [e[names[i]], e[wildcard]];
                k = 2;
                while (k--) {
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };

    /*\
     * eve.on
     [ method ]
     **
     * Binds given event handler with a given name. You can use wildcards ??*`??for the names:
     | eve.on("*.under.*", f);
     | eve("mouse.under.floor"); // triggers f
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.
     > Example:
     | eve.on("mouse", eatIt)(2);
     | eve.on("mouse", scream);
     | eve.on("mouse", catchIt)(1);
     * This will ensure that `catchIt()` function will be called before `eatIt()`.
	 *
     * If you want to put your handler before non-indexed handlers, specify a negative value.
     * Note: I assume most of the time you don?셳 need to worry about z-index, but it?셲 nice to have this feature ?쐉ust in case??
    \*/
    eve.on = function (name, f) {
		name = String(name);
		if (typeof f != "function") {
			return function () {};
		}
        var names = name.split(separator),
            e = events;
        for (var i = 0, ii = names.length; i < ii; i++) {
            e = e.n;
            e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
        }
        e.f = e.f || [];
        for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
            return fun;
        }
        e.f.push(f);
        return function (zIndex) {
            if (+zIndex == +zIndex) {
                f.zIndex = +zIndex;
            }
        };
    };
    /*\
     * eve.f
     [ method ]
     **
     * Returns function that will fire given event with optional arguments.
	 * Arguments that will be passed to the result function will be also
	 * concated to the list of final arguments.
 	 | el.onclick = eve.f("click", 1, 2);
 	 | eve.on("click", function (a, b, c) {
 	 |     console.log(a, b, c); // 1, 2, [event object]
 	 | });
     > Arguments
	 - event (string) event name
	 - varargs (?? and any other arguments
	 = (function) possible event handler function
    \*/
	eve.f = function (event) {
		var attrs = [].slice.call(arguments, 1);
		return function () {
			eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
		};
	};
    /*\
     * eve.stop
     [ method ]
     **
     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
    \*/
    eve.stop = function () {
        stop = 1;
    };
    /*\
     * eve.nt
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     > Arguments
     **
     - subname (string) #optional subname of the event
     **
     = (string) name of the event, if `subname` is not specified
     * or
     = (boolean) `true`, if current event?셲 name contains `subname`
    \*/
    eve.nt = function (subname) {
        if (subname) {
            return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(current_event);
        }
        return current_event;
    };
    /*\
     * eve.nts
     [ method ]
     **
     * Could be used inside event handler to figure out actual name of the event.
     **
     **
     = (array) names of the event
    \*/
    eve.nts = function () {
        return current_event.split(separator);
    };
    /*\
     * eve.off
     [ method ]
     **
     * Removes given function from the list of event listeners assigned to given name.
	 * If no arguments specified all the events will be cleared.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
    \*/
    /*\
     * eve.unbind
     [ method ]
     **
     * See @eve.off
    \*/
    eve.off = eve.unbind = function (name, f) {
		if (!name) {
		    eve._events = events = {n: {}};
			return;
		}
        var names = name.split(separator),
            e,
            key,
            splice,
            i, ii, j, jj,
            cur = [events];
        for (i = 0, ii = names.length; i < ii; i++) {
            for (j = 0; j < cur.length; j += splice.length - 2) {
                splice = [j, 1];
                e = cur[j].n;
                if (names[i] != wildcard) {
                    if (e[names[i]]) {
                        splice.push(e[names[i]]);
                    }
                } else {
                    for (key in e) if (e[has](key)) {
                        splice.push(e[key]);
                    }
                }
                cur.splice.apply(cur, splice);
            }
        }
        for (i = 0, ii = cur.length; i < ii; i++) {
            e = cur[i];
            while (e.n) {
                if (f) {
                    if (e.f) {
                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
                            e.f.splice(j, 1);
                            break;
                        }
                        !e.f.length && delete e.f;
                    }
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        var funcs = e.n[key].f;
                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
                            funcs.splice(j, 1);
                            break;
                        }
                        !funcs.length && delete e.n[key].f;
                    }
                } else {
                    delete e.f;
                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                        delete e.n[key].f;
                    }
                }
                e = e.n;
            }
        }
    };
    /*\
     * eve.once
     [ method ]
     **
     * Binds given event handler with a given name to only run once then unbind itself.
     | eve.once("login", f);
     | eve("login"); // triggers f
     | eve("login"); // no listeners
     * Use @eve to trigger the listener.
     **
     > Arguments
     **
     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
     - f (function) event handler function
     **
     = (function) same return function as @eve.on
    \*/
    eve.once = function (name, f) {
        var f2 = function () {
            eve.unbind(name, f2);
            return f.apply(this, arguments);
        };
        return eve.on(name, f2);
    };
    /*\
     * eve.version
     [ property (string) ]
     **
     * Current version of the library.
    \*/
    eve.version = version;
    eve.toString = function () {
        return "You are running Eve " + version;
    };
    (typeof module != "undefined" && module.exports) ? (module.exports = eve) : (!optOutModulePattern && typeof define != "undefined" ? (define("eve", [], function() { return eve; })) : (glob.eve = eve));
})(this, (typeof optOutModulePattern != "undefined" ? optOutModulePattern : false));
/**!
 * RedRaphael 1.0.0 - JavaScript Vector Library
 * Copyright (c) 2012-2013 FusionCharts Technologies <http://www.fusioncharts.com>
 *
 * Raphael 2.1.0
 * Copyright (c) 2008-2012 Dmitry Baranovskiy <http://raphaeljs.com>
 * Copyright 짤 2008-2012 Sencha Labs <http://sencha.com>
 *
 * Licensed under the MIT license.
 */
(function (glob, factory, optOutModulePattern) {
    // AMD support
    if (!optOutModulePattern && typeof define === "function" && define.amd) {
        // Define as an anonymous module
        define(["eve"], function( eve ) {
            return factory(glob, eve);
        });
    } else {
        // Browser globals (glob is window)
        // Raphael adds itself to window
        factory(glob, glob.eve);
    }
}(this, function (window, eve) {
    /*\
     * Raphael
     [ method ]
     **
     * Creates a canvas object on which to draw.
     * You must do this first, as all future calls to drawing methods
     * from this instance will be bound to this canvas.
     > Parameters
     **
     - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface
     - width (number)
     - height (number)
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - x (number)
     - y (number)
     - width (number)
     - height (number)
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.
     - callback (function) #optional callback function which is going to be executed in the context of newly created paper
     * or
     - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eve?셲 ?쏡OMLoad??event. In this case method returns `undefined`.
     = (object) @Paper
     > Usage
     | // Each of the following examples create a canvas
     | // that is 320px wide by 200px high.
     | // Canvas is created at the viewport?셲 10,50 coordinate.
     | var paper = Raphael(10, 50, 320, 200);
     | // Canvas is created at the top left corner of the #notepad element
     | // (or its top right corner in dir="rtl" elements)
     | var paper = Raphael(document.getElementById("notepad"), 320, 200);
     | // Same as above
     | var paper = Raphael("notepad", 320, 200);
     | // Image dump
     | var set = Raphael(["notepad", 320, 200, {
     |     type: "rect",
     |     x: 10,
     |     y: 10,
     |     width: 25,
     |     height: 25,
     |     stroke: "#f00"
     | }, {
     |     type: "text",
     |     x: 30,
     |     y: 40,
     |     text: "Dump"
     | }]);
    \*/
    function R(first) {
        var args,
            f;

        // Code commented as resources will now be referenced using relative urls.
        // @todo Remove once we have acertained that there are no issues in any environment.
        // if (R._url) { // reinitialize URL to be safe from popstate event
        //     R._url = (R._g && R._g.win || window).location.href.replace(/#.*?$/, "");
        // }
        R._url = '';

        if (R.is(first, "function")) {
            return loaded ? first() : eve.on("raphael.DOMload", first);
        }
        else if (R.is(first, array)) {
            return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
        }
        else {
            args = Array.prototype.slice.call(arguments, 0);
            if (R.is(args[args.length - 1], "function")) {
                f = args.pop();
                return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on("raphael.DOMload", function() {
                    f.call(R._engine.create[apply](R, args));
                });
            } else {
                return R._engine.create[apply](R, arguments);
            }
        }
    }

    R.upgrade = "1.0.0";
    R.version = "2.1.0";
    R.eve = eve;
    RedRaphael = R;

    var loaded,

        undef,
        E = "",
        S = " ",
        proto = "prototype",
        has = "hasOwnProperty",
        appendChild = "appendChild",
        apply = "apply",
        concat = "concat",
        nu = "number",
        string = "string",
        array = "array",
        object = "object",
        finite = "finite",
        toString = "toString",
        fillString = "fill",
        push = "push",
        setAttribute = "setAttribute",
        split = "split",
        none = "none",
        black = "#000",
        OBJECTSTRING = "object",
        arrayToStr = "[object Array]",
        objectToStr = "[object Object]",
        arraySlice = Array.prototype.slice,
        arraySplice = Array.prototype.splice,
        hasPrototypeBug = (function () {
            var a = function () {};
            return a.hasOwnProperty("prototype");
        }()),
        g = {
            doc: document,
            win: window
        },
        oldRaphael = {
            was: Object.prototype[has].call(g.win, "Raphael"),
            is: g.win.Raphael
        },
        doc = g.doc,
        win = g.win,

        supportsTouch = R.supportsTouch = "createTouch" in doc,

        CustomAttributes = function () {
            /*\
             * Raphael.ca
             [ property (object) ]
             **
             * Shortcut for @Raphael.customAttributes
            \*/
            /*\
             * Raphael.customAttributes
             [ property (object) ]
             **
             * If you have a set of attributes that you would like to represent
             * as a function of some number across all papers you can do it
             * easily with custom attributes:
             > Usage
             | Raphael.customAttributes.hue = function (num) {
             |     num = num % 1;
             |     return {fill: "hsb(" + num + ", 0.75, 1)"};
             | };
             | // Custom attribute ?쐆ue??will change fill
             | // to be given hue with fixed saturation and brightness.
             | // Now you can use it like this:
             | var c = paper.circle(10, 10, 10).attr({hue: .45});
             | // or even like this:
             | c.animate({hue: 1}, 1e3);
             |
             | // You could also create custom attribute
             | // with multiple parameters:
             | Raphael.customAttributes.hsb = function (h, s, b) {
             |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
             | };
             | c.attr({hsb: "0.5 .8 1"});
             | c.animate({hsb: [1, 0, 0.5]}, 1e3);
            \*/
        },
        caproto = R.ca = R.customAttributes = CustomAttributes.prototype,

        Paper = function () {
            /*\
             * Paper.ca
             [ property (object) ]
             **
             * Shortcut for @Paper.customAttributes
            \*/
            /*\
             * Paper.customAttributes
             [ property (object) ]
             **
             * If you have a set of attributes that you would like to represent
             * as a function of some number you can do it easily with custom attributes:
             > Usage
             | paper.customAttributes.hue = function (num) {
             |     num = num % 1;
             |     return {fill: "hsb(" + num + ", 0.75, 1)"};
             | };
             | // Custom attribute ?쐆ue??will change fill
             | // to be given hue with fixed saturation and brightness.
             | // Now you can use it like this:
             | var c = paper.circle(10, 10, 10).attr({hue: .45});
             | // or even like this:
             | c.animate({hue: 1}, 1e3);
             |
             | // You could also create custom attribute
             | // with multiple parameters:
             | paper.customAttributes.hsb = function (h, s, b) {
             |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
             | };
             | c.attr({hsb: "0.5 .8 1"});
             | c.animate({hsb: [1, 0, 0.5]}, 1e3);
            \*/
            this.ca = this.customAttributes = new CustomAttributes();
            this._CustomAttributes = function () {};
            this._CustomAttributes.prototype = this.ca;
            this._elementsById = {};
            this.id = R._oid++;
            eve('raphael.new', this);
        },

        /*\
         * Raphael.fn
         [ property (object) ]
         **
         * You can add your own method to the canvas. For example if you want to draw a pie chart,
         * you can create your own pie chart function and ship it as a Rapha챘l plugin. To do this
         * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a
         * Rapha챘l instance is created, otherwise it will take no effect. Please note that the
         * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to
         * ensure any namespacing ensures proper context.
         > Usage
         | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {
         |     return this.path( ... );
         | };
         | // or create namespace
         | Raphael.fn.mystuff = {
         |     arrow: function () {??,
         |     star: function () {??,
         |     // etc??         | };
         | var paper = Raphael(10, 10, 630, 480);
         | // then use it
         | paper.arrow(10, 10, 30, 30, 5).attr({fill: "#f00"});
         | paper.mystuff.arrow();
         | paper.mystuff.star();
        \*/
        paperproto = R.fn = Paper.prototype = R.prototype,

        elements = {
            circle: 1,
            rect: 1,
            path: 1,
            ellipse: 1,
            text: 1,
            image: 1,
            group: 1
        },
        events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[split](S),
        touchMap = R._touchMap = {
            mousedown: "touchstart",
            mousemove: "touchmove",
            mouseup: "touchend"
        },

        Str = win.String,
        toFloat = win.parseFloat,
        toInt = win.parseInt,
        math = win.Math,
        mmax = math.max,
        mmin = math.min,
        abs = math.abs,
        pow = math.pow,
        mathCos = math.cos,
        mathSin = math.sin,
        mathSqrt = math.sqrt,
        round = math.round,
        PI = math.PI,
        deg2rad = PI / 180,
        rad2deg = 180 / PI,

        lowerCase = Str.prototype.toLowerCase,
        upperCase = Str.prototype.toUpperCase,
        objectToString = win.Object.prototype.toString,
        paper = {},

        separator = /[, ]+/,
        formatrg = /\{(\d+)\}/g,
        ISURL = R._ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
        colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
        bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
        whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g,
        commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,
        p2s = /,?([achlmqrstvxz]),?/gi,
        pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
        tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
        pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig,
        radial_gradient = R._radial_gradient = /^x?r(?:\(([^\)]*?)\))?/,

        isnan = {
            "NaN": 1,
            "Infinity": 1,
            "-Infinity": 1
        },
        hsrg = {
            hs: 1,
            rg: 1
        },
        availableAttrs = R._availableAttrs = {
            "arrow-end": none,
            "arrow-start": none,
            blur: 0,
            "clip-rect": "0 0 1e9 1e9",
            "clip-path": E,
            cursor: "default",
            cx: 0,
            cy: 0,
            fill: "#fff",
            "fill-opacity": 1,
            font: '10px "Arial"',
            "font-family": '"Arial"',
            "font-size": "10",
            "font-style": "normal",
            "font-weight": 400,
            gradient: 0,
            height: 0,
            href: "about:blank",
            "letter-spacing": 0,
            "line-height": 12,
            "vertical-align": "middle",
            opacity: 1,
            path: "M0,0",
            r: 0,
            rx: 0,
            ry: 0,
            src: E,
            stroke: "#000",
            "stroke-dasharray": E,
            "stroke-linecap": "butt",
            "stroke-linejoin": "butt",
            "stroke-miterlimit": 0,
            "stroke-opacity": 1,
            "stroke-width": 1,
            target: "_blank",
            "text-anchor": "middle",
            "visibility": E,
            title: E,
            transform: E,
            rotation: 0,
            width: 0,
            x: 0,
            y: 0
        },
        availableAnimAttrs = R._availableAnimAttrs = {
            blur: nu,
            "clip-rect": "csv",
            "clip-path": "path",
            cx: nu,
            cy: nu,
            fill: "colour",
            "fill-opacity": nu,
            "font-size": nu,
            height: nu,
            opacity: nu,
            path: "path",
            r: nu,
            rx: nu,
            ry: nu,
            stroke: "colour",
            "stroke-opacity": nu,
            "stroke-width": nu,
            transform: "transform",
            width: nu,
            x: nu,
            y: nu
        },
        eldata = {},

        sortByKey = function(a, b) {
            return a.key - b.key;
        },
        sortByNumber = function(a, b) {
            return toFloat(a) - toFloat(b);
        },
        fun = function() {
        },
        pipe = function(x) {
            return x;
        },

        rectPath = R._rectPath = function(x, y, w, h, r) {
            if (r) {
                return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
            }
            return [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
        },

        ellipsePath = function(x, y, rx, ry) {
            if (ry == null) {
                ry = rx;
            }
            return [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
        },

        getPath = R._getPath = {
            group: function() {
                return false;
            },
            path: function(el) {
                return el.attr("path");
            },
            circle: function(el) {
                var a = el.attrs;
                return ellipsePath(a.cx, a.cy, a.r);
            },
            ellipse: function(el) {
                var a = el.attrs;
                return ellipsePath(a.cx, a.cy, a.rx, a.ry);
            },
            rect: function(el) {
                var a = el.attrs;
                return rectPath(a.x, a.y, a.width, a.height, a.r);
            },
            image: function(el) {
                var a = el.attrs;
                return rectPath(a.x, a.y, a.width, a.height);
            },
            text: function(el) {
                var bbox = el._getBBox();
                return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
            }
        },

        /*\
         * Raphael.mapPath
         [ method ]
         **
         * Transform the path string with given matrix.
         > Parameters
         - path (string) path string
         - matrix (object) see @Matrix
         = (string) transformed path string
        \*/
        mapPath = R.mapPath = function(path, matrix) {
            if (!matrix) {
                return path;
            }
            var x,
                y,
                i,
                j,
                ii,
                jj,
                pathi;

            path = path2curve(path);
            for (i = 0, ii = path.length; i < ii; i++) {
                pathi = path[i];
                for (j = 1, jj = pathi.length; j < jj; j += 2) {
                    x = matrix.x(pathi[j], pathi[j + 1]);
                    y = matrix.y(pathi[j], pathi[j + 1]);
                    pathi[j] = x;
                    pathi[j + 1] = y;
                }
            }
            return path;
        },

        /*\
         * Raphael.pick
         [ method ]
         **
         * Returns the first truthy argument.
        \*/
        pick = R.pick = function() {
            for (var arg, i = 0, ii = arguments.length; i < ii; i += 1) {
                arg = arguments[i];
                if (!arg && arg !== false && arg !== 0) {
                    continue;
                }
                return arg;
            }
            return undef;
        },

        lastArgIfGroup = R._lastArgIfGroup = function (args, clear) {
            var last = args.length - 1,
                arg = args[last];

            if (arg && (arg.constructor === R.el.constructor) && arg.type === 'group') {
                if (clear) {
                    args[last] = undefined;
                    delete args[last];
                    arraySplice.call(args, last, 1);
                }
                return arg;
            }
        },

        serializeArgs = R._serializeArgs = function (args) {
            var arg0 = args[0],
                pathString,
                attrs,
                i,
                ii;

            if (R.is(arg0, 'object') && !R.is(arg0, 'array') && arg0.type !== 'group') {

                attrs = arg0;

                if (arg0.path) {
                    pathString = arg0.path;
                    pathString && !R.is(pathString, string) &&
                        !R.is(pathString[0], array) && (pathString += E);
                }

                for (i = 1, ii = arguments.length; i < ii; i += 2) {
                    if (!attrs[arguments[i]]) {
                        attrs[arguments[i]] = arguments[i + 1];
                    }
                }
            }
            else {
                attrs = {};
                for (i = 1, ii = arguments.length; i < ii; i += 2) {
                    attrs[arguments[i]] = args[(i-1) / 2] || arguments[i+1];
                }
            }
            return attrs;
        },

        merge = R.merge = function (obj1, obj2, skipUndef, tgtArr, srcArr) {
            var item,
                srcVal,
                tgtVal,
                str,
                cRef;
            //check whether obj2 is an array
            //if array then iterate through it's index
            //**** MOOTOOLS precution

            if (!srcArr) {
                tgtArr = [obj1];
                srcArr = [obj2];
            }
            else {
                tgtArr.push(obj1);
                srcArr.push(obj2);
            }

            if (obj2 instanceof Array) {
                for (item = 0; item < obj2.length; item += 1) {
                    try {
                        srcVal = obj1[item];
                        tgtVal = obj2[item];
                    }
                    catch (e) {
                        continue;
                    }

                    if (typeof tgtVal !== OBJECTSTRING) {
                        if (!(skipUndef && tgtVal === undefined)) {
                            obj1[item] = tgtVal;
                        }
                    }
                    else {
                        if (srcVal === null || typeof srcVal !== OBJECTSTRING) {
                            srcVal = obj1[item] = tgtVal instanceof Array ? [] : {};
                        }
                        cRef = checkCyclicRef(tgtVal, srcArr);
                        if (cRef !== -1) {
                            srcVal = obj1[item] = tgtArr[cRef];
                        }
                        else {
                            merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
                        }
                    }
                }
            }
            else {
                for (item in obj2) {
                    try {
                        srcVal = obj1[item];
                        tgtVal = obj2[item];
                    }
                    catch (e) {
                        continue;
                    }

                    if (tgtVal !== null && typeof tgtVal === OBJECTSTRING) {
                        // Fix for issue BUG: FWXT-602
                        // IE < 9 Object.prototype.toString.call(null) gives
                        // "[object Object]" instead of "[object Null]"
                        // that's why null value becomes Object in IE < 9
                        str = objectToString.call(tgtVal);
                        if (str === objectToStr) {
                            if (srcVal === null || typeof srcVal !== OBJECTSTRING) {
                                srcVal = obj1[item] = {};
                            }
                            cRef = checkCyclicRef(tgtVal, srcArr);
                            if (cRef !== -1) {
                                srcVal = obj1[item] = tgtArr[cRef];
                            }
                            else {
                                merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
                            }
                        }
                        else if (str === arrayToStr) {
                            if (srcVal === null || !(srcVal instanceof Array)) {
                                srcVal = obj1[item] = [];
                            }
                            cRef = checkCyclicRef(tgtVal, srcArr);
                            if (cRef !== -1) {
                                srcVal = obj1[item] = tgtArr[cRef];
                            }
                            else {
                                merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
                            }
                        }
                        else {
                            obj1[item] = tgtVal;
                        }
                    }
                    else {
                        obj1[item] = tgtVal;
                    }
                }
            }
            return obj1;
        },

        extend = R.extend = function (obj1, obj2, skipUndef) {
            if (typeof obj1 !== OBJECTSTRING && typeof obj2 !== OBJECTSTRING) {//if none of the arguments are object then return back
                return null;
            }

            if (typeof obj2 !== OBJECTSTRING || obj2 === null) {
                return obj1;
            }

            if (typeof obj1 !== OBJECTSTRING) {
                obj1 = obj2 instanceof Array ? [] : {};
            }
            merge(obj1, obj2, skipUndef);
            return obj1;

        },

        /*\
         * Raphael.is
         [ method ]
         **
         * Handfull replacement for `typeof` operator.
         > Parameters
         - o (?? any object or primitive
         - type (string) name of the type, i.e. ?쐓tring?? ?쐄unction?? ?쐍umber?? etc.
         = (boolean) is given value is of given type
        \*/
        is = R.is = function(o, type) {
            type = lowerCase.call(type);

            if (type == finite) {
                return !isnan[has](+o);
            }
            if (type == array) {
                return o instanceof Array;
            }
            if (type === 'object' && (o === undef || o === null)) {
                return false;
            }
            return  (type == "null" && o === null) ||
                (type == typeof o && o !== null) ||
                (type == object && o === Object(o)) ||
                (type == "array" && Array.isArray && Array.isArray(o)) ||
                objectToString.call(o).slice(8, -1).toLowerCase() == type;
        },
        /*\
          * Raphael.createUUID
          [ method ]
          **
          * Returns RFC4122, version 4 ID
         \*/
        createUUID = R.createUUID = (function(uuidRegEx, uuidReplacer) {
            return function() {
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
            };
        })(/[xy]/g, function(c) {
            var r = math.random() * 16 | 0,
                v = c == "x" ? r : (r & 3 | 8);
            return v.toString(16);
        }),
        /*\
          * Raphael.clone
          [ method ]
          **
          * Returns a recursively cloned version of an object.
         \*/
        clone = R.clone = hasPrototypeBug ? function (obj) {
                if (Object(obj) !== obj) {
                    return obj;
                }
                var res = new obj.constructor;
                for (var key in obj)
                    if (key !== "prototype" && obj[has](key)) {
                        res[key] = clone(obj[key]);
                    }
                return res;
            } : function (obj) {
                if (Object(obj) !== obj) {
                    return obj;
                }
                var res = new obj.constructor;
                for (var key in obj)
                    if (obj[has](key)) {
                        res[key] = clone(obj[key]);
                    }
                return res;
            };

    R._g = g;

    /*\
     * Raphael.type
     [ property (string) ]
     **
     * Can be ?쏶VG?? ?쏺ML??or empty, depending on browser support.
    \*/
    R.type = (win.ENABLE_RED_CANVAS && (win.CanvasRenderingContext2D || doc.createElement('canvas').getContext)) ? "CANVAS" :
            (win.SVGAngle || doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML");

    if (R.type == "VML") {
        var d = doc.createElement("div"),
            b;

        d.innerHTML = '<v:shape adj="1"/>';
        b = d.firstChild;
        b.style.behavior = "url(#default#VML)";
        if (!(b && typeof b.adj == object)) {
            return (R.type = E);
        }
        d = null;
    }

    /*\
     * Raphael.svg
     [ property (boolean) ]
     **
     * `true` if browser supports SVG.
    \*/
    /*\
     * Raphael.vml
     [ property (boolean) ]
     **
     * `true` if browser supports VML.
    \*/
    R.svg = !((R.vml = R.type == "VML") || (R.canvas = R.type == "CANVAS"));

    R._Paper = Paper;
    R._id = 0;
    R._oid = 0;

    /*\
     * Raphael.angle
     [ method ]
     **
     * Returns angle between two or three points
     > Parameters
     - x1 (number) x coord of first point
     - y1 (number) y coord of first point
     - x2 (number) x coord of second point
     - y2 (number) y coord of second point
     - x3 (number) #optional x coord of third point
     - y3 (number) #optional y coord of third point
     = (number) angle in degrees.
    \*/
    R.angle = function (x1, y1, x2, y2, x3, y3) {
        if (x3 == null) {
            var x = x1 - x2,
            y = y1 - y2;
            if (!x && !y) {
                return 0;
            }
            return (180 + math.atan2(-y, -x) * rad2deg + 360) % 360;
        }
        else {
            return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
        }
    };

    /*\
     * Raphael.rad
     [ method ]
     **
     * Transform angle to radians
     > Parameters
     - deg (number) angle in degrees
     = (number) angle in radians.
    \*/
    R.rad = function (deg) {
        return deg % 360 * deg2rad;
    };

    /*\
     * Raphael.deg
     [ method ]
     **
     * Transform angle to degrees
     > Parameters
     - deg (number) angle in radians
     = (number) angle in degrees.
    \*/
    R.deg = function (rad) {
        return rad * rad2deg % 360;
    };

    /*\
     * Raphael.snapTo
     [ method ]
     **
     * Snaps given value to given grid.
     > Parameters
     - values (array|number) given array of values or step of the grid
     - value (number) value to adjust
     - tolerance (number) #optional tolerance for snapping. Default is `10`.
     = (number) adjusted value.
    \*/
    R.snapTo = function (values, value, tolerance) {
        var rem,
            i;

        if (!is(tolerance, finite)) {
            tolerance = 10;
        }

        if (is(values, array)) {
            i = values.length;
            while (i--) {
                if (abs(values[i] - value) <= tolerance) {
                    return values[i];
                }
            }
        }
        else {
            values = +values;
            rem = value % values;

            if (rem < tolerance) {
                return value - rem;
            }
            if (rem > values - tolerance) {
                return value - rem + values;
            }
        }
        return value;
    };

    /*\
     * Raphael.setWindow
     [ method ]
     **
     * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.
     > Parameters
     - newwin (window) new window object
    \*/
    R.setWindow = function (newwin) {
        eve("raphael.setWindow", R, g.win, newwin);
        win = g.win = newwin;
        doc = g.doc = g.win.document;
        if (R._engine.initWin) {
            R._engine.initWin(g.win);
        }
    };

    var toHex = function (color) {
            if (R.vml) {
                // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
                var trim = /^\s+|\s+$/g;
                var bod;
                try {
                    var docum = new ActiveXObject("htmlfile");
                    docum.write("<body>");
                    docum.close();
                    bod = docum.body;
                } catch (e) {
                    bod = createPopup().document.body;
                }
                var range = bod.createTextRange();
                toHex = cacher(function(color) {
                    try {
                        bod.style.color = Str(color).replace(trim, E);
                        var value = range.queryCommandValue("ForeColor");
                        value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);
                        return "#" + ("000000" + value.toString(16)).slice(-6);
                    } catch (e) {
                        return none;
                    }
                });
            } else {
                var i = g.doc.createElement("i");
                i.title = "Rapha\xebl Colour Picker";
                i.style.display = none;
                g.doc.body.appendChild(i);
                toHex = cacher(function(color) {
                    i.style.color = color;
                    return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
                });
            }
            return toHex(color);
        },
        hsbtoString = function() {
            return "hsb(" + [this.h, this.s, this.b] + ")";
        },
        hsltoString = function() {
            return "hsl(" + [this.h, this.s, this.l] + ")";
        },
        rgbtoString = function() {
            return this.hex;
        },
        prepareRGB = function(r, g, b) {
            if (g == null && is(r, object) && "r" in r && "g" in r && "b" in r) {
                b = r.b;
                g = r.g;
                r = r.r;
            }
            if (g == null && is(r, string)) {
                var clr = R.getRGB(r);
                r = clr.r;
                g = clr.g;
                b = clr.b;
            }
            if (r > 1 || g > 1 || b > 1) {
                r /= 255;
                g /= 255;
                b /= 255;
            }

            return [r, g, b];
        },
        packageRGB = function(r, g, b, o) {
            var rgb = {
                r: (r *= 255),
                g: (g *= 255),
                b: (b *= 255),
                hex: R.rgb(r, g, b),
                toString: rgbtoString
            };
            is(o, "finite") && (rgb.opacity = o);
            return rgb;
        };

    /*\
     * Raphael.color
     [ method ]
     **
     * Parses the color string and returns object with all values for the given color.
     > Parameters
     - clr (string) color string in one of the supported formats (see @Raphael.getRGB)
     = (object) Combined RGB & HSB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #?™™™™™?
     o     error (boolean) `true` if string can?셳 be parsed,
     o     h (number) hue,
     o     s (number) saturation,
     o     v (number) value (brightness),
     o     l (number) lightness
     o }
    \*/
    R.color = function(clr) {
        var rgb;
        if (R.is(clr, object) && "h" in clr && "s" in clr && "b" in clr) {
            rgb = R.hsb2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else if (R.is(clr, object) && "h" in clr && "s" in clr && "l" in clr) {
            rgb = R.hsl2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else {
            if (R.is(clr, "string")) {
                clr = R.getRGB(clr);
            }
            if (R.is(clr, object) && "r" in clr && "g" in clr && "b" in clr) {
                rgb = R.rgb2hsl(clr);
                clr.h = rgb.h;
                clr.s = rgb.s;
                clr.l = rgb.l;
                rgb = R.rgb2hsb(clr);
                clr.v = rgb.b;
            } else {
                clr = {
                    hex: none
                };
                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
            }
        }
        clr.toString = rgbtoString;
        return clr;
    };

    /*\
     * Raphael.hsb2rgb
     [ method ]
     **
     * Converts HSB values to RGB object.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - v (number) value or brightness
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #?™™™™™?     o }
    \*/
    R.hsb2rgb = function(h, s, v, o) {
        if (this.is(h, object) && "h" in h && "s" in h && "b" in h) {
            v = h.b;
            s = h.s;
            h = h.h;
            o = h.o;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = v * s;
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = v - C;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };

    /*\
     * Raphael.hsl2rgb
     [ method ]
     **
     * Converts HSL values to RGB object.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue,
     o     hex (string) color in HTML/CSS format: #?™™™™™?     o }
    \*/
    R.hsl2rgb = function(h, s, l, o) {
        if (this.is(h, object) && "h" in h && "s" in h && "l" in h) {
            l = h.l;
            s = h.s;
            h = h.h;
        }
        if (h > 1 || s > 1 || l > 1) {
            h /= 360;
            s /= 100;
            l /= 100;
        }
        h *= 360;
        var R, G, B, X, C;
        h = (h % 360) / 60;
        C = 2 * s * (l < .5 ? l : 1 - l);
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = l - C / 2;

        h = ~~h;
        R += [C, X, 0, 0, X, C][h];
        G += [X, C, C, X, 0, 0][h];
        B += [0, 0, X, C, C, X][h];
        return packageRGB(R, G, B, o);
    };

    /*\
     * Raphael.rgb2hsb
     [ method ]
     **
     * Converts RGB values to HSB object.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSB object in format:
     o {
     o     h (number) hue
     o     s (number) saturation
     o     b (number) brightness
     o }
    \*/
    R.rgb2hsb = function(r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, V, C;
        V = mmax(r, g, b);
        C = V - mmin(r, g, b);
        H = (C == 0 ? null :
            V == r ? (g - b) / C :
            V == g ? (b - r) / C + 2 :
            (r - g) / C + 4
            );
        H = ((H + 360) % 6) * 60 / 360;
        S = C == 0 ? 0 : C / V;
        return {
            h: H,
            s: S,
            b: V,
            toString: hsbtoString
        };
    };

    /*\
     * Raphael.rgb2hsl
     [ method ]
     **
     * Converts RGB values to HSL object.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (object) HSL object in format:
     o {
     o     h (number) hue
     o     s (number) saturation
     o     l (number) luminosity
     o }
    \*/
    R.rgb2hsl = function(r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];

        var H, S, L, M, m, C;
        M = mmax(r, g, b);
        m = mmin(r, g, b);
        C = M - m;
        H = (C == 0 ? null :
            M == r ? (g - b) / C :
            M == g ? (b - r) / C + 2 :
            (r - g) / C + 4);
        H = ((H + 360) % 6) * 60 / 360;
        L = (M + m) / 2;
        S = (C == 0 ? 0 :
            L < .5 ? C / (2 * L) :
            C / (2 - 2 * L));
        return {
            h: H,
            s: S,
            l: L,
            toString: hsltoString
        };
    };

    R._path2string = function() {
        return this.join(",").replace(p2s, "$1");
    };

    function repush(array, item) {
        for (var i = 0, ii = array.length; i < ii; i++) {
            if (array[i] === item) {
                return array.push(array.splice(i, 1)[0]);
            }
        }
    }

    var cacher = R._cacher = function (f, scope, postprocessor) {
        function cachedfunction() {
            var arg = arraySlice.call(arguments, 0),
            args = arg.join("\u2400"),
            cache = cachedfunction.cache = cachedfunction.cache || {},
            count = cachedfunction.count = cachedfunction.count || [];
            if (cache[has](args)) {
                repush(count, args);
                return postprocessor ? postprocessor(cache[args]) : cache[args];
            }
            count.length >= 1e3 && delete cache[count.shift()];
            count.push(args);
            cache[args] = f[apply](scope, arg);
            return postprocessor ? postprocessor(cache[args]) : cache[args];
        }
        return cachedfunction;
    };

    var preload = R._preload = function(src, f) {
        var img = doc.createElement("img");
        img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
        img.onload = function() {
            f.call(this);
            this.onload = null;
            doc.body.removeChild(this);
        };
        img.onerror = function() {
            doc.body.removeChild(this);
        };
        doc.body.appendChild(img);
        img.src = src;
    };

    function clrToString() {
        return this.hex;
    }

    /*\
     * Raphael.getRGB
     [ method ]
     **
     * Parses colour string as RGB object
     > Parameters
     - colour (string) colour string in one of formats:
     # <ul>
     #     <li>Colour name (??code>red</code>?? ??code>green</code>?? ??code>cornflowerblue</code>?? etc)</li>
     #     <li>#?™™???shortened HTML colour: (??code>#000</code>?? ??code>#fc0</code>?? etc)</li>
     #     <li>#?™™™™™???full length HTML colour: (??code>#000000</code>?? ??code>#bd2300</code>??</li>
     #     <li>rgb(?™™? ?™™? ?™™? ??red, green and blue channels??values: (??code>rgb(200,&nbsp;100,&nbsp;0)</code>??</li>
     #     <li>rgb(?™™?, ?™™?, ?™™?) ??same as above, but in %: (??code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>??</li>
     #     <li>hsb(?™™? ?™™? ?™™? ??hue, saturation and brightness values: (??code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>??</li>
     #     <li>hsb(?™™?, ?™™?, ?™™?) ??same as above, but in %</li>
     #     <li>hsl(?™™? ?™™? ?™™? ??same as hsb</li>
     #     <li>hsl(?™™?, ?™™?, ?™™?) ??same as hsb</li>
     # </ul>
     = (object) RGB object in format:
     o {
     o     r (number) red,
     o     g (number) green,
     o     b (number) blue
     o     hex (string) color in HTML/CSS format: #?™™™™™?
     o     error (boolean) true if string can?셳 be parsed
     o }
    \*/
    R.getRGB = cacher(function(colour) {
        var opacity,
            res,
            red,
            green,
            blue,
            t,
            values,
            rgb;

        colour && is(colour, 'object') && "opacity" in colour &&
            (opacity = colour.opacity);
        if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
            return {
                r: -1,
                g: -1,
                b: -1,
                hex: none,
                error: 1,
                toString: clrToString
            };
        }
        if (colour == none) {
            return {
                r: -1,
                g: -1,
                b: -1,
                hex: none,
                toString: clrToString
            };
        }
        !(hsrg[has](colour.toLowerCase().substring(0, 2)) ||
            colour.charAt() === "#") && (colour = toHex(colour));


        if ((rgb = colour.match(colourRegExp))) {
            if (rgb[2]) {
                blue = toInt(rgb[2].substring(5), 16);
                green = toInt(rgb[2].substring(3, 5), 16);
                red = toInt(rgb[2].substring(1, 3), 16);
            }
            if (rgb[3]) {
                blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                green = toInt((t = rgb[3].charAt(2)) + t, 16);
                red = toInt((t = rgb[3].charAt(1)) + t, 16);
            }
            if (rgb[4]) {
                values = rgb[4][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            }
            if (rgb[5]) {
                values = rgb[5][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsb2rgb(red, green, blue, opacity);
            }
            if (rgb[6]) {
                values = rgb[6][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsl2rgb(red, green, blue, opacity);
            }
            rgb = {
                r: red,
                g: green,
                b: blue,
                toString: clrToString
            };
            rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
            R.is(opacity, "finite") && (rgb.opacity = opacity);
            return rgb;
        }
        return {
            r: -1,
            g: -1,
            b: -1,
            hex: none,
            error: 1,
            toString: clrToString
        };
    }, R);

    R.tintshade = cacher(function(colour, percent) {
        var rgb = R.getRGB(colour),
            tint,
            offset = 255;

        (percent < 0) && (percent *= -1, offset = 0);
        (percent > 1) && (percent = 1);

        tint = percent === 0 ? rgb : {
            r: offset - (offset - rgb.r) * percent,
            g: offset - (offset - rgb.g) * percent,
            b: offset - (offset - rgb.b) * percent,
            toString: clrToString
        };
        tint.hex = R.rgb(tint.r, tint.g, tint.b);
        rgb.error && (tint.error = rgb.error);

        if ("opacity" in rgb) {
            tint.rgba = 'rgba(' + [tint.r, tint.g, tint.b, rgb.opacity].join(',') + ')';
            tint.opacity = rgb.opacity;
        }
        else {
            tint.rgba = 'rgb(' + [tint.r, tint.g, tint.b].join(',') + ')';
        }
        return tint;
    }, R);

    /*\
     * Raphael.hsb
     [ method ]
     **
     * Converts HSB values to hex representation of the colour.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - b (number) value or brightness
     = (string) hex representation of the colour.
    \*/
    R.hsb = cacher(function(h, s, b) {
        return R.hsb2rgb(h, s, b).hex;
    });

    /*\
     * Raphael.hsl
     [ method ]
     **
     * Converts HSL values to hex representation of the colour.
     > Parameters
     - h (number) hue
     - s (number) saturation
     - l (number) luminosity
     = (string) hex representation of the colour.
    \*/
    R.hsl = cacher(function(h, s, l) {
        return R.hsl2rgb(h, s, l).hex;
    });

    /*\
     * Raphael.rgb
     [ method ]
     **
     * Converts RGB values to hex representation of the colour.
     > Parameters
     - r (number) red
     - g (number) green
     - b (number) blue
     = (string) hex representation of the colour.
    \*/
    R.rgb = cacher(function(r, g, b) {
        return "#" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);
    });

    /*\
     * Raphael.getColor
     [ method ]
     **
     * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset
     > Parameters
     - value (number) #optional brightness, default is `0.75`
     = (string) hex representation of the colour.
    \*/
    R.getColor = function(value) {
        var start = this.getColor.start = this.getColor.start || {
            h: 0,
            s: 1,
            b: value || .75
        },
        rgb = this.hsb2rgb(start.h, start.s, start.b);
        start.h += .075;
        if (start.h > 1) {
            start.h = 0;
            start.s -= .2;
            start.s <= 0 && (this.getColor.start = {
                h: 0,
                s: 1,
                b: start.b
            });
        }
        return rgb.hex;
    };

    /*\
     * Raphael.getColor.reset
     [ method ]
     **
     * Resets spectrum position for @Raphael.getColor back to red.
    \*/
    R.getColor.reset = function() {
        delete this.start;
    };

    // http://schepers.cc/getting-to-the-point
    function catmullRom2bezier(crp, z) {
        var d = [];
        for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
            var p = [
            {
                x: +crp[i - 2],
                y: +crp[i - 1]
            },
            {
                x: +crp[i],
                y: +crp[i + 1]
            },
            {
                x: +crp[i + 2],
                y: +crp[i + 3]
            },
            {
                x: +crp[i + 4],
                y: +crp[i + 5]
            }
            ];
            if (z) {
                if (!i) {
                    p[0] = {
                        x: +crp[iLen - 2],
                        y: +crp[iLen - 1]
                    };
                } else if (iLen - 4 == i) {
                    p[3] = {
                        x: +crp[0],
                        y: +crp[1]
                    };
                } else if (iLen - 2 == i) {
                    p[2] = {
                        x: +crp[0],
                        y: +crp[1]
                    };
                    p[3] = {
                        x: +crp[2],
                        y: +crp[3]
                    };
                }
            } else {
                if (iLen - 4 == i) {
                    p[3] = p[2];
                } else if (!i) {
                    p[0] = {
                        x: +crp[i],
                        y: +crp[i + 1]
                    };
                }
            }
            d.push(["C",
                (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                (p[1].x + 6 * p[2].x - p[3].x) / 6,
                (p[1].y + 6 * p[2].y - p[3].y) / 6,
                p[2].x,
                p[2].y
                ]);
        }

        return d;
    }

    /*\
     * Raphael.parsePathString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of arrays of path segments.
     > Parameters
     - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)
     = (array) array of segments.
    \*/
    R.parsePathString = function(pathString) {
        if (!pathString) {
            return null;
        }
        var pth = paths(pathString);
        if (pth.arr) {
            return pathClone(pth.arr);
        }

        var paramCounts = {
            a: 7,
            c: 6,
            h: 1,
            l: 2,
            m: 2,
            r: 4,
            q: 4,
            s: 4,
            t: 2,
            v: 1,
            z: 0
        },
        data = [];
        if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption
            data = pathClone(pathString);
        }
        if (!data.length) {
            Str(pathString).replace(pathCommand, function(a, b, c) {
                var params = [],
                name = b.toLowerCase();
                c.replace(pathValues, function(a, b) {
                    b && params.push(+b);
                });
                if (name == "m" && params.length > 2) {
                    data.push([b][concat](params.splice(0, 2)));
                    name = "l";
                    b = b == "m" ? "l" : "L";
                }
                if (name == "r") {
                    data.push([b][concat](params));
                } else
                    while (params.length >= paramCounts[name]) {
                        data.push([b][concat](params.splice(0, paramCounts[name])));
                        if (!paramCounts[name]) {
                            break;
                        }
                    }
            });
        }
        data.toString = R._path2string;
        pth.arr = pathClone(data);
        return data;
    };

    /*\
     * Raphael.parseTransformString
     [ method ]
     **
     * Utility method
     **
     * Parses given path string into an array of transformations.
     > Parameters
     - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)
     = (array) array of transformations.
    \*/
    R.parseTransformString = cacher(function(TString) {
        if (!TString) {
            return null;
        }
        var paramCounts = {
            r: 3,
            s: 4,
            t: 2,
            m: 6
        },
        data = [];
        if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption
            data = pathClone(TString);
        }
        if (!data.length) {
            Str(TString).replace(tCommand, function(a, b, c) {
                var params = [],
                name = lowerCase.call(b);
                c.replace(pathValues, function(a, b) {
                    b && params.push(+b);
                });
                data.push([b][concat](params));
            });
        }
        data.toString = R._path2string;
        return data;
    });
    // PATHS
    var paths = function(ps) {
        var p = paths.ps = paths.ps || {};
        if (p[ps]) {
            p[ps].sleep = 100;
        } else {
            p[ps] = {
                sleep: 100
            };
        }
        setTimeout(function() {
            for (var key in p)
                if (p[has](key) && key != ps) {
                    p[key].sleep--;
                    !p[key].sleep && delete p[key];
                }
        });
        return p[ps];
    };

    /*\
     * Raphael.findDotsAtSegment
     [ method ]
     **
     * Utility method
     **
     * Find dot coordinates on the given cubic bezier curve at the given t.
     > Parameters
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     - t (number) position on the curve (0..1)
     = (object) point information in format:
     o {
     o     x: (number) x coordinate of the point
     o     y: (number) y coordinate of the point
     o     m: {
     o         x: (number) x coordinate of the left anchor
     o         y: (number) y coordinate of the left anchor
     o     }
     o     n: {
     o         x: (number) x coordinate of the right anchor
     o         y: (number) y coordinate of the right anchor
     o     }
     o     start: {
     o         x: (number) x coordinate of the start of the curve
     o         y: (number) y coordinate of the start of the curve
     o     }
     o     end: {
     o         x: (number) x coordinate of the end of the curve
     o         y: (number) y coordinate of the end of the curve
     o     }
     o     alpha: (number) angle of the curve derivative at the point
     o }
    \*/
    R.findDotsAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t,
        t13 = pow(t1, 3),
        t12 = pow(t1, 2),
        t2 = t * t,
        t3 = t2 * t,
        x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
        y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
        mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
        my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
        nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
        ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
        ax = t1 * p1x + t * c1x,
        ay = t1 * p1y + t * c1y,
        cx = t1 * c2x + t * p2x,
        cy = t1 * c2y + t * p2y,
        alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
        (mx > nx || my < ny) && (alpha += 180);
        return {
            x: x,
            y: y,
            m: {
                x: mx,
                y: my
            },
            n: {
                x: nx,
                y: ny
            },
            start: {
                x: ax,
                y: ay
            },
            end: {
                x: cx,
                y: cy
            },
            alpha: alpha
        };
    };

    /*\
     * Raphael.bezierBBox
     [ method ]
     **
     * Utility method
     **
     * Return bounding box of a given cubic bezier curve
     > Parameters
     - p1x (number) x of the first point of the curve
     - p1y (number) y of the first point of the curve
     - c1x (number) x of the first anchor of the curve
     - c1y (number) y of the first anchor of the curve
     - c2x (number) x of the second anchor of the curve
     - c2y (number) y of the second anchor of the curve
     - p2x (number) x of the second point of the curve
     - p2y (number) y of the second point of the curve
     * or
     - bez (array) array of six points for bezier curve
     = (object) point information in format:
     o {
     o     min: {
     o         x: (number) x coordinate of the left point
     o         y: (number) y coordinate of the top point
     o     }
     o     max: {
     o         x: (number) x coordinate of the right point
     o         y: (number) y coordinate of the bottom point
     o     }
     o }
    \*/
    R.bezierBBox = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!R.is(p1x, "array")) {
            p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
        }
        var bbox = curveDim.apply(null, p1x);
        return {
            x: bbox.min.x,
            y: bbox.min.y,
            x2: bbox.max.x,
            y2: bbox.max.y,
            width: bbox.max.x - bbox.min.x,
            height: bbox.max.y - bbox.min.y
        };
    };

    /*\
     * Raphael.isPointInsideBBox
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside bounding boxes.
     > Parameters
     - bbox (string) bounding box
     - x (string) x coordinate of the point
     - y (string) y coordinate of the point
     = (boolean) `true` if point inside
    \*/
    R.isPointInsideBBox = function(bbox, x, y) {
        return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
    };

    /*\
     * Raphael.isBBoxIntersect
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if two bounding boxes intersect
     > Parameters
     - bbox1 (string) first bounding box
     - bbox2 (string) second bounding box
     = (boolean) `true` if they intersect
    \*/
    R.isBBoxIntersect = function(bbox1, bbox2) {
        var i = R.isPointInsideBBox;
        return i(bbox2, bbox1.x, bbox1.y) ||
            i(bbox2, bbox1.x2, bbox1.y) ||
            i(bbox2, bbox1.x, bbox1.y2) ||
            i(bbox2, bbox1.x2, bbox1.y2) ||
            i(bbox1, bbox2.x, bbox2.y) ||
            i(bbox1, bbox2.x2, bbox2.y) ||
            i(bbox1, bbox2.x, bbox2.y2) ||
            i(bbox1, bbox2.x2, bbox2.y2) ||
            (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x ||
                bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) &&
            (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
    };

    function base3(t, p1, p2, p3, p4) {
        var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
        t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
    }

    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (z == null) {
            z = 1;
        }
        z = z > 1 ? 1 : z < 0 ? 0 : z;
        var z2 = z / 2,
        n = 12,
        Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816],
        Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472],
        sum = 0;
        for (var i = 0; i < n; i++) {
            var ct = z2 * Tvalues[i] + z2,
            xbase = base3(ct, x1, x2, x3, x4),
            ybase = base3(ct, y1, y2, y3, y4),
            comb = xbase * xbase + ybase * ybase;
            sum += Cvalues[i] * mathSqrt(comb);
        }
        return z2 * sum;
    }

    function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
            return;
        }
        var t = 1,
        step = t / 2,
        t2 = t - step,
        l,
        e = .01;
        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        while (abs(l - ll) > e) {
            step /= 2;
            t2 += (l < ll ? 1 : -1) * step;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        }
        return t2;
    }

    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (
            mmax(x1, x2) < mmin(x3, x4) ||
            mmin(x1, x2) > mmax(x3, x4) ||
            mmax(y1, y2) < mmin(y3, y4) ||
            mmin(y1, y2) > mmax(y3, y4)
            ) {
            return;
        }
        var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
        ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
        denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (!denominator) {
            return;
        }
        var px = nx / denominator,
        py = ny / denominator,
        px2 = +px.toFixed(2),
        py2 = + py.toFixed(2);
        if (
            px2 < +mmin(x1, x2).toFixed(2) ||
            px2 > +mmax(x1, x2).toFixed(2) ||
            px2 < +mmin(x3, x4).toFixed(2) ||
            px2 > +mmax(x3, x4).toFixed(2) ||
            py2 < +mmin(y1, y2).toFixed(2) ||
            py2 > +mmax(y1, y2).toFixed(2) ||
            py2 < +mmin(y3, y4).toFixed(2) ||
            py2 > +mmax(y3, y4).toFixed(2)
            ) {
            return;
        }
        return {
            x: px,
            y: py
        };
    }

    function inter(bez1, bez2) {
        return interHelper(bez1, bez2);
    }

    function interCount(bez1, bez2) {
        return interHelper(bez1, bez2, 1);
    }

    function interHelper(bez1, bez2, justCount) {
        var bbox1 = R.bezierBBox(bez1),
            bbox2 = R.bezierBBox(bez2);

        if (!R.isBBoxIntersect(bbox1, bbox2)) {
            return justCount ? 0 : [];
        }
        var l1 = bezlen.apply(0, bez1),
            l2 = bezlen.apply(0, bez2),
            n1 = mmax(~~(l1 / 5), 1),
            n2 = mmax(~~(l2 / 5), 1),
            dots1 = [],
            dots2 = [],
            xy = {},
            res = justCount ? 0 : [];

        for (var i = 0; i < n1 + 1; i++) {
            var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
            dots1.push({
                x: p.x,
                y: p.y,
                t: i / n1
            });
        }
        for (i = 0; i < n2 + 1; i++) {
            p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
            dots2.push({
                x: p.x,
                y: p.y,
                t: i / n2
            });
        }
        for (i = 0; i < n1; i++) {
            for (var j = 0; j < n2; j++) {
                var di = dots1[i],
                di1 = dots1[i + 1],
                dj = dots2[j],
                dj1 = dots2[j + 1],
                ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
                if (is) {
                    if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                        continue;
                    }
                    xy[is.x.toFixed(4)] = is.y.toFixed(4);
                    var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                    t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                    if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {
                        if (justCount) {
                            res++;
                        } else {
                            res.push({
                                x: is.x,
                                y: is.y,
                                t1: mmin(t1, 1),
                                t2: mmin(t2, 1)
                            });
                        }
                    }
                }
            }
        }
        return res;
    }

    /*\
     * Raphael.pathIntersection
     [ method ]
     **
     * Utility method
     **
     * Finds intersections of two paths
     > Parameters
     - path1 (string) path string
     - path2 (string) path string
     = (array) dots of intersection
     o [
     o     {
     o         x: (number) x coordinate of the point
     o         y: (number) y coordinate of the point
     o         t1: (number) t value for segment of path1
     o         t2: (number) t value for segment of path2
     o         segment1: (number) order number for segment of path1
     o         segment2: (number) order number for segment of path2
     o         bez1: (array) eight coordinates representing bezi챕r curve for the segment of path1
     o         bez2: (array) eight coordinates representing bezi챕r curve for the segment of path2
     o     }
     o ]
    \*/
    R.pathIntersection = function(path1, path2) {
        return interPathHelper(path1, path2);
    };
    R.pathIntersectionNumber = function(path1, path2) {
        return interPathHelper(path1, path2, 1);
    };
    function interPathHelper(path1, path2, justCount) {
        path1 = R._path2curve(path1);
        path2 = R._path2curve(path2);
        var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
        res = justCount ? 0 : [];
        for (var i = 0, ii = path1.length; i < ii; i++) {
            var pi = path1[i];
            if (pi[0] == "M") {
                x1 = x1m = pi[1];
                y1 = y1m = pi[2];
            } else {
                if (pi[0] == "C") {
                    bez1 = [x1, y1].concat(pi.slice(1));
                    x1 = bez1[6];
                    y1 = bez1[7];
                } else {
                    bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                    x1 = x1m;
                    y1 = y1m;
                }
                for (var j = 0, jj = path2.length; j < jj; j++) {
                    var pj = path2[j];
                    if (pj[0] == "M") {
                        x2 = x2m = pj[1];
                        y2 = y2m = pj[2];
                    } else {
                        if (pj[0] == "C") {
                            bez2 = [x2, y2].concat(pj.slice(1));
                            x2 = bez2[6];
                            y2 = bez2[7];
                        } else {
                            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                            x2 = x2m;
                            y2 = y2m;
                        }
                        var intr = interHelper(bez1, bez2, justCount);
                        if (justCount) {
                            res += intr;
                        } else {
                            for (var k = 0, kk = intr.length; k < kk; k++) {
                                intr[k].segment1 = i;
                                intr[k].segment2 = j;
                                intr[k].bez1 = bez1;
                                intr[k].bez2 = bez2;
                            }
                            res = res.concat(intr);
                        }
                    }
                }
            }
        }
        return res;
    }

    /*\
     * Raphael.isPointInsidePath
     [ method ]
     **
     * Utility method
     **
     * Returns `true` if given point is inside a given closed path.
     > Parameters
     - path (string) path string
     - x (number) x of the point
     - y (number) y of the point
     = (boolean) true, if point is inside the path
    \*/
    R.isPointInsidePath = function(path, x, y) {
        var bbox = R.pathBBox(path);
        return R.isPointInsideBBox(bbox, x, y) &&
        ((interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1) ||
        (interPathHelper(path, [["M", x, y], ["V", bbox.y2 + 10]], 1) % 2 == 1))
    };
    R._removedFactory = function(methodname) {
        return function() {
            eve("raphael.log", null, "Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object", methodname);
        };
    };

    /*\
     * Raphael.pathBBox
     [ method ]
     **
     * Utility method
     **
     * Return bounding box of a given path
     > Parameters
     - path (string) path string
     = (object) bounding box
     o {
     o     x: (number) x coordinate of the left top point of the box
     o     y: (number) y coordinate of the left top point of the box
     o     x2: (number) x coordinate of the right bottom point of the box
     o     y2: (number) y coordinate of the right bottom point of the box
     o     width: (number) width of the box
     o     height: (number) height of the box
     o     cx: (number) x coordinate of the center of the box
     o     cy: (number) y coordinate of the center of the box
     o }
    \*/
    var pathDimensions = R.pathBBox = function(path) {
        var pth = paths(path);
        if (pth.bbox) {
            return pth.bbox;
        }
        if (!path) {
            return {
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                x2: 0,
                y2: 0
            };
        }
        path = path2curve(path);
        var x = 0,
        y = 0,
        X = [],
        Y = [],
        p;
        for (var i = 0, ii = path.length; i < ii; i++) {
            p = path[i];
            if (p[0] == "M") {
                x = p[1];
                y = p[2];
                X.push(x);
                Y.push(y);
            } else {
                var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                X = X[concat](dim.min.x, dim.max.x);
                Y = Y[concat](dim.min.y, dim.max.y);
                x = p[5];
                y = p[6];
            }
        }
        var xmin = mmin[apply](0, X),
        ymin = mmin[apply](0, Y),
        xmax = mmax[apply](0, X),
        ymax = mmax[apply](0, Y),
        bb = {
            x: xmin,
            y: ymin,
            x2: xmax,
            y2: ymax,
            width: xmax - xmin,
            height: ymax - ymin
        };
        pth.bbox = clone(bb);
        return bb;
    },
    pathClone = function(pathArray) {
        var res = clone(pathArray);
        res.toString = R._path2string;
        return res;
    },
    pathToRelative = R._pathToRelative = function(pathArray) {
        var pth = paths(pathArray);
        if (pth.rel) {
            return pathClone(pth.rel);
        }
        if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
            pathArray = R.parsePathString(pathArray);
        }
        var res = [],
        x = 0,
        y = 0,
        mx = 0,
        my = 0,
        start = 0;
        if (pathArray[0][0] == "M") {
            x = pathArray[0][1];
            y = pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res.push(["M", x, y]);
        }
        for (var i = start, ii = pathArray.length; i < ii; i++) {
            var r = res[i] = [],
            pa = pathArray[i];
            if (pa[0] != lowerCase.call(pa[0])) {
                r[0] = lowerCase.call(pa[0]);
                switch (r[0]) {
                    case "a":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] - x).toFixed(3);
                        r[7] = +(pa[7] - y).toFixed(3);
                        break;
                    case "v":
                        r[1] = +(pa[1] - y).toFixed(3);
                        break;
                    case "m":
                        mx = pa[1];
                        my = pa[2];
                    default:
                        for (var j = 1, jj = pa.length; j < jj; j++) {
                            r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
                        }
                }
            } else {
                r = res[i] = [];
                if (pa[0] == "m") {
                    mx = pa[1] + x;
                    my = pa[2] + y;
                }
                for (var k = 0, kk = pa.length; k < kk; k++) {
                    res[i][k] = pa[k];
                }
            }
            var len = res[i].length;
            switch (res[i][0]) {
                case "z":
                    x = mx;
                    y = my;
                    break;
                case "h":
                    x += +res[i][len - 1];
                    break;
                case "v":
                    y += +res[i][len - 1];
                    break;
                default:
                    x += +res[i][len - 2];
                    y += +res[i][len - 1];
            }
        }
        res.toString = R._path2string;
        pth.rel = pathClone(res);
        return res;
    },
    pathToAbsolute = R._pathToAbsolute = function(pathArray) {
        var pth = paths(pathArray), res;
        if (pth.abs) {
            return pathClone(pth.abs);
        }
        if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
            pathArray = R.parsePathString(pathArray);
        }
        if (!pathArray || !pathArray.length) {
            res = ["M", 0, 0];
            res.toString = R._path2string;
            return res;
        }
        var x = 0,
            y = 0,
            mx = 0,
            my = 0,
            start = 0;
        res = [];
        if (pathArray[0][0] == "M") {
            x = +pathArray[0][1];
            y = +pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res[0] = ["M", x, y];
        }
        var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
        for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
            res.push(r = []);
            pa = pathArray[i];
            if (pa[0] != upperCase.call(pa[0])) {
                r[0] = upperCase.call(pa[0]);
                switch (r[0]) {
                    case "A":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] + x);
                        r[7] = +(pa[7] + y);
                        break;
                    case "V":
                        r[1] = +pa[1] + y;
                        break;
                    case "H":
                        r[1] = +pa[1] + x;
                        break;
                    case "R":
                        var dots = [x, y][concat](pa.slice(1));
                        for (var j = 2, jj = dots.length; j < jj; j++) {
                            dots[j] = +dots[j] + x;
                            dots[++j] = +dots[j] + y;
                        }
                        res.pop();
                        res = res[concat](catmullRom2bezier(dots, crz));
                        break;
                    case "M":
                        mx = +pa[1] + x;
                        my = +pa[2] + y;
                    default:
                        for (j = 1, jj = pa.length; j < jj; j++) {
                            r[j] = +pa[j] + ((j % 2) ? x : y);
                        }
                }
            } else if (pa[0] == "R") {
                dots = [x, y][concat](pa.slice(1));
                res.pop();
                res = res[concat](catmullRom2bezier(dots, crz));
                r = ["R"][concat](pa.slice(-2));
            } else {
                for (var k = 0, kk = pa.length; k < kk; k++) {
                    r[k] = pa[k];
                }
            }
            switch (r[0]) {
                case "Z":
                    x = mx;
                    y = my;
                    break;
                case "H":
                    x = r[1];
                    break;
                case "V":
                    y = r[1];
                    break;
                case "M":
                    mx = r[r.length - 2];
                    my = r[r.length - 1];
                default:
                    x = r[r.length - 2];
                    y = r[r.length - 1];
            }
        }
        res.toString = R._path2string;
        pth.abs = pathClone(res);
        return res;
    },
    l2c = function(x1, y1, x2, y2) {
        return [x1, y1, x2, y2, x2, y2];
    },
    q2c = function(x1, y1, ax, ay, x2, y2) {
        var _13 = 1 / 3,
        _23 = 2 / 3;
        return [
        _13 * x1 + _23 * ax,
        _13 * y1 + _23 * ay,
        _13 * x2 + _23 * ax,
        _13 * y2 + _23 * ay,
        x2,
        y2
        ];
    },
    a2c = function(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
        // for more information of where this math came from visit:
        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
        var _120 = PI * 120 / 180,
        rad = deg2rad * (+angle || 0),
        res = [],
        xy,
        rotate = cacher(function(x, y, rad) {
            var X = x * mathCos(rad) - y * mathSin(rad),
            Y = x * mathSin(rad) + y * mathCos(rad);
            return {
                x: X,
                y: Y
            };
        });
        if (!recursive) {
            xy = rotate(x1, y1, -rad);
            x1 = xy.x;
            y1 = xy.y;
            xy = rotate(x2, y2, -rad);
            x2 = xy.x;
            y2 = xy.y;
            var cos = mathCos(deg2rad * angle),
            sin = mathSin(deg2rad * angle),
            x = (x1 - x2) / 2,
            y = (y1 - y2) / 2;
            var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
            if (h > 1) {
                h = mathSqrt(h);
                rx = h * rx;
                ry = h * ry;
            }
            var rx2 = rx * rx,
            ry2 = ry * ry,
            k = (large_arc_flag == sweep_flag ? -1 : 1) *
            mathSqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
            cx = k * rx * y / ry + (x1 + x2) / 2,
            cy = k * -ry * x / rx + (y1 + y2) / 2,
            f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
            f2 = math.asin(((y2 - cy) / ry).toFixed(9));

            f1 = x1 < cx ? PI - f1 : f1;
            f2 = x2 < cx ? PI - f2 : f2;
            f1 < 0 && (f1 = PI * 2 + f1);
            f2 < 0 && (f2 = PI * 2 + f2);
            if (sweep_flag && f1 > f2) {
                f1 = f1 - PI * 2;
            }
            if (!sweep_flag && f2 > f1) {
                f2 = f2 - PI * 2;
            }
        } else {
            f1 = recursive[0];
            f2 = recursive[1];
            cx = recursive[2];
            cy = recursive[3];
        }
        var df = f2 - f1;
        if (abs(df) > _120) {
            var f2old = f2,
            x2old = x2,
            y2old = y2;
            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
            x2 = cx + rx * mathCos(f2);
            y2 = cy + ry * mathSin(f2);
            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
        }
        df = f2 - f1;
        var c1 = mathCos(f1),
        s1 = mathSin(f1),
        c2 = mathCos(f2),
        s2 = mathSin(f2),
        t = math.tan(df / 4),
        hx = 4 / 3 * rx * t,
        hy = 4 / 3 * ry * t,
        m1 = [x1, y1],
        m2 = [x1 + hx * s1, y1 - hy * c1],
        m3 = [x2 + hx * s2, y2 - hy * c2],
        m4 = [x2, y2];
        m2[0] = 2 * m1[0] - m2[0];
        m2[1] = 2 * m1[1] - m2[1];
        if (recursive) {
            return [m2, m3, m4][concat](res);
        } else {
            res = [m2, m3, m4][concat](res).join()[split](",");
            var newres = [];
            for (var i = 0, ii = res.length; i < ii; i++) {
                newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
            }
            return newres;
        }
    },
    findDotAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        var t1 = 1 - t;
        return {
            x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
            y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
        };
    },
    curveDim = cacher(function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
        b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
        c = p1x - c1x,
        t1 = (-b + mathSqrt(b * b - 4 * a * c)) / 2 / a,
        t2 = (-b - mathSqrt(b * b - 4 * a * c)) / 2 / a,
        y = [p1y, p2y],
        x = [p1x, p2x],
        dot;
        abs(t1) > "1e12" && (t1 = .5);
        abs(t2) > "1e12" && (t2 = .5);
        if (t1 > 0 && t1 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
            x.push(dot.x);
            y.push(dot.y);
        }
        if (t2 > 0 && t2 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
            x.push(dot.x);
            y.push(dot.y);
        }
        a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
        b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
        c = p1y - c1y;
        t1 = (-b + mathSqrt(b * b - 4 * a * c)) / 2 / a;
        t2 = (-b - mathSqrt(b * b - 4 * a * c)) / 2 / a;
        abs(t1) > "1e12" && (t1 = .5);
        abs(t2) > "1e12" && (t2 = .5);
        if (t1 > 0 && t1 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
            x.push(dot.x);
            y.push(dot.y);
        }
        if (t2 > 0 && t2 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
            x.push(dot.x);
            y.push(dot.y);
        }
        return {
            min: {
                x: mmin[apply](0, x),
                y: mmin[apply](0, y)
            },
            max: {
                x: mmax[apply](0, x),
                y: mmax[apply](0, y)
            }
        };
    }),
    path2curve = R._path2curve = cacher(function(path, path2) {
        var pth = !path2 && paths(path);
        if (!path2 && pth.curve) {
            return pathClone(pth.curve);
        }
        var p = pathToAbsolute(path),
        p2 = path2 && pathToAbsolute(path2),
        attrs = {
            x: 0,
            y: 0,
            bx: 0,
            by: 0,
            X: 0,
            Y: 0,
            qx: null,
            qy: null
        },
        attrs2 = {
            x: 0,
            y: 0,
            bx: 0,
            by: 0,
            X: 0,
            Y: 0,
            qx: null,
            qy: null
        },
        processPath = function(path, d) {
            var nx, ny;
            if (!path) {
                return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
            }
            !(path[0] in {
                T: 1,
                Q: 1
            }) && (d.qx = d.qy = null);
            switch (path[0]) {
                case "M":
                    d.X = path[1];
                    d.Y = path[2];
                    break;
                case "A":
                    path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                    break;
                case "S":
                    nx = d.x + (d.x - (d.bx || d.x));
                    ny = d.y + (d.y - (d.by || d.y));
                    path = ["C", nx, ny][concat](path.slice(1));
                    break;
                case "T":
                    d.qx = d.x + (d.x - (d.qx || d.x));
                    d.qy = d.y + (d.y - (d.qy || d.y));
                    path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                    break;
                case "Q":
                    d.qx = path[1];
                    d.qy = path[2];
                    path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                    break;
                case "L":
                    path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                    break;
                case "H":
                    path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                    break;
                case "V":
                    path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                    break;
                case "Z":
                    path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                    break;
            }
            return path;
        },
        fixArc = function(pp, i) {
            if (pp[i].length > 7) {
                pp[i].shift();
                var pi = pp[i];
                while (pi.length) {
                    pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                }
                pp.splice(i, 1);
                ii = mmax(p.length, p2 && p2.length || 0);
            }
        },
        fixM = function(path1, path2, a1, a2, i) {
            if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                path2.splice(i, 0, ["M", a2.x, a2.y]);
                a1.bx = 0;
                a1.by = 0;
                a1.x = path1[i][1];
                a1.y = path1[i][2];
                ii = mmax(p.length, p2 && p2.length || 0);
            }
        };
        for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
            p[i] = processPath(p[i], attrs);
            fixArc(p, i);
            p2 && (p2[i] = processPath(p2[i], attrs2));
            p2 && fixArc(p2, i);
            fixM(p, p2, attrs, attrs2, i);
            fixM(p2, p, attrs2, attrs, i);
            var seg = p[i],
            seg2 = p2 && p2[i],
            seglen = seg.length,
            seg2len = p2 && seg2.length;
            attrs.x = seg[seglen - 2];
            attrs.y = seg[seglen - 1];
            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
            attrs2.x = p2 && seg2[seg2len - 2];
            attrs2.y = p2 && seg2[seg2len - 1];
        }
        if (!p2) {
            pth.curve = pathClone(p);
        }
        return p2 ? [p, p2] : p;
    }, null, pathClone),
    parseDots = R._parseDots = cacher(function(gradient) {
        var dots = [];
        for (var i = 0, ii = gradient.length; i < ii; i++) {
            var dot = {},
            par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
            dot.color = R.getRGB(par[1]);
            if (dot.color.error) {
                return null;
            }
            //store opacity information
            dot.opacity = dot.color.opacity;
            dot.color = dot.color.hex;
            par[2] && (dot.offset = par[2] + "%");
            dots.push(dot);
        }
        for (i = 1, ii = dots.length - 1; i < ii; i++) {
            if (!dots[i].offset) {
                var start = toFloat(dots[i - 1].offset || 0),
                end = 0;
                for (var j = i + 1; j < ii; j++) {
                    if (dots[j].offset) {
                        end = dots[j].offset;
                        break;
                    }
                }
                if (!end) {
                    end = 100;
                    j = ii;
                }
                end = toFloat(end);
                var d = (end - start) / (j - i + 1);
                for (; i < j; i++) {
                    start += d;
                    dots[i].offset = start + "%";
                }
            }
        }
        return dots;
    }),
    tear = R._tear = function(el, paper) {
        el == paper.top && (paper.top = el.prev);
        el == paper.bottom && (paper.bottom = el.next);
        el.next && (el.next.prev = el.prev);
        el.prev && (el.prev.next = el.next);
    },
    tofront = R._tofront = function(el, paper) {
        if (paper.top === el) {
            return false;
        }
        tear(el, paper);
        el.next = null;
        el.prev = paper.top;
        paper.top.next = el;
        paper.top = el;
        return true;
    },
    toback = R._toback = function(el, paper) {
        if (paper.bottom === el) {
            return false;
        }
        tear(el, paper);
        el.next = paper.bottom;
        el.prev = null;
        paper.bottom.prev = el;
        paper.bottom = el;
        return true;
    },
    insertafter = R._insertafter = function(el, el2, paper, paper2) {
        tear(el, paper);
        el.parent = paper2;
        el2 === paper2.top && (paper2.top = el);
        el2.next && (el2.next.prev = el);
        el.next = el2.next;
        el.prev = el2;
        el2.next = el;
    },
    insertbefore = R._insertbefore = function(el, el2, paper, paper2) {
        tear(el, paper);
        el.parent = paper2;
        el2 === paper2.bottom && (paper2.bottom = el);
        el2.prev && (el2.prev.next = el);
        el.prev = el2.prev;
        el2.prev = el;
        el.next = el2;
    },

        /*\
         * Raphael.toMatrix
         [ method ]
         **
         * Utility method
         **
         * Returns matrix of transformations applied to a given path
         > Parameters
         - path (string) path string
         - transform (string|array) transformation string
         = (object) @Matrix
        \*/
    toMatrix = R.toMatrix = function(path, transform) {
        var bb = pathDimensions(path),
        el = {
            _: {
                transform: E
            },
            getBBox: function() {
                return bb;
            }
        };
        extractTransform(el, transform);
        return el.matrix;
    },

        /*\
         * Raphael.transformPath
         [ method ]
         **
         * Utility method
         **
         * Returns path transformed by a given transformation
         > Parameters
         - path (string) path string
         - transform (string|array) transformation string
         = (string) path
        \*/
    transformPath = R.transformPath = function(path, transform) {
        return mapPath(path, toMatrix(path, transform));
    },
    extractTransform = R._extractTransform = function(el, tstr) {
        if (tstr == null) {
            return el._.transform;
        }
        tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
        var tdata = R.parseTransformString(tstr),
        deg = 0,
        dx = 0,
        dy = 0,
        sx = 1,
        sy = 1,
        _ = el._,
        m = new Matrix;
        _.transform = tdata || [];
        if (tdata) {
            for (var i = 0, ii = tdata.length; i < ii; i++) {
                var t = tdata[i],
                tlen = t.length,
                command = Str(t[0]).toLowerCase(),
                absolute = t[0] != command,
                inver = absolute ? m.invert() : 0,
                x1,
                y1,
                x2,
                y2,
                bb;
                if (command == "t" && tlen == 3) {
                    if (absolute) {
                        x1 = inver.x(0, 0);
                        y1 = inver.y(0, 0);
                        x2 = inver.x(t[1], t[2]);
                        y2 = inver.y(t[1], t[2]);
                        m.translate(x2 - x1, y2 - y1);
                    } else {
                        m.translate(t[1], t[2]);
                    }
                } else if (command == "r") {
                    if (tlen == 2) {
                        bb = bb || el.getBBox(1);
                        m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                        deg += t[1];
                    } else if (tlen == 4) {
                        if (absolute) {
                            x2 = inver.x(t[2], t[3]);
                            y2 = inver.y(t[2], t[3]);
                            m.rotate(t[1], x2, y2);
                        } else {
                            m.rotate(t[1], t[2], t[3]);
                        }
                        deg += t[1];
                    }
                } else if (command == "s") {
                    if (tlen == 2 || tlen == 3) {
                        bb = bb || el.getBBox(1);
                        m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                        sx *= t[1];
                        sy *= t[tlen - 1];
                    } else if (tlen == 5) {
                        if (absolute) {
                            x2 = inver.x(t[3], t[4]);
                            y2 = inver.y(t[3], t[4]);
                            m.scale(t[1], t[2], x2, y2);
                        } else {
                            m.scale(t[1], t[2], t[3], t[4]);
                        }
                        sx *= t[1];
                        sy *= t[2];
                    }
                } else if (command == "m" && tlen == 7) {
                    m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
                }
                _.dirtyT = 1;
                el.matrix = m;
            }
        }

        /*\
         * Element.matrix
         [ property (object) ]
         **
         * Keeps @Matrix object, which represents element transformation
        \*/
        el.matrix = m;

        _.sx = sx;
        _.sy = sy;
        _.deg = deg;
        _.dx = dx = m.e;
        _.dy = dy = m.f;

        if (sx == 1 && sy == 1 && !deg && _.bbox) {
            _.bbox.x += +dx;
            _.bbox.y += +dy;
        } else {
            _.dirtyT = 1;
        }
    },
    getEmpty = function(item) {
        var l = item[0];
        switch (l.toLowerCase()) {
            case "t":
                return [l, 0, 0];
            case "m":
                return [l, 1, 0, 0, 1, 0, 0];
            case "r":
                if (item.length == 4) {
                    return [l, 0, item[2], item[3]];
                } else {
                    return [l, 0];
                }
            case "s":
                if (item.length == 5) {
                    return [l, 1, 1, item[3], item[4]];
                } else if (item.length == 3) {
                    return [l, 1, 1];
                } else {
                    return [l, 1];
                }
        }
    },
    equaliseTransform = R._equaliseTransform = function(t1, t2) {
        t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
        t1 = R.parseTransformString(t1) || [];
        t2 = R.parseTransformString(t2) || [];
        var maxlength = mmax(t1.length, t2.length),
        from = [],
        to = [],
        i = 0, j, jj,
        tt1, tt2;
        for (; i < maxlength; i++) {
            tt1 = t1[i] || getEmpty(t2[i]);
            tt2 = t2[i] || getEmpty(tt1);
            if ((tt1[0] != tt2[0]) ||
                (tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
                (tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
                ) {
                return;
            }
            from[i] = [];
            to[i] = [];
            for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {
                j in tt1 && (from[i][j] = tt1[j]);
                j in tt2 && (to[i][j] = tt2[j]);
            }
        }
        return {
            from: from,
            to: to
        };
    };
    R._getContainer = function(x, y, w, h) {
        var container;
        container = h == null && !R.is(x, object) ? g.doc.getElementById(x) : x;
        if (container == null) {
            return;
        }
        if (container.tagName) {
            if (y == null) {
                return {
                    container: container,
                    width: container.style.pixelWidth || container.offsetWidth,
                    height: container.style.pixelHeight || container.offsetHeight
                };
            } else {
                return {
                    container: container,
                    width: y,
                    height: w
                };
            }
        }
        return {
            container: 1,
            x: x,
            y: y,
            width: w,
            height: h
        };
    };

    /*\
     * Raphael.pathToRelative
     [ method ]
     **
     * Utility method
     **
     * Converts path to relative form
     > Parameters
     - pathString (string|array) path string or array of segments
     = (array) array of segments.
    \*/
    R.pathToRelative = pathToRelative;
    R._engine = {};

    /*\
     * Raphael.path2curve
     [ method ]
     **
     * Utility method
     **
     * Converts path to a new path where all segments are cubic bezier curves.
     > Parameters
     - pathString (string|array) path string or array of segments
     = (array) array of segments.
    \*/
    R.path2curve = path2curve;

    /*\
     * Raphael.matrix
     [ method ]
     **
     * Utility method
     **
     * Returns matrix based on given parameters.
     > Parameters
     - a (number)
     - b (number)
     - c (number)
     - d (number)
     - e (number)
     - f (number)
     = (object) @Matrix
    \*/
    R.matrix = function(a, b, c, d, e, f) {
        return new Matrix(a, b, c, d, e, f);
    };

    function Matrix(a, b, c, d, e, f) {
        if (a != null) {
            this.a = +a;
            this.b = +b;
            this.c = +c;
            this.d = +d;
            this.e = +e;
            this.f = +f;
        } else {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.e = 0;
            this.f = 0;
        }
    }
    (function(matrixproto) {

        /*\
         * Matrix.add
         [ method ]
         **
         * Adds given matrix to existing one.
         > Parameters
         - a (number)
         - b (number)
         - c (number)
         - d (number)
         - e (number)
         - f (number)
         or
         - matrix (object) @Matrix
        \*/
        matrixproto.add = function(a, b, c, d, e, f) {
            var out = [[], [], []],
            m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
            matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
            x, y, z, res;

            if (a && a instanceof Matrix) {
                matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
            }

            for (x = 0; x < 3; x++) {
                for (y = 0; y < 3; y++) {
                    res = 0;
                    for (z = 0; z < 3; z++) {
                        res += m[x][z] * matrix[z][y];
                    }
                    out[x][y] = res;
                }
            }
            this.a = out[0][0];
            this.b = out[1][0];
            this.c = out[0][1];
            this.d = out[1][1];
            this.e = out[0][2];
            this.f = out[1][2];
        };

        /*\
         * Matrix.invert
         [ method ]
         **
         * Returns inverted version of the matrix
         = (object) @Matrix
        \*/
        matrixproto.invert = function() {
            var me = this,
            x = me.a * me.d - me.b * me.c;
            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
        };

        /*\
         * Matrix.clone
         [ method ]
         **
         * Returns copy of the matrix
         = (object) @Matrix
        \*/
        matrixproto.clone = function() {
            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
        };

        /*\
         * Matrix.translate
         [ method ]
         **
         * Translate the matrix
         > Parameters
         - x (number)
         - y (number)
        \*/
        matrixproto.translate = function(x, y) {
            this.add(1, 0, 0, 1, x, y);
        };

        /*\
         * Matrix.scale
         [ method ]
         **
         * Scales the matrix
         > Parameters
         - x (number)
         - y (number) #optional
         - cx (number) #optional
         - cy (number) #optional
        \*/
        matrixproto.scale = function(x, y, cx, cy) {
            y == null && (y = x);
            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
            this.add(x, 0, 0, y, 0, 0);
            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
        };

        /*\
         * Matrix.rotate
         [ method ]
         **
         * Rotates the matrix
         > Parameters
         - a (number)
         - x (number)
         - y (number)
        \*/
        matrixproto.rotate = function(a, x, y) {
            a = R.rad(a);
            x = x || 0;
            y = y || 0;
            var cos = +mathCos(a).toFixed(9),
            sin = + mathSin(a).toFixed(9);
            this.add(cos, sin, -sin, cos, x, y);
            this.add(1, 0, 0, 1, -x, -y);
        };

        /*\
         * Matrix.x
         [ method ]
         **
         * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y
         > Parameters
         - x (number)
         - y (number)
         = (number) x
        \*/
        matrixproto.x = function(x, y) {
            return x * this.a + y * this.c + this.e;
        };

        /*\
         * Matrix.y
         [ method ]
         **
         * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x
         > Parameters
         - x (number)
         - y (number)
         = (number) y
        \*/
        matrixproto.y = function(x, y) {
            return x * this.b + y * this.d + this.f;
        };
        matrixproto.get = function(i) {
            return +this[Str.fromCharCode(97 + i)].toFixed(4);
        };
        matrixproto.toString = function() {
            return R.svg ?
            "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" :
            [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();
        };
        matrixproto.toMatrixString = function() {
            return "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")";
        };
        matrixproto.toFilter = function() {
            return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) +
            ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) +
            ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')";
        };
        matrixproto.offset = function() {
            return [this.e.toFixed(4), this.f.toFixed(4)];
        };
        function norm(a) {
            return a[0] * a[0] + a[1] * a[1];
        }
        function normalize(a) {
            var mag = mathSqrt(norm(a));
            a[0] && (a[0] /= mag);
            a[1] && (a[1] /= mag);
        }

        /*\
         * Matrix.split
         [ method ]
         **
         * Splits matrix into primitive transformations
         = (object) in format:
         o dx (number) translation by x
         o dy (number) translation by y
         o scalex (number) scale by x
         o scaley (number) scale by y
         o shear (number) shear
         o rotate (number) rotation in deg
         o isSimple (boolean) could it be represented via simple transformations
        \*/
        matrixproto.split = function() {
            var out = {};
            // translation
            out.dx = this.e;
            out.dy = this.f;

            // scale and shear
            var row = [[this.a, this.c], [this.b, this.d]];
            out.scalex = mathSqrt(norm(row[0]));
            normalize(row[0]);

            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
            row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

            out.scaley = mathSqrt(norm(row[1]));
            normalize(row[1]);
            out.shear /= out.scaley;

            // rotation
            var sin = -row[0][1],
            cos = row[1][1];
            if (cos < 0) {
                out.rotate = R.deg(math.acos(cos));
                if (sin < 0) {
                    out.rotate = 360 - out.rotate;
                }
            } else {
                out.rotate = R.deg(math.asin(sin));
            }

            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
            return out;
        };

        /*\
         * Matrix.toTransformString
         [ method ]
         **
         * Return transform string that represents given matrix
         = (string) transform string
        \*/
        matrixproto.toTransformString = function(shorter) {
            var s = shorter || this[split]();
            if (s.isSimple) {
                s.scalex = +s.scalex.toFixed(4);
                s.scaley = +s.scaley.toFixed(4);
                s.rotate = +s.rotate.toFixed(4);
                return  (s.dx || s.dy ? "t" + [s.dx, s.dy] : E) +
                (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
                (s.rotate ? "r" + [s.rotate, 0, 0] : E);
            } else {
                return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
            }
        };
    })(Matrix.prototype);

    // WebKit rendering bug workaround method
    var version = navigator.userAgent.match(/Version\/(.*?)\s/) || navigator.userAgent.match(/Chrome\/(\d+)/);
    if ((navigator.vendor == "Apple Computer, Inc.") && (version && version[1] < 4 || navigator.platform.slice(0, 2) == "iP") ||
        (navigator.vendor == "Google Inc." && version && version[1] < 8)) {

        /*\
         * Paper.safari
         [ method ]
         **
         * There is an inconvenient rendering bug in Safari (WebKit):
         * sometimes the rendering should be forced.
         * This method should help with dealing with this bug.
        \*/
        paperproto.safari = function() {
            var rect = this.rect(-99, -99, this.width + 99, this.height + 99).attr({
                stroke: "none"
            });
            setTimeout(function() {
                rect.remove();
            });
            return true;
        };
    } else {
        paperproto.safari = fun;
    }

    var preventDefault = function() {
        this.returnValue = false;
    },
    preventTouch = function() {
        return this.originalEvent.preventDefault();
    },
    stopPropagation = function() {
        this.cancelBubble = true;
    },
    stopTouch = function() {
        return this.originalEvent.stopPropagation();
    },
    addEvent = R.addEvent = (function() {
        if (g.doc.addEventListener) {
            return function(obj, type, fn, element) {
                var realName = supportsTouch && touchMap[type] ? touchMap[type] : type,
                f = function(e) {
                    var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                        scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
                    if (supportsTouch && touchMap[has](type)) {
                        for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                            if (e.targetTouches[i].target == obj) {
                                var olde = e;
                                e = e.targetTouches[i];
                                e.originalEvent = olde;
                                e.preventDefault = preventTouch;
                                e.stopPropagation = stopTouch;
                                break;
                            }
                        }
                    }
                    return fn.call(element, e, e.clientX + scrollX, e.clientY + scrollY);
                };
                obj.addEventListener(realName, f, false);
                return function() {
                    obj.removeEventListener(realName, f, false);
                    return true;
                };
            };
        } else if (g.doc.attachEvent) {
            return function(obj, type, fn, element) {
                var f = function(e) {
                    e = e || g.win.event;
                    var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                    scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                    x = e.clientX + scrollX,
                    y = e.clientY + scrollY;
                    e.preventDefault = e.preventDefault || preventDefault;
                    e.stopPropagation = e.stopPropagation || stopPropagation;
                    return fn.call(element, e, x, y);
                };
                obj.attachEvent("on" + type, f);
                var detacher = function() {
                    obj.detachEvent("on" + type, f);
                    return true;
                };
                return detacher;
            };
        }
    })(),

    drag = [],

    dragMove = function(e) {
        var x = e.clientX,
            y = e.clientY,
            scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
            scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
            dragi,
            j = drag.length;

        while (j--) {
            dragi = drag[j];
            if (supportsTouch) {
                var i = e.touches.length,
                touch;
                while (i--) {
                    touch = e.touches[i];
                    if (touch.identifier == dragi.el._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                        break;
                    }
                }
            } else {
                e.preventDefault();
            }

            if (dragi.el.removed) {
                continue;
            }

            var node = R._engine.getNode(dragi.el),
                o,
                next = node.nextSibling,
                parent = node.parentNode,
                display = node.style.display;

            g.win.opera && parent.removeChild(node);

            node.style.display = "none";
            o = dragi.el.paper.getElementByPoint(x, y);
            node.style.display = display;
            g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
            o && eve("raphael.drag.over." + dragi.el.id, dragi.el, o);
            x += scrollX;
            y += scrollY;
            eve("raphael.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
        }
    },
    dragUp = function(e) {
        R.unmousemove(dragMove).unmouseup(dragUp);
        var i = drag.length,
            dragi;

        while (i--) {
            dragi = drag[i];
            dragi.el._drag = {};
            eve("raphael.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
        }
        drag = [];
    },

    /*\
     * Raphael.el
     [ property (object) ]
     **
     * You can add your own method to elements. This is usefull when you want to hack default functionality or
     * want to wrap some common transformation or attributes in one method. In difference to canvas methods,
     * you can redefine element method at any time. Expending element methods wouldn?셳 affect set.
     > Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | // then use it
     | paper.circle(100, 100, 20).red();
    \*/
    elproto = R.el = {};

    /*\
     * Element.click
     [ method ]
     **
     * Adds event handler for click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unclick
     [ method ]
     **
     * Removes event handler for click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.dblclick
     [ method ]
     **
     * Adds event handler for double click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.undblclick
     [ method ]
     **
     * Removes event handler for double click for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mousedown
     [ method ]
     **
     * Adds event handler for mousedown for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousedown
     [ method ]
     **
     * Removes event handler for mousedown for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mousemove
     [ method ]
     **
     * Adds event handler for mousemove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmousemove
     [ method ]
     **
     * Removes event handler for mousemove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseout
     [ method ]
     **
     * Adds event handler for mouseout for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseout
     [ method ]
     **
     * Removes event handler for mouseout for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseover
     [ method ]
     **
     * Adds event handler for mouseover for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseover
     [ method ]
     **
     * Removes event handler for mouseover for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.mouseup
     [ method ]
     **
     * Adds event handler for mouseup for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.unmouseup
     [ method ]
     **
     * Removes event handler for mouseup for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchstart
     [ method ]
     **
     * Adds event handler for touchstart for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchstart
     [ method ]
     **
     * Removes event handler for touchstart for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchmove
     [ method ]
     **
     * Adds event handler for touchmove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchmove
     [ method ]
     **
     * Removes event handler for touchmove for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchend
     [ method ]
     **
     * Adds event handler for touchend for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchend
     [ method ]
     **
     * Removes event handler for touchend for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/

    /*\
     * Element.touchcancel
     [ method ]
     **
     * Adds event handler for touchcancel for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    /*\
     * Element.untouchcancel
     [ method ]
     **
     * Removes event handler for touchcancel for the element.
     > Parameters
     - handler (function) handler for the event
     = (object) @Element
    \*/
    for (var i = events.length; i--; ) {
        (function(eventName) {
            R[eventName] = elproto[eventName] = function(fn, scope) {
                if (R.is(fn, "function")) {
                    this.events = this.events || [];
                    this.events.push({
                        name: eventName,
                        f: fn,
                        unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)
                    });
                }
                return this;
            };
            R["un" + eventName] = elproto["un" + eventName] = function(fn) {
                var events = this.events || [],
                l = events.length;
                while (l--)
                    if (events[l].name == eventName && events[l].f == fn) {
                        events[l].unbind();
                        events.splice(l, 1);
                        !events.length && delete this.events;
                        return this;
                    }
                return this;
            };
        })(events[i]);
    }

    /*\
     * Element.data
     [ method ]
     **
     * Adds or retrieves given value asociated with given key.
     **
     * See also @Element.removeData
     > Parameters
     - key (string) key to store data
     - value (any) #optional value to store
     = (object) @Element
     * or, if value is not specified:
     = (any) value
     > Usage
     | for (var i = 0, i < 5, i++) {
     |     paper.circle(10 + 15 * i, 10, 10)
     |          .attr({fill: "#000"})
     |          .data("i", i)
     |          .click(function () {
     |             alert(this.data("i"));
     |          });
     | }
    \*/
    elproto.data = function(key, value) {
        var data = eldata[this.id] = eldata[this.id] || {};
        if (arguments.length == 1) {
            if (R.is(key, object)) {
                for (var i in key)
                    if (key[has](i)) {
                        this.data(i, key[i]);
                    }
                return this;
            }
            eve("raphael.data.get." + this.id, this, data[key], key);
            return data[key];
        }
        data[key] = value;
        eve("raphael.data.set." + this.id, this, value, key);
        return this;
    };

    /*\
     * Element.removeData
     [ method ]
     **
     * Removes value associated with an element by given key.
     * If key is not provided, removes all the data of the element.
     > Parameters
     - key (string) #optional key
     = (object) @Element
    \*/
    elproto.removeData = function (key) {
        if (key == null) {
            delete eldata[this.id];
        } else {
            eldata[this.id] && delete eldata[this.id][key];
        }
        return this;
    };

     /*\
     * Element.getData
     [ method ]
     **
     * Retrieves the element data
     = (object) data
    \*/
    elproto.getData = function () {
        return clone(eldata[this.id] || {});
    };

    var downables = [],
        mouseDown = function () {
            this.untrack = addEvent(g.doc, 'mouseup', mouseUp, this);
        },
        mouseUp = function () {
            this.untrack();
            this.untrack = null;
            return this.fn && this.fn.apply(this.scope || this.el, arguments);

        };
    elproto.mouseup = function (fn, scope, track) {
        if (!track) {
            return R.mouseup.apply(this, arguments);
        }
        downables.push(track = {
            el: this,
            fn: fn,
            scope: scope
        });
        track.unbind = addEvent(this.shape || this.node || g.doc,
            'mousedown', mouseDown, track);

        return this;
    };

    elproto.unmouseup = function (fn) {
        var i = downables.length,
            undowned;
        while (i--) {
            if (downables[i].el === this && downables[i].fn === fn) {
                undowned = downables[i];
                undowned.unbind();
                undowned.untrack && undowned.untrack();
                downables.splice(i, 1);
            }
        }
        return undowned ? this : R.unmouseup.apply(this, arguments);
    };

    /*\
     * Element.hover
     [ method ]
     **
     * Adds event handlers for hover for the element.
     > Parameters
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     - icontext (object) #optional context for hover in handler
     - ocontext (object) #optional context for hover out handler
     = (object) @Element
    \*/
    elproto.hover = function(f_in, f_out, scope_in, scope_out) {
        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };

    /*\
     * Element.unhover
     [ method ]
     **
     * Removes event handlers for hover for the element.
     > Parameters
     - f_in (function) handler for hover in
     - f_out (function) handler for hover out
     = (object) @Element
    \*/
    elproto.unhover = function(f_in, f_out) {
        return this.unmouseover(f_in).unmouseout(f_out);
    };
    var draggable = [];

    /*\
     * Element.drag
     [ method ]
     **
     * Adds event handlers for drag of the element.
     > Parameters
     - onmove (function) handler for moving
     - onstart (function) handler for drag start
     - onend (function) handler for drag end
     - mcontext (object) #optional context for moving handler
     - scontext (object) #optional context for drag start handler
     - econtext (object) #optional context for drag end handler
     * Additionaly following `drag` events will be triggered: `drag.start.<id>` on start,
     * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element
     * `drag.over.<id>` will be fired as well.
     *
     * Start event and start handler will be called in specified context or in context of the element with following parameters:
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * Move event and move handler will be called in specified context or in context of the element with following parameters:
     o dx (number) shift by x from the start point
     o dy (number) shift by y from the start point
     o x (number) x position of the mouse
     o y (number) y position of the mouse
     o event (object) DOM event object
     * End event and end handler will be called in specified context or in context of the element with following parameters:
     o event (object) DOM event object
     = (object) @Element
    \*/
    elproto.drag = function(onmove, onstart, onend, move_scope, start_scope, end_scope) {
        function start(e) {
            (e.originalEvent || e).preventDefault();
            var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;

            this._drag.x = e.clientX + scrollX;
            this._drag.y = e.clientY + scrollY;
            this._drag.id = e.identifier;

            !drag.length && R.mousemove(dragMove).mouseup(dragUp);

            drag.push({
                el: this,
                move_scope: move_scope,
                start_scope: start_scope,
                end_scope: end_scope
            });

            onstart && eve.on("raphael.drag.start." + this.id, onstart);
            onmove && eve.on("raphael.drag.move." + this.id, onmove);
            onend && eve.on("raphael.drag.end." + this.id, onend);
            eve("raphael.drag.start." + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
        }
        this._drag = {};
        draggable.push({
            el: this,
            start: start
        });
        this.mousedown(start);
        return this;
    };

    /*\
     * Element.onDragOver
     [ method ]
     **
     * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).
     > Parameters
     - f (function) handler for event, first argument would be the element you are dragging over
    \*/
    elproto.onDragOver = function(f) {
        f ? eve.on("raphael.drag.over." + this.id, f) : eve.unbind("raphael.drag.over." + this.id);
    };

    /*\
     * Element.undrag
     [ method ]
     **
     * Removes all drag event handlers from given element.
    \*/
    elproto.undrag = function() {
        var i = draggable.length;
        while (i--) {
            if (draggable[i].el == this) {
                this.unmousedown(draggable[i].start);
                draggable.splice(i, 1);
                eve.unbind("raphael.drag.*." + this.id);
            }
        }

        !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
        delete this._drag;
    };

    elproto.follow = function(el, callback, stalk) {
        if (el.removed || el.constructor !== R.el.constructor) {
            return this;
        }
        el.followers.push({
            el: this,
            stalk: (stalk = {before: 'insertBefore', after: 'insertAfter'}[stalk]),
            cb: callback
        });

        stalk && this[stalk](el);
        return this;
    };

    elproto.unfollow = function(el) {
        if (el.removed || el.constructor !== R.el.constructor) {
            return this;
        }
        for (var i = 0, ii = el.followers.length; i < ii; i++) {
            if (el.followers[i].el === this) {
                el.followers.splice(i, 1);
                break;
            }
        }
        return this;
    };

    /*\
     * Paper.hide
     [ method ]
     **
     * Hides a paper
     **
     > Usage
     | paper.hide();
    \*/
    paperproto.hide = function () {
        var paper = this;
        paper.canvas.style.visibility = "hidden";
        return paper;
    };

    /*\
     * Paper.show
     [ method ]
     **
     * Shows a hidden paper
     **
     > Usage
     | paper.show();
    \*/
    paperproto.show = function () {
        var paper = this;
        paper.canvas.style.visibility = E;
        return paper;
    };

    /*\
     * Paper.group
     [ method ]
     **
     * Creates a group
     **
     > Parameters
     **
     - id (number) id of the group
     = (object) Rapha챘l element object with type ?쐅roup??     **
     > Usage
     | var g = paper.group();
    \*/
    paperproto.group = function () { // id
        var paper = this,
            args = arguments,
            group = lastArgIfGroup(args, true),
            out = R._engine.group(paper, args[0], group);
        return (paper.__set__ && paper.__set__.push(out), (paper._elementsById[out.id] = out));
    };

    /*\
     * Paper.circle
     [ method ]
     **
     * Draws a circle.
     **
     > Parameters
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - r (number) radius
     = (object) Rapha챘l element object with type ?쐁ircle??     **
     > Usage
     | var c = paper.circle(50, 50, 40);
    \*/
    paperproto.circle = function () { // x, y, r
        var paper = this,
            args = arguments,
            group = lastArgIfGroup(args, true),
            attrs = serializeArgs(args,
                "cx", 0,
                "cy", 0,
                "r", 0,
                "fill", none,
                "stroke", black),
            out = R._engine.circle(paper, attrs, group);

        return (paper.__set__ && paper.__set__.push(out), (paper._elementsById[out.id] = out));
    };


    /*\
     * Paper.rect
     [ method ]
     *
     * Draws a rectangle.
     **
     > Parameters
     **
     - x (number) x coordinate of the top left corner
     - y (number) y coordinate of the top left corner
     - width (number) width
     - height (number) height
     - r (number) #optional radius for rounded corners, default is 0
     = (object) Rapha챘l element object with type ?쐒ect??     **
     > Usage
     | // regular rectangle
     | var c = paper.rect(10, 10, 50, 50);
     | // rectangle with rounded corners
     | var c = paper.rect(40, 40, 50, 50, 10);
    \*/
    paperproto.rect = function () {
        var paper = this,
            args = arguments,
            group = lastArgIfGroup(args, true),
            attrs = serializeArgs(args,
                "x", 0,
                "y", 0,
                "width", 0,
                "height", 0,
                "r", 0,
                "fill", none,
                "stroke", black),
            out = R._engine.rect(paper, attrs, group);

        return (paper.__set__ && paper.__set__.push(out), (paper._elementsById[out.id] = out));
    };

    /*\
     * Paper.ellipse
     [ method ]
     **
     * Draws an ellipse.
     **
     > Parameters
     **
     - x (number) x coordinate of the centre
     - y (number) y coordinate of the centre
     - rx (number) horizontal radius
     - ry (number) vertical radius
     = (object) Rapha챘l element object with type ?쐃llipse??     **
     > Usage
     | var c = paper.ellipse(50, 50, 40, 20);
    \*/
    paperproto.ellipse = function () {
        var paper = this,
            args = arguments,
            group = lastArgIfGroup(args, true),
            attrs = serializeArgs(args,
                "x", 0,
                "y", 0,
                "rx", 0,
                "ry", 0,
                "fill", none,
                "stroke", black),
            out = R._engine.ellipse(this, attrs, group);

        return (paper.__set__ && paper.__set__.push(out), (paper._elementsById[out.id] = out));
    };

    /*\
     * Paper.path
     [ method ]
     **
     * Creates a path element by given path data string.
     > Parameters
     - pathString (string) #optional path string in SVG format.
     * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:
     | "M10,20L30,40"
     * Here we can see two commands: ?쏮?? with arguments `(10, 20)` and ?쏬??with arguments `(30, 40)`. Upper case letter mean command is absolute, lower case?봱elative.
     *
     # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a>.</p>
     # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
     # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
     # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
     # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
     # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
     # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
     # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
     # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
     # <tr><td>Q</td><td>quadratic B챕zier curveto</td><td>(x1 y1 x y)+</td></tr>
     # <tr><td>T</td><td>smooth quadratic B챕zier curveto</td><td>(x y)+</td></tr>
     # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
     # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull?밨om_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
     * * ?쏞atmull-Rom curveto??is a not standard SVG command and added in 2.0 to make life easier.
     * Note: there is a special case when path consist of just three commands: ?쏮10,10R?쫧?? In this case path will smoothly connects to its beginning.
     > Usage
     | var c = paper.path("M10 10L90 90");
     | // draw a diagonal line:
     | // move to 10,10, line to 90,90
     * For example of path strings, check out these icons: http://raphaeljs.com/icons/
    \*/
    paperproto.path = function () {
        var paper = this,
            args = arguments,
            group = lastArgIfGroup(args, true),
            attrs = serializeArgs(args,
                "path", E,
                "fill", none,
                "stroke", black),
            out = R._engine.path(paper, attrs, group);
        return (paper.__set__ && paper.__set__.push(out), (paper._elementsById[out.id] = out));
    };

    /*\
     * Paper.image
     [ method ]
     **
     * Embeds an image into the surface.
     **
     > Parameters
     **
     - src (string) URI of the source image
     - x (number) x coordinate position
     - y (number) y coordinate position
     - width (number) width of the image
     - height (number) height of the image
     = (object) Rapha챘l element object with type ?쐇mage??     **
     > Usage
     | var c = paper.image("apple.png", 10, 10, 80, 80);
    \*/
    paperproto.image = function () {
        var paper = this,
            args = arguments,
            group = lastArgIfGroup(args, true),
            attrs = serializeArgs(args,
                "src", "about:blank",
                "x", 0,
                "y", 0,
                "width", 0,
                "height", 0)
            out = R._engine.image(paper, attrs, group);
        return (paper.__set__ && paper.__set__.push(out), (paper._elementsById[out.id] = out));
    };

    /*\
     * Paper.text
     [ method ]
     **
     * Draws a text string. If you need line breaks, put ??n??in the string.
     **
     > Parameters
     **
     - x (number) x coordinate position
     - y (number) y coordinate position
     - text (string) The text string to draw
     = (object) Rapha챘l element object with type ?쐔ext??     **
     > Usage
     | var t = paper.text(50, 50, "Rapha챘l\nkicks\nbutt!");
    \*/
    paperproto.text = function() {
        var paper = this,
            args = arguments,
            group = lastArgIfGroup(args, true),
            attrs = serializeArgs(args,
                "x", 0,
                "y", 0,
                "text", E,
                "stroke", none,
                "fill", black,
                "text-anchor", "middle",
                "vertical-align", "middle"),

            out = R._engine.text(paper, attrs, group);
        return (paper.__set__ && paper.__set__.push(out), (paper._elementsById[out.id] = out));
    };

    /*\
     * Paper.set
     [ method ]
     **
     * Creates array-like object to keep and operate several elements at once.
     * Warning: it doesn?셳 create any elements for itself in the page, it just groups existing elements.
     * Sets act as pseudo elements ??all methods available to an element can be used on a set.
     = (object) array-like object that represents set of elements
     **
     > Usage
     | var st = paper.set();
     | st.push(
     |     paper.circle(10, 10, 5),
     |     paper.circle(30, 10, 5)
     | );
     | st.attr({fill: "red"}); // changes the fill of both circles
    \*/
    paperproto.set = function(itemsArray) {
        !R.is(itemsArray, "array") && (itemsArray = arraySplice.call(arguments, 0, arguments.length));
        var out = new Set(itemsArray);
        this.__set__ && this.__set__.push(out);
        return out;
    };

    /*\
     * Paper.setStart
     [ method ]
     **
     * Creates @Paper.set. All elements that will be created after calling this method and before calling
     * @Paper.setFinish will be added to the set.
     **
     > Usage
     | paper.setStart();
     | paper.circle(10, 10, 5),
     | paper.circle(30, 10, 5)
     | var st = paper.setFinish();
     | st.attr({fill: "red"}); // changes the fill of both circles
    \*/
    paperproto.setStart = function(set) {
        this.__set__ = set || this.set();
    };

    /*\
     * Paper.setFinish
     [ method ]
     **
     * See @Paper.setStart. This method finishes catching and returns resulting set.
     **
     = (object) set
    \*/
    paperproto.setFinish = function(set) {
        var out = this.__set__;
        delete this.__set__;
        return out;
    };

    /*\
     * Paper.setSize
     [ method ]
     **
     * If you need to change dimensions of the canvas call this method
     **
     > Parameters
     **
     - width (number) new width of the canvas
     - height (number) new height of the canvas
    \*/
    paperproto.setSize = function(width, height) {
        return R._engine.setSize.call(this, width, height);
    };

    /*\
     * Paper.setViewBox
     [ method ]
     **
     * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by
     * specifying new boundaries.
     **
     > Parameters
     **
     - x (number) new x position, default is `0`
     - y (number) new y position, default is `0`
     - w (number) new width of the canvas
     - h (number) new height of the canvas
     - fit (boolean) `true` if you want graphics to fit into new boundary box
    \*/
    paperproto.setViewBox = function(x, y, w, h, fit) {
        return R._engine.setViewBox.call(this, x, y, w, h, fit);
    };

    /*\
     * Paper.top
     [ property ]
     **
     * Points to the topmost element on the paper
    \*/
    /*\
     * Paper.bottom
     [ property ]
     **
     * Points to the bottom element on the paper
    \*/
    paperproto.top = paperproto.bottom = null;

    /*\
     * Paper.raphael
     [ property ]
     **
     * Points to the @Raphael object/function
    \*/
    paperproto.raphael = R;

    var getOffset = function(elem) {
        var box = elem.getBoundingClientRect(),
        doc = elem.ownerDocument,
        body = doc.body,
        docElem = doc.documentElement,
        clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
        top = box.top + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop) - clientTop,
        left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
        return {
            y: top,
            x: left
        };
    };

    /*\
     * Paper.getElementByPoint
     [ method ]
     **
     * Returns you topmost element under given point.
     **
     = (object) Rapha챘l element object
     > Parameters
     **
     - x (number) x coordinate from the top left corner of the window
     - y (number) y coordinate from the top left corner of the window
     > Usage
     | paper.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
    \*/
    paperproto.getElementByPoint = function(x, y) {
        var paper = this,
        svg = paper.canvas,
        target = g.doc.elementFromPoint(x, y);
        if (g.win.opera && target.tagName == "svg") {
            var so = getOffset(svg),
            sr = svg.createSVGRect();
            sr.x = x - so.x;
            sr.y = y - so.y;
            sr.width = sr.height = 1;
            var hits = svg.getIntersectionList(sr, null);
            if (hits.length) {
                target = hits[hits.length - 1];
            }
        }
        if (!target) {
            return null;
        }
        while (target.parentNode && target != svg.parentNode && !target.raphael) {
            target = target.parentNode;
        }
        target == paper.canvas.parentNode && (target = svg);
        target = target && target.raphael ? paper.getById(target.raphaelid) : null;
        return target;
    };

    /*\
     * Paper.getElementsByBBox
     [ method ]
     **
     * Returns set of elements that have an intersecting bounding box
     **
     > Parameters
     **
     - bbox (object) bbox to check with
     = (object) @Set
     \*/
     paperproto.getElementsByBBox = function (bbox) {
         var set = this.set();
         this.forEach(function (el) {
             if (R.isBBoxIntersect(el.getBBox(), bbox)) {
                 set.push(el);
             }
         });
         return set;
     };

    paperproto.getById = function(id) {
        return this._elementsById[id] || null;
    };

    /*\
     * Paper.forEach
     [ method ]
     **
     * Executes given function for each element on the paper
     *
     * If callback function returns `false` it will stop loop running.
     **
     > Parameters
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Paper object
     > Usage
     | paper.forEach(function (el) {
     |     el.attr({ stroke: "blue" });
     | });
    \*/
    paperproto.forEach = function(callback, thisArg) {
        var bot = this.bottom;
        while (bot) {
            if (callback.call(thisArg, bot) === false) {
                return this;
            }
            bot = bot.next;
        }
        return this;
    };

    /*\
     * Paper.getElementsByPoint
     [ method ]
     **
     * Returns set of elements that have common point inside
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (object) @Set
    \*/
    paperproto.getElementsByPoint = function(x, y) {
        var set = this.set();
        this.forEach(function(el) {
            if (el.isPointInside(x, y)) {
                set.push(el);
            }
        });
        return set;
    };
    function x_y() {
        return this.x + S + this.y;
    }
    function x_y_w_h() {
        return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
    }

    /*\
     * Element.isPointInside
     [ method ]
     **
     * Determine if given point is inside this element?셲 shape
     **
     > Parameters
     **
     - x (number) x coordinate of the point
     - y (number) y coordinate of the point
     = (boolean) `true` if point inside the shape
    \*/
    elproto.isPointInside = function(x, y) {
        var rp = this.realPath = this.realPath || getPath[this.type](this),
	      	tr;
		return R.isPointInsidePath(((tr = this.attr('transform')) &&
		        tr.length && R.transformPath(rp, tr)) || rp, x, y);
    };

    /*\
     * Element.getBBox
     [ method ]
     **
     * Return bounding box for a given element
     **
     > Parameters
     **
     - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.
     = (object) Bounding box object:
     o {
     o     x: (number) top left corner x
     o     y: (number) top left corner y
     o     x2: (number) bottom right corner x
     o     y2: (number) bottom right corner y
     o     width: (number) width
     o     height: (number) height
     o }
    \*/
    elproto.getBBox = function(isWithoutTransform) {
        if (this.removed) {
            return {};
        }
        var _ = this._;
        if (isWithoutTransform) {
            if (_.dirty || !_.bboxwt) {
                this.realPath = getPath[this.type](this);
                _.bboxwt = pathDimensions(this.realPath);
                _.bboxwt.toString = x_y_w_h;
                _.dirty = 0;
            }
            return _.bboxwt;
        }
        if (_.dirty || _.dirtyT || !_.bbox) {
            if (_.dirty || !this.realPath) {
                _.bboxwt = 0;
                this.realPath = getPath[this.type](this);
            }
            _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
            _.bbox.toString = x_y_w_h;
            _.dirty = _.dirtyT = 0;
        }
        return _.bbox;
    };

    /*\
     * Element.clone
     [ method ]
     **
     = (object) clone of a given element
     **
    \*/
    elproto.clone = function() {
        if (this.removed) {
            return null;
        }
        var o = this,
            out = o.paper[o.type]().attr(o.attr());
        o.__set__ && o.__set__.push(out);
        return out;
    };

    /*\
     * Element.glow
     [ method ]
     **
     * Return set of elements that create glow-like effect around given element. See @Paper.set.
     *
     * Note: Glow is not connected to the element. If you change element attributes it won?셳 adjust itself.
     **
     > Parameters
     **
     - glow (object) #optional parameters object with all properties optional:
     o {
     o     width (number) size of the glow, default is `10`
     o     fill (boolean) will it be filled, default is `false`
     o     opacity (number) opacity, default is `0.5`
     o     offsetx (number) horizontal offset, default is `0`
     o     offsety (number) vertical offset, default is `0`
     o     color (string) glow colour, default is `black`
     o }
     = (object) @Paper.set of elements that represents glow
    \*/
    elproto.glow = function(glow) {
        if (this.type == "text") {
            return null;
        }
        glow = glow || {};
        var s = {
            width: (glow.width || 10) + (+this.attr("stroke-width") || 1),
            fill: glow.fill || false,
            opacity: glow.opacity || .5,
            offsetx: glow.offsetx || 0,
            offsety: glow.offsety || 0,
            color: glow.color || "#000"
        },
        c = s.width / 2,
        r = this.paper,
        out = r.set(),
        path = this.realPath || getPath[this.type](this);
        path = this.matrix ? mapPath(path, this.matrix) : path;
        for (var i = 1; i < c + 1; i++) {
            out.push(r.path(path).attr({
                stroke: s.color,
                fill: s.fill ? s.color : "none",
                "stroke-linejoin": "round",
                "stroke-linecap": "round",
                "stroke-width": +(s.width / c * i).toFixed(3),
                opacity: +(s.opacity / c).toFixed(3)
            }));
        }
        return out.insertBefore(this).translate(s.offsetx, s.offsety);
    };
    var curveslengths = {},
    getPointAtSegmentLength = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
        if (length == null) {
            return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
        } else {
            return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
        }
    },
    getLengthFactory = function(istotal, subpath) {
        return function(path, length, onlystart) {
            path = path2curve(path);
            var x, y, p, l, sp = "", subpaths = {}, point,
            len = 0;
            for (var i = 0, ii = path.length; i < ii; i++) {
                p = path[i];
                if (p[0] == "M") {
                    x = +p[1];
                    y = +p[2];
                } else {
                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    if (len + l > length) {
                        if (subpath && !subpaths.start) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            sp += ["C" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
                            if (onlystart) {
                                return sp;
                            }
                            subpaths.start = sp;
                            sp = ["M" + point.x, point.y + "C" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();
                            len += l;
                            x = +p[5];
                            y = +p[6];
                            continue;
                        }
                        if (!istotal && !subpath) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            return {
                                x: point.x,
                                y: point.y,
                                alpha: point.alpha
                            };
                        }
                    }
                    len += l;
                    x = +p[5];
                    y = +p[6];
                }
                sp += p.shift() + p;
            }
            subpaths.end = sp;
            point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
            point.alpha && (point = {
                x: point.x,
                y: point.y,
                alpha: point.alpha
            });
            return point;
        };
    };
    var getTotalLength = getLengthFactory(1),
    getPointAtLength = getLengthFactory(),
    getSubpathsAtLength = getLengthFactory(0, 1);

    R.getTotalLength = getTotalLength;

    R.getPointAtLength = getPointAtLength;

    R.getSubpath = function(path, from, to) {
        if (this.getTotalLength(path) - to < 1e-6) {
            return getSubpathsAtLength(path, from).end;
        }
        var a = getSubpathsAtLength(path, to, 1);
        return from ? getSubpathsAtLength(a, from).end : a;
    };

    /*\
     * Raphael.getTotalLength
     [ method ]
     **
     * Returns length of the given path in pixels.
     **
     > Parameters
     **
     - path (string) SVG path string.
     **
     = (number) length.
    \*/
    elproto.getTotalLength = function() {
        if (this.type != "path") {
            return;
        }
        if (this.node.getTotalLength) {
            return this.node.getTotalLength();
        }
        return getTotalLength(this.attrs.path);
    };

    /*\
     * Raphael.getPointAtLength
     [ method ]
     **
     * Return coordinates of the point located at the given length on the given path.
     **
     > Parameters
     **
     - path (string) SVG path string
     - length (number)
     **
     = (object) representation of the point:
     o {
     o     x: (number) x coordinate
     o     y: (number) y coordinate
     o     alpha: (number) angle of derivative
     o }
    \*/
    elproto.getPointAtLength = function(length) {
        if (this.type != "path") {
            return;
        }
        return getPointAtLength(this.attrs.path, length);
    };

    /*\
     * Raphael.getSubpath
     [ method ]
     **
     * Return subpath of a given path from given length to given length.
     **
     > Parameters
     **
     - path (string) SVG path string
     - from (number) position of the start of the segment
     - to (number) position of the end of the segment
     **
     = (string) pathstring for the segment
    \*/
    elproto.getSubpath = function(from, to) {
        if (this.type != "path") {
            return;
        }
        return R.getSubpath(this.attrs.path, from, to);
    };

    /*\
     * Raphael.easing_formulas
     [ property ]
     **
     * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:
     # <ul>
     #     <li>?쐋inear??/li>
     #     <li>??lt;??or ?쐃aseIn??or ?쐃ase-in??/li>
     #     <li>????or ?쐃aseOut??or ?쐃ase-out??/li>
     #     <li>??lt;>??or ?쐃aseInOut??or ?쐃ase-in-out??/li>
     #     <li>?쐀ackIn??or ?쐀ack-in??/li>
     #     <li>?쐀ackOut??or ?쐀ack-out??/li>
     #     <li>?쐃lastic??/li>
     #     <li>?쐀ounce??/li>
     # </ul>
     # <p>See also <a href="http://raphaeljs.com/easing.html">Easing demo</a>.</p>
    \*/
    var ef = R.easing_formulas = {
        linear: function(n) {
            return n;
        },
        "<": function(n) {
            return pow(n, 1.7);
        },
        ">": function(n) {
            return pow(n, .48);
        },
        "<>": function(n) {
            var q = .48 - n / 1.04,
            Q = mathSqrt(.1734 + q * q),
            x = Q - q,
            X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),
            y = -Q - q,
            Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),
            t = X + Y + .5;
            return (1 - t) * 3 * t * t + t * t * t;
        },
        backIn: function(n) {
            var s = 1.70158;
            return n * n * ((s + 1) * n - s);
        },
        backOut: function(n) {
            n = n - 1;
            var s = 1.70158;
            return n * n * ((s + 1) * n + s) + 1;
        },
        elastic: function(n) {
            if (n == !!n) {
                return n;
            }
            return pow(2, -10 * n) * mathSin((n - .075) * (2 * PI) / .3) + 1;
        },
        bounce: function(n) {
            var s = 7.5625,
            p = 2.75,
            l;
            if (n < (1 / p)) {
                l = s * n * n;
            } else {
                if (n < (2 / p)) {
                    n -= (1.5 / p);
                    l = s * n * n + .75;
                } else {
                    if (n < (2.5 / p)) {
                        n -= (2.25 / p);
                        l = s * n * n + .9375;
                    } else {
                        n -= (2.625 / p);
                        l = s * n * n + .984375;
                    }
                }
            }
            return l;
        }
    };
    ef.easeIn = ef["ease-in"] = ef["<"];
    ef.easeOut = ef["ease-out"] = ef[">"];
    ef.easeInOut = ef["ease-in-out"] = ef["<>"];
    ef["back-in"] = ef.backIn;
    ef["back-out"] = ef.backOut;

    var animationElements = [],
    requestAnimFrame = window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(callback) {
        setTimeout(callback, 16);
    },
    animation = function() {
        var Now = +new Date,
        l = 0;
        for (; l < animationElements.length; l++) {
            var e = animationElements[l];
            if (e.el.removed || e.paused) {
                continue;
            }
            var time = Now - e.start,
            ms = e.ms,
            easing = e.easing,
            from = e.from,
            diff = e.diff,
            to = e.to,
            t = e.t,
            that = e.el,
            set = {},
            now,
            init = {},
            key;
            if (e.initstatus) {
                time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
                e.status = e.initstatus;
                delete e.initstatus;
                e.stop && animationElements.splice(l--, 1);
            } else {
                e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
            }
            if (time < 0) {
                continue;
            }
            if (time < ms) {
                var pos = easing(time / ms);
                for (var attr in from)
                    if (from[has](attr)) {
                        switch (availableAnimAttrs[attr]) {
                            case nu:
                                now = +from[attr] + pos * ms * diff[attr];
                                break;
                            case "colour":
                                now = "rgb(" + [
                                upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                                upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                                upto255(round(from[attr].b + pos * ms * diff[attr].b))
                                ].join(",") + ")";
                                break;
                            case "path":
                                now = [];
                                for (var i = 0, ii = from[attr].length; i < ii; i++) {
                                    now[i] = [from[attr][i][0]];
                                    for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                        now[i][j] = (+from[attr][i][j] + pos * ms * diff[attr][i][j]).toFixed(4);
                                    }
                                    now[i] = now[i].join(S);
                                }
                                now = now.join(S);
                                break;
                            case "transform":
                                if (diff[attr].real) {
                                    now = [];
                                    for (i = 0, ii = from[attr].length; i < ii; i++) {
                                        now[i] = [from[attr][i][0]];
                                        for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                            now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                                        }
                                    }
                                } else {
                                    var get = function(i) {
                                        return +from[attr][i] + pos * ms * diff[attr][i];
                                    };
                                    // now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
                                    now = [["m", get(0), get(1), get(2), get(3), get(4), get(5)]];
                                }
                                break;
                            case "csv":
                                if (attr == "clip-rect") {
                                    now = [];
                                    i = 4;
                                    while (i--) {
                                        now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                                    }
                                }
                                break;
                            default:
                                var from2 = [][concat](from[attr]);
                                now = [];
                                i = that.ca[attr].length;
                                while (i--) {
                                    now[i] = +from2[i] + pos * ms * diff[attr][i];
                                }
                                break;
                        }
                        set[attr] = now;
                    }
                that.attr(set);
                (function(id, that, anim) {
                    setTimeout(function() {
                        eve("raphael.anim.frame." + id, that, anim);
                    });
                })(that.id, that, e.anim);
            } else {
                (function(f, el, a) {
                    setTimeout(function() {
                        eve("raphael.anim.frame." + el.id, el, a);
                        eve("raphael.anim.finish." + el.id, el, a);
                        R.is(f, "function") && f.call(el);
                    });
                })(e.callback, that, e.anim);
                that.attr(to);
                animationElements.splice(l--, 1);
                if (e.repeat > 1 && !e.next) {
                    for (key in to)
                        if (to[has](key)) {
                            init[key] = e.totalOrigin[key];
                        }
                    e.el.attr(init);
                    runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
                }
                if (e.next && !e.stop) {
                    runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
                }
            }
        }
        R.svg && that && that.paper && that.paper.safari();
        animationElements.length && requestAnimFrame(animation);
    },
    upto255 = function(color) {
        return color > 255 ? 255 : color < 0 ? 0 : color;
    };

    /*\
     * Element.animateWith
     [ method ]
     **
     * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.
     **
     > Parameters
     **
     - el (object) element to sync with
     - anim (object) animation to sync with
     - params (object) #optional final attributes for the element, see also @Element.attr
     - ms (number) #optional number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     * or
     - element (object) element to sync with
     - anim (object) animation to sync with
     - animation (object) #optional animation object, see @Raphael.animation
     **
     = (object) original element
    \*/
    elproto.animateWith = function(el, anim, params, ms, easing, callback) {
        var element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),
        x, y;
        runAnimation(a, element, a.percents[0], null, element.attr());
        for (var i = 0, ii = animationElements.length; i < ii; i++) {
            if (animationElements[i].anim == anim && animationElements[i].el == el) {
                animationElements[ii - 1].start = animationElements[i].start;
                break;
            }
        }
        return element;
    //
    //
    // var a = params ? R.animation(params, ms, easing, callback) : anim,
    //     status = element.status(anim);
    // return this.animate(a).status(a, status * anim.ms / a.ms);
    };
    function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
        var cx = 3 * p1x,
        bx = 3 * (p2x - p1x) - cx,
        ax = 1 - cx - bx,
        cy = 3 * p1y,
        by = 3 * (p2y - p1y) - cy,
        ay = 1 - cy - by;
        function sampleCurveX(t) {
            return ((ax * t + bx) * t + cx) * t;
        }
        function solve(x, epsilon) {
            var t = solveCurveX(x, epsilon);
            return ((ay * t + by) * t + cy) * t;
        }
        function solveCurveX(x, epsilon) {
            var t0, t1, t2, x2, d2, i;
            for (t2 = x, i = 0; i < 8; i++) {
                x2 = sampleCurveX(t2) - x;
                if (abs(x2) < epsilon) {
                    return t2;
                }
                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                if (abs(d2) < 1e-6) {
                    break;
                }
                t2 = t2 - x2 / d2;
            }
            t0 = 0;
            t1 = 1;
            t2 = x;
            if (t2 < t0) {
                return t0;
            }
            if (t2 > t1) {
                return t1;
            }
            while (t0 < t1) {
                x2 = sampleCurveX(t2);
                if (abs(x2 - x) < epsilon) {
                    return t2;
                }
                if (x > x2) {
                    t0 = t2;
                } else {
                    t1 = t2;
                }
                t2 = (t1 - t0) / 2 + t0;
            }
            return t2;
        }
        return solve(t, 1 / (200 * duration));
    }
    elproto.onAnimation = function(f) {
        f ? eve.on("raphael.anim.frame." + this.id, f) : eve.unbind("raphael.anim.frame." + this.id);
        return this;
    };
    function Animation(anim, ms) {
        var percents = [],
        newAnim = {};
        this.ms = ms;
        this.times = 1;
        if (anim) {
            for (var attr in anim)
                if (anim[has](attr)) {
                    newAnim[toFloat(attr)] = anim[attr];
                    percents.push(toFloat(attr));
                }
            percents.sort(sortByNumber);
        }
        this.anim = newAnim;
        this.top = percents[percents.length - 1];
        this.percents = percents;
    }

    /*\
     * Animation.delay
     [ method ]
     **
     * Creates a copy of existing animation object with given delay.
     **
     > Parameters
     **
     - delay (number) number of ms to pass between animation start and actual animation
     **
     = (object) new altered Animation object
     | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);
     | circle1.animate(anim); // run the given animation immediately
     | circle2.animate(anim.delay(500)); // run the given animation after 500 ms
    \*/
    Animation.prototype.delay = function(delay) {
        var a = new Animation(this.anim, this.ms);
        a.times = this.times;
        a.del = +delay || 0;
        return a;
    };

    /*\
     * Animation.repeat
     [ method ]
     **
     * Creates a copy of existing animation object with given repetition.
     **
     > Parameters
     **
     - repeat (number) number iterations of animation. For infinite animation pass `Infinity`
     **
     = (object) new altered Animation object
    \*/
    Animation.prototype.repeat = function(times) {
        var a = new Animation(this.anim, this.ms);
        a.del = this.del;
        a.times = math.floor(mmax(times, 0)) || 1;
        return a;
    };
    function runAnimation(anim, element, percent, status, totalOrigin, times) {
        percent = toFloat(percent);
        var params,
        isInAnim,
        isInAnimSet,
        percents = [],
        next,
        prev,
        timestamp,
        ms = anim.ms,
        from = {},
        to = {},
        diff = {};
        if (status) {
            for (i = 0, ii = animationElements.length; i < ii; i++) {
                var e = animationElements[i];
                if (e.el.id == element.id && e.anim == anim) {
                    if (e.percent != percent) {
                        animationElements.splice(i, 1);
                        isInAnimSet = 1;
                    } else {
                        isInAnim = e;
                    }
                    element.attr(e.totalOrigin);
                    break;
                }
            }
        } else {
            status = +to; // NaN
        }
        for (var i = 0, ii = anim.percents.length; i < ii; i++) {
            if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
                percent = anim.percents[i];
                prev = anim.percents[i - 1] || 0;
                ms = ms / anim.top * (percent - prev);
                next = anim.percents[i + 1];
                params = anim.anim[percent];
                break;
            } else if (status) {
                element.attr(anim.anim[anim.percents[i]]);
            }
        }
        if (!params) {
            return;
        }
        if (!isInAnim) {
            for (var attr in params)
                if (params[has](attr)) {
                    if (availableAnimAttrs[has](attr) || element.ca[attr]) {
                        from[attr] = element.attr(attr);
                        (from[attr] == null) && (from[attr] = availableAttrs[attr]);
                        to[attr] = params[attr];
                        switch (availableAnimAttrs[attr]) {
                            case nu:
                                diff[attr] = (to[attr] - from[attr]) / ms;
                                break;
                            case "colour":
                                from[attr] = R.getRGB(from[attr]);
                                var toColour = R.getRGB(to[attr]);
                                diff[attr] = {
                                    r: (toColour.r - from[attr].r) / ms,
                                    g: (toColour.g - from[attr].g) / ms,
                                    b: (toColour.b - from[attr].b) / ms
                                };
                                break;
                            case "path":
                                var pathes = path2curve(from[attr], to[attr]),
                                toPath = pathes[1];
                                from[attr] = pathes[0];
                                diff[attr] = [];
                                for (i = 0, ii = from[attr].length; i < ii; i++) {
                                    diff[attr][i] = [0];
                                    for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                        diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                                    }
                                }
                                break;
                            case "transform":
                                var _ = element._,
                                eq = equaliseTransform(_[attr], to[attr]);
                                if (eq) {
                                    from[attr] = eq.from;
                                    to[attr] = eq.to;
                                    diff[attr] = [];
                                    diff[attr].real = true;
                                    for (i = 0, ii = from[attr].length; i < ii; i++) {
                                        diff[attr][i] = [from[attr][i][0]];
                                        for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                            diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                                        }
                                    }
                                } else {
                                    var m = (element.matrix || new Matrix),
                                    to2 = {
                                        _: {
                                            transform: _.transform
                                        },
                                        getBBox: function() {
                                            return element.getBBox(1);
                                        }
                                    };
                                    from[attr] = [
                                    m.a,
                                    m.b,
                                    m.c,
                                    m.d,
                                    m.e,
                                    m.f
                                    ];
                                    extractTransform(to2, to[attr]);
                                    to[attr] = to2._.transform;
                                    diff[attr] = [
                                    (to2.matrix.a - m.a) / ms,
                                    (to2.matrix.b - m.b) / ms,
                                    (to2.matrix.c - m.c) / ms,
                                    (to2.matrix.d - m.d) / ms,
                                    (to2.matrix.e - m.e) / ms,
                                    (to2.matrix.f - m.f) / ms
                                    ];
                                // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
                                // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
                                // extractTransform(to2, to[attr]);
                                // diff[attr] = [
                                //     (to2._.sx - _.sx) / ms,
                                //     (to2._.sy - _.sy) / ms,
                                //     (to2._.deg - _.deg) / ms,
                                //     (to2._.dx - _.dx) / ms,
                                //     (to2._.dy - _.dy) / ms
                                // ];
                                }
                                break;
                            case "csv":
                                var values = Str(params[attr])[split](separator),
                                from2 = Str(from[attr])[split](separator);
                                if (attr == "clip-rect") {
                                    from[attr] = from2;
                                    diff[attr] = [];
                                    i = from2.length;
                                    while (i--) {
                                        diff[attr][i] = (values[i] - from[attr][i]) / ms;
                                    }
                                }
                                to[attr] = values;
                                break;
                            default:
                                values = [][concat](params[attr]);
                                from2 = [][concat](from[attr]);
                                diff[attr] = [];
                                i = element.ca[attr].length;
                                while (i--) {
                                    diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
                                }
                                break;
                        }
                    }
                }
            var easing = params.easing,
            easyeasy = R.easing_formulas[easing];
            if (!easyeasy) {
                easyeasy = Str(easing).match(bezierrg);
                if (easyeasy && easyeasy.length == 5) {
                    var curve = easyeasy;
                    easyeasy = function(t) {
                        return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                    };
                } else {
                    easyeasy = pipe;
                }
            }
            timestamp = params.start || anim.start || +new Date;
            e = {
                anim: anim,
                percent: percent,
                timestamp: timestamp,
                start: timestamp + (anim.del || 0),
                status: 0,
                initstatus: status || 0,
                stop: false,
                ms: ms,
                easing: easyeasy,
                from: from,
                diff: diff,
                to: to,
                el: element,
                callback: params.callback,
                prev: prev,
                next: next,
                repeat: times || anim.times,
                origin: element.attr(),
                totalOrigin: totalOrigin
            };
            animationElements.push(e);
            if (status && !isInAnim && !isInAnimSet) {
                e.stop = true;
                e.start = new Date - ms * status;
                if (animationElements.length == 1) {
                    return animation();
                }
            }
            if (isInAnimSet) {
                e.start = new Date - e.ms * status;
            }
            animationElements.length == 1 && requestAnimFrame(animation);
        } else {
            isInAnim.initstatus = status;
            isInAnim.start = new Date - isInAnim.ms * status;
        }
        eve("raphael.anim.start." + element.id, element, anim);
    }

    /*\
     * Raphael.animation
     [ method ]
     **
     * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.
     * See also @Animation.delay and @Animation.repeat methods.
     **
     > Parameters
     **
     - params (object) final attributes for the element, see also @Element.attr
     - ms (number) number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     **
     = (object) @Animation
    \*/
    R.animation = function(params, ms, easing, callback) {
        if (params instanceof Animation) {
            return params;
        }
        if (R.is(easing, "function") || !easing) {
            callback = callback || easing || null;
            easing = null;
        }
        params = Object(params);
        ms = +ms || 0;
        var p = {},
        json,
        attr;
        for (attr in params)
            if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + "%" != attr) {
                json = true;
                p[attr] = params[attr];
            }
        if (!json) {
            return new Animation(params, ms);
        } else {
            easing && (p.easing = easing);
            callback && (p.callback = callback);
            return new Animation({
                100: p
            }, ms);
        }
    };

    /*\
     * Element.animate
     [ method ]
     **
     * Creates and starts animation for given element.
     **
     > Parameters
     **
     - params (object) final attributes for the element, see also @Element.attr
     - ms (number) number of milliseconds for animation to run
     - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
     - callback (function) #optional callback function. Will be called at the end of animation.
     * or
     - animation (object) animation object, see @Raphael.animation
     **
     = (object) original element
    \*/
    elproto.animate = function(params, ms, easing, callback) {
        var element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
        runAnimation(anim, element, anim.percents[0], null, element.attr());
        return element;
    };

    /*\
     * Element.setTime
     [ method ]
     **
     * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.
     **
     > Parameters
     **
     - anim (object) animation object
     - value (number) number of milliseconds from the beginning of the animation
     **
     = (object) original element if `value` is specified
     * Note, that during animation following events are triggered:
     *
     * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.
    \*/
    elproto.setTime = function(anim, value) {
        if (anim && value != null) {
            this.status(anim, mmin(value, anim.ms) / anim.ms);
        }
        return this;
    };

    /*\
     * Element.status
     [ method ]
     **
     * Gets or sets the status of animation of the element.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     - value (number) #optional 0 ??1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.
     **
     = (number) status
     * or
     = (array) status if `anim` is not specified. Array of objects in format:
     o {
     o     anim: (object) animation object
     o     status: (number) status
     o }
     * or
     = (object) original element if `value` is specified
    \*/
    elproto.status = function(anim, value) {
        var out = [],
        i = 0,
        len,
        e;
        if (value != null) {
            runAnimation(anim, this, -1, mmin(value, 1));
            return this;
        } else {
            len = animationElements.length;
            for (; i < len; i++) {
                e = animationElements[i];
                if (e.el.id == this.id && (!anim || e.anim == anim)) {
                    if (anim) {
                        return e.status;
                    }
                    out.push({
                        anim: e.anim,
                        status: e.status
                    });
                }
            }
            if (anim) {
                return 0;
            }
            return out;
        }
    };

    /*\
     * Element.pause
     [ method ]
     **
     * Stops animation of the element with ability to resume it later on.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/
    elproto.pause = function(anim) {
        for (var i = 0; i < animationElements.length; i++)
            if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
                if (eve("raphael.anim.pause." + this.id, this, animationElements[i].anim) !== false) {
                    animationElements[i].paused = true;
                }
            }
        return this;
    };

    /*\
     * Element.resume
     [ method ]
     **
     * Resumes animation if it was paused with @Element.pause method.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/
    elproto.resume = function(anim) {
        for (var i = 0; i < animationElements.length; i++)
            if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
                var e = animationElements[i];
                if (eve("raphael.anim.resume." + this.id, this, e.anim) !== false) {
                    delete e.paused;
                    this.status(e.anim, e.status);
                }
            }
        return this;
    };

    /*\
     * Element.stop
     [ method ]
     **
     * Stops animation of the element.
     **
     > Parameters
     **
     - anim (object) #optional animation object
     **
     = (object) original element
    \*/
    elproto.stop = function(anim) {
        for (var i = 0; i < animationElements.length; i++)
            if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
                if (eve("raphael.anim.stop." + this.id, this, animationElements[i].anim) !== false) {
                    animationElements.splice(i--, 1);
                }
            }
        return this;
    };
    function stopAnimation(paper) {
        for (var i = 0; i < animationElements.length; i++)
            if (animationElements[i].el.paper == paper) {
                animationElements.splice(i--, 1);
            }
    }
    eve.on("raphael.remove", stopAnimation);
    eve.on("raphael.clear", stopAnimation);
    elproto.toString = function() {
        return "Rapha\xebl\u2019s object";
    };

    elproto.toFront = function() {
        if (this.removed) {
            return this;
        }

        var o = this,
            thisNode = R._engine.getNode(o),
            parent = o.parent,
            followers = o.followers,
            follower,
            i,
            ii;

        if (R._tofront(o, parent)) {
            parent.canvas.appendChild(thisNode);
        }

        for (i = 0, ii = followers.length; i < ii; i++) {
            (follower = followers[i]).stalk && follower.el[follower.stalk](o);
        }
        return o;
    };

    elproto.toBack = function() {
        if (this.removed) {
            return this;
        }

        var o = this,
            thisNode = R._engine.getNode(o),
            parent = o.parent,
            followers = o.followers,
            follower,
            i,
            ii;

        if (R._toback(o, parent)) {
            parent.canvas.insertBefore(thisNode, parent.canvas.firstChild);
        }

        for (i = 0, ii = followers.length; i < ii; i++) {
            (follower = followers[i]).stalk && follower.el[follower.stalk](o);
        }
        return o;
    };

    elproto.insertAfter = function(element) {
        if (this.removed) {
            return this;
        }

        var o = this,
            thisNode = R._engine.getNode(o),
            thatNode = R._engine.getLastNode(element),
            parentNode = element.parent.canvas,
            followers = o.followers,
            follower,
            i,
            ii;

        if (thatNode.nextSibling) {
            parentNode.insertBefore(thisNode, thatNode.nextSibling);
        }
        else {
            parentNode.appendChild(thisNode);
        }
        R._insertafter(o, element, o.parent, element.parent);

        for (i = 0, ii = followers.length; i < ii; i++) {
            (follower = followers[i]).stalk &&
                follower.el[follower.stalk](element);
        }
        return o;
    };

    elproto.insertBefore = function(element) {
        if (this.removed) {
            return this;
        }

        var o = this,
            thisNode = R._engine.getNode(o),
            thatNode = R._engine.getNode(element),
            followers = o.followers,
            follower,
            i,
            ii;

        element.parent.canvas.insertBefore(thisNode, thatNode);
        R._insertbefore(o, element, o.parent, element.parent);
        o.parent = element.parent;

        for (i = 0, ii = followers.length; i < ii; i++) {
            (follower = followers[i]).stalk &&
                follower.el[follower.stalk](element);
        }
        return this;
    };

    elproto.appendChild = function (element) {
        if (this.removed || this.type !== 'group') {
            return this;
        }

        var group = this,
            followers = group.followers,
            follower,
            thatNode,
            i,
            ii;

        // If appending in same group, simply perform toFront().
        if (element.parent === group) {
            element.toFront();
            return group;
        }

        thatNode = R._engine.getNode(element);

        // first remove from own group
        R._tear(element, element.parent);

        group.canvas.appendChild(thatNode);
        element.parent = group;

        !group.bottom && (group.bottom = element);
        element.prev = group.top;
        element.next = null;
        group.top && (group.top.next = element);
        group.top = element;

        for (i = 0, ii = followers.length; i < ii; i++) {
            (follower = followers[i]).stalk &&
                follower.el[follower.stalk](element);
        }

        return group;
    };

    elproto.removeChild = function (element) {
        if (this.removed || this.type !== 'group' || element.parent !== this) {
            return this;
        }

        var o = this,
            thatNode = R._engine.getNode(element),
            paper = o.paper;

        R._tear(element, o);
        paper.canvas.appendChild(thatNode);

        o.parent = paper;
        !paper.bottom && (paper.bottom = o);

        o.prev = paper.top;
        paper.top && (paper.top.next = o);
        paper.top = o;
        o.next = null;

        return o;
    };

    // Set
    var Set = function(items) {
        this.items = [];
        this.length = 0;
        this.type = "set";
        if (items) {
            for (var i = 0, ii = items.length; i < ii; i++) {
                if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
                    this[this.items.length] = this.items[this.items.length] = items[i];
                    this.length++;
                }
            }
        }
    },
    setproto = Set.prototype;

    /*\
     * Set.push
     [ method ]
     **
     * Adds each argument to the current set.
     = (object) original element
    \*/
    setproto.push = function() {
        var item,
        len;
        for (var i = 0, ii = arguments.length; i < ii; i++) {
            item = arguments[i];
            if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
                len = this.items.length;
                this[len] = this.items[len] = item;
                this.length++;
            }
        }
        return this;
    };

    /*\
     * Set.pop
     [ method ]
     **
     * Removes last element and returns it.
     = (object) element
    \*/
    setproto.pop = function() {
        this.length && delete this[this.length--];
        return this.items.pop();
    };

    /*\
     * Set.forEach
     [ method ]
     **
     * Executes given function for each element in the set.
     *
     * If function returns `false` it will stop loop running.
     **
     > Parameters
     **
     - callback (function) function to run
     - thisArg (object) context object for the callback
     = (object) Set object
    \*/
    setproto.forEach = function(callback, thisArg) {
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            if (callback.call(thisArg, this.items[i], i) === false) {
                return this;
            }
        }
        return this;
    };
    for (var method in elproto)
        if (elproto[has](method)) {
            setproto[method] = (function(methodname) {
                return function() {
                    var arg = arguments;
                    return this.forEach(function(el) {
                        el[methodname][apply](el, arg);
                    });
                };
            })(method);
        }
    setproto.attr = function(name, value) {
        if (name && R.is(name, array) && R.is(name[0], object)) {
            for (var j = 0, jj = name.length; j < jj; j++) {
                this.items[j].attr(name[j]);
            }
        } else {
            for (var i = 0, ii = this.items.length; i < ii; i++) {
                this.items[i].attr(name, value);
            }
        }
        return this;
    };

    /*\
     * Set.clear
     [ method ]
     **
     * Removeds all elements from the set
    \*/
    setproto.clear = function() {
        while (this.length) {
            this.pop();
        }
    };

    /*\
     * Set.splice
     [ method ]
     **
     * Removes given element from the set
     **
     > Parameters
     **
     - index (number) position of the deletion
     - count (number) number of element to remove
     - insertion??(object) #optional elements to insert
     = (object) set elements that were deleted
    \*/
    setproto.splice = function(index, count, insertion) {
        index = index < 0 ? mmax(this.length + index, 0) : index;
        count = mmax(0, mmin(this.length - index, isNaN(count) && this.length || count));
        var tail = [],
        todel = [],
        args = [],
        i;
        for (i = 2; i < arguments.length; i++) {
            args.push(arguments[i]);
        }
        for (i = 0; i < count; i++) {
            todel.push(this[index + i]);
        }
        for (; i < this.length - index; i++) {
            tail.push(this[index + i]);
        }
        var arglen = args.length;
        for (i = 0; i < arglen + tail.length; i++) {
            this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
        }
        i = this.items.length = this.length -= count - arglen;
        while (this[i]) {
            delete this[i++];
        }
        return new Set(todel);
    };

    /*\
     * Set.exclude
     [ method ]
     **
     * Removes given element from the set
     **
     > Parameters
     **
     - element (object) element to remove
     = (boolean) `true` if object was found & removed from the set
    \*/
    setproto.exclude = function(el) {
        for (var i = 0, ii = this.length; i < ii; i++)
            if (this[i] == el) {
                this.splice(i, 1);
                return true;
            }
    };
    setproto.animate = function(params, ms, easing, callback) {
        (R.is(easing, "function") || !easing) && (callback = easing || null);
        var len = this.items.length,
        i = len,
        item,
        set = this,
        collector;
        if (!len) {
            return this;
        }
        callback && (collector = function() {
            !--len && callback.call(set);
        });
        easing = R.is(easing, string) ? easing : collector;
        var anim = R.animation(params, ms, easing, collector);
        item = this.items[--i].animate(anim);
        while (i--) {
            this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
        }
        return this;
    };
    setproto.insertAfter = function(el) {
        var i = this.items.length;
        while (i--) {
            this.items[i].insertAfter(el);
        }
        return this;
    };
    setproto.getBBox = function() {
        var x = [],
        y = [],
        x2 = [],
        y2 = [];
        for (var i = this.items.length; i--; )
            if (!this.items[i].removed) {
                var box = this.items[i].getBBox();
                x.push(box.x);
                y.push(box.y);
                x2.push(box.x + box.width);
                y2.push(box.y + box.height);
            }
        x = mmin[apply](0, x);
        y = mmin[apply](0, y);
        x2 = mmax[apply](0, x2);
        y2 = mmax[apply](0, y2);
        return {
            x: x,
            y: y,
            x2: x2,
            y2: y2,
            width: x2 - x,
            height: y2 - y
        };
    };
    setproto.clone = function(s) {
        s = new Set;
        for (var i = 0, ii = this.items.length; i < ii; i++) {
            s.push(this.items[i].clone());
        }
        return s;
    };
    setproto.toString = function() {
        return "Rapha\xebl\u2018s set";
    };

     setproto.glow = function(glowConfig) {
         var ret = this.paper.set();
         this.forEach(function(shape, index){
             var g = shape.glow(glowConfig);
             if(g != null){
                 g.forEach(function(shape2, index2){
                     ret.push(shape2);
                 });
             }
         });
         return ret;
     };

    /*\
     * Raphael.registerFont
     [ method ]
     **
     * Adds given font to the registered set of fonts for Rapha챘l. Should be used as an internal call from within Cuf처n?셲 font file.
     * Returns original parameter, so it could be used with chaining.
     # <a href="http://wiki.github.com/sorccu/cufon/about">More about Cuf처n and how to convert your font form TTF, OTF, etc to JavaScript file.</a>
     **
     > Parameters
     **
     - font (object) the font to register
     = (object) the font you passed in
     > Usage
     | Cufon.registerFont(Raphael.registerFont({??));
    \*/
    R.registerFont = function(font) {
        if (!font.face) {
            return font;
        }
        this.fonts = this.fonts || {};
        var fontcopy = {
            w: font.w,
            face: {},
            glyphs: {}
        },
        family = font.face["font-family"];
        for (var prop in font.face)
            if (font.face[has](prop)) {
                fontcopy.face[prop] = font.face[prop];
            }
        if (this.fonts[family]) {
            this.fonts[family].push(fontcopy);
        } else {
            this.fonts[family] = [fontcopy];
        }
        if (!font.svg) {
            fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
            for (var glyph in font.glyphs)
                if (font.glyphs[has](glyph)) {
                    var path = font.glyphs[glyph];
                    fontcopy.glyphs[glyph] = {
                        w: path.w,
                        k: {},
                        d: path.d && "M" + path.d.replace(/[mlcxtrv]/g, function(command) {
                            return {
                                l: "L",
                                c: "C",
                                x: "z",
                                t: "m",
                                r: "l",
                                v: "c"
                            }
                            [command] || "M";
                        }) + "z"
                    };
                    if (path.k) {
                        for (var k in path.k)
                            if (path[has](k)) {
                                fontcopy.glyphs[glyph].k[k] = path.k[k];
                            }
                    }
                }
        }
        return font;
    };

    /*\
     * Paper.getFont
     [ method ]
     **
     * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like ?쏮yriad??for ?쏮yriad Pro??
     **
     > Parameters
     **
     - family (string) font family name or any word from it
     - weight (string) #optional font weight
     - style (string) #optional font style
     - stretch (string) #optional font stretch
     = (object) the font object
     > Usage
     | paper.print(100, 100, "Test string", paper.getFont("Times", 800), 30);
    \*/
    paperproto.getFont = function(family, weight, style, stretch) {
        stretch = stretch || "normal";
        style = style || "normal";
        weight = +weight || {
            normal: 400,
            bold: 700,
            lighter: 300,
            bolder: 800
        }
        [weight] || 400;
        if (!R.fonts) {
            return;
        }
        var font = R.fonts[family];
        if (!font) {
            var name = new RegExp("(^|\\s)" + family.replace(/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
            for (var fontName in R.fonts)
                if (R.fonts[has](fontName)) {
                    if (name.test(fontName)) {
                        font = R.fonts[fontName];
                        break;
                    }
                }
        }
        var thefont;
        if (font) {
            for (var i = 0, ii = font.length; i < ii; i++) {
                thefont = font[i];
                if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
                    break;
                }
            }
        }
        return thefont;
    };

    /*\
     * Paper.print
     [ method ]
     **
     * Creates path that represent given text written using given font at given position with given size.
     * Result of the method is path element that contains whole text as a separate path.
     **
     > Parameters
     **
     - x (number) x position of the text
     - y (number) y position of the text
     - string (string) text to print
     - font (object) font object, see @Paper.getFont
     - size (number) #optional size of the font, default is `16`
     - origin (string) #optional could be `"baseline"` or `"middle"`, default is `"middle"`
     - letter_spacing (number) #optional number in range `-1..1`, default is `0`
     = (object) resulting path element, which consist of all letters
     > Usage
     | var txt = r.print(10, 50, "print", r.getFont("Museo"), 30).attr({fill: "#fff"});
    \*/
    paperproto.print = function(x, y, string, font, size, origin, letter_spacing) {
        origin = origin || "middle"; // baseline|middle
        letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
        var letters = Str(string)[split](E),
        shift = 0,
        notfirst = 0,
        path = E,
        scale;
        R.is(font, string) && (font = this.getFont(font));
        if (font) {
            scale = (size || 16) / font.face["units-per-em"];
            var bb = font.face.bbox[split](separator),
            top = +bb[0],
            lineHeight = bb[3] - bb[1],
            shifty = 0,
            height = + bb[1] + (origin == "baseline" ? lineHeight + ( + font.face.descent) : lineHeight / 2);
            for (var i = 0, ii = letters.length; i < ii; i++) {
                if (letters[i] == "\n") {
                    shift = 0;
                    curr = 0;
                    notfirst = 0;
                    shifty += lineHeight;
                } else {
                    var prev = notfirst && font.glyphs[letters[i - 1]] || {},
                    curr = font.glyphs[letters[i]];
                    shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;
                    notfirst = 1;
                }
                if (curr && curr.d) {
                    path += R.transformPath(curr.d, ["t", shift * scale, shifty * scale, "s", scale, scale, top, height, "t", (x - top) / scale, (y - height) / scale]);
                }
            }
        }
        return this.path(path).attr({
            fill: "#000",
            stroke: "none"
        });
    };

    /*\
     * Paper.add
     [ method ]
     **
     * Imports elements in JSON array in format `{type: type, <attributes>}`
     **
     > Parameters
     **
     - json (array)
     = (object) resulting set of imported elements
     > Usage
     | paper.add([
     |     {
     |         type: "circle",
     |         cx: 10,
     |         cy: 10,
     |         r: 5
     |     },
     |     {
     |         type: "rect",
     |         x: 10,
     |         y: 10,
     |         width: 10,
     |         height: 10,
     |         fill: "#fc0"
     |     }
     | ]);
    \*/
    paperproto.add = function(json) {
        if (R.is(json, "array")) {
            var res = this.set(),
            i = 0,
            ii = json.length,
            j;
            for (; i < ii; i++) {
                j = json[i] || {};
                elements[has](j.type) && res.push(this[j.type]().attr(j));
            }
        }
        return res;
    };

    /*\
     * Raphael.format
     [ method ]
     **
     * Simple format function. Replaces construction of type ??{<number>}`??to the corresponding argument.
     **
     > Parameters
     **
     - token (string) string to format
     - ??(string) rest of arguments will be treated as parameters for replacement
     = (string) formated string
     > Usage
     | var x = 10,
     |     y = 20,
     |     width = 40,
     |     height = 50;
     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Raphael.format("M{0},{1}h{2}v{3}h{4}z", x, y, width, height, -width));
    \*/
    R.format = function(token, params) {
        var args = R.is(params, array) ? [0][concat](params) : arguments;
        token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function(str, i) {
            return args[++i] == null ? E : args[i];
        }));
        return token || E;
    };

    /*\
     * Raphael.fullfill
     [ method ]
     **
     * A little bit more advanced format function than @Raphael.format. Replaces construction of type ??{<name>}`??to the corresponding argument.
     **
     > Parameters
     **
     - token (string) string to format
     - json (object) object which properties will be used as a replacement
     = (string) formated string
     > Usage
     | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
     | paper.path(Raphael.fullfill("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
     |     x: 10,
     |     y: 20,
     |     dim: {
     |         width: 40,
     |         height: 50,
     |         "negative width": -40
     |     }
     | }));
    \*/
    R.fullfill = (function() {
        var tokenRegex = /\{([^\}]+)\}/g,
        objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
        replacer = function(all, key, obj) {
            var res = obj;
            key.replace(objNotationRegex, function(all, name, quote, quotedName, isFunc) {
                name = name || quotedName;
                if (res) {
                    if (name in res) {
                        res = res[name];
                    }
                    typeof res == "function" && isFunc && (res = res());
                }
            });
            res = (res == null || res == obj ? all : res) + "";
            return res;
        };
        return function(str, obj) {
            return String(str).replace(tokenRegex, function(all, key) {
                return replacer(all, key, obj);
            });
        };
    })();

    /*\
     * Raphael.ninja
     [ method ]
     **
     * If you want to leave no trace of Rapha챘l (Well, Rapha챘l creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.
     * Beware, that in this case plugins could stop working, because they are depending on global variable existance.
     **
     = (object) Raphael object
     > Usage
     | (function (local_raphael) {
     |     var paper = local_raphael(10, 10, 320, 200);
     |     ??     | })(Raphael.ninja());
    \*/
    R.ninja = function() {
        oldRaphael.was ? (g.win.Raphael = oldRaphael.is) : delete Raphael;
        return R;
    };

    var crispFixer = (R.vml && 0.5 || 0);

    R.crispBound = cacher(function (x, y, w, h, s) {
        var at = {},
            normalizer;

        x = x || 0;
        y = y || 0;
        w = w || 0;
        h = h || 0;
        s = s || 0;
        normalizer = s % 2 / 2 + crispFixer;

        // normalize for crisp edges
        at.x = round(x + normalizer) - normalizer;
        at.y = round(y + normalizer) - normalizer;
        at.width = round(x + w + normalizer) - normalizer - at.x;
        at.height = round(y + h + normalizer) - normalizer - at.y;
        at['stroke-width'] = s;

        // adjust to single pixel if resultant dimension is zero.
        (at.width === 0 && w !== 0) && (at.width = 1);
        (at.height === 0 && h !== 0) && (at.height = 1);

        return at;
    }, R);

    elproto.crisp = function () {
        var o = this,
            attrs = o.attrs,
            key,
            attr = {},
            values = o.attr(['x', 'y', 'width', 'height', 'stroke-width']);

        values = R.crispBound(values.x, values.y, values.width, values.height,
            values['stroke-width']);

        for (key in values) {
            if (attrs[key] === values[key]) { // only set attribute if changed
                delete values[key];
            }
        }

        return o.attr(values);
    };

    /*\
     * Raphael.st
     [ property (object) ]
     **
     * You can add your own method to elements and sets. It is wise to add a set method for each element method
     * you added, so you will be able to call the same method on sets too.
     **
     * See also @Raphael.el.
     > Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | Raphael.st.red = function () {
     |     this.forEach(function (el) {
     |         el.red();
     |     });
     | };
     | // then use it
     | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();
    \*/
    R.st = setproto;

    /*\
     * Raphael.define
     [ method ]
     **
     * Allows a unified definition of composite shapes and other behaviours using
     * simple directives.
     **
     > Parameters
     **
     - definition (object) the shape definition
    \*/
    R.define = function (name, init, ca, fn, e, data) {
        var i,
            ii;

        // multi definition
        if (R.is(name, array)) {
            for (i = 0, ii = name.length; i < ii; i++) {
                R.define(name[i]);
            }
            return;
        }
        // object definition
        else if (R.is(name, object)) {
            R.define(name.name, name[name.name], name.ca, name.fn, name.e, name.data);
            return;
        }
        // invalid or duplicate definition
        else if (!name || R.fn[name]) {
            return;
        }

        R.fn[name] = function () {
            var args = arguments,
                element = init.apply(this, args),
                key;

            if (fn && R.is(fn, object)) {
                for (key in fn) {
                    element[key] = fn[key];
                }
            }

            if (e && R.is(e, object)) {
                for (key in e) {
                    element[key] && element[key](e[key]);
                }
            }

            if (ca) {
                if (R.is(ca, 'function')) {
                    element.ca[name] = ca;
                }
                else {
                    for (key in ca) {
                        element.ca[key] = ca[key];
                    }
                }

                // Check if namesake ca exists and apply it
                if (element.ca[name]) {
                    R._lastArgIfGroup(args, true); // purge group
                    element.attr(name, arraySlice.call(args))
                }
            }

            return element;
        };

        if (ca) { R.fn[name].ca = ca; }
        if (fn) { R.fn[name].fn = fn; }
        if (e) { R.fn[name].e = e; }
        if (data) { R.fn[name].data = data; }

        return R.fn[name];
    };
    // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
    (function(doc, loaded, f) {
        if (doc.readyState == null && doc.addEventListener) {
            doc.addEventListener(loaded, f = function() {
                doc.removeEventListener(loaded, f, false);
                doc.readyState = "complete";
            }, false);
            doc.readyState = "loading";
        }
        function isLoaded() {
            (/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve("raphael.DOMload");
        }
        isLoaded();
    })(document, "DOMContentLoaded");

    eve.on("raphael.DOMload", function() {
        loaded = true;
    });

/**!
* RedRaphael 1.0.0 - JavaScript Vector Library SVG Module
* Copyright (c) 2012-2013 FusionCharts Technologies <http://www.fusioncharts.com>
*
* Raphael 2.1.0 - JavaScript Vector Library SVG Module
* Copyright (c) 2008-2012 Dmitry Baranovskiy <http://raphaeljs.com>
* Copyright 짤 2008-2012 Sencha Labs <http://sencha.com>
*
* Licensed under the MIT license.
*/
(function(){
    if (!R.svg) {
        return;
    }
    var has = "hasOwnProperty",
        Str = String,
        toFloat = parseFloat,
        toInt = parseInt,
        math = Math,
        mmax = math.max,
        abs = math.abs,
        pow = math.pow,
        sqrt = math.sqrt,
        separator = /[, ]+/,
        zeroStrokeFix = !!(/AppleWebKit/.test(R._g.win.navigator.userAgent) &&
                (!/Chrome/.test(R._g.win.navigator.userAgent) ||
                R._g.win.navigator.appVersion.match(/Chrome\/(\d+)\./)[1] < 29)),
        eve = R.eve,
        E = "",
        S = " ",
        xlink = "http://www.w3.org/1999/xlink",
        markers = {
            block: "M5,0 0,2.5 5,5z",
            classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
            diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
            open: "M6,1 1,3.5 6,6",
            oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
        },
        markerCounter = {},
        updateReferenceUrl = function () {
            return R._url = R._g.win.location.href.replace(/#.*?$/, E);
        };

    R.toString = function() {
        return  "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
    };

    // Code commented as resources will now be referenced using relative urls.
    // @todo Remove once we have acertained that there are no issues in any environment.
    // Automatic gradient and other reference update on state change
    // R._url = (/msie/i.test(navigator.userAgent) && !window.opera) ?
    //     E : updateReferenceUrl();
    // if (R._url && R._g.win.history.pushState) {
    //     R._g.win.history.pushState = (function () {
    //         var fn = R._g.win.history.pushState;
    //         return function () {
    //             var ret = fn.apply(R._g.win.history, arguments);
    //             return updateReferenceUrl(), ret;
    //         };
    //     }());
    //     R._g.win.addEventListener("popstate", updateReferenceUrl, false);
    // }
    R._url = E;

    var updateGradientReference = function (element, newGradient) {
        var gradient = element.gradient;

        if (gradient) {
            if (gradient === newGradient) {
                return; // no change
            }
            // else gradient is specified and it is not same as newGradient, implying a dereference
            gradient.refCount--;
            if (!gradient.refCount) {
                gradient.parentNode.removeChild(gradient);
            }
            delete element.gradient;
        }

        if (newGradient) { // add new gradient
            element.gradient = newGradient;
            newGradient.refCount++;
        }
    };

    var $ = R._createNode = function(el, attr) {
        if (attr) {
            if (typeof el == "string") {
                el = $(el);
            }
            for (var key in attr)
                if (attr[has](key)) {
                    if (key.substring(0, 6) == "xlink:") {
                        el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
                    } else {
                        el.setAttribute(key, Str(attr[key]));
                    }
                }
        } else {
            el = R._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
        }
        return el;
    },
    gradientUnitNames = {
        userSpaceOnUse: 'userSpaceOnUse',
        objectBoundingBox: 'objectBoundingBox'
    },
    gradientSpreadNames = {
        pad: 'pad',
        redlect: 'reflect',
        repeat: 'repeat'
    },
    addGradientFill = function(element, gradient) {
        if (!element.paper || !element.paper.defs) {
            return 0;
        }

        var type = "linear",
            SVG = element.paper,
            id = (SVG.id + '-' + gradient).replace(/[\(\)\s%:,\xb0#]/g, "_"),
            fx = .5, fy = .5, r, cx, cy, units, spread,
            o = element.node,
            s = o.style,
            el = R._g.doc.getElementById(id);

        if (!el) {
            gradient = Str(gradient).replace(R._radial_gradient, function(all, opts) {
                type = "radial";
                opts = opts && opts.split(',') || [];
                units = opts[5];
                spread = opts[6];

                var _fx = opts[0],
                    _fy = opts[1],
                    _r = opts[2],
                    _cx = opts[3],
                    _cy = opts[4],
                    shifted = (_fx && _fy),
                    dir,
                    sqx;

                if (_r) {
                    r = /\%/.test(_r) ? _r : toFloat(_r);
                }

                if (units === gradientUnitNames.userSpaceOnUse) {
                    if (shifted) {
                        fx = _fx;
                        fy = _fy;
                    }
                    if (_cx && _cy) {
                        cx = _cx;
                        cy = _cy;
                        if (!shifted) {
                            fx = cx;
                            fy = cy;
                        }
                    }
                    return E;
                }

                if (shifted) {
                    fx = toFloat(_fx);
                    fy = toFloat(_fy);
                    dir = ((fy > .5) * 2 - 1);
                    (sqx = pow(fx - .5, 2)) + pow(fy - .5, 2) > .25 &&
                    (sqx < .25) && (fy = sqrt(.25 - sqx) * dir + .5) &&
                    fy !== .5 &&
                    (fy = fy.toFixed(5) - 1e-5 * dir);
                }
                if (_cx && _cy) {
                    cx = toFloat(_cx);
                    cy = toFloat(_cy);
                    dir = ((cy > .5) * 2 - 1);

                    (sqx = pow(cx - .5, 2)) + pow(cy - .5, 2) > .25 &&
                    (sqx < .25) && (cy = sqrt(.25 - sqx) * dir + .5) &&
                    cy !== .5 &&
                    (cy = cy.toFixed(5) - 1e-5 * dir);

                    if (!shifted) {
                        fx = cx;
                        fy = cy;
                    }
                }

                return E;
            });
            gradient = gradient.split(/\s*\-\s*/);
            if (type == "linear") {
                var angle = gradient.shift(),
                    specs = angle.match(/\((.*)\)/),
                    vector,
                    max;

                specs = specs && specs[1] && specs[1].split(/\s*\,\s*/);
                angle = -toFloat(angle);
                if (isNaN(angle)) {
                    return null;
                }
                if (specs && specs.length) {
                    if (specs[0] in gradientUnitNames) {
                        units = specs.shift();
                        (specs[0] in gradientSpreadNames) &&
                            (spread = specs.shift());
                    }
                    else {
                        specs[4] && (units = specs[4]);
                        specs[5] && (spread = specs[5]);
                    }

                    /** @todo apply angle rotation and validation */
                    vector = [
                        specs[0] || "0%", specs[1] || "0%",
                        specs[2] || "100%", specs[3] || "0%"
                    ];
                }
                else {
                    vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))];
                    max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                    vector[2] *= max;
                    vector[3] *= max;
                    if (vector[2] < 0) {
                        vector[0] = -vector[2];
                        vector[2] = 0;
                    }
                    if (vector[3] < 0) {
                        vector[1] = -vector[3];
                        vector[3] = 0;
                    }
                }
            }
            var dots = R._parseDots(gradient);
            if (!dots) {
                return null;
            }

            el = $(type + "Gradient", {
                id: id
            });
            el.refCount = 0;
            (units in gradientUnitNames) &&
                    el.setAttribute('gradientUnits', Str(units));
            (spread in gradientSpreadNames) &&
                    el.setAttribute('spreadMethod', Str(spread));
            if (type === "radial") {
                (r !== undefined) && el.setAttribute('r', Str(r));

                if (cx !== undefined && cy !== undefined) {
                    el.setAttribute('cx', Str(cx));
                    el.setAttribute('cy', Str(cy));
                }
                el.setAttribute('fx', Str(fx));
                el.setAttribute('fy', Str(fy));
            }
            else {
                $(el, {
                    x1: vector[0],
                    y1: vector[1],
                    x2: vector[2],
                    y2: vector[3]
                });
            }

            for (var i = 0, ii = dots.length; i < ii; i++) {
                el.appendChild($("stop", {
                    offset: dots[i].offset ? dots[i].offset : i ? "100%" : "0%",
                    "stop-color": dots[i].color || "#fff",
                    //add stop opacity information
                    "stop-opacity": dots[i].opacity === undefined ? 1 : dots[i].opacity
                }));
            }
            SVG.defs.appendChild(el);
        }

        updateGradientReference(element, el);

        $(o, {
            fill: "url('" + R._url + "#" + id + "')",
            opacity: 1,
            "fill-opacity": 1
        });
        s.fill = E;
        s.opacity = 1;
        s.fillOpacity = 1;
        return 1;
    },
    updatePosition = function(o) {
        var bbox = o.getBBox(1);
        $(o.pattern, {
            patternTransform: o.matrix.invert() + " translate(" + bbox.x + "," + bbox.y + ")"
        });
    },
    addArrow = function(o, value, isEnd) {
        if (o.type == "path") {
            var values = Str(value).toLowerCase().split("-"),
            p = o.paper,
            se = isEnd ? "end" : "start",
            node = o.node,
            attrs = o.attrs,
            stroke = attrs["stroke-width"],
            i = values.length,
            type = "classic",
            from,
            to,
            dx,
            refX,
            attr,
            w = 3,
            h = 3,
            t = 5;
            while (i--) {
                switch (values[i]) {
                    case "block":
                    case "classic":
                    case "oval":
                    case "diamond":
                    case "open":
                    case "none":
                        type = values[i];
                        break;
                    case "wide":
                        h = 5;
                        break;
                    case "narrow":
                        h = 2;
                        break;
                    case "long":
                        w = 5;
                        break;
                    case "short":
                        w = 2;
                        break;
                }
            }
            if (type == "open") {
                w += 2;
                h += 2;
                t += 2;
                dx = 1;
                refX = isEnd ? 4 : 1;
                attr = {
                    fill: "none",
                    stroke: attrs.stroke
                };
            } else {
                refX = dx = w / 2;
                attr = {
                    fill: attrs.stroke,
                    stroke: "none"
                };
            }
            if (o._.arrows) {
                if (isEnd) {
                    o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
                    o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
                } else {
                    o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
                    o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
                }
            } else {
                o._.arrows = {};
            }
            if (type != "none") {
                var pathId = "raphael-marker-" + type,
                markerId = "raphael-marker-" + se + type + w + h + "-obj" + o.id;
                if (!R._g.doc.getElementById(pathId)) {
                    p.defs.appendChild($($("path"), {
                        "stroke-linecap": "round",
                        d: markers[type],
                        id: pathId
                    }));
                    markerCounter[pathId] = 1;
                } else {
                    markerCounter[pathId]++;
                }
                var marker = R._g.doc.getElementById(markerId),
                use;
                if (!marker) {
                    marker = $($("marker"), {
                        id: markerId,
                        markerHeight: h,
                        markerWidth: w,
                        orient: "auto",
                        refX: refX,
                        refY: h / 2
                    });
                    use = $($("use"), {
                        "xlink:href": "#" + pathId,
                        transform: (isEnd ? "rotate(180 " + w / 2 + " " + h / 2 + ") " : E) + "scale(" + w / t + "," + h / t + ")",
                        "stroke-width": (1 / ((w / t + h / t) / 2)).toFixed(4)
                    });
                    marker.appendChild(use);
                    p.defs.appendChild(marker);
                    markerCounter[markerId] = 1;
                } else {
                    markerCounter[markerId]++;
                    use = marker.getElementsByTagName("use")[0];
                }
                $(use, attr);
                var delta = dx * (type != "diamond" && type != "oval");
                if (isEnd) {
                    from = o._.arrows.startdx * stroke || 0;
                    to = R.getTotalLength(attrs.path) - delta * stroke;
                } else {
                    from = delta * stroke;
                    to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                }
                attr = {};
                attr["marker-" + se] = "url('" + R._url + "#" + markerId + "')";
                if (to || from) {
                    attr.d = R.getSubpath(attrs.path, from, to);
                }
                $(node, attr);
                o._.arrows[se + "Path"] = pathId;
                o._.arrows[se + "Marker"] = markerId;
                o._.arrows[se + "dx"] = delta;
                o._.arrows[se + "Type"] = type;
                o._.arrows[se + "String"] = value;
            } else {
                if (isEnd) {
                    from = o._.arrows.startdx * stroke || 0;
                    to = R.getTotalLength(attrs.path) - from;
                } else {
                    from = 0;
                    to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                }
                o._.arrows[se + "Path"] && $(node, {
                    d: R.getSubpath(attrs.path, from, to)
                });
                delete o._.arrows[se + "Path"];
                delete o._.arrows[se + "Marker"];
                delete o._.arrows[se + "dx"];
                delete o._.arrows[se + "Type"];
                delete o._.arrows[se + "String"];
            }
            for (attr in markerCounter)
                if (markerCounter[has](attr) && !markerCounter[attr]) {
                    var item = R._g.doc.getElementById(attr);
                    item && item.parentNode.removeChild(item);
                }
        }
    },
    dasharray = {
        "": [0],
        "none": [0],
        "-": [3, 1],
        ".": [1, 1],
        "-.": [3, 1, 1, 1],
        "-..": [3, 1, 1, 1, 1, 1],
        ". ": [1, 3],
        "- ": [4, 3],
        "--": [8, 3],
        "- .": [4, 3, 1, 3],
        "--.": [8, 3, 1, 3],
        "--..": [8, 3, 1, 3, 1, 3]
    },
    addDashes = function(o, value, params) {
        var predefValue = dasharray[Str(value).toLowerCase()],
            calculatedValues,
            width,
            butt,
            i,
            l,
            widthFactor;

        value = predefValue || ((value !== undefined) && [].concat(value));
        if (value) {

            width = o.attrs["stroke-width"] || 1;
            butt = {
                round: width,
                square: width,
                butt: 0
            }[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0;
            l = i = value.length;
            widthFactor = predefValue ? width : 1;

            calculatedValues = [];
            while (i--) {
                calculatedValues[i] = value[i] * widthFactor + ((i % 2) ? 1 : -1) * butt;
                calculatedValues[i] < 0 && (calculatedValues[i] = 0);
            }

            if (R.is(value, 'array')) {
                $(o.node, {
                    "stroke-dasharray": calculatedValues.join(",")
                });
            }
        }
    },

    applyCustomAttributes = function (o, attrs) {
        for (var key in attrs) {
            eve("raphael.attr." + key + "." + o.id, o, attrs[key], key);
            o.ca[key] && o.attr(key, attrs[key]);
        }
    },

    setFillAndStroke = R._setFillAndStroke = function(o, params) {
        if (!o.paper.canvas) {
            return;
        }
        var node = o.node,
            attrs = o.attrs,
            paper = o.paper,
            s = node.style,
            vis = s.visibility;

        s.visibility = "hidden";
        for (var att in params) {
            if (params[has](att)) {
                if (!R._availableAttrs[has](att)) {
                    continue;
                }
                var value = params[att];
                attrs[att] = value;
                switch (att) {
                    case "blur":
                        o.blur(value);
                        break;
                    case "href":
                    case "title":
                    case "target":
                        var pn = node.parentNode;
                        if (pn.tagName.toLowerCase() != "a") {
                            if (value == E) { break; }
                            var hl = $("a");
                            hl.raphael = true;
                            hl.raphaelid = node.raphaelid;
                            pn.insertBefore(hl, node);
                            hl.appendChild(node);
                            pn = hl;
                        }
                        if (att == "target") {
                            pn.setAttributeNS(xlink, "show", value == "blank" ? "new" : value);
                        } else {
                            pn.setAttributeNS(xlink, att, value);
                        }
                        node.titleNode = pn;
                        break;
                    case "cursor":
                        s.cursor = value;
                        break;
                    case "transform":
                        o.transform(value);
                        break;
                    case "rotation":
                        if (R.is(value, "array")) {
                            o.rotate.apply(o, value);
                        }
                        else {
                            o.rotate(value);
                        }
                        break;
                    case "arrow-start":
                        addArrow(o, value);
                        break;
                    case "arrow-end":
                        addArrow(o, value, 1);
                        break;
                    case "clip-path":
                        var pathClip = true;
                    case "clip-rect":
                        var rect = !pathClip && Str(value).split(separator);
                        o._.clipispath = !!pathClip;
                        if (pathClip || rect.length == 4) {
                            o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                            var el = $("clipPath"),
                            rc = $(pathClip ? "path" : "rect");
                            el.id = R.createUUID();
                            $(rc, pathClip ? {
                                d: value ? attrs['clip-path'] = R._pathToAbsolute(value) : R._availableAttrs.path,
                                fill: 'none'
                            } : {
                                x: rect[0],
                                y: rect[1],
                                width: rect[2],
                                height: rect[3],
                                transform: o.matrix.invert()
                            });
                            el.appendChild(rc);
                            paper.defs.appendChild(el);
                            $(node, {
                                "clip-path": "url('" + R._url +"#" + el.id + "')"
                            });
                            o.clip = rc;
                        }
                        if (!value) {
                            var path = node.getAttribute("clip-path");
                            if (path) {
                                var clip = R._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
                                clip && clip.parentNode.removeChild(clip);
                                $(node, {
                                    "clip-path": E
                                });
                                delete o.clip;
                            }
                        }
                        break;
                    case "path":
                        if (o.type == "path") {
                            $(node, {
                                d: value ? attrs.path = R._pathToAbsolute(value) : R._availableAttrs.path
                            });
                            o._.dirty = 1;
                            if (o._.arrows) {
                                "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                            }
                        }
                        break;
                    case "width":
                        node.setAttribute(att, value);
                        o._.dirty = 1;
                        if (attrs.fx) {
                            att = "x";
                            value = attrs.x;
                        } else {
                            break;
                        }
                    case "x":
                        if (attrs.fx) {
                            value = -attrs.x - (attrs.width || 0);
                        }
                    case "rx":
                        if (att == "rx" && o.type == "rect") {
                            break;
                        }
                    case "cx":
                        node.setAttribute(att, value);
                        o.pattern && updatePosition(o);
                        o._.dirty = 1;
                        break;
                    case "height":
                        node.setAttribute(att, value);
                        o._.dirty = 1;
                        if (attrs.fy) {
                            att = "y";
                            value = attrs.y;
                        } else {
                            break;
                        }
                    case "y":
                        if (attrs.fy) {
                            value = -attrs.y - (attrs.height || 0);
                        }
                    case "ry":
                        if (att == "ry" && o.type == "rect") {
                            break;
                        }
                    case "cy":
                        node.setAttribute(att, value);
                        o.pattern && updatePosition(o);
                        o._.dirty = 1;
                        break;
                    case "r":
                        if (o.type == "rect") {
                            $(node, {
                                rx: value,
                                ry: value
                            });
                        } else {
                            node.setAttribute(att, value);
                        }
                        o._.dirty = 1;
                        break;
                    case "src":
                        if (o.type == "image") {
                            node.setAttributeNS(xlink, "href", value);
                        }
                        break;
                    case "stroke-width":
                        if (o._.sx != 1 || o._.sy != 1) {
                            value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
                        }
                        if (paper._vbSize) {
                            value *= paper._vbSize;
                        }
                        if (zeroStrokeFix && value === 0) {
                            value = 0.000001;
                        }
                        node.setAttribute(att, value);
                        if (attrs["stroke-dasharray"]) {
                            addDashes(o, attrs["stroke-dasharray"], params);
                        }
                        if (o._.arrows) {
                            "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                            "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                        }
                        break;
                    case "stroke-dasharray":
                        addDashes(o, value, params);
                        break;
                    case "fill":
                        var isURL = Str(value).match(R._ISURL);
                        if (isURL) {
                            el = $("pattern");
                            var ig = $("image");
                            el.id = R.createUUID();
                            $(el, {
                                x: 0,
                                y: 0,
                                patternUnits: "userSpaceOnUse",
                                height: 1,
                                width: 1
                            });
                            $(ig, {
                                x: 0,
                                y: 0,
                                "xlink:href": isURL[1]
                            });
                            el.appendChild(ig);

                            (function(el) {
                                R._preload(isURL[1], function() {
                                    var w = this.offsetWidth,
                                    h = this.offsetHeight;
                                    $(el, {
                                        width: w,
                                        height: h
                                    });
                                    $(ig, {
                                        width: w,
                                        height: h
                                    });
                                    paper.safari();
                                });
                            })(el);
                            paper.defs.appendChild(el);
                            s.fill = "url('" + R._url + "#" + el.id + "')";
                            $(node, {
                                fill: s.fill
                            });

                            o.pattern = el;
                            o.pattern && updatePosition(o);
                            break;
                        }
                        var clr = R.getRGB(value);
                        if (!clr.error) {
                            delete params.gradient;
                            delete attrs.gradient;
                            !R.is(attrs.opacity, "undefined") &&
                                R.is(params.opacity, "undefined") &&
                                $(node, {
                                    opacity: attrs.opacity
                                });
                            !R.is(attrs["fill-opacity"], "undefined") &&
                                R.is(params["fill-opacity"], "undefined") &&
                                $(node, {
                                    "fill-opacity": attrs["fill-opacity"]
                                });
                            o.gradient && updateGradientReference(o);
                        }
                        else if ((o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value)) {
                            if ("opacity" in attrs || "fill-opacity" in attrs) {
                                var gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                                if (gradient) {
                                    var stops = gradient.getElementsByTagName("stop");
                                    $(stops[stops.length - 1], {
                                        "stop-opacity": ("opacity" in attrs ? attrs.opacity : 1) * ("fill-opacity" in attrs ? attrs["fill-opacity"] : 1)
                                    });
                                }
                            }
                            attrs.gradient = value;
                            attrs.fill = "none";
                            s.fill = E;
                            break;
                        }
                        if (clr[has]("opacity")) {
                            $(node, {
                                "fill-opacity": (s.fillOpacity =
                                    (clr.opacity > 1 ? clr.opacity / 100 : clr.opacity))
                            });
                            o._.fillOpacityDirty = true;
                        }
                        else if (o._.fillOpacityDirty && R.is(attrs['fill-opacity'], "undefined") &&
                                R.is(params["fill-opacity"], "undefined")) {
                            node.removeAttribute('fill-opacity');
                            s.fillOpacity = E;
                            delete o._.fillOpacityDirty;
                        }
                    case "stroke":
                        clr = R.getRGB(value);
                        node.setAttribute(att, clr.hex);
                        s[att] = clr.hex;
                        if (att == "stroke") { // remove stroke opacity when stroke is set to none
                            if (clr[has]("opacity")) {
                                $(node, {
                                    "stroke-opacity": (s.strokeOpacity =
                                        (clr.opacity > 1 ? clr.opacity / 100 : clr.opacity))
                                });
                                o._.strokeOpacityDirty = true;
                            }
                            else if (o._.strokeOpacityDirty && R.is(attrs['stroke-opacity'], "undefined") &&
                                    R.is(params["stroke-opacity"], "undefined")) {
                                node.removeAttribute('stroke-opacity');
                                s.strokeOpacity = E;
                                delete o._.strokeOpacityDirty;
                            }
                            if (o._.arrows) {
                                "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                                "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                            }
                        }
                        break;
                    case "gradient":
                        (o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value);
                        break;
                    case 'line-height': // do not apply
                    case 'vertical-align': // do not apply
                        break;
                    case "visibility":
                        value === 'hidden' ? o.hide() : o.show();
                        break;
                    case "opacity":
                        if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                            $(node, {
                                "stroke-opacity": value > 1 ? value / 100 : value
                            });
                        }
                    // fall
                    case "fill-opacity":
                        if (attrs.gradient) {
                            gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                            if (gradient) {
                                stops = gradient.getElementsByTagName("stop");
                                $(stops[stops.length - 1], {
                                    "stop-opacity": value
                                });
                            }
                            break;
                        }
                    default:
                        att == "font-size" && (value = toInt(value, 10) + "px");
                        var cssrule = att.replace(/(\-.)/g, function(w) {
                            return w.substring(1).toUpperCase();
                        });
                        s[cssrule] = value;
                        o._.dirty = 1;
                        node.setAttribute(att, value);
                        break;
                }
            }
        }

        (o.type === 'text') && tuneText(o, params);
        s.visibility = vis;
    },
    leading = 1.2,
    tuneText = function(el, params) {
        if (el.type != "text" || !(params[has]("text") || params[has]("font") ||
                params[has]("font-size") || params[has]("x") || params[has]("y") ||
                params[has]("line-height") || params[has]("vertical-align"))) {
            return;
        }
        var a = el.attrs,
            node = el.node,
            computedStyle = node.firstChild && R._g.doc.defaultView.getComputedStyle(node.firstChild, E),
            fontSize = computedStyle ?
                toFloat(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size")) : 10,
            lineHeight = toFloat(params['line-height'] || a['line-height']) || fontSize * leading,
            valign = a[has]("vertical-align") ? a["vertical-align"] : "middle";

        if (isNaN(lineHeight)) {
            lineHeight = fontSize * leading;
        }

        if (R.is(params.text, 'array')) {
            params.text = params.text.join('<br>');
        }

        valign = valign === 'top' ? -0.5 : (valign === 'bottom' ? 0.5 : 0);

        if (params[has]("text") && (params.text !== a.text || el._textdirty)) {
            a.text = params.text;
            while (node.firstChild) {
                node.removeChild(node.firstChild);
            }
            var texts = Str(params.text).split(/\n|<br\s*?\/?>/ig),
            tspans = [],
            tspan;
            for (var i = 0, ii = texts.length; i < ii; i++) {
                tspan = $("tspan");
                if (i) {
                    $(tspan, {
                        dy: lineHeight,
                        x: a.x
                    });
                } else {
                    $(tspan, {
                        dy: lineHeight * texts.length * valign,
                        x: a.x
                    });
                }
                if (!texts[i]) { // preserve blank lines
                    tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace",
                        "xml:space","preserve");
                    texts[i] = " ";
                }
                tspan.appendChild(R._g.doc.createTextNode(texts[i]));
                node.appendChild(tspan);
                tspans[i] = tspan;
            }
            el._textdirty = false;
        } else {
            tspans = node.getElementsByTagName("tspan");
            for (i = 0, ii = tspans.length; i < ii; i++)
                if (i) {
                    $(tspans[i], {
                        dy: lineHeight,
                        x: a.x
                    });
                } else {
                    $(tspans[0], {
                        dy: lineHeight * tspans.length * valign,
                        x: a.x
                    });
                }
        }
        $(node, {
            x: a.x,
            y: a.y
        });
        el._.dirty = 1;
        var bb = el._getBBox(),
        dif = a.y - (bb.y + bb.height / 2);

        // If the bbox is calculated then we need to make additional adjustments,
        // to account for the fact that the calculated bbox already has the
        // text alignment, both horizontal and vertical, included in the calculation.
        if (bb.isCalculated) {
            switch (a['vertical-align']) {
                case "top":
                    dif = bb.height * .75;
                    break;
                case "bottom":
                    dif = - (bb.height * .25);
                    break;
                default:
                    dif = a.y - (bb.y + bb.height * .25);
                    break;
            };
        }

        dif && R.is(dif, "finite") && tspans[0] && $(tspans[0], {
            dy: dif
        });
    },
    Element = function(node, svg, group) {
        var o = this,
            parent = group || svg;

        parent.canvas && parent.canvas.appendChild(node);

        o.node = o[0] = node;
        node.raphael = true;
        node.raphaelid = o.id = R._oid++;

        o.matrix = R.matrix();
        o.realPath = null;

        o.attrs = o.attrs || {};
        o.followers = o.followers || [];

        o.paper = svg;
        o.ca = o.customAttributes = o.customAttributes ||
            new svg._CustomAttributes();

        o._ = {
            transform: [],
            sx: 1,
            sy: 1,
            deg: 0,
            dx: 0,
            dy: 0,
            dirty: 1
        };

        o.parent = parent;
        !parent.bottom && (parent.bottom = o);

        o.prev = parent.top;
        parent.top && (parent.top.next = o);
        parent.top = o;
        o.next = null;
    },
    elproto = R.el;

    Element.prototype = elproto;
    elproto.constructor = Element;

    R._engine.getNode = function (el) {
        var node = el.node || el[0].node;
        return node.titleNode || node;
    };
    R._engine.getLastNode = function (el) {
        var node = el.node || el[el.length - 1].node;
        return node.titleNode || node;
    };

    elproto.rotate = function(deg, cx, cy) {
        var o = this,
            bbox;
        if (o.removed) {
            return o;
        }
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            bbox = o.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        o.transform(o._.transform.concat([["r", deg, cx, cy]]));
        return o;
    };

    elproto.scale = function(sx, sy, cx, cy) {
        var o = this,
            bbox;
        if (o.removed) {
            return o;
        }
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
        }
        sx = toFloat(sx[0]);
        (sy == null) && (sy = sx);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            bbox = o.getBBox(1);
        }
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;
        o.transform(o._.transform.concat([["s", sx, sy, cx, cy]]));
        return o;
    };

    elproto.translate = function(dx, dy) {
        var o = this;
        if (o.removed) {
            return o;
        }
        dx = Str(dx).split(separator);
        if (dx.length - 1) {
            dy = toFloat(dx[1]);
        }
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        o.transform(o._.transform.concat([["t", dx, dy]]));
        return o;
    };

    elproto.transform = function(tstr) {
        var o = this,
            _ = o._,
            sw;

        if (tstr == null) {
            return _.transform;
        }
        R._extractTransform(o, tstr);

        o.clip && !_.clipispath && $(o.clip, {
            transform: o.matrix.invert()
        });
        o.pattern && updatePosition(o);
        o.node && $(o.node, {
            transform: o.matrix
        });

        if (_.sx != 1 || _.sy != 1) {
            sw = o.attrs[has]("stroke-width") ? o.attrs["stroke-width"] : 1;
            o.attr({
                "stroke-width": sw
            });
        }

        return o;
    };

    elproto.hide = function() {
        var o = this;
        !o.removed && o.paper.safari(o.node.style.display = "none");
        return o;
    };

    elproto.show = function() {
        var o = this;
        !o.removed && o.paper.safari(o.node.style.display = E);
        return o;
    };

    elproto.remove = function() {
        if (this.removed || !this.parent.canvas) {
            return;
        }

        var o = this,
            node = R._engine.getNode(o),
            paper = o.paper,
            defs = paper.defs,
            i;

        paper.__set__ && paper.__set__.exclude(o);
        eve.unbind("raphael.*.*." + o.id);

        if (o.gradient && defs) {
            updateGradientReference(o);
        }
        while (i = o.followers.pop()) {
            i.el.remove();
        }
        while (i = o.bottom) {
            i.remove();
        }

        if (o._drag) {
            o.undrag();
        }

        if (o.events)  {
            while (i = o.events.pop()) {
                i.unbind();
            }
        }

        o.parent.canvas.removeChild(node);
        o.removeData();
        delete paper._elementsById[o.id]; // remove from lookup hash
        R._tear(o, o.parent);

        for (i in o) {
            o[i] = typeof o[i] === "function" ? R._removedFactory(i) : null;
        }

        o.removed = true;
    };
    elproto._getBBox = function() {
        var o = this,
            node = o.node,
            bbox = {},
            a = o.attrs,
            align,
            hide;

        if (node.style.display === "none") {
            o.show();
            hide = true;
        }

        try {
            bbox = node.getBBox();

            if (o.type == "text") {
                // If bbox does not have x / y, which is possible in certain
                // environments, we mathematically calculate these values by
                // using x, y (adjusted using the values of text-anchor, and
                // vertical-align attributes), of the element along with the
                // width and height provided by the getBBox().
                if (bbox.x === undefined) {
                    bbox.isCalculated = true;
                    align = a['text-anchor'];
                    bbox.x = (a.x || 0) - (bbox.width * ((align === "start") ?
                        0 : (align === "middle") ? 0.5 : 1));
                }

                if (bbox.y === undefined) {
                    bbox.isCalculated = true;
                    align = a['vertical-align'];
                    bbox.y = (a.y || 0) - (bbox.height * ((align === "bottom") ?
                        1 : (align === "middle") ? 0.5 : 0));
                }
            }

        } catch (e) {
        // Firefox 3.0.x plays badly here
        } finally {
            bbox = bbox || {};
        }
        hide && o.hide();
        return bbox;
    };

    elproto.attr = function(name, value) {
        if (this.removed) {
            return this;
        }
        if (name == null) {
            var res = {};
            for (var a in this.attrs)
                if (this.attrs[has](a)) {
                    res[a] = this.attrs[a];
                }
            res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
            res.transform = this._.transform;
            res.visibility = this.node.style.display === "none" ? "hidden" : "visible";
            return res;
        }
        if (value == null && R.is(name, "string")) {
            if (name == "fill" && this.attrs.fill == "none" && this.attrs.gradient) {
                return this.attrs.gradient;
            }
            if (name == "transform") {
                return this._.transform;
            }
            if (name == "visibility") {
                return this.node.style.display === "none" ? "hidden" : "visible";
            }
            var names = name.split(separator),
            out = {};
            for (var i = 0, ii = names.length; i < ii; i++) {
                name = names[i];
                if (name in this.attrs) {
                    out[name] = this.attrs[name];
                } else if (R.is(this.ca[name], "function")) {
                    out[name] = this.ca[name].def;
                } else {
                    out[name] = R._availableAttrs[name];
                }
            }
            return ii - 1 ? out : out[names[0]];
        }
        if (value == null && R.is(name, "array")) {
            out = {};
            for (i = 0, ii = name.length; i < ii; i++) {
                out[name[i]] = this.attr(name[i]);
            }
            return out;
        }
        if (value != null) {
            var params = {};
            params[name] = value;
        } else if (name != null && R.is(name, "object")) {
            params = name;
        }
        for (var key in params) {
            eve("raphael.attr." + key + "." + this.id, this, params[key], key);
        }
        var todel = {};
        for (key in this.ca) {
            if (this.ca[key] && params[has](key) && R.is(this.ca[key], "function") && !this.ca['_invoked' + key]) {

                this.ca['_invoked'+key] = true; // prevent recursion
                var par = this.ca[key].apply(this, [].concat(params[key]));
                delete this.ca['_invoked'+key];

                for (var subkey in par) {
                    if (par[has](subkey)) {
                         params[subkey] = par[subkey];
                    }
                }
                this.attrs[key] = params[key];
                if (par === false) {
                    todel[key] = params[key];
                    delete params[key];
                }
            }
        }

        setFillAndStroke(this, params);

        var follower;
        for (i = 0, ii = this.followers.length; i < ii; i++) {
            follower = this.followers[i];
            (follower.cb && !follower.cb.call(follower.el, params, this)) ||
                follower.el.attr(params);
        }

        for (subkey in todel) {
            params[subkey] = todel[subkey];
        }
        return this;
    };

    elproto.blur = function(size) {
        // Experimental. No Safari support. Use it on your own risk.
        var t = this;
        if (+size !== 0) {
            var fltr = $("filter"),
            blur = $("feGaussianBlur");
            t.attrs.blur = size;
            fltr.id = R.createUUID();
            $(blur, {
                stdDeviation: +size || 1.5
            });
            fltr.appendChild(blur);
            t.paper.defs.appendChild(fltr);
            t._blur = fltr;
            $(t.node, {
                filter: "url('" + R._url + "#" + fltr.id + "')"
            });
        } else {
            if (t._blur) {
                t._blur.parentNode.removeChild(t._blur);
                delete t._blur;
                delete t.attrs.blur;
            }
            t.node.removeAttribute("filter");
        }
    };

    elproto.on = function(eventType, handler) {
        if (this.removed) {
            return this;
        }

        var fn = handler;
        if (R.supportsTouch) {
            eventType = R._touchMap[eventType] ||
                (eventType === 'click' && 'touchstart') || eventType;
            fn = function(e) {
                e.preventDefault();
                handler();
            };
        }
        this.node['on'+ eventType] = fn;
        return this;
    };

    R._engine.path = function(svg, attrs, group) {
        var el = $("path"),
            res = new Element(el, svg, group);

        res.type = "path";
        setFillAndStroke(res, attrs);
        applyCustomAttributes(res, attrs);
        return res;
    };

    R._engine.group = function(svg, id, group) {
        var el = $("g"),
            res = new Element(el, svg, group);

        res.type = "group";
        res.canvas = res.node;
        res.top = res.bottom = null;
        res._id = id || E;
        id && el.setAttribute('class', 'raphael-group-' + res.id + '-' + id);
        return res;
    };

    R._engine.circle = function(svg, attrs, group) {
        var el = $("circle"),
            res = new Element(el, svg, group);

        res.type = "circle";
        setFillAndStroke(res, attrs);
        applyCustomAttributes(res, attrs);
        return res;
    };
    R._engine.rect = function(svg, attrs, group) {
        var el = $("rect"),
            res = new Element(el, svg, group);

        res.type = "rect";
        attrs.rx = attrs.ry = attrs.r;
        setFillAndStroke(res, attrs);
        applyCustomAttributes(res, attrs);
        return res;
    };
    R._engine.ellipse = function(svg, attrs, group) {
        var el = $("ellipse"),
            res = new Element(el, svg, group);

        res.type = "ellipse";
        setFillAndStroke(res, attrs);
        applyCustomAttributes(res, attrs);
        return res;
    };
    R._engine.image = function(svg, attrs, group) {
        var el = $("image"),
            src = attrs.src,
            res = new Element(el, svg, group);

        res.type = "image";
        el.setAttribute("preserveAspectRatio", "none");
        setFillAndStroke(res, attrs);
        applyCustomAttributes(res, attrs);
        return res;
    };
    R._engine.text = function(svg, attrs, group) {
        var el = $("text"),
            res = new Element(el, svg, group);
        res.type = "text";
        res._textdirty = true;
        setFillAndStroke(res, attrs);
        applyCustomAttributes(res, attrs);
        return res;
    };

    R._engine.setSize = function(width, height) {
        this.width = width || this.width;
        this.height = height || this.height;
        this.canvas.setAttribute("width", this.width);
        this.canvas.setAttribute("height", this.height);
        if (this._viewBox) {
            this.setViewBox.apply(this, this._viewBox);
        }
        return this;
    };
    R._engine.create = function() {
        var con = R._getContainer.apply(0, arguments),
        container = con && con.container,
        x = con.x,
        y = con.y,
        width = con.width,
        height = con.height;
        if (!container) {
            throw new Error("SVG container not found.");
        }
        var cnvs = $("svg"),
        css = "overflow:hidden;-webkit-tap-highlight-color:rgba(0,0,0,0);"+
            "-webkit-user-select:none;-moz-user-select:-moz-none;-khtml-user-select:none;"+
            "-ms-user-select:none;user-select:none;-o-user-select:none;cursor:default;",
        isFloating;
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        $(cnvs, {
            height: height,
            version: 1.1,
            width: width,
            xmlns: "http://www.w3.org/2000/svg"
        });
        if (container == 1) {
            cnvs.style.cssText = css + "position:absolute;left:" + x + "px;top:" + y + "px";
            R._g.doc.body.appendChild(cnvs);
            isFloating = 1;
        } else {
            cnvs.style.cssText = css + "position:relative";
            if (container.firstChild) {
                container.insertBefore(cnvs, container.firstChild);
            } else {
                container.appendChild(cnvs);
            }
        }
        container = new R._Paper;
        container.width = width;
        container.height = height;
        container.canvas = cnvs;
        $(cnvs, {
            id: "raphael-paper-" + container.id
        });
        container.clear();
        container._left = container._top = 0;
        isFloating && (container.renderfix = function() {
            });
        container.renderfix();
        return container;
    };
    R._engine.setViewBox = function(x, y, w, h, fit) {
        eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
        var size = mmax(w / this.width, h / this.height),
        top = this.top,
        aspectRatio = fit ? "meet" : "xMinYMin",
        vb,
        sw;
        if (x == null) {
            if (this._vbSize) {
                size = 1;
            }
            delete this._vbSize;
            vb = "0 0 " + this.width + S + this.height;
        } else {
            this._vbSize = size;
            vb = x + S + y + S + w + S + h;
        }
        $(this.canvas, {
            viewBox: vb,
            preserveAspectRatio: aspectRatio
        });
        while (size && top) {
            sw = "stroke-width" in top.attrs ? top.attrs["stroke-width"] : 1;
            top.attr({
                "stroke-width": sw
            });
            top._.dirty = 1;
            top._.dirtyT = 1;
            top = top.prev;
        }
        this._viewBox = [x, y, w, h, !!fit];
        return this;
    };

    R.prototype.renderfix = function() {
        var cnvs = this.canvas,
        s = cnvs.style,
        pos;
        try {
            pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
        } catch (e) {
            pos = cnvs.createSVGMatrix();
        }
        var left = -pos.e % 1,
        top = - pos.f % 1;
        if (left || top) {
            if (left) {
                this._left = (this._left + left) % 1;
                s.left = this._left + "px";
            }
            if (top) {
                this._top = (this._top + top) % 1;
                s.top = this._top + "px";
            }
        }
    };

    R.prototype._desc = function (txt) {
        var desc = this.desc;

        if (!desc) {
            this.desc = desc = $("desc");
            this.canvas.appendChild(desc);
        }
        else {
            while (desc.firstChild) {
                desc.removeChild(desc.firstChild);
            }
        }
        desc.appendChild(R._g.doc.createTextNode(R.is(txt, "string") ? txt : ("Created with Red Rapha\xebl " +
            R.version)));
    };

    R.prototype.clear = function() {
        var c;
        eve("raphael.clear", this);

        while (c = this.bottom) {
            c.remove();
        }

        c = this.canvas;
        while (c.firstChild) {
            c.removeChild(c.firstChild);
        }
        this.bottom = this.top = null;
        c.appendChild(this.desc = $("desc"));
        c.appendChild(this.defs = $("defs"));
    };

    R.prototype.remove = function() {
        var i;
        eve("raphael.remove", this);

        while (i = this.bottom) {
            i.remove();
        }

        this.defs && this.defs.parentNode.removeChild(this.defs);
        this.desc && this.desc.parentNode.removeChild(this.desc);
        this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
        for (i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        this.removed = true;
    };
    var setproto = R.st;
    for (var method in elproto)
        if (elproto[has](method) && !setproto[has](method)) {
            setproto[method] = (function(methodname) {
                return function() {
                    var arg = arguments;
                    return this.forEach(function(el) {
                        el[methodname].apply(el, arg);
                    });
                };
            })(method);
        }
})();

/**!
* RedRaphael 1.0.0 - JavaScript Vector Library VML Module
* Copyright (c) 2012-2013 FusionCharts Technologies <http://www.fusioncharts.com>
*
* Raphael 2.1.0 - JavaScript Vector Library VML Module
* Copyright (c) 2008-2012 Dmitry Baranovskiy <http://raphaeljs.com>
* Copyright 짤 2008-2012 Sencha Labs <http://sencha.com>
*
* Licensed under the MIT license.
*/

(function(){
    if (!R.vml) {
        return;
    }
    var has = "hasOwnProperty",
    Str = String,
    toFloat = parseFloat,
    math = Math,
    round = math.round,
    mmax = math.max,
    mmin = math.min,
    sqrt = math.sqrt,
    abs = math.abs,
    fillString = "fill",
    separator = /[, ]+/,
    eve = R.eve,
    ms = " progid:DXImageTransform.Microsoft",
    S = " ",
    E = "",
    map = {
        M: "m",
        L: "l",
        C: "c",
        Z: "x",
        m: "t",
        l: "r",
        c: "v",
        z: "x"
    },
    bites = /([clmz]),?([^clmz]*)/gi,
    blurregexp = / progid:\S+Blur\([^\)]+\)/g,
    val = /-?[^,\s-]+/g,
    cssDot = "position:absolute;left:0;top:0;width:1px;height:1px",
    zoom = 21600,
    pathTypes = {
        path: 1,
        rect: 1,
        image: 1
    },
    ovalTypes = {
        circle: 1,
        ellipse: 1
    },
    path2vml = function(path) {
        var total = /[ahqstv]/ig,
        command = R._pathToAbsolute;
        Str(path).match(total) && (command = R._path2curve);
        total = /[clmz]/g;
        if (command == R._pathToAbsolute && !Str(path).match(total)) {
            var res = Str(path).replace(bites, function(all, command, args) {
                var vals = [],
                isMove = command.toLowerCase() == "m",
                res = map[command];
                args.replace(val, function(value) {
                    if (isMove && vals.length == 2) {
                        res += vals + map[command == "m" ? "l" : "L"];
                        vals = [];
                    }
                    vals.push(round(value * zoom));
                });
                return res + vals;
            });

            return res || 'm0,0';
        }
        var pa = command(path), p, r;
        res = [];
        for (var i = 0, ii = pa.length; i < ii; i++) {
            p = pa[i];
            r = pa[i][0].toLowerCase();
            r == "z" && (r = "x");
            for (var j = 1, jj = p.length; j < jj; j++) {
                r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
            }
            res.push(r);
        }
        return res.length ? res.join(S) : 'm0,0';
    },
    compensation = function(deg, dx, dy) {
        var m = R.matrix();
        m.rotate(-deg, .5, .5);
        return {
            dx: m.x(dx, dy),
            dy: m.y(dx, dy)
        };
    },
    setCoords = function(p, sx, sy, dx, dy, deg) {
        var _ = p._,
        m = p.matrix,
        fillpos = _.fillpos,
        o = p.node,
        s = o.style,
        y = 1,
        flip = "",
        dxdy,
        kx = zoom / sx,
        ky = zoom / sy;
        s.visibility = "hidden";
        if (!sx || !sy) {
            return;
        }
        o.coordsize = abs(kx) + S + abs(ky);
        s.rotation = deg * (sx * sy < 0 ? -1 : 1);
        if (deg) {
            var c = compensation(deg, dx, dy);
            dx = c.dx;
            dy = c.dy;
        }
        sx < 0 && (flip += "x");
        sy < 0 && (flip += " y") && (y = -1);
        s.flip = flip;
        o.coordorigin = (dx * -kx) + S + (dy * -ky);
        if (fillpos || _.fillsize) {
            var fill = o.getElementsByTagName(fillString);
            fill = fill && fill[0];
            if (fill) {
                o.removeChild(fill);
                if (fillpos) {
                    c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));
                    fill.position = c.dx * y + S + c.dy * y;
                }
                if (_.fillsize) {
                    fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);
                }
                o.appendChild(fill);
            }
        }
        s.visibility = "visible";
    };
    R._url = E;
    R.toString = function() {
        return  "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
    };
    var addArrow = function(o, value, isEnd) {
        var values = Str(value).toLowerCase().split("-"),
        se = isEnd ? "end" : "start",
        i = values.length,
        type = "classic",
        w = "medium",
        h = "medium";
        while (i--) {
            switch (values[i]) {
                case "block":
                case "classic":
                case "oval":
                case "diamond":
                case "open":
                case "none":
                    type = values[i];
                    break;
                case "wide":
                case "narrow":
                    h = values[i];
                    break;
                case "long":
                case "short":
                    w = values[i];
                    break;
            }
        }
        var stroke = o.node.getElementsByTagName("stroke")[0];
        stroke[se + "arrow"] = type;
        stroke[se + "arrowlength"] = w;
        stroke[se + "arrowwidth"] = h;
    },

    applyCustomAttributes = function (o, attrs) {
        for (var key in attrs) {
            eve("raphael.attr." + key + "." + o.id, o, attrs[key], key);
            o.ca[key] && o.attr(key, attrs[key]);
        }
    },

    setFillAndStroke = R._setFillAndStroke = function(o, params) {
        if (!o.paper.canvas) return;
        // o.paper.canvas.style.display = "none";
        o.attrs = o.attrs || {};
        var node = o.node,
        a = o.attrs,
        s = node.style,
        xy,
        newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),
        isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),
        isGroup = o.type === 'group',
        res = o;


        for (var par in params)
            if (params[has](par)) {
                a[par] = params[par];
            }
        if (newpath) {
            a.path = R._getPath[o.type](o);
            o._.dirty = 1;
        }
        params.href && (node.href = params.href);
        params.title && (node.title = params.title);
        params.target && (node.target = params.target);
        params.cursor && (s.cursor = params.cursor);
        "blur" in params && o.blur(params.blur);

        if (params.path && o.type == "path" || newpath) {
            node.path = path2vml(~Str(a.path).toLowerCase().indexOf("r") ? R._pathToAbsolute(a.path) : a.path);
            if (o.type == "image") {
                o._.fillpos = [a.x, a.y];
                o._.fillsize = [a.width, a.height];
                setCoords(o, 1, 1, 0, 0, 0);
            }
        }
        "transform" in params && o.transform(params.transform);
        if ("rotation" in params) {
            var rotation = params.rotation;
            if (R.is(rotation, "array")) {
                o.rotate.apply(o, rotation);
            }
            else {
                o.rotate(rotation);
            }
        }
        if ("visibility" in params) {
            params.visibility === 'hidden' ? o.hide() : o.show();
        }
        if (isOval) {
            var cx = +a.cx,
            cy = +a.cy,
            rx = +a.rx || +a.r || 0,
            ry = + a.ry || + a.r || 0;
            node.path = R.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));
        }
        if ("clip-rect" in params) {
            var rect = Str(params["clip-rect"]).split(separator);

            if (rect.length == 4) {
                rect[0] = +rect[0];
                rect[1] = +rect[1];
                rect[2] = +rect[2] + rect[0];
                rect[3] = +rect[3] + rect[1];

                /** @todo create separate element for group clip-rect to
                 * avoid unclipping issue */
                var div = isGroup ? node : (node.clipRect ||
                        R._g.doc.createElement("div")),
                    offset,
                    dstyle = div.style;

                if (isGroup) {
                    o.clip = rect.slice(); // copy param
                    offset = o.matrix.offset();
                    offset = [toFloat(offset[0]), toFloat(offset[1])];
                    // invert matrix calculation
                    rect[0] -= offset[0];
                    rect[1] -= offset[1];
                    rect[2] -= offset[0];
                    rect[3] -= offset[1];
                    // Fix for bug in ie clip-auto when height/width is not defined
                    /** @todo set dynamic w/h based on clip bounds or find
                     * another workaround fix */
                    dstyle.width = "10800px";
                    dstyle.height = "10800px";
                }
                else if (!node.clipRect) {
                    dstyle.top = "0";
                    dstyle.left = "0";
                    dstyle.width = o.paper.width + "px";
                    dstyle.height = o.paper.height + "px";
                    node.parentNode.insertBefore(div, node);
                    div.appendChild(node);
                    div.raphael = true;
                    div.raphaelid = node.raphaelid;
                    node.clipRect = div;
                }
                dstyle.position = "absolute";
                dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);
            }
            if (!params["clip-rect"]) {
                if (isGroup && o.clip) {
                    node.style.clip = "rect(auto auto auto auto)";
                    delete o.clip;
                }
                else if (node.clipRect) {
                    node.clipRect.style.clip = "rect(auto auto auto auto)";
                }
            }
        }
        if (o.textpath) {
            var textpathStyle = o.textpath.style;
            params.font && (textpathStyle.font = params.font);
            params["font-family"] && (textpathStyle.fontFamily = '"' + params["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, E) + '"');
            params["font-size"] && (textpathStyle.fontSize = params["font-size"]);
            params["font-weight"] && (textpathStyle.fontWeight = params["font-weight"]);
            params["font-style"] && (textpathStyle.fontStyle = params["font-style"]);
        }
        if ("arrow-start" in params) {
            addArrow(res, params["arrow-start"]);
        }
        if ("arrow-end" in params) {
            addArrow(res, params["arrow-end"], 1);
        }
        if (params.opacity != null ||
            params["stroke-width"] != null ||
            params.fill != null ||
            params.src != null ||
            params.stroke != null ||
            params["stroke-width"] != null ||
            params["stroke-opacity"] != null ||
            params["fill-opacity"] != null ||
            params["stroke-dasharray"] != null ||
            params["stroke-miterlimit"] != null ||
            params["stroke-linejoin"] != null ||
            params["stroke-linecap"] != null) {
            var fill = node.getElementsByTagName(fillString),
            newfill = false,
            fillOpacity = -1;
            fill = fill && fill[0];
            !fill && (newfill = fill = createNode(fillString));
            if (o.type == "image" && params.src) {
                fill.src = params.src;
            }
            params.fill && (fill.on = true);
            if (fill.on == null || params.fill == "none" || params.fill === null) {
                fill.on = false;
            }
            if (fill.on && params.fill) {
                var isURL = Str(params.fill).match(R._ISURL);
                if (isURL) {
                    fill.parentNode == node && node.removeChild(fill);
                    fill.rotate = true;
                    fill.src = isURL[1];
                    fill.type = "tile";
                    var bbox = o.getBBox(1);
                    fill.position = bbox.x + S + bbox.y;
                    o._.fillpos = [bbox.x, bbox.y];

                    R._preload(isURL[1], function() {
                        o._.fillsize = [this.offsetWidth, this.offsetHeight];
                    });
                } else {
                    var color = R.getRGB(params.fill);
                    fill.color = color.hex;
                    fill.src = E;
                    fill.type = "solid";
                    if (color.error && (res.type in {
                        circle: 1,
                        ellipse: 1
                    } || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill, fill)) {
                        a.fill = "none";
                        a.gradient = params.fill;
                        fill.rotate = false;
                    }
                    else if ("opacity" in color && !("fill-opacity" in params)) {
                        fillOpacity = color.opacity;
                    }
                }
            }
            if (fillOpacity !== -1 || "fill-opacity" in params || "opacity" in params) {
                var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+fillOpacity + 1 || 2) - 1);
                opacity = mmin(mmax(opacity, 0), 1);
                fill.opacity = opacity;
                if (fill.src) {
                    fill.color = "none";
                }
            }
            node.appendChild(fill);
            var stroke = (node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0]),
                newstroke = false;
            !stroke && (newstroke = stroke = createNode("stroke"));
            if ((params.stroke && params.stroke != "none") ||
                params["stroke-width"] ||
                params["stroke-opacity"] != null ||
                params["stroke-dasharray"] ||
                params["stroke-miterlimit"] ||
                params["stroke-linejoin"] ||
                params["stroke-linecap"]) {
                stroke.on = true;
            }
            (params.stroke == "none" || params.stroke === null || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
            var strokeColor = R.getRGB(('stroke' in params) ? params.stroke : a.stroke);
            stroke.on && params.stroke && (stroke.color = strokeColor.hex);
            opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.opacity + 1 || 2) - 1);
            var width = (toFloat(params["stroke-width"]) || 1) * .75;
            opacity = mmin(mmax(opacity, 0), 1);
            params["stroke-width"] == null && (width = a["stroke-width"]);
            params["stroke-width"] && (stroke.weight = width);
            width && width < 1 && (opacity *= width) && (stroke.weight = 1);
            stroke.opacity = opacity;

            params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"]) || newstroke && (newstroke.joinstyle = 'miter');
            stroke.miterlimit = params["stroke-miterlimit"] || 8;
            params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
            if (params["stroke-dasharray"]) {
                var dasharray = {
                    "-": "shortdash",
                    ".": "shortdot",
                    "-.": "shortdashdot",
                    "-..": "shortdashdotdot",
                    ". ": "dot",
                    "- ": "dash",
                    "--": "longdash",
                    "- .": "dashdot",
                    "--.": "longdashdot",
                    "--..": "longdashdotdot"
                };
                stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] :
                        ((params["stroke-dasharray"].join && params["stroke-dasharray"].join(' ')) || E);
            }
            newstroke && node.appendChild(stroke);
        }
        if (res.type == "text") {
            res.paper.canvas.style.display = E;
            var span = res.paper.span,
            m = 100,
            fontSize = a.font && a.font.match(/\d+(?:\.\d*)?(?=px)/),
            lineHeight = a['line-height'] && (a['line-height']+E).match(/\d+(?:\.\d*)?(?=px)/);
            s = span.style;
            a.font && (s.font = a.font);
            a["font-family"] && (s.fontFamily = a["font-family"]);
            a["font-weight"] && (s.fontWeight = a["font-weight"]);
            a["font-style"] && (s.fontStyle = a["font-style"]);
            fontSize = toFloat(a["font-size"] || fontSize && fontSize[0]) || 10;
            s.fontSize = fontSize * m + "px";
            lineHeight = toFloat(a["line-height"] || lineHeight && lineHeight[0]) || 12;
            a["line-height"] && (s.lineHeight = lineHeight * m + 'px');
            R.is(params.text, 'array') && (params.text = res.textpath.string = params.text.join('\n').replace(/<br\s*?\/?>/ig, '\n'));
            res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>"));
            var brect = span.getBoundingClientRect();
            res.W = a.w = (brect.right - brect.left) / m;
            res.H = a.h = (brect.bottom - brect.top) / m;
            // res.paper.canvas.style.display = "none";
            res.X = a.x;
            res.Y = a.y;
            var leading = lineHeight - fontSize;

            switch(a["vertical-align"]) {
                case "top":
                    res.bby = res.H / 2; // + leading;
                    break;
                case "bottom":
                    res.bby = -res.H / 2; // - leading;
                    break;
                default:
                    res.bby = 0;
            }

            ("x" in params || "y" in params || res.bby !== undefined) && (res.path.v = R.format("m{0},{1}l{2},{1}", round(a.x * zoom), round((a.y + (res.bby || 0)) * zoom), round(a.x * zoom) + 1));
            var dirtyattrs = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size", "line-height"];
            for (var d = 0, dd = dirtyattrs.length; d < dd; d++)
                if (dirtyattrs[d] in params) {
                    res._.dirty = 1;
                    break;
                }

            // text-anchor emulation
            switch (a["text-anchor"]) {
                case "start":
                    res.textpath.style["v-text-align"] = "left";
                    res.bbx = res.W / 2;
                    break;
                case "end":
                    res.textpath.style["v-text-align"] = "right";
                    res.bbx = -res.W / 2;
                    break;
                default:
                    res.textpath.style["v-text-align"] = "center";
                    res.bbx = 0;
                    break;
            }
            res.textpath.style["v-text-kern"] = true;
        }
    // res.paper.canvas.style.display = E;
    },
    addGradientFill = function(o, gradient, fill) {
        o.attrs = o.attrs || {};
        var attrs = o.attrs,
        pow = Math.pow,
        opacity,
        oindex,
        type = "linear",
        fxfy = ".5 .5";
        o.attrs.gradient = gradient;
        gradient = Str(gradient).replace(R._radial_gradient, function(all, opts) {
            type = "radial";
            opts = opts && opts.split(',') || [];

            // fx,fy of vml is cx,cy of svg
            var cx = opts[0],
                cy = opts[1],
                r = opts[2],
                fx = opts[3],
                fy = opts[4],
                units = opts[5];
            if (fx && fy) {
                fx = toFloat(fx);
                fy = toFloat(fy);
                pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
                fxfy = fx + S + fy;
            }
            return E;
        });
        gradient = gradient.split(/\s*\-\s*/);
        if (type == "linear") {
            var angle = gradient.shift();
            angle = -toFloat(angle);
            if (isNaN(angle)) {
                return null;
            }
        }
        var dots = R._parseDots(gradient);
        if (!dots) {
            return null;
        }
        o = o.shape || o.node;
        if (dots.length) {
            fill.parentNode == o && o.removeChild(fill);
            fill.on = true;
            fill.method = "none";
            fill.color = dots[0].color;
            fill.color2 = dots[dots.length - 1].color;
            //For VML use first and last available alpha
            var clrs = [],
            opacity1 = 1,
            opacity2 = dots[0].opacity === undefined ? 1 : dots[0].opacity;
            for (var i = 0, ii = dots.length; i < ii; i++) {
                dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);
                if (dots[i].opacity !== undefined) {
                    opacity1 = dots[i].opacity;//update with latest avaible opacity
                }
            }
            fill.colors = clrs.length ? clrs.join() : "0% " + fill.color;
            //set opacity1 & opacity2
            fill.opacity = opacity1;
            fill['o:opacity2'] = opacity2;
            if (type == "radial") {
                fill.type = "gradientTitle";
                fill.focus = "100%";
                fill.focussize = "0 0";
                fill.focusposition = fxfy;
                fill.angle = 0;
            } else {
                // fill.rotate= true;
                fill.type = "gradient";
                fill.angle = (270 - angle) % 360;
            }
            o.appendChild(fill);
        }
        return 1;
    },
    Element = function(node, vml, group) {
        var o = this,
            parent = group || vml,
			skew;

		parent.canvas && parent.canvas.appendChild(node);
		skew = createNode("skew");
        skew.on = true;
        node.appendChild(skew);
        o.skew = skew;

        o.node = o[0] = node;
        node.raphael = true;
        node.raphaelid = o.id = R._oid++;

        o.X = 0;
        o.Y = 0;

        o.attrs = o.attrs || {};
        o.followers = o.followers || [];

        o.paper = vml;
        o.ca = o.customAttributes = o.customAttributes ||
            new vml._CustomAttributes();

        o.matrix = R.matrix();
        o._ = {
            transform: [],
            sx: 1,
            sy: 1,
            dx: 0,
            dy: 0,
            deg: 0,
            dirty: 1,
            dirtyT: 1
        };

        o.parent = parent;
        !parent.bottom && (parent.bottom = o);

        o.prev = parent.top;
        parent.top && (parent.top.next = o);
        parent.top = o;
        o.next = null;
    };
    var elproto = R.el;

    Element.prototype = elproto;
    elproto.constructor = Element;

    elproto.transform = function(tstr) {
        if (tstr == null) {
            return this._.transform;
        }
        var vbs = this.paper._viewBoxShift,
        vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E,
        oldt;

        if (vbs) {
            oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, this._.transform || E);
        }

        R._extractTransform(this, vbt + tstr);

        var matrix = this.matrix.clone(),
        skew = this.skew,
        o = this.node,
        split,
        isGrad = ~Str(this.attrs.fill).indexOf("-"),
        isPatt = !Str(this.attrs.fill).indexOf("url(");
        matrix.translate(-.5, -.5);
        if (isPatt || isGrad || this.type == "image") {
            skew.matrix = "1 0 0 1";
            skew.offset = "0 0";
            split = matrix.split();
            if ((isGrad && split.noRotation) || !split.isSimple) {
                o.style.filter = matrix.toFilter();
                var bb = this.getBBox(),
                bbt = this.getBBox(1),
                xget = bb.x2 && bbt.x2 && 'x2' || 'x',
                yget = bb.y2 && bbt.y2 && 'y2' || 'y',
                dx = bb[xget] - bbt[xget],
                dy = bb[yget] - bbt[yget];
                o.coordorigin = (dx * -zoom) + S + (dy * -zoom);
                setCoords(this, 1, 1, dx, dy, 0);
            } else {
                o.style.filter = E;
                setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);
            }
        } else {
            o.style.filter = E;
            skew.matrix = Str(matrix);
            skew.offset = matrix.offset();
        }
        oldt && (this._.transform = oldt);

        return this;
    };
    elproto.rotate = function(deg, cx, cy) {
        if (this.removed) {
            return this;
        }
        if (deg == null) {
            return;
        }
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        this._.dirtyT = 1;
        this.transform(this._.transform.concat([["r", deg, cx, cy]]));
        return this;
    };
    elproto.translate = function(dx, dy) {
        if (this.removed) {
            return this;
        }
        dx = Str(dx).split(separator);
        if (dx.length - 1) {
            dy = toFloat(dx[1]);
        }
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        if (this._.bbox) {
            this._.bbox.x += dx;
            this._.bbox.y += dy;
        }
        this.transform(this._.transform.concat([["t", dx, dy]]));
        return this;
    };
    elproto.scale = function(sx, sy, cx, cy) {
        if (this.removed) {
            return this;
        }
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
            isNaN(cx) && (cx = null);
            isNaN(cy) && (cy = null);
        }
        sx = toFloat(sx[0]);
        (sy == null) && (sy = sx);
        (cy == null) && (cx = cy);
        if (cx == null || cy == null) {
            var bbox = this.getBBox(1);
        }
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;

        this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
        this._.dirtyT = 1;
        return this;
    };
    elproto.hide = function(soft) {
        var o = this;
        !o.removed && (o.node.style.display = "none");
        return o;
    };

    elproto.show = function(soft) {
        var o = this;
        !o.removed && (o.node.style.display = E);
        return o;
    };
    elproto._getBBox = function() {
        if (this.removed) {
            return {};
        }
        return {
            x: this.X + (this.bbx || 0) - this.W / 2,
            y: this.Y + (this.bby || 0) - this.H / 2,
            width: this.W,
            height: this.H
        };
    };
    elproto.remove = function() {
        if (this.removed || !this.parent.canvas) {
            return;
        }

        var o = this,
            node = R._engine.getNode(o),
            paper = o.paper,
            shape = o.shape,
            i;

        paper.__set__ && paper.__set__.exclude(o);
        eve.unbind("raphael.*.*." + o.id);

        shape && shape.parentNode.removeChild(shape);
        node.parentNode && node.parentNode.removeChild(node);

        while (i = o.followers.pop()) {
            i.el.remove();
        }
        while (i = o.bottom) {
            i.remove();
        }

        if (o._drag) {
            o.undrag();
        }

        if (o.events)  {
            while (i = o.events.pop()) {
                i.unbind();
            }
        }

        o.removeData();
        delete paper._elementsById[o.id];
        R._tear(o, o.parent);

        for (var i in o) {
            o[i] = typeof o[i] === "function" ? R._removedFactory(i) : null;
        }
        o.removed = true;
    };

    elproto.attr = function(name, value) {
        if (this.removed) {
            return this;
        }
        if (name == null) {
            var res = {};
            for (var a in this.attrs)
                if (this.attrs[has](a)) {
                    res[a] = this.attrs[a];
                }
            res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
            res.transform = this._.transform;
            res.visibility = this.node.style.display === "none" ? "hidden" : "visible";
            return res;
        }
        if (value == null && R.is(name, "string")) {
            if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
                return this.attrs.gradient;
            }
            if (name == "visibility") {
                return this.node.style.display === "none" ? "hidden" : "visible";
            }
            var names = name.split(separator),
            out = {};
            for (var i = 0, ii = names.length; i < ii; i++) {
                name = names[i];
                if (name in this.attrs) {
                    out[name] = this.attrs[name];
                } else if (R.is(this.ca[name], "function")) {
                    out[name] = this.ca[name].def;
                } else {
                    out[name] = R._availableAttrs[name];
                }
            }
            return ii - 1 ? out : out[names[0]];
        }
        if (this.attrs && value == null && R.is(name, "array")) {
            out = {};
            for (i = 0, ii = name.length; i < ii; i++) {
                out[name[i]] = this.attr(name[i]);
            }
            return out;
        }
        var params;
        if (value != null) {
            params = {};
            params[name] = value;
        }
        value == null && R.is(name, "object") && (params = name);
        for (var key in params) {
            eve("raphael.attr." + key + "." + this.id, this, params[key], key);
        }
        if (params) {
            var todel = {};
            for (key in this.ca) {
                if (this.ca[key] && params[has](key) && R.is(this.ca[key], "function") && !this.ca['_invoked' + key]) {
                    this.ca['_invoked' + key] = true; // prevent recursion
                    var par = this.ca[key].apply(this, [].concat(params[key]));
                    delete this.ca['_invoked' + key];

                    for (var subkey in par) {
                        if (par[has](subkey)) {
                            params[subkey] = par[subkey];
                        }
                    }
                    this.attrs[key] = params[key];
                    if (par === false) {
                        todel[key] = params[key];
                        delete params[key];
                    }
                }
            }

            // this.paper.canvas.style.display = "none";
            if ('text' in params && this.type == "text") {
                R.is(params.text, 'array') && (params.text = params.text.join('\n'));
                this.textpath.string = params.text.replace(/<br\s*?\/?>/ig, '\n');
            }
            setFillAndStroke(this, params);
            var follower;
            for (i = 0, ii = this.followers.length; i < ii; i++) {
                follower = this.followers[i];
                (follower.cb && !follower.cb.call(follower.el, params, this)) ||
                    follower.el.attr(params);
            }
            for (var subkey in todel) {
                params[subkey] = todel[subkey];
            }
        // this.paper.canvas.style.display = E;
        }
        return this;
    };

    elproto.blur = function(size) {
        var s = this.node.runtimeStyle,
        f = s.filter;
        f = f.replace(blurregexp, E);
        if (+size !== 0) {
            this.attrs.blur = size;
            s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
            s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
        } else {
            s.filter = f;
            s.margin = 0;
            delete this.attrs.blur;
        }
        return this;
    };

    elproto.on = function(eventType, handler) {
        if (this.removed) {
            return this;
        }

        this.node['on'+ eventType] = function() {
            var evt = R._g.win.event;
            evt.target = evt.srcElement;
            handler(evt);
        };
        return this;
    };

    R._engine.getNode = function (el) {
        var node = el.node || el[0].node;
        return node.clipRect || node;
    };
    R._engine.getLastNode = function (el) {
        var node = el.node || el[el.length - 1].node;
        return node.clipRect || node;
    };

    R._engine.group = function(vml, id, group) {
        var el = R._g.doc.createElement("div"),
            p = new Element(el, vml, group);

        el.style.cssText = cssDot;
        p._id = id || E;
        id && (el.className = 'raphael-group-' + p.id + '-' + id);
        (group || vml).canvas.appendChild(el);

        p.type = 'group';
        p.canvas = p.node;
        p.transform = R._engine.group.transform;
        p.top = null;
        p.bottom = null;

        return p;
    };

    R._engine.group.transform = function(tstr) {
        if (tstr == null) {
            return this._.transform;
        }

        var o = this,
            s = o.node.style,
            c = o.clip,
            vbs = o.paper._viewBoxShift,
            vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E,
            oldt,
            matrix,
            offset,
            tx,
            ty;

        if (vbs) {
            oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, o._.transform || E);
        }
        R._extractTransform(o, vbt + tstr);
        matrix = o.matrix;
        offset = matrix.offset();
        tx = toFloat(offset[0]) || 0;
        ty = toFloat(offset[1]) || 0;

        s.left = tx + "px";
        s.top = ty + "px";
        s.zoom = (o._.tzoom = matrix.get(0)) + E;

        /** @todo try perform relative group transform, thus avoiding
         * transform on clipping */
        c && (s.clip = R.format("rect({1}px {2}px {3}px {0}px)", [
            c[0] - tx, c[1] - ty, c[2] - tx, c[3] - ty
        ]));

        return o;
    };

    R._engine.path = function(vml, attrs, group) {
        var el = createNode("shape");
        el.style.cssText = cssDot;
        el.coordsize = zoom + S + zoom;
        el.coordorigin = vml.coordorigin;

		var p = new Element(el, vml, group);
        p.type = attrs.type || "path";
		p.path = [];
        p.Path = E;

		attrs.type && (delete attrs.type);
        setFillAndStroke(p, attrs);
        applyCustomAttributes(p, attrs);
        return p;
    };

    R._engine.rect = function(vml, attrs, group) {
        var path = R._rectPath(attrs.x, attrs.y, attrs.w, attrs.h, attrs.r);

		attrs.path = path;
		attrs.type = "rect";

		var res = vml.path(attrs, group),
        a = res.attrs;
        res.X = a.x;
        res.Y = a.y;
        res.W = a.width;
        res.H = a.height;
        a.path = path;

		return res;
    };
    R._engine.ellipse = function(vml, attrs, group) {
		attrs.type = "ellipse";

		var res = vml.path(attrs, group),
			a = res.attrs;
        res.X = a.x - a.rx;
        res.Y = a.y - a.ry;
        res.W = a.rx * 2;
        res.H = a.ry * 2;

        return res;
    };
    R._engine.circle = function(vml, attrs, group) {
        attrs.type = "circle";

        var res = vml.path(attrs, group),
			a = res.attrs;

        res.X = a.x - a.r;
        res.Y = a.y - a.r;
        res.W = res.H = a.r * 2;
        return res;
    };
    R._engine.image = function(vml, attrs, group) {
        var path = R._rectPath(attrs.x, attrs.y, attrs.w, attrs.h);

		attrs.path = path;
		attrs.type = "image";
		attrs.stroke = "none";
        var res = vml.path(attrs, group),
			a = res.attrs,
			node = res.node,
			fill = node.getElementsByTagName(fillString)[0];

        a.src = attrs.src;
        res.X = a.x = attrs.x;
        res.Y = a.y = attrs.y;
        res.W = a.width = attrs.w;
        res.H = a.height = attrs.h;

        fill.parentNode == node && node.removeChild(fill);
        fill.rotate = true;
        fill.src = a.src;
        fill.type = "tile";
        res._.fillpos = [a.x, a.y];
        res._.fillsize = [a.w, a.h];
        node.appendChild(fill);
        setCoords(res, 1, 1, 0, 0, 0);
        return res;
    };
    R._engine.text = function(vml, attrs, group) {
        var el = createNode("shape"),
			path = createNode("path"),
			o = createNode("textpath");
        x = attrs.x || 0;
        y = attrs.y || 0;
        text = attrs.text;
        path.v = R.format("m{0},{1}l{2},{1}", round(attrs.x * zoom), round(attrs.y * zoom), round(attrs.x * zoom) + 1);
        path.textpathok = true;
        o.string = Str(attrs.text).replace(/<br\s*?\/?>/ig, '\n');
        o.on = true;
        el.style.cssText = cssDot;
        el.coordsize = zoom + S + zoom;
        el.coordorigin = "0 0";
        var p = new Element(el, vml, group);

        p.shape = el;
        p.path = path;
        p.textpath = o;
        p.type = "text";
        p.attrs.text = Str(attrs.text || E);
        p.attrs.x = attrs.x;
        p.attrs.y = attrs.y;
        p.attrs.w = 1;
        p.attrs.h = 1;
        setFillAndStroke(p, attrs);
        applyCustomAttributes(p, attrs);

        el.appendChild(o);
        el.appendChild(path);

        return p;
    };

    R._engine.setSize = function(width, height) {
        var cs = this.canvas.style;
        this.width = width;
        this.height = height;
        width == +width && (width += "px");
        height == +height && (height += "px");
        cs.width = width;
        cs.height = height;
        cs.clip = "rect(0 " + width + " " + height + " 0)";
        if (this._viewBox) {
            R._engine.setViewBox.apply(this, this._viewBox);
        }
        return this;
    };
    R._engine.setViewBox = function(x, y, w, h, fit) {
        eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
        var width = this.width,
        height = this.height,
        size = 1 / mmax(w / width, h / height),
        H, W;
        if (fit) {
            H = height / h;
            W = width / w;
            if (w * H < width) {
                x -= (width - w * H) / 2 / H;
            }
            if (h * W < height) {
                y -= (height - h * W) / 2 / W;
            }
        }
        this._viewBox = [x, y, w, h, !!fit];
        this._viewBoxShift = {
            dx: -x,
            dy: -y,
            scale: size
        };
        this.forEach(function(el) {
            el.transform("...");
        });
        return this;
    };
    var createNode;
    R._engine.initWin = function(win) {
        var doc = win.document;
        doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
        try {
            !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
            createNode = R._createNode = function(tagName, attrs) {
                var el = doc.createElement('<rvml:' + tagName + ' class="rvml">'),
                prop;
                for (prop in attrs) {
                    el[prop] = Str(attrs[prop]);
                }
                return el;
            };
        } catch (e) {
            createNode = R._createNode = function(tagName, attrs) {
                var el = doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">'),
                prop;
                for (prop in attrs) {
                    el[prop] = Str(attrs[prop]);
                }
                return el;
            };
        }
    };
    R._engine.initWin(R._g.win);
    R._engine.create = function() {
        var con = R._getContainer.apply(0, arguments),
        container = con.container,
        height = con.height,
        s,
        width = con.width,
        x = con.x,
        y = con.y;
        if (!container) {
            throw new Error("VML container not found.");
        }
        var res = new R._Paper,
        c = res.canvas = R._g.doc.createElement("div"),
        cs = c.style;
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        res.width = width;
        res.height = height;
        width == +width && (width += "px");
        height == +height && (height += "px");
        res.coordsize = zoom * 1e3 + S + zoom * 1e3;
        res.coordorigin = "0 0";
        c.id = "raphael-paper-" + res.id;
        res.span = R._g.doc.createElement("span");
        res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;";
        c.appendChild(res.span);
        cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;cursor:default;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
        if (container == 1) {
            R._g.doc.body.appendChild(c);
            cs.left = x + "px";
            cs.top = y + "px";
            cs.position = "absolute";
        } else {
            if (container.firstChild) {
                container.insertBefore(c, container.firstChild);
            } else {
                container.appendChild(c);
            }
        }
        res.renderfix = function() {
        };
        return res;
    };
    R.prototype.clear = function() {
        var c;
        eve("raphael.clear", this);
        while (c = this.bottom) {
            c.remove();
        }
        this.canvas.innerHTML = E;
        this.span = R._g.doc.createElement("span");
        this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
        this.canvas.appendChild(this.span);
        this.bottom = this.top = null;
    };
    R.prototype.remove = function() {
        var i;
        eve("raphael.remove", this);
        while (i = this.bottom) {
            i.remove();
        }
        this.canvas.parentNode.removeChild(this.canvas);
        for (i in this) {
            this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
        }
        return true;
    };

    var setproto = R.st;
    for (var method in elproto)
        if (elproto[has](method) && !setproto[has](method)) {
            setproto[method] = (function(methodname) {
                return function() {
                    var arg = arguments;
                    return this.forEach(function(el) {
                        el[methodname].apply(el, arg);
                    });
                };
            })(method);
        }
})();



    // EXPOSE
    // SVG and VML are appended just before the EXPOSE line
    // Even with AMD, Raphael should be defined globally
    oldRaphael.was ? (g.win.Raphael = R) : (Raphael = R);

    return R;
}, (typeof optOutModulePattern != "undefined" ? optOutModulePattern : false)));



    })();


    // Restore old Raphael or remove it from global scope
    lib.Raphael = RedRaphael;
    lib.Raphael.desc = '';
    if (someRaphael && someRaphael !== RedRaphael) {
        window.Raphael = someRaphael;
    }
    else if (window.Raphael === RedRaphael) {
        window.Raphael = undefined;
    }

}]);/**
 * @private
 * @module fusioncharts.redraphael
 * @requires fusioncharts.renderer.javascript.lib
 * @requires ../../../../vendors/redraphael/package/raphael-fusioncharts.js
 */
FusionCharts.register('module', ['private', 'fusioncharts.redraphael.helper', function () {
    var R = this.hcLib.Raphael,
        blankObject = {};

    R.fn._elementFromEvent = function (event) {
        if (!event || this.removed) {
            return null;
        }

        var element = event.srcElement || event.target || (event = event.originalEvent) &&
            (event.srcElement || event.target) || blankObject;

        (element.nodeName === 'tspan') && (element = element.parentNode);
        return this.getById(element.raphaelid);
    };
}]);
/**
 * RedRaphael extension for dealing with CSS
 *
 * @private
 * @since 3.3
 *
 * @module fusioncharts.redraphael.css
 * @requires fusioncharts.redraphael
 */
FusionCharts.register('module', ['private', 'fusioncharts.redraphael.css', function () {

    var R = this.hcLib.Raphael,
        eve = R.eve,
        g = R._g,
        paperproto = R.fn,
        elproto = R.el,
        separator = /[, ]+/,
        E = '',
        S = ' ',
        cssStyleRegEx = /\B([A-Z]{1})/g,
        StyleSheet,
        sheetproto;

    /**
     * Manage Stylesheet on a page.
     *
     * @constructor
     * @private
     */
    StyleSheet = function (ns) {
        this.rules = {};
        this.ns = ns || E;
    };

    sheetproto = StyleSheet.prototype;

    /**
     * Gets the stylesheet node associated with this instance or creates new if not already.
     * @returns {HTMLStyleElement}
     */
    sheetproto.getSheet = function () {
        var node = this.node;

        if (!node) {
            // Create a style node and append it to page head.
            node = this.node = g.doc.createElement('style');
            this.node.setAttribute('id', R.format('raphael-stylesheet-{0}', R._oid++)); // set an id to the sheet
            this.node.setAttribute('type', 'text/css'); // set an id to the sheet
            (g.doc.head || g.doc.getElementsByTagName('head')[0]).appendChild(this.node); // attach to page
        }

        return node;
    };

    /**
     * Sets css text on style node
     * @private
     * @param {string} cssText
     */
    sheetproto.setCssText = function (cssText) {
        var node = this.node;

        if (!node) {
            if (cssText) {
                node = this.getSheet();
            }
            // Nothing to set and no node to set anything to. Hence, nothing to do!
            else {
                return;
            }
        }

        if (node.styleSheet) {
            node.styleSheet.cssText = cssText || E;
        }
        else {
            node.innerHTML = E;
            cssText && node.appendChild(g.doc.createTextNode(cssText));
        }
    };

    /**
     * Disposes the stylesheet object.
     * @memberOf StyleSheet#
     */
    sheetproto.destroy = function () {
        this.node && this.node.parentNode && this.node.parentNode.removeChild(this.node);
        delete this.rules;
    };

    /**
     * Clears all css rules.
     * @memberOf StyleSheet#
     */
    sheetproto.clear = function () {
        this.setCssText(E);
        this.rules = {};
    };

    /**
     * Adds a css rule
     * @memberOf StyleSheet#
     *
     * @param {string} selector
     * @param {object} styles
     */
    sheetproto.add = function (selector, styles) {
        var s = this.rules[selector] || (this.rules[selector] = {}),
            i;

        for (i in styles) {
            s[i] = styles[i];
        }
    };

    /**
     * Renders a stylesheet after it is updated.
     * @memberOf StyleSheet#
     */
    sheetproto.render = function () {
        this.setCssText(this.toString());
    };

    sheetproto.toString = function (compressed) {
        var newline = compressed ? E : '\n',
            indent = compressed ? E : '\t',
            keyseparator = compressed ? ':' : ': ',

            css = newline,
            rule,
            prop;

        // Convert the css rules object to css text
        for (rule in this.rules) {
            css += rule.replace(/(^|\,)/g, '$1' + this.ns + S) + ' {' + newline;
            rule = this.rules[rule];
            for (prop in rule) {
                rule[prop] && (css += indent + prop.replace(cssStyleRegEx, '-$1').toLowerCase() + keyseparator +
                    rule[prop] + ';' + newline);

            }
            css += '}' + newline;
        }

        return css;
    };

    // Initialise stylesheet for new papers.
    eve.on('raphael.new', function () {
        this._stylesheet = this._stylesheet || new StyleSheet();
        this.cssNamespace(E);
    });

    // Remove stylesheet on paper dispose
    eve.on('raphael.remove', function () {
        this._stylesheet && this._stylesheet.destroy();
        delete this._stylesheet;
    });


    /**
     * Sets the namespace of the stylesheet associated with a paper
     * @param {string} ns
     */
    paperproto.cssNamespace = function (ns) {
        if (arguments.length) {
            // ensure strict paper locked namespace
            this._stylesheet.ns = R.format('{0}#raphael-paper-{1}', ns && ns + S || E, this.id);
        }
        return this._stylesheet.ns;
    };

    /**
     * Adds a css rule to the paper. The function can also accept a single object as argument having selectors as keys
     * and their corresponding style objects.
     *
     * @param {string} selector
     * @param {object} styles
     */
    paperproto.cssAddRule = function (selector, styles) {
        if (arguments.length === 1 && (typeof selector === 'object')) { // support object style
            for (var prop in selector) {
                this.cssAddRule(prop, selector[prop]);
            }
            return this;
        }
        return (this._stylesheet.add(selector, styles), this);
    };

    /**
     * Renders a stylesheet after it is updated.
     */
    paperproto.cssRender = function () {
        return (R.svg && this._stylesheet.render(), this);
    };

    /**
     * Removes all css rules.
     */
    paperproto.cssClear = function () {
        return (this._stylesheet.clear(), this);
    };

    // Adding `class` to the availableAttrs list so that the event is raised by the respective
    // setFillAndStroke functions.
    R._availableAttrs['class'] = '';

    R.svg && eve.on('raphael.attr.class', function (value) {
        var o = this,
            node = o.node;

        value = value || E;
        node.setAttribute('class', (o.type === 'group' && o._id) ?
            'raphael-group-' + o.id + '-' + o._id + S + value : value);
    });

    // Special handling for VML based browsers
    R.vml && eve.on('raphael.attr.class', function (value) {
        var o = this,
            node = o.node,
            paper = o.paper,
            selector = '.' + value,
            styleRules = paper._stylesheet && paper._stylesheet.rules,
            target = o.parent,
            attrs = o.attrs,
            cssObj = {},
            rule,
            targetClass,
            i;

        (node.className = (o.type === 'group') ? value && (o._id + S + value) || o._id : ('rvml ' + value));

        /** @todo Implement stylesheet for VML */
        // Since vml does not play nice with dynamic css and styles  we have to explicitly apply the attributes to the
        // element. We traverse up all the parent elements and procure their classes.
        if (selector && styleRules) {
            rule = styleRules[selector];
            for (i in rule) {
                (i === 'color' && o.type === 'text') && (i = 'fill');
                !attrs[i] && (cssObj[i] = rule[i]);
            }

            while (target && target.attr) {
                if ((targetClass = target.attr('class'))) {
                    selector = ('.' + targetClass + S + selector);
                    rule = styleRules[selector];
                    for (i in rule) {
                        (i === 'color' && o.type === 'text') && (i = 'fill');
                        !attrs[i] && !cssObj[i] && (cssObj[i] = rule[i]);
                    }
                }
                target = target.parent;
            }

            o.css(cssObj);
        }
    });

    /**
     * Support for element.css
     * @param {string} name
     * @param {value} value
     */
    elproto.css = function (name, value) {
        var names,
            params,
            out,
            otherkey,
            doattrs,
            i,
            ii;

        // do not parse css in case element is removed.
        if (this.removed) {
            return this;
        }

        if (!this.styles) {
            this.styles = {};
        }

        // process as getter when a single key is sent as parameter.
        if (value == null && R.is(name, 'string')) {
            names = name.split(separator),
            out = {};
            for (i = 0, ii = names.length; i < ii; i++) {
                name = names[i];
                if (name in this.styles) {
                    out[name] = this.styles[name];
                }
            }
            return ii - 1 ? out : out[names[0]];
        }
        // process as getter when multiple keys are pre-sent as array.
        if (value == null && R.is(name, 'array')) {
            out = {};
            for (i = 0, ii = name.length; i < ii; i++) {
                out[name[i]] = this.styles(name[i]);
            }
            return out;
        }

        // convert single key-value setter into object style standard.
        if (value != null) {
            params = {};
            params[name] = value;
        }
        else if (name != null && R.is(name, 'object')) {
            params = name;
        }
        // iterate on keys and set style or raise events.
        doattrs = {};
        for (i in params) {
            otherkey = i.replace(/\B([A-Z]{1})/g, '-$1').toLowerCase();

            // If keys are supported via attr then use attr instead of css.
            if (R._availableAttrs.hasOwnProperty(otherkey) || otherkey === 'color') {
                // Replace 'color' with fill
                (otherkey === 'color' && this.type === 'text') && (otherkey = 'fill');

                doattrs[otherkey] = params[i];
                doattrs.dirty = true;
                continue;
            }
            eve('raphael.css.' + otherkey + '.' + this.id, this, params[i], otherkey);
            this.node.style[otherkey] = params[i];
            this.styles[otherkey] = params[i];
        }
        // run on followers
        for (i = 0, ii = this.followers.length; i < ii; i++) {
            this.followers[i].el.attr(params);
        }
        // apply css via attrs
        if (doattrs.hasOwnProperty('dirty')) {
            delete doattrs.dirty;
            this.attr(doattrs);
        }
        return this;
    };
}]);
/**
 * Red Raphael JavaScript Library
 * ------------------------------
 * Extension for support of export feature of paper
 * @since 3.3
 * @private
 *
 * @module fusioncharts.redraphael.export
 * @requires fusioncharts.redraphael
 */
FusionCharts.register('module', ['private', 'modules.renderer.js-raphaelexport', function() {
    var global = this,
        lib = global.hcLib,
        R = lib.Raphael,
        pluckNumber = lib.pluckNumber,
        pluck = lib.pluck,
        availableAttrs = R._availableAttrs,

        NONE = 'none',
        BLANK = '',
        SPACE = ' ',
        UNDERSCORE = '_',
        COLON = ':',
        SCOLONSPACE = '; ',
        EQUALQUOT = '="',
        QUOT = '"',
        QUOTSPACE = QUOT + SPACE,
        LT = '<',
        GT = '>',
        NODESTRPART5 = '</',
        XLINK = ' xlink:href="',
        IMGNODE = 'image',
        TXTNODE = 'text',
        GRADIENT = 'gradient',
        RECT = 'rect',
        ASPRATIO = ' preserveAspectRatio="none"',
        NODESTRPART2 = ' transform="matrix(',
        NODESTRPART3 = ')" style="',
        VALIGNSTR = 'vertical-align',
        TEXTANCHOR = 'text-anchor',
        MIDDLE = 'middle',
        TOP = 'top',
        BOTTOM = 'bottom',
        FONTSIZE = 'font-size',
        FONT = 'font',
        LINEHEIGHT = 'line-height',
        FONTFAMILY = 'font-family',
        FONTWEIGHT = 'font-weight',
        CURSOR = 'cursor:',
        TSPANSTR1 = '<tspan ',
        TSPANSTR2 = 'dy="',
        TSPANSTR3 = '" x="',
        TSPANSTR4 = 'dy="',
        RX = 'rx',
        RY = 'ry',
        TSPANSTR6 = '</tspan>',
        PXSPACE = 'px; ',
        CLIPRECT = 'clip-rect',
        CLIPSTR1 = '<clipPath id="',
        CLIPSTR2 = '"><rect x="',
        CLIPSTR3 = '" y="',
        CLIPSTR4 = '" width="',
        CLIPSTR5 = '" height="',
        CLIPSTR6 = '"/></clipPath>',
        CLIPSTR7 = ' clip-path="url(#',
        CLIPSTR8 = QUOT + NODESTRPART2,
        URLCLOSE = '\')"',
        BRACKETCLOSE = ')',
        DTAG = ' d="',
        FILLSTR1 = 'fill:',
        FILLSTR2 = ' fill="',
        FILLSTR3 = ' fill="url(\'#',
        FILLSTR4 = ' fill-opacity="',
        STROKE1 = ' stroke="',
        STROKE2 = ' stroke-opacity="',
        STROKEOPAC = 'stroke-opacity',
        LINEAR = 'linear',
        RADIAL = 'radial',
        RGRADIENTSTR1 = '<radialGradient fx = "',
        RGRADIENTSTR3 = '</radialGradient>',
        RGRADIENTSTR2 = '" fy = "',
        RGRADIENTSTR6 = '" cy = "',
        RGRADIENTSTR5 = '" cx = "',
        RGRADIENTSTR7 = '" r = "',
        RGRADIENTSTR8 = '" gradientUnits = "',
        ID = '" id = "',
        RGRADIENTSTR4 = '">',
        LGRADIENTSTR6 = '</linearGradient>',
        LGRADIENTSTR5 = '" gradientTransform ="matrix(',
        LGRADIENTSTR1 = '<linearGradient x1 = "',
        LGRADIENTSTR2 = '" y1 = "',
        LGRADIENTSTR3 = '" x2 = "',
        LGRADIENTSTR4 = '" y2 = "',
        STOPSTR1 = '<stop',
        STOPSTR2 = ' offset="',
        STOPSTR3 = '" stop-color="',
        STOPSTR4 = '" stop-opacity="',
        STOPSTR5 = '" />',
        COLORWHITE = '#fff',
        PERCENT100 = '100%',
        PERCENT0 = '0%',

        //frequently used reg-exp
        matrixSanitizerReg = /^matrix\(|\)$/g,
        commaSanitizerReg = /\,/g,
        textNewLineReg = /\n|<br\s*?\/?>/ig,
        retriveNumReg = /[^\d\.]/ig,
        idSanitizerReg = /[\%\(\)\s,\xb0#]/g,
        grouptagtestReg = /group/ig,
        ampregex = /&/g,
        quot1regex = /"/g,
        quot2regex = /'/g,
        ltregex = /</g,
        gtregex = />/g,
        ampSTR = '&amp;',
        quot1STR = '&quot;',
        quot2STR = '&#39;',
        ltSTR = '&lt;',
        gtSTR = '&gt;',
        IdCounter = 0,
        gradientUnitNames = {
            userSpaceOnUse: 'userSpaceOnUse',
            objectBoundingBox: 'objectBoundingBox'
        };

        //raphael toSvg methode
        //Wrapper function
    (function(R) {
        var math = Math,
                toFloat = parseFloat,
                mmax = math.max,
                abs = math.abs,
                pow = math.pow,
                Str = String,
                separator = /[, ]+/,
                regStore = [
            {//clean all prefis and add xlink
                reg: /xmlns\=\"http\:\/\/www.w3.org\/2000\/svg\"/ig,
                repStr: ''
            },
            {//clean all prefis and add xlink
                reg: /^.*<svg /,
                repStr: '<svg xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" '
            },
            {//clean all suffix
                reg: /\/svg>.*$/,
                repStr: '/svg>'
            },
            {//remove desc tag
                reg: /<desc\>[^<]*<\/desc\>/,
                repStr: BLANK
            },
            {//clean all extra attributes
                /** @todo  after completion of REDRaphael check all attribute that are not requird then remove them */
                reg: /zIndex="[^"]+"/g,
                repStr: BLANK
            },
            {//Patched for iOS bug : #FCXT-28
                reg: /url\((\\?[\'\"])[^#]+#/g,
                repStr: 'url($1#'
            },
            {//sanitize href
                reg: / href=/g,
                repStr: ' xlink:href='
            }, //following are IE specific
            {//quote the attribute value
                reg: /(id|class|width|height)=([^" >]+)/g,
                repStr: '$1="$2"'
            },
            {//sanitize element tag
                reg: /:(path|rect)/g,
                repStr: '$1'
            },
            {//sanitize image/img tag
                reg: /<ima?ge? ([^\>]+?)[^\/]\>/gi,
                repStr: '<image $1 />'
            },
            {//remove closing image/img tag
                reg: /<\/ima?ge?\>/g,
                repStr: BLANK
            },
            {// closes image tags for firefox
                reg: /style="([^"]+)"/g,
                repStr: function(s) {
                    return s.toLowerCase();
                }
            }
        ],
        attributeParser = {
            blur: function (){
                /** @todo stop use of blur as attribute */
            },
            transform: function() {
                //skip this attribute
            },
            src: function(node, conf) {
                var attrsObj = conf.attrs,
                        value = attrsObj.src;
                conf.attrSTR += XLINK + value + QUOT;
            },
            path: function(node, conf) {
                var attrsObj = conf.attrs,
                    value = attrsObj.path;

                value = R._pathToAbsolute(value || BLANK);
                conf.attrSTR += DTAG + ((value.toString && value.toString()) || BLANK)
                    .replace(commaSanitizerReg, SPACE) + QUOT;
            },
            gradient: function(node, conf, defs) {
                var attrsObj = node.attrs,
                    value = attrsObj.gradient,
                    type = LINEAR,
                    id = value,
                    angle,
                    vector,
                    max,
                    dots,
                    fx = 0.5,
                    fy = 0.5,
                    gStr = BLANK,
                    gCloseStr = BLANK,
                    stopStr = BLANK,
                    i,
                    ln,
                    cx,
                    cy,
                    r,
                    units;

                id = id.replace(idSanitizerReg, UNDERSCORE);
                if (!defs[id]) {
                    value = Str(value).replace(R._radial_gradient, function(all, opts) { // jshint ignore: line
                        var _fx,
                            _fy,
                            dir,
                            _r,
                            _cx,
                            _cy,
                            sqx,
                            shifted;

                        opts = opts && opts.split(',') || [];
                        type = RADIAL;

                        _fx = opts[0];
                        _fy = opts[1];
                        _r = opts[2];
                        _cx = opts[3];
                        _cy = opts[4];
                        units = opts[5];
                        shifted = (_fx && _fy);

                        if (_r) {
                            r = /\%/.test(_r) ? _r : toFloat(_r);
                        }

                        if (units === gradientUnitNames.userSpaceOnUse) {
                            if (shifted) {
                                fx = _fx;
                                fy = _fy;
                            }
                            if (_cx && _cy) {
                                cx = _cx;
                                cy = _cy;
                                if (!shifted) {
                                    fx = cx;
                                    fy = cy;
                                }
                            }
                            return BLANK;
                        }

                        if (shifted) {
                            fx = toFloat(_fx);
                            fy = toFloat(_fy);
                            dir = ((fy > 0.5) * 2 - 1);
                            (sqx = pow(fx - 0.5, 2)) + pow(fy - 0.5, 2) > 0.25 &&
                            (sqx < 0.25) && (fy = math.sqrt(0.25 - sqx) * dir + 0.5) &&
                            fy !== 0.5 &&
                            (fy = fy.toFixed(5) - 1e-5 * dir);
                        }
                        if (_cx && _cy) {
                            cx = toFloat(_cx);
                            cy = toFloat(_cy);
                            dir = ((cy > 0.5) * 2 - 1);

                            (sqx = pow(cx - 0.5, 2)) + pow(cy - 0.5, 2) > 0.25 &&
                            (sqx < 0.25) && (cy = math.sqrt(0.25 - sqx) * dir + 0.5) &&
                            cy !== 0.5 &&
                            (cy = cy.toFixed(5) - 1e-5 * dir);

                            if (!shifted) {
                                fx = cx;
                                fy = cy;
                            }
                        }
                        return BLANK;
                    });
                    value = value.split(/\s*\-\s*/);
                    if (type === LINEAR) {
                        angle = value.shift();
                        angle = -toFloat(angle);
                        if (isNaN(angle)) {
                            return null;
                        }
                        vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))];
                        max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                        vector[2] *= max;
                        vector[3] *= max;
                        if (vector[2] < 0) {
                            vector[0] = -vector[2];
                            vector[2] = 0;
                        }
                        if (vector[3] < 0) {
                            vector[1] = -vector[3];
                            vector[3] = 0;
                        }
                    }
                    dots = R._parseDots(value);
                    if (!dots) {
                        return null;
                    }

                    if (type === RADIAL) {
                        gStr = RGRADIENTSTR1 + fx +
                                RGRADIENTSTR2 + fy +
                                RGRADIENTSTR6 + cy +
                                RGRADIENTSTR5 + cx +
                                RGRADIENTSTR7 + r +
                                RGRADIENTSTR8 + units +
                                ID + id + RGRADIENTSTR4;
                        gCloseStr = RGRADIENTSTR3;
                    }
                    else {
                        gStr = LGRADIENTSTR1 + vector[0] + LGRADIENTSTR2 +
                            vector[1] + LGRADIENTSTR3 + vector[2] + LGRADIENTSTR4 + vector[3] +
                            LGRADIENTSTR5 + node.matrix.invert() + BRACKETCLOSE + ID +
                            id + RGRADIENTSTR4;

                        gCloseStr = LGRADIENTSTR6;
                    }

                    for (i = 0, ln = dots.length; i < ln; i++) {
                        stopStr += STOPSTR1 +
                                STOPSTR2 + (dots[i].offset ? dots[i].offset : (i ? PERCENT100 : PERCENT0)) +
                                STOPSTR3 + (dots[i].color || COLORWHITE) +
                                STOPSTR4 + (dots[i].opacity === undefined ? 1 : dots[i].opacity) + STOPSTR5;
                    }
                    defs[id] = true;
                    defs.str += gStr + stopStr + gCloseStr;
                }
                conf.attrSTR += FILLSTR3 + id + URLCLOSE;
            },
            fill: function(node, conf) {
                var attrsObj = conf.attrs,
                    value = attrsObj.fill,
                    color,
                    opacity;
                if (!node.attrs.gradient) {
                    color = R.color(value);
                    opacity = color.opacity;
                    if (node.type === TXTNODE) {
                        conf.styleSTR += FILLSTR1 + color + SCOLONSPACE + STROKEOPAC + COLON + 0 + SCOLONSPACE;
                    }
                    else {
                        conf.attrSTR += FILLSTR2 + color + QUOT;
                        if (!attrsObj['fill-opacity'] && (opacity || opacity === 0)) {
                            conf.attrSTR += FILLSTR4 + opacity + QUOT;
                        }
                    }
                }
            },
            stroke: function(node, conf) {
                var attrsObj = conf.attrs,
                value = attrsObj.stroke,
                color,
                opacity;
                color = R.color(value);
                opacity = color.opacity;
                if (node.type !== TXTNODE) {
                    conf.attrSTR += STROKE1 + color + QUOT;
                    if (!attrsObj[STROKEOPAC] && (opacity || opacity === 0)) {
                        conf.attrSTR += STROKE2 + opacity + QUOT;
                    }
                }
            },
            'clip-rect': function(node, conf, defs) {

                var attrsObj = conf.attrs,
                    value = Str(attrsObj[CLIPRECT]),
                    rect = value.split(separator),
                    id = value.replace(idSanitizerReg, UNDERSCORE) +
                        UNDERSCORE + UNDERSCORE + (IdCounter ++);

                if (rect.length === 4) {
                    if (!defs[id]) {
                        defs[id] = true;
                        defs.str += CLIPSTR1 + id + CLIPSTR2 +
                                rect[0] + CLIPSTR3 + rect[1] + CLIPSTR4 +
                                rect[2] + CLIPSTR5 + rect[3] + CLIPSTR8 +
                                node.matrix.invert().toMatrixString().replace(matrixSanitizerReg, BLANK) +
                                BRACKETCLOSE + CLIPSTR6;
                    }
                    conf.attrSTR += CLIPSTR7 + id + BRACKETCLOSE + QUOT;
                }
            },
            cursor: function(node, conf) {
                var attrsObj = conf.attrs,
                        value = attrsObj.cursor;
                if (value) {
                    conf.styleSTR += CURSOR + value + SCOLONSPACE;
                }
            },
            font: function(node, conf) {
                var attrsObj = conf.attrs,
                        value = attrsObj.font;
                conf.styleSTR += FONT + COLON + value.replace(/\"/ig, SPACE) + SCOLONSPACE;
            },
            'font-size': function(node, conf) {
                var attrsObj = conf.attrs,
                    value = pluck(attrsObj[FONTSIZE], '10');
                if (value && value.replace) {
                    value = value.replace(retriveNumReg, BLANK);
                }
                conf.styleSTR += FONTSIZE + COLON + value + PXSPACE;
            },
            'font-weight': function(node, conf) {
                var attrsObj = conf.attrs,
                        value = attrsObj[FONTWEIGHT];
                conf.styleSTR += FONTWEIGHT + COLON + value + SCOLONSPACE;
            },
            'font-family': function(node, conf) {
                var attrsObj = conf.attrs,
                        value = attrsObj[FONTFAMILY];
                conf.styleSTR += FONTFAMILY + COLON + value + SCOLONSPACE;
            },
            'line-height': function() {
            },
            'clip-path': function() {
            },
            'visibility': function() {
            },
            'vertical-align': function() {
            },
            'text-anchor': function(node, conf) {
                var attrsObj = conf.attrs,
                value = attrsObj[TEXTANCHOR] || MIDDLE;
                if (node.type === TXTNODE) {
                    conf.attrSTR += SPACE + TEXTANCHOR + EQUALQUOT + value + QUOT;
                }
            },
            title: function() {
            },
            text: function(node, conf) {
                var attrsObj = conf.attrs,
                    value = attrsObj.text,
                    fontSize = pluck(attrsObj[FONTSIZE], attrsObj[FONT], '10'),
                    lineHeight = pluck(attrsObj[LINEHEIGHT]),
                    baseHeight,
                    x,
                    valign,
                    texts,
                    i,
                    ii,
                    baseAdjust,
                    text;

                if (fontSize && fontSize.replace) {
                    fontSize = fontSize.replace(retriveNumReg, BLANK);
                }
                fontSize = pluckNumber(fontSize);
                if (lineHeight && lineHeight.replace) {
                    lineHeight = lineHeight.replace(retriveNumReg, BLANK);
                }
                lineHeight = pluckNumber(lineHeight, fontSize && fontSize * 1.2);
                baseHeight = fontSize ? fontSize * 0.85 : lineHeight * 0.75;
                x = attrsObj.x;
                valign = pluck(attrsObj[VALIGNSTR], MIDDLE).toLowerCase();
                texts = Str(value).split(textNewLineReg);
                ii = texts.length;
                i = 0;
                baseAdjust = (valign === TOP ? baseHeight : (valign === BOTTOM ?
                (baseHeight - (lineHeight * ii)) : (baseHeight - (lineHeight * ii * 0.5))));

                for (; i < ii; i++) {
                    conf.textSTR += TSPANSTR1;
                    text = (texts[i] || BLANK).replace(ampregex, ampSTR)
                        .replace(quot1regex, quot1STR)
                        .replace(quot2regex, quot2STR)
                        .replace(ltregex, ltSTR)
                        .replace(gtregex, gtSTR);
                    if (i) {
                        conf.textSTR += TSPANSTR2 + lineHeight + TSPANSTR3 + x + QUOTSPACE;
                    }
                    else {
                        conf.textSTR += TSPANSTR4 + baseAdjust + QUOT;
                    }
                    conf.textSTR += GT + text + TSPANSTR6;
                }
            }
        },
        /**
         * This the methode used to generate SVG string of a Raphael element.
         * This methode is used in non-SVG browser only.
         *
         * @param {RaphaelElement} node is to be converted into xml string
         * @param {object} defs is the store of all defs information
         *
         */

        parseNode = function(node, defs) {
            var xmlSTR = BLANK,
                conf = {
                    attrSTR: BLANK,
                    styleSTR: BLANK,
                    textSTR: BLANK,
                    attrs: node.attr()
                },
                isShadow = node.isShadow,
                childXMLSTR = BLANK,
                nextXMLSTR = BLANK,
                attrName,
                styleName,
                nodeType,
                attrs = conf.attrs;

            //parse visible nodes only
            if (node.node.style.display !== NONE && !isShadow) {
                //parse all atributes
                for (attrName in attrs) {
                    if (attrName !== GRADIENT && (availableAttrs[attrName] !== undefined ||
                        attributeParser[attrName]) && attrs[attrName] !== undefined){
                        ///if custom parser exist then use it
                        if (attributeParser[attrName]) {//if need persing
                            attributeParser[attrName](node, conf, defs);
                        }
                        else {//else add the attribute directly
                            conf.attrSTR += SPACE + attrName + EQUALQUOT + attrs[attrName] + QUOT;
                        }
                    }
                }
                //add the gradient
                if(node.attrs.gradient){
                    attributeParser.gradient(node, conf, defs);
                }
                if (node.type === RECT && attrs.r){
                    conf.attrSTR += SPACE + RX + EQUALQUOT + attrs.r + QUOT +
                            SPACE + RY + EQUALQUOT + attrs.r + QUOT;
                }

                //Parse all style atributes that are not in attrs
                for (styleName in node.styles) {
                    conf.styleSTR += styleName + COLON + node.styles[styleName] + SCOLONSPACE;
                }

                //node type speciffic changes
                if (node.type === IMGNODE) {
                    conf.attrSTR += ASPRATIO;
                }

                //For text node apply default text anchor
                if (node.type === TXTNODE && !attrs[TEXTANCHOR]) {
                    attributeParser[TEXTANCHOR](node, conf);
                }


                //if node has a child element then parse the child element
                if (node.bottom) {
                    childXMLSTR = parseNode(node.bottom, defs);
                }
                //parse following sibling also
                if (node.next) {
                    nextXMLSTR = parseNode(node.next, defs);
                }
                nodeType = node.type;
                if (nodeType.match(grouptagtestReg)) {
                    nodeType = 'g';
//                        matrixStr = node.matrix.toMatrixString().replace(matrixSanitizerReg, BLANK);
//                    }
//                    else {
//                        matrixStr = node.matrix.toMatrixString().replace(matrixSanitizerReg, BLANK);
                }
                //generate SVG string
                xmlSTR += LT + nodeType + NODESTRPART2 +
                    node.matrix.toMatrixString().replace(matrixSanitizerReg, BLANK) +
                    NODESTRPART3 + conf.styleSTR + QUOT + conf.attrSTR +
                    GT + conf.textSTR + childXMLSTR + NODESTRPART5 +
                    nodeType + GT + nextXMLSTR;
            }
            else {
                //parse following sibling also
                if (node.next) {
                    xmlSTR += parseNode(node.next, defs);
                }
            }
            return xmlSTR;
        };

        /**
         * This the methode return the SVG string of a Raphael paper.
         *
         */
        R.fn.toSVG = function(keepImages) {
            var paper = this,
                svg = BLANK,
                defs = {str: BLANK},
                regObj,
                i = 0,
                ln = regStore.length,
                childXMLSTR = BLANK;

            // If SVG browser then get the innerHTML of the parent node
            // and sanitize the SVG string
            if (R.svg) {
                if (paper.canvas && paper.canvas.parentNode) {
                    svg = paper.canvas.parentNode.innerHTML;
                    // sanitize svg string
                    for (; i < ln; i += 1) {
                        regObj = regStore[i];
                        svg = svg.replace(regObj.reg, regObj.repStr);
                    }
                    // add stylesheet
                    if (paper._stylesheet) {
                        svg = svg.replace(/^(<svg\s[\s\S]*?>)/ig, '$1<style type="text/css">' +
                            paper._stylesheet.toString(true) + '</style>');
                    }
                }
            }
            // for VML browser parse node element and create SVG string
            else {
                svg = '<svg style="overflow: hidden; position: relative;" xmlns="http://www.w3.org/2000/svg"' +
                    ' xmlns:xlink="http://www.w3.org/1999/xlink" width="' +
                    paper.width + '" version="1.1" height="' + paper.height + '">';

                if (paper.bottom) {
                    //parse all node manualy and create XML string
                    childXMLSTR = parseNode(paper.bottom, defs);
                }
                svg += '<defs>' + defs.str + '</defs>' + childXMLSTR + '</svg>';
            }
            //remove all image tags
            if (!keepImages) {
                svg = svg.replace(/<image [^\>]*\>/gi, BLANK);
            }
            return svg;
        };

    })(R);
}]);
/**
 * Red Raphael JavaScript Library
 * ------------------------------
 * Extension for support of drop-shadow on elements
 * @private
 *
 * @module fusioncharts.redraphael.shadow
 * @requires fusioncharts.redraphael
 */
FusionCharts.register('module', ['private', 'modules.renderer.js-raphaelshadow', function () {
    var global = this,
        win = global.window,
        lib = global.hcLib,
        math = win.Math,
        mathSqrt = math.sqrt,
        toFloat = win.parseFloat,
        toInt = win.parseInt,

        EMP = '', // empty string
        SPC = ' ', // white-space
        NONE = 'none',
        ROUND = 'round',
        STROKE_WIDTH = 'stroke-width',
        DROP_SHADOW = 'drop-shadow',
        BLACK = 'rgba(0,0,0,1)',

        hasSVGFilters = win.SVGFilterElement  || (win.SVGFEColorMatrixElement &&
            win.SVGFEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_SATURATE === 2),

        R = lib.Raphael,
        forbiddenAttrs = {
            'drop-shadow': 'drop-shadow',
            'stroke': 'stroke',
            'fill': 'fill',
            'stroke-width': 'stroke-width',
            'stroke-opacity': 'stroke-opacity',
            'stroke-linecap': 'stroke-linecap',
            'stroke-linejoin': 'stroke-linejoin',
            'shape-rendering': 'shape-rendering',
            'transform': 'transform'
        },
        createNode = R._createNode,
        supervisor;

    if (R.svg) {

        // Browsers that support SVG filters needs filters to not just be
        // created, but managed as well. This is done so that multiple elements
        // can share same filter definition.
        if (hasSVGFilters) {

            R.el.dropshadow = function (dx, dy, spread, color) {
                var o = this,
                    node = o.node,
                    shadow = o._.shadowFilter,
                    cache = o.paper.cacheShadows || (o.paper.cacheShadows = {}),
                    hash = DROP_SHADOW + [dx, dy, spread, color].join(SPC),
                    prop,
                    filter,
                    opacity,
                    el;

                if (dx === NONE) {
                    if (shadow) {
                        shadow.use -= 1; // dereference
                        o.node.removeAttribute('filter');

                        // In case there is no remainig reference
                        // for the shadow, we need to remove the
                        // element in use.
                        if (!shadow.use) {
                            hash = shadow.hash; // retain hash
                            for (prop in shadow) {
                                el = shadow[prop];
                                if (el.parentNode) {
                                    el.parentNode.removeChild(el);
                                }
                                delete shadow[prop];
                            }
                            // Cleanup
                            el = null;
                            delete cache[hash];
                        }
                        // Cleanup
                        shadow = null;
                        delete o._.shadowFilter;
                    }
                }
                // In case of a valid value and shadow is yet to be
                // defined then create one.
                else if (!(shadow && cache[hash] === shadow)) {
                    filter = o.paper.defs.appendChild(createNode('filter', {
                        id: R.createUUID(),
                        width: '200%',
                        height: '200%'
                    }));
                    color = R.color(color);
                    if (color.error) {
                        color = R.color(BLACK);
                    }
                    opacity = R.pick(color.opacity, 1);

                    // Create the filters that are required to give shadow
                    // effect on an element.
                    shadow = o._.shadowFilter = cache[hash] = {
                        use: 1,
                        filter: filter,
                        hash: hash,
                        offset: filter.appendChild(createNode('feOffset', {
                            result: 'offOut',
                            'in': 'SourceGraphic',
                            dx: toFloat(dx),
                            dy: toFloat(dy)
                        })),
                        matrix: filter.appendChild(createNode('feColorMatrix', {
                            result: 'matrixOut',
                            'in': 'offOut',
                            type: 'matrix',
                            // remove all colors and add specified color
                            // retain original alpha channel to avoid feOffset
                            // being overridden
                            values: '0 0 0 0 ' + color.r / 255 +
                                    ' 0 0 0 0 ' + color.g / 255 +
                                    ' 0 0 0 0 ' + color.b / 255 +
                                    ' 0 0 0 ' + opacity + ' 0'
                        })),
                        blur: filter.appendChild(createNode('feGaussianBlur', {
                            result: 'blurOut',
                            'in': 'matrixOut',
                            stdDeviation: mathSqrt(toFloat(spread))
                        })),
                        blend: filter.appendChild(createNode('feComposite', {
                            'in': 'SourceGraphic',
                            in2: 'blurOut',
                            operator: 'over'
                        }))
                    };

                    node.setAttribute('filter',
                        'url("' + R._url + '#' + filter.id + '")');
                }

                return this;
            };
        }

        supervisor = function (params, leader) {
            var o = this,
                scale = o.__shadowscale,
                del = {},
                matrix,
                key;

            for (key in params) {
                if (forbiddenAttrs[key]) {
                    del[key] = params[key];
                    delete params[key];
                }
                switch (key) {

                case 'transform':
                    matrix = leader.matrix.clone();
                    matrix.translate(o.__shadowx, o.__shadowy);
                    o.transform(matrix.toTransformString());
                    break;
                case STROKE_WIDTH:
                    params[key] = ((del[key] || 1) + 6 - 2 * o.__shadowlevel) * scale;
                    break;
                }
            }
            o.attr(params);
            for (key in del) {
                params[key] = del[key];
            }
        };

        R.ca[DROP_SHADOW] = function (offX, offY, spread, color, scale, group) {
            var o = this,
                shadows = o._.shadows || (o._.shadows = []),
                opacity,
                shadow,
                offset,
                matrix,
                tScale,
                strScale,
                i;

            if (o.__shadowblocked) {
                return false;
            }
            else if (offX === NONE) {
                while (shadow = shadows.pop()) {
                    shadow.remove();
                }
            }
            else {
                color = R.color(color);
                if (color.error) {
                    color = R.color(BLACK);
                }

                if (scale instanceof Array) {
                    tScale = scale[0];
                    strScale = scale[1];
                }
                else {
                    tScale = strScale = scale;
                }

                tScale = 1 / R.pick(tScale, 1);
                strScale = 1 / R.pick(strScale, 1);

                offX = R.pick(offX, 1) * tScale;
                offY = R.pick(offY, 1) * tScale;
                opacity = R.pick(color.opacity, 1) * 0.05;
                offset = toInt(o.attr(STROKE_WIDTH) || 1, 10) + 6;
                matrix = o.matrix.clone();
                matrix.translate(offX, offY);

                for (i = 1; i <= 3; i++) {
                    shadow = (shadows[i - 1] || o.clone()
                            .follow(o, supervisor, !group && 'before')).attr({
                        'stroke': color.hex,
                        'stroke-opacity': opacity * i,
                        'stroke-width':  (offset - 2 * i) * strScale,
                        'transform': matrix.toTransformString(),
                        'stroke-linecap': ROUND,
                        'stroke-linejoin': ROUND,
                        'fill': NONE
                    });

                    shadow.__shadowlevel = i;
                    shadow.__shadowscale = strScale;
                    shadow.__shadowx = offX;
                    shadow.__shadowy = offY;
                    group && group.appendChild(shadow);

                    shadows.push(shadow);
                }

            }

            return false;
        };


       /**
        * Add or remove a shadow composition to the element.
        *
        * @param {boolean} apply
        * @param {number} opacity
        */
        R.el.shadow = function (apply, opacity, scale, group) {

            var useFilter;

            // allow alternative polymorphism in last two parameters
            if (scale && scale.constructor === R.el.constructor) {
                group = scale;
                scale = undefined;
            }

            // In case the parameter is provided in object style then expand it
            if (typeof apply === 'object') {
                opacity && opacity.constructor === R.el.constructor && (group = opacity);
                opacity = apply.opacity;
                scale = apply.scalefactor;
                useFilter = !!apply.useFilter;
                apply = (apply.apply === undefined) ? !!opacity : apply.apply;
            }

            // In case opacity is undefined, set it to full.
            (opacity === undefined) && (opacity = 1);

            // Check if filter based shadow needs some modification or not.
            if (this.dropshadow) {
                if (useFilter) {
                    apply && this.dropshadow(1, 1, 3, 'rgb(64,64,64)') ||
                            this.dropshadow(NONE);
                    return this;
                }
                else if (this._.shadowFilter) {
                    this.dropshadow(NONE);
                }
            }

            return this.attr(DROP_SHADOW, apply ?
                    [1, 1, 3, 'rgba(64,64,64,' + (opacity) + ')', scale, group] : NONE);

        };

    }

    // For VML based browsers, there is a single implementation across IE 6-8.
    // As such, it requires only a single implementation.
    else if (R.vml) {

        R.ca['drop-shadow'] = function (offX, offY, spread, color, scale, group) {
            var o = this,
                shadow = o._.shadow,
                style,
                filter,
                tScale,
                opacity;

            // do not apply shadow on shadow!
            if (o.isShadow) {
                return false;
            }

            if (offX === NONE) {
                shadow && (shadow = o._.shadow = shadow.remove());
            }
            else {
                if (!shadow) {

                    shadow = o._.shadow = o.clone();
                    // while adding to separate shadow group, we cannot mark the
                    // shadow as stalker as that would break the shadow away from
                    // shadow group and insert it before the main element.
                    group &&
                        group.appendChild(shadow.follow(o)) ||
                        shadow.follow(o, undefined, 'before');

                    shadow.attr({
                        fill: 'none',
                        'fill-opacity': 0.5,
                        'stroke-opacity': 1
                    }).isShadow = true;

                    if (shadow.attr(STROKE_WIDTH) <= 0) {
                        shadow.attr(STROKE_WIDTH, 1);
                    }
                }

                style = shadow.node.runtimeStyle;
                filter = style.filter.replace(/ progid:\S+Blur\([^\)]+\)/g, EMP);

                color = R.color(color);
                if (color.error) {
                    color = R.color(BLACK);
                }
                opacity = R.pick(color.opacity, 1) / 5;

                if (scale instanceof Array) {
                    tScale = scale[0];
                }
                else {
                    tScale = scale;
                }

                tScale = 1 / R.pick(scale, 1);

                offX = R.pick(offX, 1) * tScale;
                offY = R.pick(offY, 1) * tScale;

                shadow.translate(offX, offY);
                style.filter = filter +
                    ' progid:DXImageTransform.Microsoft.Blur(pixelRadius=' +
                    toFloat(spread * 0.4) + ' makeShadow=True Color=' +
                    color.hex + ' shadowOpacity="' + opacity + '");';
            }

            return false;
        };

        /**
         * Add or remove a shadow composition to the element.
         *
         * @param {boolean} apply
         * @param {number} opacity
         */
        R.el.shadow = function (apply, opacity, scale, group) {
            var o = this;

            // allow alternative polymorphism in last two parameters
            if (scale && scale.constructor === R.el.constructor) {
                group = scale;
                scale = undefined;
            }

            // In case the parameter is provided in object style then expand it
            if (typeof apply === 'object') {
                opacity && opacity.type === 'group' && (group = opacity);
                opacity = apply.opacity;
                scale = apply.scalefactor;
                apply = apply.apply === undefined ? !!opacity : apply.apply;
            }

            // In case opacity is undefined, set it to full.
            (opacity === undefined) && (opacity = 1);

            return o.attr(DROP_SHADOW, apply || !opacity ?
                [1, 1, 5, 'rgba(64,64,64,' + (opacity) + ')', scale, group] : NONE);

        };
    }
    else if (R.canvas) {
        R.el.shadow = function () {
            return this;
        };
    }
}]);
/**
 * Red Raphael JavaScript Library
 * ------------------------------
 * Extension for support of easy drawing of polygons using raphael
 * @private
 *
 * @module fusioncharts.redraphael.shapes
 * @requires fusioncharts.redraphael
 */
FusionCharts.register('module', ['private', 'modules.renderer.js-raphaelshapes', function () {
    var global = this,
        win = global.window,
        userAgent = win.navigator.userAgent,

        hasTouch = 'createTouch' in win.document,
        isIE = /msie/i.test(userAgent) && !win.opera,

        math = win.Math,
        mathCos = math.cos,
        mathSin = math.sin,
        mathAbs = math.abs,
        mathPow = math.pow,
        mathAtan2 = math.atan2,
        mathTan = math.tan,
        mathAcos = math.acos,
        mathMin = math.min,
        mathRound = math.round,
        mathPI = math.PI,
        mathSqrt = math.sqrt,
        twoPI = 2 * mathPI,
        toInt = win.parseInt,
        toFloat = win.parseFloat,
        toStr = String,
        arraySlice = Array.prototype.slice,

        HAS = 'hasOwnProperty',
        ARRAY = 'array',
        OBJECT = 'object',
        BLANK = '',
        COMMA = ',',
        SPACE = ' ',
        NONE = 'none',
        CRISP = 'crisp',
        FILL = 'fill',
        WIDTH = 'width',
        HEIGHT = 'height',
        M = 'M',
        L = 'L',
        A = 'A',
        Z = 'Z',
        Q = 'Q',
        STROKE = 'stroke',
        PATH = 'path',
        POLYPATH = 'polypath',
        RINGPATH = 'ringpath',
        CUBEPATH = 'cubepath',
        TEXTBOUND = 'text-bound',

        FLAT = 'flat',
        TRANSPARENT = 'transparent',
        HORIZONTAL = 'horizontal',
        VERTICAL = 'vertical',
        SCROLL_RATIO = 'scroll-ratio',
        SCROLL_POSITION = 'scroll-position',
        SCROLL_ORIENTATION = 'scroll-orientation',
        SCROLL_REPAINT = 'scroll-repaint',
        SCROLL_DISPLAY_STYLE = 'scroll-display-style',
        SCROLL_DISPLAY_BUTTONS = 'scroll-display-buttons',

        EVE_SCROLLSTART = 'raphael.scroll.start.',
        EVE_SCROLLCHANGE = 'raphael.scroll.change.',
        EVE_SCROLLEND = 'raphael.scroll.end.',

        EPSILON = mathPow(2, -24),
        minRenderingDistance = 0.01, //Minimum distance between two pixel to render them.
        TRACKER_FILL = 'rgba(192,192,192,'+ (isIE ? 0.002 : 0.000001) +')', // invisible but clickable

        lib = global.hcLib,
        R = lib.Raphael,
        eve = R.eve,

        createNode = R._createNode,
        setFillAndStroke = R._setFillAndStroke,
        Element = R.el.constructor,

        shapeRenderingAttrs = {
            speed: 'optimizeSpeed',
            crisp: 'crispEdges',
            precision: 'geometricPrecision'
        },
        // Enum of attributes that are valid for button-active property
        buttonDisabledAttrs = {
            'enabled': false,
            'false': false,
            '0': false,
            'disabled': true,
            'true': true,
            '1': true
        },
        // High performance path rendering extension for Red Raphael.
        LITEPATH = 'litepath',
        CSSFLOOD = 'position:absolute;left:0;top:0;width:21600px;height:21600px;',
        COORD21600 = '21600 21600',

        s2vcmd = {
            'Q': 'L',
            'Z': 'X',
            'q': 'l',
            'z': 'x',
            ',': ' '
        },
        p2s = /,?([achlmqrstvxz]),?/gi,
        commaseparator = /\s*\,\s*/g,
        p2srep,
        path2string = function() {
            return this.join(COMMA).replace(p2s, p2srep);
        },

        litepathsetter,
        vmlTransformHelper,

        p2pdistance = R._cacher(function (x1, y1, x2, y2) {
            // Returns distance between two points
            return mathSqrt(mathPow(x2 - x1, 2) + mathPow(y2 - y1, 2));
        }),

        pointAtLength = R._cacher(function (x1, y1, x2, y2, d) {
            /* Returns the coordinates of the point at distance 'd' from point (x1, y1)
             * on the line between point (x1, y1) and point (x2, y2).
             */

            // Calculate vectors along path
            var vx = x2 - x1,
                vy = y2 - y1,
                l, px, py;

            // Calculate total length of the path
            l = p2pdistance(x1, y1, x2, y2);

            // Normalize the vectors
            vx /= l;
            vy /= l;

            // Calculate required point coordinates
            px = x1 + vx * d;
            py = y1 + vy * d;

            return {
                x: px,
                y: py
            };
        });

    // Shape rendering attribute support
    if (R.svg) {
        eve.on('raphael.attr.shape-rendering', function (value, key) {
            var o = this,
                node = o.node;
            o.attrs[key] = value = shapeRenderingAttrs[value] || value || 'auto';
            node.setAttribute(key, value);
            node.style.shapeRendering = value;
        });
    }
    else if (R.vml) {
        eve.on('raphael.attr.shape-rendering', function (val) {
            this.node.style.antialias = (val !== 'crisp');
        });
    }

    R.define && R.define([{
        name: 'polypath',

        // args: sides, cx, cy, r, angle, dip, group
        polypath: function () {
            return this.path(undefined, R._lastArgIfGroup(arguments));
        },

        ca: {
            polypath: function (sides, cx, cy, r, startAngle, dip) {
                var path,
                    inangle,
                    i,
                    angle,
                    h;

                path = [];
                sides = toInt(sides, 10) || 0;
                cx = toFloat(cx) || 0;
                cy = toFloat(cy) || 0;
                r = toFloat(r) || 0;
                startAngle = (startAngle === null || isNaN(startAngle)) ?
                    mathPI * 0.5 : R.rad(startAngle);
                dip = (dip === null || isNaN(dip)) ? 0 : toFloat(dip);
                angle = startAngle;

                if (sides > 2) {
                    inangle = 2 * mathPI / sides;

                    switch(dip) {
                    // polygon
                    case 0:
                        for (i = 0; i < sides; i++) {
                            path.push(L,
                                        cx + r * mathCos(-angle),
                                        cy + r * mathSin(-angle)
                                      );
                            angle += inangle;
                        }
                         // we need to replace the first command to move. it was not
                         // done earlier and is done now to ease out the algorithm.
                        path[0] = M;
                        // close path at end
                        path.push(Z);
                        break;

                    // spoke
                    case 1:
                        for (i = 0; i < sides; i++) {
                            path.push(M, cx, cy,
                                      L,
                                        cx + r * mathCos(-angle),
                                        cy + r * mathSin(-angle)
                                      );
                            angle += inangle;
                        }
                        break;

                    // star
                    default:
                        inangle *= 0.5;
                        // R cos(alpha) here is the radial distance of midpoint of two
                        // consecutive vertices.
                        h = r * mathCos(inangle) * (1 - dip);

                        for (i = 0; i < sides; i++) {
                            path.push(L,
                                        cx + r * mathCos(-angle),
                                        cy + r * mathSin(-angle)
                                      );
                            angle += inangle;

                            path.push(L,
                                        cx + h * mathCos(-angle),
                                        cy + h * mathSin(-angle)
                                      );
                            angle += inangle;
                        }
                         // we need to replace the first command to move. it was not
                         // done earlier and is done now to ease out the algorithm.
                        path[0] = M;
                        // close path at end
                        path.push(Z);
                        break;
                    }
                }
                // If 'sides' is less than three then draw a circle.
                else {
                    // In case r is zero, we need to avoid creating arcs so that VML
                    // does not get broken due to zero-radius arcs.
                    if (r === 0) {
                        path.push(M, cx, cy,
                                  L, cx, cy,
                                  Z);
                    }
                    else {
                        path.push(M, cx - r, cy,
                                  A, r, r, 0, 0, 0, cx + r, cy,
                                  A, r, r, 0, 0, 0, cx - r, cy,
                                  Z);
                    }
                }

                return {
                    path: path
                };
            },

            r: function (value) {
                var o = this,
                    attr = o.attrs.polypath;

                // if attr was previously defined then update the radius
                attr[3] = value;
                o.attr(POLYPATH, attr);

                return false;

            }
        }
    }, {
        name: RINGPATH,
        // args: x, y, r1, r2, start, end, group
        ringpath: function () {
            return this.path(undefined, R._lastArgIfGroup(arguments));
        },

        ca: function (x, y, r1, r2, start, end) {
            var o = this,
                // The angles are normalized to be in the range of - twoPI to +twoPI.
                delta = (end % twoPI) - (start % twoPI),
                deltaOrig = end - start,
                cosStart,
                sinStart,
                cosEnd,
                sinEnd,
                longshort,
                path,
                x1,
                x2,
                x3,
                x4,
                y1,
                y2,
                y3,
                y4;

            // Save the angle in private for use.
            o._.ringangle = (start + end) * 0.5;

            // For deltaOrig very close to zero, thin line drawing is required.
            if (mathAbs(deltaOrig) < EPSILON) {
                cosStart = mathCos(start);
                sinStart = mathSin(start);

                path = [
                    M, x + r1 * cosStart, y + r1 * sinStart,
                    L, x + r2 * cosStart, y + r2 * sinStart,
                    Z
                ];
            }
            // If delta is very close to multiples of PI, requiring full
            // circle drawing.
            // When angle is twoPI split arcs are drawn to combat the full arc
            // drawing issue.
            else if (mathAbs(deltaOrig) > EPSILON && mathAbs(deltaOrig) % twoPI < EPSILON) {
                path = [
                    M, x - r1, y,
                    A, r1, r1, 0, 0, 0, x + r1, y,
                    A, r1, r1, 0, 0, 0, x - r1, y
                ];
                // draw inner arc only if specified. this helps draw only a circle
                // when inner radius is zero.
                if (r2 !== 0) {
                    path = path.concat([
                        M, x - r2, y,
                        A, r2, r2, 0, 0, 1, x + r2, y,
                        A, r2, r2, 0, 0, 1, x - r2, y
                    ]);
                }
                path.push(Z);
            }
            else {
                cosStart = mathCos(start);
                sinStart = mathSin(start);
                cosEnd = mathCos(end);
                sinEnd = mathSin(end);

                delta = delta % twoPI;

                // Negative resolved value of delta indicate it to be between - twoPI
                // and zero. The value is further normalised to be in the range of zero
                // to twoPI.
                if (delta < 0) {
                    delta += twoPI;
                }

                longshort = delta < mathPI ? 0 : 1;

                x1 = x + r1 * cosStart;
                y1 = y + r1 * sinStart;
                x2 = x + r1 * cosEnd;
                y2 = y + r1 * sinEnd;
                x3 = x + r2 * cosEnd;
                y3 = y + r2 * sinEnd;

                if (mathAbs(x1 - x2) < minRenderingDistance && mathAbs(y1 - y2) < minRenderingDistance) {
                    y1 = y2 + minRenderingDistance;
                }

                path = [
                    M, x1, y1, A, r1,  r1, 0, longshort, 1, x2, y2, L, x3, y3
                ];
                // Draw inner arc only when inner radius is not zero. This is needed
                // to avoid zero arc related issue on Raphael's VML.
                if (r2 !== 0) {
                    x4 = x + r2 * cosStart;
                    y4 = y + r2 * sinStart;
                    if (mathAbs(x3 - x4) < minRenderingDistance && mathAbs(y3 - y4) < minRenderingDistance) {
                        y4 = y3 + minRenderingDistance;
                    }
                    path.push(A, r2, r2, 0, longshort, 0, x4, y4);
                }
                path.push(Z);
            }

            return {
                path: path
            };
        }
    }, {
        name: 'cubepath',
        // args: [x, y, w, h, zw, zh]
        cubepath: function () {
            var paper = this,
                shapeDefaultAttrs = {
                    'stroke-linejoin': 'round',
                    'shape-rendering': 'precision',
                    'stroke': NONE
                },
                args = arguments,
                lastArg = args.length - 1,
                group = args[lastArg],
                top,
                side,
                a,
                face;

            group && (group.constructor === R.el.constructor) ?
                (args[lastArg] = undefined) : (group = undefined);

            top = paper.path(shapeDefaultAttrs, group);
            side = paper.path(shapeDefaultAttrs, group);
            face = paper.path(shapeDefaultAttrs, group);

            face._.cubetop = top.follow(face, undefined, 'before');
            face._.cubeside = side.follow(face, undefined, 'before');

            for (a in R.fn.cubepath.ca) {
                face.ca[a] = R.fn.cubepath.ca[a];
            }

            return face.attr(CUBEPATH, [args[0], args[1], args[2], args[3], args[4], args[5]]);
        },
        fn: {
            // Return the bounding box of the back face of the 3D shape.
            // This is an internal function, which is not implemented to the complete level, as such
            // there is no proper definition the function is supposed to do, hence it is prefixed with
            // an '_' and named as _getBBox2
            _getBBox2: function () {
                var shape = this,
                    sideBox = shape._.cubeside.getBBox(),
                    topBox = shape._.cubetop.getBBox(),
                    bbox = shape.getBBox();

                //Calculate the backface bbox like object consisting of x,y width, height
                //using the sideBox,topBox,bBox
                return {
                    x: bbox.x + topBox.height,
                    y: bbox.y - sideBox.width,
                    width: bbox.width,
                    height: bbox.height
                };
            }
        },
        ca: {
            cubepath: function (x, y, w, h, zw, zh) {
                var o = this,
                    t = o._.cubetop,
                    s = o._.cubeside;

                x = x || 0;
                y = y || 0;
                w = w || 0;
                h = h || 0;
                zw = zw || 0;
                zh = zh || 0;

                /* The issue of pixel wide gap found between adjacent faces when input params
                 * are not all intezers, is solved by adding extra portion in top and side faces.
                 * The side face is extended to the left with a pixel wide rectange, whole top
                 * end is cut diagonally to avoid overlapping stoke effect. Like wise, the top face
                 * is extended below with a pixel height rectangle whose left end is cut diagonally for
                 * the same rason as above. Motive was to keep the bounding box intact as intended.
                 */
                o.attr(PATH, ['M', x + w, y, 'l', 0, h, -w, 0, 0, -h, 'z']);
                t.attr(PATH, ['M', x, y, 'l', 1, 1, w - 1, 0, 0, -1, zw, -zh, -w, 0, 'z']);
                s.attr(PATH, ['M', x + w -1, y + 1, 'l', 0, h - 1, 1, 0, zw, -zh, 0, -h, -zw, zh]);

                return false;
            },

            'stroke-linejoin': function () {
                // We force the linejoin to always be round. Otherwise, the cube
                // edges will look horrible.
                return {
                    'stroke-linejoin': 'round'
                };
            },

            'drop-shadow': function (dx, dy, spread, color) {
                var o = this,
                    top  = o._.cubetop,
                    side = o._.cubeside;

                // Only allow filter based shadow.
                if (o.dropshadow) {
                    top.dropshadow(dx, -dy, spread, color);
                    side.dropshadow(dx, -dy, spread, color);
                }

                return false;
            },

            'fill': function (color, nogradient) {
                var o = this,
                    top  = o._.cubetop,
                    side = o._.cubeside,
                    attr = o.attr(CUBEPATH) || [0, 0, 0, 0, 0, 0],
                    width = attr[2],
                    zw = attr[4],
                    zh = attr[5],
                    rgba;

                color = R.color(color);

                if (nogradient) {
                    o.attr(FILL, color);
                    top.attr(FILL, R.tintshade(color, -0.78).rgba);
                    side.attr(FILL, R.tintshade(color, -0.65).rgba);
                }
                else {
                    // Since the color has been already calculated in object form,
                    // we manually recalculate the rgba here since re-sending object
                    // to Raphael's tintshade can cause it to return stale result
                    // from its cache.
                    rgba = ('opacity' in color) ?
                        ('rgba(' + [color.r, color.g, color.b, color.opacity] + ')') :
                        ('rgb(' +[color.r, color.g, color.b] + ')');

                    o.attr(FILL, [270, R.tintshade(rgba, 0.55).rgba,
                        R.tintshade(rgba, -0.65).rgba].join('-'));
                    side.attr(FILL, [270,
                        R.tintshade(rgba, -0.75).rgba,
                        R.tintshade(rgba, -0.35).rgba].join('-'));
                    top.attr(FILL, [45 + R.deg(mathAtan2(zh, zw + width)),
                        R.tintshade(rgba, -0.78).rgba,
                        R.tintshade(rgba, 0.22).rgba].join('-'));
                    /**
                     * @note
                    // This is the gradient calculation mapping that accounts for
                    // the skew of the top face.
                    o.attr(FILL, [285, R.tintshade(rgba, .55).rgba,
                        R.tintshade(rgba, -.65).rgba].join('-'));
                    side.attr(FILL, [50 + R.deg(mathAtan2(height + zh, zw)),
                        R.tintshade(rgba, -.45).rgba,
                        R.tintshade(rgba, -.75).rgba].join('-'));
                    top.attr(FILL, [R.deg(mathAtan2(zh, zw + width)),
                        R.tintshade(rgba, -.85).rgba,
                        R.tintshade(rgba, .35).rgba].join('-'));
                    */
                }

                // We return false so that the attribute is not applied to the
                // composite shape's leading element (the front face.)
                return false;
            }
        }
    }, {
        name: 'scroller',
        /*
         * Generate a composite collection of object to provide scrollbar
         * functionality on SVG.
         *
         * ~param {number} x
         * ~param {number} y
         * ~param {number} w
         * ~param {number} h
         * ~param {boolean} horiz
         * ~param {object} options
         * - showButtons:boolean
         * - displayStyleFlat:boolean
         * - scrollRatio:number
         * - scrollPosition:number
         * ~param {RaphaelElement} parent
         */
        scroller: function (x, y, w, h, horiz, options, parent) {
            var paper = this,
                o = paper.group('scroller', parent),
                attrs = o.attrs,
                scroller = o._.scroller = {},
                orientation = horiz && HORIZONTAL || VERTICAL,
                _trackAnim,
                _anchorAnimAttr = {},
                _dragstart,
                _dragaxis,
                a;

            // Create the scroller track and setup click behavior on track region.
            scroller.track = paper.rect(o).mousedown(function (evt) {
                var orientation = attrs[SCROLL_ORIENTATION],
                    pos = attrs[SCROLL_POSITION],
                    dx;

                dx = (orientation === HORIZONTAL) ? (evt.layerX || evt.x) : (evt.layerY || evt.y);
                dx = (dx - scroller.anchorOffset) / scroller.trackLength;

                _trackAnim = R.animation({
                    'scroll-position': dx
                }, 2000 * mathAbs(pos - dx), 'easeIn');
                o.animate(_trackAnim);

                eve(EVE_SCROLLSTART + o.id, o, pos);
            }).mouseup(scroller._mouseupTrack = function () {
                this.stop(_trackAnim);
                eve(EVE_SCROLLEND + this.id, this, attrs[SCROLL_POSITION]);
            }, o, true);

            // Create the track and anchor elements as the will always be needed!
            // Setup drag behavior of the anchor.
            scroller.anchor = paper.rect(o).drag(function () {
                _anchorAnimAttr[SCROLL_POSITION] = _dragstart +
                    arguments[_dragaxis] / scroller.trackLength;
                o.animate(_anchorAnimAttr, 0);
            }, function (_x, _y, event) {
                _dragaxis = (attrs[SCROLL_ORIENTATION] === HORIZONTAL) ? 0 : 1;
                eve(EVE_SCROLLSTART + o.id, o,
                    _dragstart = attrs[SCROLL_POSITION]);
                event.stopPropagation();
            }, function () {
                eve(EVE_SCROLLEND + o.id, o,
                    _dragstart = attrs[SCROLL_POSITION]);
            });

            // Add the custom functions.
            for (a in R.fn.scroller.fn) {
                o[a] = R.fn.scroller.fn[a];
            }
            // Add the custom attributes.
            for (a in R.fn.scroller.ca) {
                o.ca[a] = R.fn.scroller.ca[a];
            }

            // Set initial attributes to cover dependency of scroll-orientation.
            attrs[SCROLL_ORIENTATION] = orientation;
            attrs['stroke-width'] = 1;
            o.ca[SCROLL_REPAINT] = o.ca['scroll-repaint-' + orientation];

            !R.is(options, OBJECT) && (options = {});
            return o.attr({
                ishot: true,
                'scroll-display-buttons': options.showButtons && 'arrow' || NONE,
                'scroll-display-style': options.displayStyleFlat && FLAT || '3d',
                'scroll-ratio': toFloat(options.scrollRatio) || 1,
                'scroll-position': toFloat(options.scrollPosition) || 0,
                'scroll-repaint': [x, y, w, h]
            });
        },

        fn: {
            scroll: function (callback, scope) {
                var o = this,
                    scroller = o._.scroller;
                scope = scope || o;
                scroller.callback = function () {
                    return callback.apply(scope, arguments);
                };
                return o;
            },

            remove: function () {
                var o = this,
                    scroller = o._.scroller,
                    key;

                o.attr('scroll-display-buttons', NONE);
                scroller.track.unmouseup(scroller._mouseupTrack);
                for (key in scroller) {
                    scroller[key] && scroller[key].remove && scroller[key].remove();
                    scroller[key] = null;
                }

                delete o._.scroller;
                R.el.remove.apply(o, arguments);
            }
        },

        ca: {
            'stroke-width': function () {
                return false;
            },

            'drop-shadow': function (ox, oy, spread, color, s, g) {
                this._.scroller.track.attr('drop-shadow', [ox, oy, spread, color, s, g]);
                return false;
            },

            'scroll-display-style': function (value) {
                var o = this,
                    attrs = o.attrs,
                    currentStyle = attrs[SCROLL_DISPLAY_STYLE],
                    fill = attrs.fill;

                value = {
                    flat: FLAT,
                    '3d': '3d',
                    transparent: TRANSPARENT
                }[value] || currentStyle;

                // In case of change in value, and if already filled, re-fill.
                if (fill && value !== currentStyle) {
                    attrs[SCROLL_DISPLAY_STYLE] = value;
                    o.attr(FILL, fill);
                }

                return {
                    'scroll-display-style': value
                };
            },

            'scroll-display-buttons': function (value) {
                var o = this,
                    paper = o.paper,
                    scroller = o._.scroller,
                    attrs = o.attrs,
                    currentDisplayButtons = attrs[SCROLL_DISPLAY_BUTTONS],
                    repaint = attrs[SCROLL_REPAINT],
                    _anim0, _anim1;

                // For first-run, attrs will have undefined. Hence, set it to none. This will ensure that the toggling
                // logic will work from the start.
                (currentDisplayButtons === undefined) && (currentDisplayButtons = NONE);

                // Validate the input.
                value = {
                        none: NONE,
                        arrow: 'arrow'
                    }[value] || currentDisplayButtons;

                // This is a simple job! If button is needed, draw the elements and
                // if not then remove them. We first check change in this attr's
                // value. That saves us needless check whether the elements to be
                // removed exists or not.
                if (value !== currentDisplayButtons) {
                    attrs[SCROLL_DISPLAY_BUTTONS] = value; // set for repaint
                    if (value === NONE && scroller.start) {
                        scroller.arrowstart.remove();
                        delete scroller.arrowstart;

                        scroller.arrowend.remove();
                        delete scroller.arrowend;

                        scroller.start.unmouseup(scroller._mouseupStart);
                        scroller.start.remove();
                        delete scroller.start;

                        scroller.end.unmouseup(scroller._mouseupEnd);
                        scroller.end.remove();
                        delete scroller.end;
                    }
                    else {
                        /** @todo make scroll button anim duration based on width
                           or height */
                        scroller.arrowstart = paper.polypath(o);
                        scroller.arrowend = paper.polypath(o);

                        // For scroller animation on button click, we run two sets.
                        // The first animation ensures that the anchor moves 20% for
                        // interaction for botton-less touchpads.
                        // and then the second set of animation becomes cancelable
                        // by mouse up.
                        scroller.start = paper.rect(o).mousedown(function () {
                            var pos;
                            if ((pos = attrs[SCROLL_POSITION]) === 0) {
                                return;
                            }

                            o.animate({
                                'scroll-position': pos - 0.1
                            }, 100).animate((_anim0 = R.animation({
                                'scroll-position': 0
                            }, 4500 * pos, 'easeIn')));
                            eve(EVE_SCROLLSTART + o.id, o,pos);
                        }).mouseup(scroller._mouseupStart = function (){
                            o.stop(_anim0);
                            eve(EVE_SCROLLEND + o.id, o,
                                attrs[SCROLL_POSITION]);
                        }, o, true);
                        scroller.end = paper.rect(o).mousedown(function () {
                            var pos;
                            if ((pos = attrs[SCROLL_POSITION]) === 1) {
                                return;
                            }

                            o.animate({
                                'scroll-position': pos + 0.1
                            }, 100).animate((_anim1 = R.animation({
                                'scroll-position': 1
                            }, 4500 * (1 - pos), 'easeIn')));
                            eve(EVE_SCROLLSTART + o.id, o, pos);
                        }).mouseup(scroller._mouseupEnd = function (){
                            o.stop(_anim1);
                            eve(EVE_SCROLLEND + o.id, o,
                                attrs[SCROLL_POSITION]);
                        }, o, true);
                        // if the scroller has been filled before, we need to
                        // re-fill it! Else the new elements will look odd
                        if (attrs.fill) {
                            o.attr(FILL, attrs.fill);
                        }
                    }

                    // Repaint on change of buttons
                    if (repaint) {
                        o.attr(SCROLL_REPAINT, repaint);
                    }
                }

                return {
                    'scroll-display-buttons': value
                };
            },

            'scroll-orientation': function (value) {
                var o = this,
                    attrs = o.attrs,
                    repaint = attrs[SCROLL_REPAINT],
                    currentOrientation = attrs[SCROLL_ORIENTATION];

                value = {
                    horizontal: HORIZONTAL,
                    vertical: VERTICAL
                }[value] || currentOrientation;

                // Register change in orientation and redraw.
                if (currentOrientation !== value) {
                    o.ca[SCROLL_REPAINT] = o.ca['scroll-repaint-' + value];
                    if (repaint) {
                        repaint[2] = repaint[2] + repaint[3];
                        repaint[3] = repaint[2] - repaint[3];
                        repaint[2] = repaint[2] - repaint[3];
                        o.attr(SCROLL_REPAINT, repaint);
                    }
                    // if the scroller has been filled before, we need to
                    // re-fill it! Else the new elements will look odd
                    if (attrs.fill) {
                        o.attr(FILL, attrs.fill);
                    }
                }

                return {
                    'scroll-orientation': value
                };
            },

            'scroll-ratio': function (value) {
                var o = this,
                    attrs = o.attrs,
                    currentRatio = attrs[SCROLL_RATIO],
                    repaint = attrs[SCROLL_REPAINT];

                // We validate the scroll-position value. Restricting it strictly
                // between 0 and 1. But not exactly 0 as that would mean zero
                // dimension anchor!
                /** @todo replace the static 0.01 min ratio with a dynamic one. */
                value = value > 1 ? 1 : (value < 0.01 ? 0.01 : toFloat(value));

                // On change of ratio on a painted scroller, we need to resize
                // and reposition the anchor. Thankfully, the calculation of the
                // new anchor dimension is fairly simple when we take the scroller's
                // total dimension as reference.
                if (repaint && value !== currentRatio) {
                    attrs[SCROLL_RATIO] = value;
                    // Note that the anchor is padded by half a pixel, as such,
                    // the calculation is done accordingly.
                    /** @todo
                     * store butt
                     */
                    //anchor.attr(wOrh, value * (anchorWidth + 1) / currentRatio - 1);
                    // since position percentage remains same, we need to set the
                    // 'force' flag of positioning to true.
                    o.attr(SCROLL_REPAINT, repaint);
                }

                return {
                    'scroll-ratio': value
                };
            },

            'scroll-position': function (value, _force) {
                var o = this,
                    attrs = o.attrs,
                    horiz = (attrs[SCROLL_ORIENTATION] === HORIZONTAL),
                    repaint = attrs[SCROLL_REPAINT],
                    currentPosition = attrs[SCROLL_POSITION],
                    scroller =  o._.scroller,
                    anchor = scroller.anchor,
                    button;

                // Positionhas to be validated between 0 and 1, else anchor will
                // spill out of area!
                value = value > 1 ? 1 : (value < 0 ? 0 : toFloat(value));
                isNaN(value) && (value = currentPosition);

                // On change of value, we recalculate the anchor dimension (width or
                // height based on directionality) from the painted originals.
                // Buttons' presence has to be accounted for.
                // We can avoid complicated ratio calculation by retrieving the
                // already calculated result from the anchor dimension.
                if (repaint && (currentPosition !== value || _force)) {
                    button = scroller.start &&
                        scroller.start.attr(horiz && WIDTH || HEIGHT) || 0;
                    horiz &&
                        anchor.attr('x', repaint[0] + button +
                            (repaint[2] - 2 * button - anchor.attr(WIDTH)) * value + 0.5) ||
                        anchor.attr('y', repaint[1] + button +
                            (repaint[3] - 2 * button - anchor.attr(HEIGHT)) * value + 0.5);

                    // Raise event and execute callback on position change.
                    if (!_force && attrs[SCROLL_RATIO] < 1) {
                        eve(EVE_SCROLLCHANGE + o.id, o, value);
                        scroller.callback && scroller.callback(value);
                    }
                }

                return {
                    'scroll-position': value
                };
            },

            r: function (value) {
                var o = this,
                    scroller = o._.scroller;

                scroller.track.attr('r', value);
                scroller.anchor.attr('r', (o.attrs[SCROLL_DISPLAY_BUTTONS] === NONE) &&
                        value || 0);

                return false;
            },

            'scroll-repaint-horizontal': function (x, y, w, h) {
                var o = this,
                    attrs = o.attrs,
                    scroller = o._.scroller,
                    ratio = attrs[SCROLL_RATIO],
                    position = attrs[SCROLL_POSITION],
                    button = 0,
                    track = w * ratio,
                    nobutton = attrs[SCROLL_DISPLAY_BUTTONS] === NONE;

                w && (w -= 1);
                x && (x += 0.5);
                h && (h -= 1);
                y && (y += 0.5);

                // The track forms the base of the scroller and as such, occupies
                // entire space.
                scroller.track.attr({
                    width: w,
                    height: h,
                    y: y,
                    x: x
                }).crisp();

                // Draw buttons if needed and also perform calculations that the
                // presence of button will affect anchor.
                if (!nobutton) {
                    button = mathMin(h, w * 0.5);
                    track -= button * 2 * ratio;

                    scroller.start.attr({
                        width: button,
                        height: h,
                        x: x,
                        y: y
                    });
                    scroller.arrowstart.attr(POLYPATH,
                        [3, x + button * 0.5, y + h * 0.5, button * 0.25, 180]);
                    scroller.end.attr({
                        width: button,
                        height: h,
                        x: x + w - button,
                        y: y
                    });
                    scroller.arrowend.attr(POLYPATH,
                        [3, x + w - button * 0.5, y + button * 0.5, button * 0.25, 0]);
                }

                // The anchor position is calculated in full (ratio included).
                // This saves needless function/attr call.
                scroller.trackLength = w - 2 * button - track;
                scroller.trackOffset = x + button + 0.5;
                scroller.anchorOffset = scroller.trackOffset + (track - 1) * 0.5;
                scroller.anchor.attr({
                    height: h,
                    width: track - 1,
                    y: y,
                    x: scroller.trackOffset + scroller.trackLength * position
                }).crisp();
            },

            'scroll-repaint-vertical': function (x, y, w, h) {
                var o = this,
                    attrs = o.attrs,
                    scroller = o._.scroller,
                    ratio = attrs[SCROLL_RATIO],
                    position = attrs[SCROLL_POSITION],
                    button = 0,
                    track = h * ratio,
                    nobutton = attrs[SCROLL_DISPLAY_BUTTONS] === NONE;

                w && (w -= 1);
                x && (x += 0.5);
                h && (h -= 1);
                y && (y += 0.5);

                // The track forms the base of the scroller and as such, occupies
                // entire space.
                scroller.track.attr({
                    width: w,
                    height: h,
                    y: y,
                    x: x
                }).crisp();

                // Draw buttons if needed and also perform calculations that the
                // presence of button will affect anchor.
                if (!nobutton) {
                    button = mathMin(w, h * 0.5);
                    track -= button * 2 * ratio;
                    scroller.start.attr({
                        width: w,
                        height: button,
                        x: x,
                        y: y
                    });
                    scroller.arrowstart.attr(POLYPATH,
                        [3, x + w * 0.5, y + button * 0.5, button * 0.25, 90]);
                    scroller.end.attr({
                        width: w,
                        height: button,
                        x: x,
                        y: y + h - button
                    });
                    scroller.arrowend.attr(POLYPATH,
                        [3, x + w * 0.5, y + h - button * 0.5, button * 0.25, -90]);
                }

                // The anchor position is calculated in full (ratio included).
                // This saves needless function/attr call.
                scroller.trackLength = h - 2 * button - track;
                scroller.trackOffset = y + button + 0.5;
                scroller.anchorOffset = scroller.trackOffset + (track - 1) * 0.5;
                scroller.anchor.attr({
                    height: track - 1,
                    width: w,
                    y: scroller.trackOffset + scroller.trackLength * position,
                    x: x
                }).crisp();
            },

            fill: function (color) {
                var o = this,
                    attrs = o.attrs,
                    scroller = o._.scroller,
                    repaint = attrs[SCROLL_REPAINT],
                    flat = (attrs[SCROLL_DISPLAY_STYLE] === FLAT),
                    horiz = (attrs[SCROLL_ORIENTATION] === HORIZONTAL),
                    setter = { // will use single obj as setter (save mem)
                        stroke: NONE
                    },
                    strokeCompensation;

                // For touch devices, we increase accessibility by adding an
                // increased area of transparent stroke
                if (hasTouch && repaint &&
                        (strokeCompensation = 16 - repaint[horiz && 3 || 2]) > 3) {
                    setter.stroke = TRACKER_FILL;
                    setter['stroke-width'] = strokeCompensation;
                }

                // Parse color. Pass it via tintshade to get standard rgba text
                color = R.color(color);
                color.error && (color = '#000000');
                color = ('opacity' in color) ?
                        ('rgba(' + [color.r, color.g, color.b, color.opacity] + ')') :
                        ('rgb(' +[color.r, color.g, color.b] + ')');

                // Individually calculate the fill gradients of various elements
                // using tint/shade of the base color and set it on the scroller
                // elements.
                // Note that we multiply gradient angle with boolean. Neat trick to
                // set them zero when boolean is false.
                setter.fill = flat && color || [90 * horiz,
                    R.tintshade(color, 0.15).rgba, color].join('-');
                setter.stroke = R.tintshade(color, -0.75).rgba;
                scroller.track.attr(setter);

                setter.fill = flat && R.tintshade(color, -0.6).rgba || [270 * horiz,
                    R.tintshade(color, 0.3).rgba + ':40',
                    R.tintshade(color, -0.7).rgba].join('-');
                setter.stroke = R.tintshade(color, -0.6).rgba;
                scroller.anchor.attr(setter);
                // reset stroke
                setter.stroke = NONE;

                // Now, if buttons are available, we fill the tracker and the
                // arrows.
                if (attrs[SCROLL_DISPLAY_BUTTONS] !== NONE) {
                    setter.fill = TRACKER_FILL;
                    scroller.start.attr(setter);
                    scroller.end.attr(setter);

                    setter.fill = R.tintshade(color, -0.4).rgba;
                    scroller.arrowstart.attr(setter);
                    scroller.arrowend.attr(setter);
                }

                // return false to prevent default.
                return false;
            }
        }
    }, {
        name: 'button',

        /*
         * Renders a Raphael composite button element.
         *
         * ~param {number} x
         * ~param {number} y
         * ~param {string} labelText
         * ~param {string} symbolName
         * ~param {object} options
         * Supports the following option attributes during construction
         * - symbolPadding
         * - horizontalPadding
         * - verticalPadding
         * - width
         * - height
         * - r
         * - symbolPosition,
         * - symbolPadding
         * - disabled
         * ~param {RaphaelElement} parent
         */
        button: function (x, y, labelText, symbolName, options, parent) {
            var paper = this,
                o = paper.group('button', parent),
                a;

            o._.button = {
                bound: paper.rect(o),
                tracker: paper.rect(o).attr({
                    fill: TRACKER_FILL,
                    stroke: TRACKER_FILL,
                    cursor: 'pointer'
                }).data('compositeButton', o)
            };

            !R.is(options, OBJECT) && (options = {});

            // We are adding the fn/ca before .define does so that the attributes of repaint are available.
            for (a in R.fn.button.fn) {
                o[a] = R.fn.button.fn[a];
            }
            for (a in R.fn.button.ca) {
                o.ca[a] = R.fn.button.ca[a];
            }

            return o.attr({
                ishot: true,
                'button-padding': [options.horizontalPadding, options.verticalPadding],
                'button-label': labelText,
                'button-symbol': symbolName,
                'button-disabled': options.disabled || 'false',
                'button-symbol-position': options.symbolPosition,
                'button-symbol-padding': options.symbolPadding
            }).attr('button-repaint', [x, y, options.width, options.height, options.r]);
        },

        data: {
            hoverin: function () {
                var o = this,
                    button = o._.button,
                    callback = button.hoverbackIn;
                (callback && (callback() === false)) ||
                    (o.attr('fill', 'hover').hovered = true);
            },
            hoverout: function () {
                var o = this,
                    button = o._.button,
                    callback = button.hoverbackOut;
                (callback && (callback() === false)) ||
                    (o.attr('fill', (o.pressed || o.active) && 'active' || 'normal').hovered = false);
            },
            mousedown: function () {
                var o = this;
                o.attr('fill', 'active').pressed = true;
            },
            mouseup: function () {
                var o = this,
                    button = o._.button,
                    callback = button.callback;
                o.attr('fill', o.hovered && 'hover' || o.active && 'active' || 'normal').pressed = false;
                callback();
            }
        },

        fn: {
            tooltip: function () {
                R.el.tooltip && R.el.tooltip.apply(this._.button.tracker, arguments);
                return this;
            },

            buttonclick: function (callback, scope) {
                var o = this,
                    button = o._.button;
                scope = scope || o;
                button.callback = function () {
                    return callback.apply(scope, arguments);
                };
                return o;
            },

            labelcss: function () {
                var button = this._.button,
                    label = button.label;

                button.cssArg = arguments;
                label && label.css.apply(label, arguments);

                return this.attr('button-repaint', this.attrs['button-repaint']);
            },

            buttonhover: function (callbackIn, callbackOut, scopeIn, scopeOut) {
                var o = this,
                    button = o._.button;

                scopeIn = scopeIn || o;
                scopeOut = scopeOut || o;
                button.hoverbackIn = function () {
                    return callbackIn.apply(scopeIn, arguments);
                };
                button.hoverbackOut = function () {
                    return callbackOut.apply(scopeOut, arguments);
                };
                return o;
            },

            remove: function () {
                var o = this,
                    button = o._.button,
                    key;

                o.attr('button-disabled', 'true');

                for (key in button) {
                    button[key] && button[key].remove && button[key].remove();
                    button[key] = null;
                }

                delete o._.button;
                R.el.remove.apply(o, arguments);
            }
        },

        ca: {
            'button-active': function (value) {
                var o = this;
                o.attr('fill', (o.active = !!value) ?
                    'active' : (o.hovered && 'hover' || 'normal'));
            },

            'button-disabled': function (value) {
                var o = this,
                    paper = o.paper,
                    button = o._.button,
                    tracker = button.tracker,
                    attr = o.attrs['button-disabled'],
                    events = paper.button.data;

                value = buttonDisabledAttrs[value];
                attr = buttonDisabledAttrs[attr];

                // Ensure that invalid values are ignored
                if (value === undefined || value === attr) {
                    return;
                }

                switch (value) {
                    case true:
                        tracker.attr('fill', 'rgba(204,204,205,.5)')
                            .unmousedown(events.mousedown).unmouseup(events.mouseup)
                            .unhover(events.hoverin, events.hoverout);
                        break;
                    case false:
                        tracker.attr('fill', TRACKER_FILL)
                            .mousedown(events.mousedown, o).mouseup(events.mouseup, o, true)
                            .hover(events.hoverin, events.hoverout, o, o);
                        break;
                }
            },

            'button-label': function (text) {
                var o = this,
                    button = o._.button,
                    attrs = o.attrs,
                    label = button.label,
                    cssArg = button.cssArg,
                    repaint = o.attrs['button-repaint'];

                text = toStr(text || BLANK);

                if (text === NONE) {
                    label && (button.label = label.remove());
                }
                else if (text) {
                    !label && (label = button.label = o.paper.text(o)
                        .insertBefore(button.tracker));
                    label.attr({
                        text: text,
                        'text-anchor': 'middle',
                        'vertical-align': 'middle'
                    });
                    cssArg && cssArg.length && label.css.apply(label, cssArg);
                }

                if (repaint && attrs['button-label'] !== text) {
                    o.attr('button-repaint', repaint);
                }
            },

            'button-symbol': function (name) {
                var o = this,
                    attrs = o.attrs,
                    button = o._.button,
                    symbol = button.symbol,
                    repaint = o.attrs['button-repaint'];

                name = toStr(name || BLANK);

                if (name === NONE) {
                    symbol && (button.symbol = symbol.remove());
                }
                else if (name && !symbol) {
                    symbol = button.symbol = o.paper.symbol(o)
                        .insertAfter(button.bound);
                }

                if (repaint && attrs['button-symbol'] !== name) {
                    o.attr('button-repaint', repaint);
                }
            },

            'button-symbol-position': function (position) {
                return {
                    'button-symbol-position': {
                        top: 'top',
                        right: 'right',
                        bottom: 'bottom',
                        left: 'left',
                        none: 'none'
                    }[toStr(position).toLowerCase()] || NONE
                };
            },

            'button-symbol-padding': function (value) {
                return {
                    'button-symbol-padding': toFloat(value)
                };
            },

            'button-padding': function (px, py) {
                return {
                    'button-padding': [(px == null) && (px = 5) || toFloat(px),
                        (py == null) && px || toFloat(py)]
                };
            },

            'button-repaint': function (x, y, w, h, r) {
                var o = this,
                    button = o._.button,
                    bound = button.bound,
                    label = button.label,
                    symbol = button.symbol,
                    attrs = o.attrs,
                    attrPads = attrs['button-padding'],
                    padX = attrPads[0],
                    padY = attrPads[1],
                    symX,
                    symY,
                    symD,
                    symR,
                    padSym,
                    bbox,
                    obj;

                // In case a specific coord is not provided, set them to zero.
                (x === undefined) && (x = 0);
                (y === undefined) && (y = 0);

                if (w === undefined || h === undefined) {
                    bbox = label && label.getBBox() || { width: 0, height: 0 };
                    (w === undefined) && (w = padX * 2 + bbox.width);
                    (h === undefined) && (h = padY * 2 + bbox.height);
                }

                obj = R.crispBound(x, y, w, h, bound.attr('stroke-width'));
                obj.r = r = R.pick(r, mathRound(mathMin(h, w) * 0.1));
                x = obj.x;
                y = obj.y;
                w = obj.width;
                h = obj.height;

                label && label.attr({
                    x: x + w / 2,
                    y: y + h / 2
                });

                if (symbol) {
                    // auto alculate symbol radius
                    !R.is((padSym = attrs['button-symbol-padding']), 'finite') && (padSym = h * 0.2);
                    symD = (h - padY);
                    symR = symD * 0.5;

                    switch (attrs['button-symbol-position'] + (label && '+' || '-')) {
                    case 'right+':
                        w += symR * 2 + padY;
                        symX = x + w - symR - padX;
                        symY = y + h * 0.5;
                        label.attr('transform', ['t', -(symD + padSym), 0]);
                        break;

                    case 'left+':
                        w += symR * 2 + padY;
                        symX = x + padX + symR;
                        symY = y + h * 0.5;
                        label.attr('transform', ['t', (symD + padSym), 0]);
                        break;

                    case 'top+':
                        h += symR * 2 + padSym;
                        symX = x + w * 0.5;
                        symY = y + attrPads[1] + symR;
                        label.attr('transform', ['t', 0, (symD + padSym)]);
                        break;

                    case 'bottom+':
                        h += symR * 2 + padSym;
                        symX = x + w * 0.5;
                        symY = y + h - padY - symR;
                        label.attr('transform', ['t', 0, -(symD + padSym)]);
                        break;

                    default: // none
                        symX = (x + w * 0.5);
                        symY = (y + h * 0.5);
                    }

                    symbol.attr('symbol', [attrs['button-symbol'], symX, symY, symR]);
                }

                button.bound.attr(obj);
                button.tracker.attr(obj);
            },

            fill: function (color, labelFill, symbolFill, hover) {

                var o = this,
                    button = o._.button,
                    bound = button.bound,
                    symbol = button.symbol,
                    label = button.label,
                    state = {
                        normal: button.gradient,
                        active: button.gradientActive,
                        hover: button.gradientHover
                    }[color];

                if (!state) {
                    color = R.getRGB(color);
                    color.error && (color = R.color('#cccccc'));
                    color = ('opacity' in color) ?
                        ('rgba(' + [color.r, color.g, color.b, color.opacity] + ')') :
                        ('rgb(' +[color.r, color.g, color.b] + ')');

                    button.gradient = [90,
                        R.tintshade(color, -0.8).rgba + ':0',
                        R.tintshade(color, 0.8).rgba + ':100'].join('-'),
                    button.gradientActive = [270,
                        R.tintshade(color, -0.8).rgba + ':0',
                        R.tintshade(color, 0.8).rgba + ':100'].join('-');

                    hover = R.getRGB(hover);
                    hover.error && (hover = color) ||
                        (hover = ('opacity' in hover) ?
                            ('rgba(' + [hover.r, hover.g, hover.b, hover.opacity] + ')') :
                            ('rgb(' +[hover.r, hover.g, hover.b] + ')'));

                    button.gradientHover = [90,
                        R.tintshade(hover, -0.9).rgba + ':0',
                        R.tintshade(hover, 0.7).rgba + ':100'].join('-'),

                    symbolFill = symbolFill || R.tintshade(color, 0.2).rgba;
                    labelFill = labelFill || R.tintshade(color, -0.2).rgba;

                    button.symbolFill = symbolFill;
                    button.labelFill = labelFill;

                    state = ((o.pressed || o.active) && button.gradientActive) ||
                            (o.hovered && button.gradienthover) || button.gradient;
                }

                bound.attr('fill', state);
                symbol && symbol.attr('fill', button.symbolFill);
                label && label.attr('fill', button.labelFill);
                return false;
            },

            stroke: function (color, forSymbol) {
                var button = this._.button,
                    symbol = button.symbol;

                color = R.color(color);
                color.error && (color = R.color('#999999'));

                button.bound.attr(STROKE, color);
                symbol && symbol.attr(STROKE, forSymbol || color);

                return false;
            },

            'stroke-width': function (value, forSymbol) {
                var button = this._.button,
                    symbol = button.symbol;

                button.bound.attr('stroke-width', value);
                button.tracker.attr('stroke-width', value);
                symbol && symbol.attr('stroke-width', forSymbol);

                return false;
            }
        }
    }, {
        // Name of the component goes here.
        name: 'trianglepath',

        // Constructor of the component goes here. Must be same name as the name of the component.
        trianglepath: function () { // args: [x1, y1, x2, y2, x3, y3, r1, r2, r3]
            var paper = this,
                args = arguments,
                group = R._lastArgIfGroup(args),
                face = paper.path(group);

            return face.attr('trianglepath', [
                args[0], args[1],
                args[2], args[3],
                args[4], args[5],
                args[6] || 0,
                args[7] || 0,
                args[8] || 0
            ]);
        },

        fn: {
            sides: function () {
                // Use p2pdistance library function to compute sides of a triangle.
                var points = this._args;
                return [
                    p2pdistance(points[0], points[1], points[2], points[3]), // p1, p2
                    p2pdistance(points[2], points[3], points[4], points[5]), // p2, p3
                    p2pdistance(points[4], points[5], points[0], points[1])  // p3, p1
                ];
            },

            enclosedAngles: function () {
                // Returns the three angles of a triangle formed by the given sides
                var edges = this._sides;
                return [
                    mathAcos((mathPow(edges[0], 2) + mathPow(edges[2], 2) - mathPow(edges[1], 2)) /
                        (2 * edges[0] * edges[2])),
                    mathAcos((mathPow(edges[0], 2) + mathPow(edges[1], 2) - mathPow(edges[2], 2)) /
                        (2 * edges[0] * edges[1])),
                    mathAcos((mathPow(edges[2], 2) + mathPow(edges[1], 2) - mathPow(edges[0], 2)) /
                        (2 * edges[2] * edges[1]))
                ];
            },

            semiperimeter: function () {
                // Returns the semiperimeter of triangle
                var sides = this._sides || this.sides();
                return ( (sides[0] + sides[1] + sides[2]) / 2);
            }
        },

        ca: {
            trianglepath: function (x1, y1, x2, y2, x3, y3, r1, r2, r3) {
                /* Create the triangle path with the provided vertices.
                 * Make rounded triangle corners if radius is provided.
                 * r1, r2, r3 are the radii of respective vertices.
                 */
                if (r1 || r2 || r3) {
                    // Store arguments in trianglepath element
                    this._args = arguments;

                    // Calculate length of all sides of the triangle
                    this._sides = this.sides();

                    // Get all the angles of the triangle
                    var angles = this.enclosedAngles(),
                        curveDistance,
                        curvePoints,
                        inradius,
                        s = this.semiperimeter();

                    // Calculate inradius of triangle
                    inradius = mathSqrt(s * (s - this._sides[0]) * (s - this._sides[1]) * (s - this._sides[2])) / s;

                    // Get distance of points of curves from corresponding vertices
                    // Impose an upper limit on radius which is inradius of triangle
                    curveDistance = [
                        mathMin(r1, inradius) / mathTan(angles[0] / 2),
                        mathMin(r2, inradius) / mathTan(angles[1] / 2),
                        mathMin(r3, inradius) / mathTan(angles[2] / 2)
                    ];

                    // Get coordinates of the points of curve on the triangle
                    curvePoints = [
                        pointAtLength(x1, y1, x3, y3, curveDistance[0]),
                        pointAtLength(x1, y1, x2, y2, curveDistance[0]),

                        pointAtLength(x2, y2, x1, y1, curveDistance[1]),
                        pointAtLength(x2, y2, x3, y3, curveDistance[1]),

                        pointAtLength(x3, y3, x2, y2, curveDistance[2]),
                        pointAtLength(x3, y3, x1, y1, curveDistance[2])
                    ];

                    // Draw the triangle path with rounded corners
                    this.attr({
                        path: [
                            M, curvePoints[0].x, curvePoints[0].y,
                            Q, x1, y1, curvePoints[1].x, curvePoints[1].y,
                            L, curvePoints[2].x, curvePoints[2].y,
                            Q, x2, y2, curvePoints[3].x, curvePoints[3].y,
                            L, curvePoints[4].x, curvePoints[4].y,
                            Q, x3, y3, curvePoints[5].x, curvePoints[5].y,
                            L, curvePoints[0].x, curvePoints[0].y
                        ]
                    });
                } else {
                    this.attr({
                        path: [M, x1, y1, L, x2, y2, x3, y3, Z]
                    });
                }
            }
        }
    }]);

    R.ca[TEXTBOUND] = function (fill, stroke, strokeWidth, padding, cornerRadius, dasharray) {
        var o = this,
            paper = o.paper,
            bound = o._.textbound;

        if (this.type !== 'text') {
            return;
        }

        if ((!stroke || stroke === NONE) && (!fill || fill === NONE)) {
            o._.textbound = (bound && bound.unfollow(o).remove());
            return false;
        }

        (!strokeWidth || !R.is(strokeWidth, 'finite')) && (strokeWidth = 0);
        (!cornerRadius || !R.is(cornerRadius, 'finite')) && (cornerRadius = 0);
        !bound && (bound = o._.textbound = paper.rect(0, 0, 0, 0, o.group)
            .follow(o, R.ca[TEXTBOUND].reposition, 'before'));

        bound.attr({
            'stroke': stroke,
            'stroke-width': strokeWidth,
            'fill': fill,
            'shape-rendering': (strokeWidth === 1) && CRISP || BLANK,
            r: cornerRadius
        });
        dasharray && bound.attr('stroke-dasharray', dasharray);

        // Call the repositioning function
        R.ca[TEXTBOUND].reposition.call(bound, o.attr(), o);
        return false;
    };

    R.ca[TEXTBOUND].reposition = function (params, leader) {
        var o = this,
            updates = {},
            attr,
            padding,
            padX,
            padY,
            bbox,
            w,
            h;

        // check visibility first
        if (params[HAS]('visibility')) {
            o.attr('visibility', params.visibility);
        }

        // filter out the attributes that affects text-bound.
        if (!(params[HAS](TEXTBOUND) || params[HAS]('x') || params[HAS]('y') ||
                params[HAS]('text') || params[HAS]('text-anchor') ||
                params[HAS]('text-align') || params[HAS]('font-size') ||
                params[HAS]('line-height') || params[HAS]('vertical-align') ||
                params[HAS]('transform') || params[HAS]('rotation'))) {
            return;
        }

        attr = leader.attrs[TEXTBOUND];
        padding = toStr(attr && attr[3] || '0').split(commaseparator);
        padX = toFloat(padding[0]) || 0;
        padY = R.pick(toFloat(padding[1]), padX);
        bbox = leader.getBBox();
        w = bbox.width;
        h = bbox.height;

        // In case bounding box failed to return value, we do not need to change position.
        if (!isNaN(w)) {
            updates.x = bbox.x - padX;
            updates.y = bbox.y - padY;
            updates.width = w + padX * 2;
            updates.height = h + padY * 2;
        }

        o.attr(updates);
    };

    R.fn.symbol = function () {// name, x, y, (r || w , h)
        var paper = this,
            args = arguments,
            lastArg = args.length - 1,
            group = args[lastArg],
            o;

        group && (group.constructor === R.el.constructor) ?
            (args[lastArg] = undefined) : (group = undefined);

        o = paper.path(undefined, group);
        o.ca.symbol = R.fn.symbol.ca.symbol;
        return (args.length === !!group+0) ? o : o.attr('symbol', args);
    };

    R.fn.symbol.cache = {
        '': R._cacher(function (x, y, r, h) {
                return (arguments.length > 3) ?
                    ['M', x, y, 'h', r, 'v', h, 'h', -r, 'v', -h, 'z'] :
                        ['M', x - r, y - r,
                            'h', r *= 2, 'v', r, 'h', -r, 'v', -r, 'z'];
            })
    };
    R.fn.symbol.ca = {
        symbol: function (name) {
            var o = this,
                args = R.is(name, OBJECT) && (arguments.length === 1) &&
                    !R.is(name, 'function') ? name : arguments,
                symbolFn,
                symbolData;

            (args === name) && (name = args[0]);

            symbolFn = R.is(name, 'function') && name ||
                R.fn.symbol.cache[name] || R.fn.symbol.cache[''];
            symbolData = symbolFn && symbolFn.apply(R, arraySlice.call(args, 1));

            (R.is(symbolData, 'array') || R.is(symbolData, 'string')) ?
                o.attr('path', symbolData) :
                    (symbolData && o.attr(symbolData));
        }
    };

    R.addSymbol = function (name, fn) {

        var items = R.is(fn, 'function') &&
                (items = {}, (items[name] = fn), items) || name,
            cache = R.fn.symbol.cache,
            alias = [],
            i;

        for (i in items) {
            fn = items[i];
            cache[i] = R.is(fn, 'function') && R._cacher(fn, R) ||
                (alias.push(i), fn);
        }
        while (i = alias.pop()) {
            cache[i] = cache[cache[i]];
        }
    };

    if (R.svg) {
        p2srep = '$1';

        litepathsetter = function (path) {
            var o = this;

            if (!path) {
                path = 'M0,0';
            }
            else if (typeof path === 'string') {
                path = path.replace(p2s, p2srep);
            }
            else {
                path.toString = path2string;
            }

            o.node.setAttribute('d', path.toString());
            return o;
        };

        R._engine.litepath = function(path, svg, zoom, group) {

            var el = createNode('path'),
                p;

            (group || svg).canvas.appendChild(el);

            p = new Element(el, svg, group);
            p.type = LITEPATH;
            p.id = el.raphaelid = R._oid++;
            el.raphael = true;

            setFillAndStroke(p, {
                fill: NONE,
                stroke: '#000'
            });

            return p;
        };

        R._getPath.litepath = function (el) {
            return R.parsePathString(el.node.getAttribute('d'));
        };
    }
    else if (R.vml) {
        p2srep = function (cmd, $1) {
            return (s2vcmd[$1] || $1);
        };

        vmlTransformHelper = function () {
            var o = this;
            o._transform.apply(o, arguments);
            o._.bcoord && (o.node.coordsize = o._.bcoord);
            return o;
        };


        litepathsetter = function (path) {
            var o = this;

            if (!path) {
                path = 'M0,0';
            }
            else if (typeof path === 'string') {
                path = path.replace(p2s, p2srep);
            }
            else {
                path.toString = path2string;
            }

            o.node.path = path;
            return o;
        };

        R._engine.litepath = function(pathString, vml, zoom, group) {
            var el = createNode('shape'),
                s = el.style,
                p = new Element(el, vml, group),
                attr = {
                    fill: NONE,
                    stroke: '#000'
                },
                skew;

            s.cssText = CSSFLOOD;
            zoom = toFloat(zoom);
            if (isNaN(zoom)) {
                el.coordsize = COORD21600;
            }
            else {
                p._.bzoom = zoom;
                s.width = '1px';
                s.height = '1px';
                el.coordsize = p._.bcoord = zoom + SPACE + zoom;
            }
            el.coordorigin = vml.coordorigin;

            p.type = LITEPATH;
            p.id = el.raphaelid = R._oid++;
            el.raphael = true;

            p._transform = p.transform;
            p.transform = vmlTransformHelper;

            R._setFillAndStroke(p, attr);
            (group || vml).canvas.appendChild(el);

            skew = createNode('skew');
            skew.on = true;
            el.appendChild(skew);
            p.skew = skew;
            return p;
        };

        R._getPath.litepath = function (el) {
            return R.parsePathString(el.node.path || BLANK);
        };
    }

    // pathString
    R.fn[LITEPATH] = function(path, zoom, group) {
        var paper = this,
            out;

        if (zoom && zoom.constructor === Element) {
            group = zoom;
            zoom = undefined;
        }
        if (path && path.constructor === Element) {
            group = path;
            path = BLANK;
        }

        // create element and update the custom attribute.
        out = R._engine[LITEPATH](path, this, zoom, group);
        out.ca[LITEPATH] = litepathsetter;

        path && out.attr(LITEPATH, R.is(path, ARRAY) ? [path] : path);
        return (paper.__set__ && this.__set__.push(out), (paper._elementsById[out.id] = out));
    };
}]);
/**
 * Red Raphael JavaScript Library
 * ------------------------------
 * Extension for support for rendering HTML overlay elements on Raphael
 * @private
 * @since 3.3
 *
 * @module fusioncharts.redraphael.html
 * @requires fusioncharts.redraphael
 */
FusionCharts.register('module', ['private', 'modules.renderer.js-htmlrenderer', function () {

    var global = this,
        lib = global.hcLib,
        R = lib.Raphael,
        dem = lib.dem,
        win = global.window,
        doc = win.document,
        isIE = /msie/i.test(win.navigator.userAgent) && !win.opera,
        isVML = (R.type === 'VML'),
        hasTouch = 'createTouch' in doc,

        NONE = 'none',
        ABSOLUTE = 'absolute',
        BLANK = '',
        PX = 'px',

        styleAttrMap = {
            'cursor': 'cursor'
        },
        styleAttrNumericMap = {
            x: 'left',
            y: 'top',
            strokeWidth: 'borderThickness',
            'stroke-width': 'borderThickness',
            width: 'width',
            height: 'height'
        },
        styleAttrColorMap = {
            fill: 'backgroundColor',
            stroke: 'borderColor',
            color: 'color'
        },
        defaultElementStyle = {
            left: 0,
            top: 0,
            padding: 0,
            border: NONE,
            margin: 0,
            outline: NONE,
            '-webkit-apperance': NONE,
            position: ABSOLUTE,
            zIndex: 20
        },

        /**
         * Fixes color values by appending hash wherever needed
         */
        hashify = function (color) {
            return color && color.replace(/^#?([a-f0-9]+)/ig, '#$1') || NONE;
        },

        garbageBin, // HTML element

        /**
         * This function is used to create html DOM
         *
         * @param {string} tagName the name of the HTML tag
         * @param {object} attributes Object contain all attribute name and value
         * @param {DOMobject} parentElement parent node of the newly created element
         */
        createElement = function(tagName, attributes, css, parentElement) {
            var elem = doc.createElement(tagName),
            x;
            //apply all attribute
            for (x in attributes) {
                if (styleAttrNumericMap[x]) {
                    elem.style[x] = attributes[x];
                }
                else {
                    elem.setAttribute(x, attributes[x]);
                }
            }
            for (x in css) {
                elem.style[x] = css[x];
            }
            //append in parent element
            parentElement && parentElement.appendChild && parentElement.appendChild(elem);
            return elem;
        },

        /**
         * Discard an element by moving it to the bin and delete
         * @param {object} The HTML node to discard
         */
        discardElement = function (element) {
            // create a garbage bin element, not part of the DOM
            if (!garbageBin) {
                garbageBin = createElement('div');
            }

            // move the node and empty bin
            if (element) {
                garbageBin.appendChild(element);
            }
            garbageBin.innerHTML = '';
        },

        /**
         * Set or get an attribute or an object of attributes. Can't use jQuery attr because
         * it attempts to set expando properties on the SVG element, which is not allowed.
         *
         * @param {object} elem The DOM element to receive the attribute(s)
         * @param {string|object} prop The property or an abject of key-value pairs
         * @param {string} value The value if a single property is set
         */
        attr = function (elem, prop, value) {
            var key,
                ret;

            // if the prop is a string
            if (typeof prop === 'string') {
                // set the value
                if (value !== undefined && value !== null) {

                    elem.setAttribute(prop, value);

                // get the value
                }
                else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
                    ret = elem.getAttribute(prop);
                }

            // else if prop is defined, it is a hash of key/value pairs
            }
            else if (prop !== undefined && prop !== null && typeof prop === 'object') {
                for (key in prop) {
                    elem.setAttribute(key, prop[key]);
                }
            }
            return ret;
        },

        HTMLElement;

    HTMLElement = function (node, group, attrs) {
        var wrapper = this,
            element;

        if (group && group instanceof HTMLElement) {
            group = group.element;
        }
        element = wrapper.element = createElement(node, attrs,
            defaultElementStyle, group);
        element.ishot = 'true';
        wrapper.nodeName = node.toLowerCase();
        wrapper.added = Boolean(group);
    };

    HTMLElement.prototype = {
        attr: function (hash) {

            var wrapper = this,
                element = wrapper.element,
                restore = {},
                key,
                val,
                value,
                skipAttr,
                state,
                optionArr,
                optionString,
                i,
                len,
                ele;

            // getter
            if (typeof hash !== 'object') {
                // @todo: The attr is function is not defined! What is it supposed to do?
                return wrapper[hash] || attr(element, hash);
            }

            // super-setter
            for (key in hash) {
                value = hash[key];
                if (styleAttrMap[key]) {
                    switch (key) {
                    case 'cursor':
                        if (value === 'pointer' && isVML) {
                            value = 'hand';
                        }
                        break;
                    }
                    element.style[styleAttrMap[key]] = value;
                    skipAttr = true;
                }
                else if (styleAttrNumericMap[key]) {
                    element.style[styleAttrNumericMap[key]] = value + PX;
                    skipAttr = true;
                }
                else if (styleAttrColorMap[key]) {
                    element.style[styleAttrColorMap[key]] = hashify(value);
                    skipAttr = true;
                }
                else if (/^visibility$/i.test(key)) {
                    state = (value === 'hidden');
                    element.style.display = state ? 'none' : '';
                    wrapper.hidden = state;
                    skipAttr = true;
                }
                else if (/^opacity$/i.test(key)) {
                    element.style.opacity = value;
                    if (isIE) {
                        val = Number(value) * 100;
                        element.style.filter = 'progid:DXImageTransform.Microsoft.Alpha(Opacity=' + val + ')';
                    }

                    skipAttr = true;
                }
                else if (/^innerhtml$/i.test(key)) {
                    // IE < 9 does not allow options string to be added as innerHTML of the select element.
                    if (isVML && element.nodeName.toLowerCase() == 'select') {
                        // Parse all options using regex and create the option element
                        // and then add the option element to the select element
                        optionArr = value.match(/<option\s?[\s\S]*?(\/>|><\/option>|>[\s\S]*?<\/option>)/ig);
                        // Remove all child nodes before adding new nodes
                        while (element.firstChild) {
                            element.removeChild(element.firstChild);
                        }
                        for (i = 0, len = optionArr.length; i < len; i += 1) {
                            optionString = optionArr[i];
                            ele = doc.createElement('option');

                            if (/<option\s([\s\S]*[\'\"])\s*?(\/>|>[\s\S]*<\/option>)/ig.test(optionString)) {
                                ele.value = optionString
                                    .replace(/<option\s([\s\S]*[\'\"])\s*?(\/>|>[\s\S]*<\/option>)/ig, '$1')
                                    .replace(/[\s\S]*value\s*\=\s*[\'\"]([\s\S]*)[\'\"]/, '$1');
                            }
                            ele.text = optionString
                                .replace(/<option\s*[\s\S]*[\'\"]?\s*?[\/>|\>]([\s\S]*)<\/option>/ig, '$1 ');
                            element.options.add(ele);
                        }
                    } else {
                        (element.nodeName.toLowerCase() !== 'input') &&
                            (value !== undefined) && (element.innerHTML = (value || BLANK));
                    }
                    skipAttr = true;
                }
                else if (/^text$/i.test(key)) {
                    if (element.nodeName.toLowerCase() !== 'input') {
                        element.innerHTML = '';
                        (value !== undefined) && element.appendChild(doc.createTextNode(value));
                    }
                    skipAttr = true;
                }
                else if (/^type$/i.test(key) && isIE && wrapper.added) { // not in ie
                    skipAttr = true;
                }

                if (skipAttr) {
                    restore[key] = value;
                    delete hash[key];
                    skipAttr = false;
                }
            }

            for (key in hash) {
                element.setAttribute(key, hash[key]);
            }

            for (key in restore) {
                wrapper[key] = hash[key] = restore[key];
                delete restore[key];
            }
            return this;
        },

        val: function (set) {
            var wrapper = this,
                element = wrapper.element,
                getter = (set === undefined);

            if (wrapper.nodeName === 'input' && element.getAttribute('type') === 'checkbox') {
                return getter ? (wrapper.checked() ? 1 : 0) :
                        wrapper.checked(set);
            }

            return getter ? element.value : ((element.value = set), wrapper);
        },

        checked: function (set) {
            var wrapper = this,
                element = wrapper.element;
            return (set === undefined) ? element.checked : ((set ? element.setAttribute('checked', 'checked') :
                    element.removeAttribute('checked')), wrapper);
        },

        css: function (hash, val) {
            var wrapper = this,
                element = wrapper.element,
                styleObj = element.style,
                key;

            if (typeof hash === 'object') {
                for (key in hash) {
                    styleObj[key] = hash[key];
                }
            }
            else if (key) {
                if (val !== undefined) {
                    styleObj[key] = val;
                }
            }
            return wrapper;
        },

        translate: function (x, y) {
            var wrapper = this,
                element = wrapper.element;

            if (x !== undefined) {
                element.style.left = x + PX;
            }
            if (y !== undefined) {
                element.style.top = y + PX;
            }

            return wrapper;
        },

        add: function (group, prepend) {
            var wrapper = this,
                element = this.element,
                parent = group.element;

            if (prepend) {
                parent.insertBefore(element, parent.firstChild);
            }
            else {
                parent.appendChild(element);
            }

            wrapper.added = true;
            return wrapper;
        },

        hide: function () {
            this.element.style.display = 'none';
            return this;
        },

        show: function () {
            this.element.style.display = '';
            return this;
        },

        focus: function () {
            if (typeof this.element.focus === 'function') {
                this.element.focus();
            }
            else {
                lib.dem.fire(this.element, 'focus');
            }
        },

        destroy: function () {
            var wrapper = this,
                element = wrapper.element || {};

            // remove events
            element.onclick = element.onmouseout = element.onmouseover =
                element.onmousemove = element.onblur =
                element.onfocus = null;

            // remove from dom
            // @todo: discardElement is not defined! :(
            element = discardElement(element);
            delete wrapper.element;
            return null;
        },

        on: isVML ? function(eventType, handler) {
                var wrapper = this;

                // simplest possible event model for internal use
                wrapper.element['on'+ eventType] = function() {
                    var evt = win.event;
                    evt.target = evt.srcElement;
                    handler(evt);
                };
                return wrapper;
            } :
        function (eventType, handler) {
            var fn = handler,
                wrapper = this;
            // touch
            if (hasTouch && eventType === 'click') {
                eventType = 'touchstart';
                fn = function(e) {
                    e.preventDefault();
                    handler();
                };
            }
            // simplest possible event model for internal use
            wrapper.element['on'+ eventType] = fn;
            return wrapper;
        },

        bind: function (event, handler, data) {
            dem.listen(this.element, event, handler, data);
            return this;
        },

        unbind: function (event, handler) {
            dem.unlisten(this.element, event, handler);
            return this;
        },

        trigger: function (event, eventObj) {
            dem.fire(this.element, event, eventObj);
            return this;
        },

        fadeIn: function (transition, callback) {
            var duration = transition === 'fast' ? 400 : 1000;

            this.show();
            this.attr({opacity: 0});
            lib.danimate.animate(this.element, {opacity: 1}, duration, 'linear', callback);
        }
    };

    HTMLElement.prototype.constructor = HTMLElement;

    R.fn.html = function (node, attrs, css, group) {
        var rootAttr = {},
            wrapper,
            prop;

        // type cannot be updated post addition
        if (attrs && ('type' in attrs)) {
            rootAttr.type = attrs.type;
            delete attrs.type;
        }

        wrapper = new HTMLElement(node, group, rootAttr)
            .css(css)
            .attr(attrs);

        for (prop in rootAttr) {
            attrs[prop] = rootAttr[prop];
        }

        return wrapper;
    };
}]);
/**
 * Red Raphael JavaScript Library
 * ------------------------------
 * Extension for support of tooltip
 * @since 3.3
 * @private
 *
 * @module fusioncharts.redraphael.tooltip
 * @requires fusioncharts.redraphael
 */

FusionCharts.register('module', ['private', 'modules.renderer.js-raphaeltooltip', function () {

    var global = this,
        win = global.window,
        doc = win.document,
        docBody = doc.body || doc.getElementsByTagName('body')[0],
        lib = global.hcLib,
        R = lib.Raphael,
        eve = R.eve,
        createElement = lib.createElement,
        addEvent = lib.addEvent,
        removeEvent = lib.removeEvent,
        getPosition = lib.getPosition,
        hasTouch = lib.hasTouch,
        touchSafeEvent = lib.getTouchEvent,

        math = win.Math,
        mathCeil = math.ceil,
        mathFloor = math.floor,

        NONE = 'none',
        INLINE = 'inline',
        E = '',
        MINVPWIDTH = 100,
        MINVPHEIGHT = 100,
        DUMBOBJ = {},
        vpHeight = win.screen.availHeight,
        vpWidth = win.screen.availWidth,

        cssVendorPrefixes = {'':1, moz:1, webkit:1, o:1, ms:1},
        vendorSpecificStyles = {
            borderRadius: 'borderRadius',
            boxShadow: 'boxShadow'
        },

        regexCamelCase = /\-([a-z])/ig,
        regexCamelCaseReplacer = function (_a, _b) {
            return _b.toUpperCase();
        },

        StyleProperty = function (overrides) {
            var f = tip.forbiddenStyle,
                key,
                csskey,
                subkey;

            for (key in overrides) {
                // In case any hyphenated key is passed, convert it to camelCase.
                csskey = regexCamelCase.test(key) ?
                    key.replace(regexCamelCase, regexCamelCaseReplacer) : key;
                (overrides[key] !== undefined) && !f[csskey] &&
                    (this[csskey] = overrides[key]);

                // Convert color to hex for VML based browsers since they do not
                // support RGBA.
                if (R.vml && /color/ig.test(csskey)) {
                    this[csskey] = R.getRGB(this[csskey]).toString();
                }
            }

            // Do special handling and vendor prefixing for border radius
            for (key in vendorSpecificStyles) {
                if (this[key]) {
                    for (subkey in cssVendorPrefixes) {
                        this[subkey + key] = this[key];
                    }
                }
            }
        },

        tip = lib.toolTip = {
            elementId: 'fusioncharts-tooltip-element',
            element: null,
            lastTarget: null,
            currentTarget: null,
            currentPaper: null,
            pointeroffset: 12,
            prevented: false,

            defaultStyle: lib.extend2(StyleProperty.prototype, {
                backgroundColor: '#ffffee',
                borderColor: '#000000',
                borderWidth: '1px',
                color: '#000000',
                fontSize: '10px',
                lineHeight: '12px',
                padding: '3px',
                borderStyle: 'solid'
            }),

            defaultContainerStyle: {
                position: 'absolute',
                textAlign: 'left',
                margin: '0',
                zIndex: '99999',
                pointer: 'default',
                display: 'block'
            },

            forbiddenStyle: {}
        },

        trackOutOfBoundInteraction = function (event) {
            if (tip._oobready === true) { // first launch (ignore)
                tip._oobready = false;
                return;
            }

            removeEvent(docBody, 'touchstart', trackOutOfBoundInteraction);
            if (tip.hidden || !tip.currentTarget) {
                return;
            }

            var element = event.srcElement || event.target || DUMBOBJ;
            if (!element.raphael || tip.currentTarget.paper.getById(element.raphaelid) !== tip.currentTarget) {
                tip.hide();
            }
        };

    if (R.svg) {
        tip.defaultContainerStyle.pointerEvents = NONE;
        tip.defaultStyle.borderRadius = '0';
        tip.defaultStyle.boxShadow = NONE;
    }

    if (R.vml) {
        tip.forbiddenStyle.borderRadius = true;
        tip.forbiddenStyle.boxShadow = true;
        tip.defaultStyle.filter = E;
    }

    tip.setup = function () {
        var container = tip.container,
            textElement = tip.textElement,
            containerStyle = tip.style,
            defaultContainerStyle = tip.defaultContainerStyle,
            f = tip.forbiddenStyle,
            key;

        if (!container) {
            container = tip.element = createElement('span');
            (doc.body || doc.getElementsByTagName('body')[0])
                .appendChild(container);
            container.setAttribute('id', tip.elementId);
            // Fix for toolip printing issue in VML #RED-1029
            containerStyle = tip.containerStyle = container.style;

            textElement = tip.textElement = createElement('span');
            container.appendChild(textElement);
            tip.style = R.vml ? textElement.runtimeStyle : textElement.style;
            tip.style.overflow = 'hidden';
            tip.style.display = 'block';

            tip.hidden = false;
            tip.hide();
        }

        // Set default styles.
        for (key in defaultContainerStyle) {
            !f[key] && (containerStyle[key] = defaultContainerStyle[key]);
        }

        // on accidental touch of element, move it fast.
        //addEvent(container, hasTouch && 'touchstart' || 'mouseover', tip.onredraw); // cannot in raphael event

        // on drag of elements, hide the tooltip
        tip.scatted = true;
        eve.on('raphael.drag.start.*', function () {
            tip.scatted && (tip.waitingScat = true);
        });
        eve.on('raphael.drag.move.*', function () {
            if (tip.waitingScat) {
                tip.block();
                tip.waitingScat = false;
            }
        });
        eve.on('raphael.drag.end.*', function () {
            tip.waitingScat = false;
            if (tip.scatted) {
                tip.unblock(true);
            }
        });

        // Ensure tooltip hides when paper is removed
        eve.on('raphael.remove', function () {
            if (tip.currentPaper === this || tip.currentTarget &&
                (tip.currentTarget.paper === this)) {
                tip.hide();
                tip.currentTarget = tip.currentPaper = null;
            }
        });

        // Also need to handle the case of linkedCharts being invoked
        // in which case the tooltip should be hidden if the linkedChart
        // replaces the current chart.
        global.addEventListener('LinkedChartInvoked', function (event) {
            var chartObj = event.sender,
                chartPaper = chartObj.jsVars.hcObj.paper,
                tipPaper = tip.currentPaper;

            if (tipPaper === chartPaper) {
                tip.hide();
            }
        });
    };

    tip.restyle = function (style) {
        var s = tip.style,
            key;

        for (key in style) {
            s[key] = style[key];
        }
    };

    tip.onelement = function (event) {
        if (event.__tipProcessed) {
            return;
        }

        var tracker = this,
            paper = tracker.paper,
            o = (tracker.type === 'group' ? paper && paper._elementFromEvent(event) : tracker),
            tipStyle = paper.__tipStyle;

        // If not setup then do not initiate
        if (!o || !tipStyle || !o.__tipNeeded) {
            return;
        }

        if ((event.originalEvent || event).FusionChartsPreventEvent) {
            tip.preventTooltip();
        }

        // prevent hiding.
        tip.hiding && (tip.hiding = clearTimeout(tip.hiding));

        if (tip.currentPaper !== paper) {
            paper.__tipCp = paper.canvas && getPosition(paper.canvas.parentNode, true) || {};
            tip.restyle(paper.__tipStyle);
            tip.currentPaper = paper;
        }
        tip.lastTarget = tip.currentTarget;
        tip.currentTarget = o;

        // update scat information
        (tip.scatted = o.__tipScatted);

        tip.onredraw.call(this, event);

        event.__tipProcessed = true; // we mark tip processed after everything so that onredraw does not pre-exit

        // for touch device listen window click to hide tooltip
        if (hasTouch) {
            tip._oobready = true;
            addEvent(docBody || (docBody = doc.body || doc.getElementsByTagName('body')[0]), 'touchstart',
                trackOutOfBoundInteraction);
        }
    };

    tip.onredraw = function (event) {
        if (event.__tipProcessed) {
            return;
        }
        event.__tipProcessed = true;

        // Pointer is on element other than the tooltip target. If this.paper does not exist, it is safe to assume
        // click has been on some other non raphael element. Even if it is from some other paper, the getEventFromId
        // will return null
        if ((this.paper && this.paper._elementFromEvent(event)) !== tip.currentTarget) {
            return;
        }

        tip.redrawing && clearTimeout(tip.redrawing);
        event = touchSafeEvent(event);
        tip.x = mathFloor(event.pageX || (event.clientX + doc.body.scrollLeft + doc.documentElement.scrollLeft) || 0);
        tip.y = mathFloor(event.pageY || (event.clientY + doc.body.scrollTop + doc.documentElement.scrollTop) || 0);
        tip.redrawing = setTimeout(tip.redraw, 0);
    };

    tip.onhide = function (event) {
        if (event.__tipProcessed) {
            return;
        }
        event.__tipProcessed = true;
        if ((this.paper && this.paper._elementFromEvent(event)) !== tip.currentTarget) {
            return;
        }

        tip.hiding = setTimeout(tip.hide, 200);
    };

    tip.redraw = function () {

        if (tip.prevented || tip.blocked || !tip.currentTarget || !tip.currentTarget.__tipNeeded) {
            return;
        }

        var o = tip.currentTarget,
            paper = o.paper,
            textEl = tip.textElement,
            containerStyle = tip.containerStyle,
            style = tip.style,
            text = o.__tipText,
            offset = tip.pointeroffset,
            cp = paper.__tipCp,
            docEl = doc.documentElement || doc.body,
            scrollLeft = docEl.scrollLeft,
            scrollTop = docEl.scrollTop,
            x = tip.x,
            y = tip.y,
            width,
            height,
            pw = paper.width,
            ph = paper.height,
            constrain = paper.__tipConstrain;

        if (pw < MINVPWIDTH || ph < MINVPHEIGHT) {
            constrain = false;
        }

        if (tip.hidden) {
            tip.containerStyle.top = '-999em'; // perform changes out of view
            tip.show();
        }

        if (text !== tip.text) {
            tip.text = text;
            containerStyle.width = containerStyle.height = '';

            // Set text and compute its dimensions when word-wrapping is not
            // applied.
            textEl.innerHTML = text;
            style.whiteSpace = 'nowrap';
            width = mathCeil(style.pixelWidth || textEl.offsetWidth || 0);
            height = mathCeil(style.pixelHeight || textEl.offsetHeight || 0);

            //tooltext will overflow chart area, when the width from the current
            //position will exceed the chart's right margin.
            if (tip.textWidthOverflow = (x + width > cp.left + pw)) {
                //tooltip width should always be the minimum among the width required
                //to render the total text or the chart width, which is the max
                //allowable width.
                containerStyle.width = ( (pw > width) ? width + offset * 2 :
                                                         (pw - offset * 2 || 0) ) + 'px';
                style.whiteSpace = 'normal';
            }
            else {
                containerStyle.width = '';
            }

            if (tip.textHeightOverflow = (height > ph)) {
                containerStyle.height = (ph || 0) - offset * 2 + 'px';
                style.whiteSpace = 'normal';
            }
            else {
                containerStyle.height = '';
            }
        }

        width = mathCeil(style.pixelWidth || textEl.offsetWidth || 0);
        height = mathCeil(style.pixelHeight || textEl.offsetHeight || 0);

        // if the tooltip is to be constrained within the paper
        if (constrain) {
            // is there enough space to show the tooltip in the default position
            if (tip.textWidthOverflow) {
                //When text overflows. We should set position based on the newly set
                //width. We should only align the text to the extreme chart left
                //when tooltext is going outside chart left.
                x = ((x - width < cp.left) ? cp.left : x - width) - scrollLeft;
            }
            // if not reposition the tooltip
            else if (x + offset + width > cp.left - scrollLeft + pw - offset) {
                x = x - width - offset;
            }

            if (tip.textHeightOverflow) {
                y = cp.top - scrollTop;
            }
            else if (y + offset + height > cp.top - scrollTop + ph - offset) {
                y = y - height - offset * 1.5;
            }
        }
        else {
            if (scrollLeft + vpWidth < x + offset + width) {
                x = x - width - offset;
            }

            if (scrollTop + vpHeight < y + offset + height) {
                y = y - height - offset * 1.5;
            }
        }

        containerStyle.left = ((x + offset) || 0) + 'px';
        containerStyle.top = ((y + offset) || 0) + 'px';

        if (tip.hidden) {
            tip.show();
        }
    };

    tip.hide = function () {
        tip.hiding && (tip.hiding = clearTimeout(tip.hiding));
        tip.containerStyle.display = NONE;
        tip.hidden = true;
        tip.prevented = false;
    };

    tip.show = function () {
        if (!tip.blocked) {
            tip.hiding && (tip.hiding = clearTimeout(tip.hiding));
            tip.containerStyle.display = INLINE;
            tip.hidden = false;
        }
    };

    tip.preventTooltip = function () {
        tip.prevented = true;
    };

    tip.block = function () {
        tip.blocked = true;
        tip.containerStyle.display = NONE;
    };

    tip.unblock = function (retain) {
        tip.blocked = false;
        retain && (tip.containerStyle.display = (tip.hidden && NONE || INLINE));
    };

    R.fn.tooltip = function (css, shadow, constrain) {

        var paper = this,
            op;

        if (shadow) {
            op = (shadow.opacity === undefined ? 1 : shadow.opacity) * 0.4;
            if (R.svg) {
                css.boxShadow = '1px 1px 3px rgba(64,64,64,' + op +')';
            }
            else {
                css.filter = 'progid:DXImageTransform.Microsoft.Shadow' +
                    '(Strength=2, Direction=135, Color="#404040", shadowOpacity="' + op / 2 + '")';
            }
        }

        paper.__tipStyle = new StyleProperty(css);
        paper.__tipCp = paper.canvas && getPosition(paper.canvas.parentNode, true) || {};
        paper.__tipConstrain = Boolean(constrain);

        return paper;
    };

    R.el.trackTooltip = function (status) {
        var o = this,
            tracking = !!o.__tiptracking;

        // no new state provided or no change in tracking state
        if ((status === undefined) || (status = !!status) === tracking) {
            return o;
        }

        if (status) {
            if (hasTouch) {
                o.touchstart(tip.onelement);
            }
            else {
                o.mouseover(tip.onelement);
                o.mousemove(tip.onredraw);
                o.mouseout(tip.onhide);
            }
        }
        else {
            if (hasTouch) {
                o.untouchstart(tip.onelement);
            }
            else {
                o.unmouseover(tip.onelement);
                o.unmousemove(tip.onredraw);
                o.unmouseout(tip.onhide);
            }
        }

        o.__tiptracking = status;
        return o;
    };

    R.el.tooltip = function (text, x, y, unscat, blocked) {
        tip.setup();
        R.el.tooltip = function (text, x, y, unscat, blocked) {
            var o = this,
                notext = (text === false) || (text === undefined) || (text === E);

            o.__tipScatted = (unscat === undefined) ? o.__tipScatted : !unscat;
            (o.__tipScatted === undefined) && (o.__tipScatted = true);

            if (blocked !== null) {
                o.__tip_blocked = blocked; //jshint ignore: line
            }

            if (notext ^ !o.__tipText) {
                o.__tipNeeded = !notext;
            }
            o.__tipText = text;

            if (tip.currentTarget === o && text !== tip.text && !tip.hidden) {
                tip[notext ? 'hide' : 'redraw']();
            }

            return o;
        };
        return R.el.tooltip.call(this, text, x, y, unscat, blocked);
    };

    // Add ability to execute tooltip configuration from FusionCharts namespace.
    global.core._setTooltipZIndex = function (value) {
        // Ensure that the input is a valid number
        value = parseInt(value, 10);
        if (tip && !isNaN(value)) {
            // Update the default style property.
            tip.defaultContainerStyle.zIndex = value;
            // In case tooltip element is already ready then also directly
            // update its style.
            if (tip.containerStyle) {
                tip.containerStyle.zIndex = value;
            }
        }
    };
}]);
/**
 * FusionCharts JavaScript Library SmartLabel component module.
 * @private
 *
 * @module fusioncharts.renderer.javascript.smartlabel
 * @requires fusioncharts.renderer.javascript.lib
 */
FusionCharts.register('module', ['private', 'modules.renderer.js-smartlabel', function () {
    var global = this,
        lib = global.hcLib,
        isIE = lib.isIE,
        hasSVG = lib.hasSVG,
        math = Math,
        mathMax = math.max,
        win = global.window,
        isHeadLess = new RegExp(' HtmlUnit').test(win.navigator.userAgent),
        doc = win.document,
        isWebKit = new RegExp(' AppleWebKit/').test(win.navigator.userAgent),
        hasCanvas = !!(doc.createElement('canvas').getContext),
        hasMeasureText = !!(hasCanvas && doc.createElement('canvas').getContext('2d').measureText),

    SmartLabelManager = (function () {

        var supportedStyle = lib.supportedStyle,

            supportedCanvasStyle = {
                fontWeight: 1,
                'font-weight': 1,
                fontStyle: 1,
                'font-style': 1,
                fontSize: 1,
                'font-size': 1,
                fontFamily: 1,
                'font-family': 1
            },
            //style that will be set at the creation of the text container and will
            // not be changed
            fixedStyle = {
                position: 'absolute',
                top: '-9999em',
                left: '-9999em',
                whiteSpace: 'nowrap',
                padding: '0px',
                width: '1px',
                height: '1px',
                overflow: 'hidden'
            },
            SVG_BBOX_CORRECTION = isWebKit ? 0 : 4.5, // Arrived at through trial and error. Why 4.5??
            ellipsesWidth = 0,
            //class name
            className = '_SmartLabel',
            className2 = '_SmartLabelBR',
            //have to modyfy sothat it can retrive classname among more
            classNameReg = /\b_SmartLabel\b/,
            classNameBrReg = /\b_SmartLabelBR\b/,
            spanAdditionRegx = /(<[^<\>]+?\>)|(&(?:[a-z]+|#[0-9]+);|.)/ig,
            spanAdditionReplacer = '$1<span class="'+ className + '">$2</span>',
            spanRemovalRegx = new RegExp('\\<span[^\\>]+?'+ className +'[^\\>]{0,}\\>(.*?)\\<\\/span\\>', 'ig'),
            xmlTagRegEx = new RegExp('<[^>][^<]*[^>]+>', 'i'),
            testStrAvg = 'WgI',
            isBrowserLess = false,
            minWidth = 0,
            avgCharWidth = 0,
            dotWidth = 0,
            containerIdIncriment = 0,
            spanTagString = 'span',
            ChildRetriverFN,
            ChildRetriverSTRING,
            noClassTesting;

        if (doc.getElementsByClassName) {
            ChildRetriverFN = 'getElementsByClassName';
            ChildRetriverSTRING = className;
            noClassTesting = true;
        }
        else {
            ChildRetriverFN = 'getElementsByTagName';
            ChildRetriverSTRING = spanTagString;
            noClassTesting = false;
        }

        //this function will create a container
        function createContainer (containerParent) {
            var body, container;

            if (containerParent && (containerParent.offsetWidth || containerParent.offsetHeight)) {
                if (containerParent.appendChild) {
                    containerParent.appendChild(container = doc.createElement('div'));
                    container.className = 'fusioncharts-smartlabel-container';
                    container.setAttribute('aria-hidden', 'true');
                    container.setAttribute('role', 'presentation');
                    return container;
                }
            }
            else {
                body = doc.getElementsByTagName('body')[0];
                //if body ready then Execuate the function otherwise add it at dom ready

                if (body && body.appendChild) {
                    ////create the text container element
                    container = doc.createElement('div');
                    container.className = 'fusioncharts-smartlabel-container';
                    container.setAttribute('aria-hidden', 'true');
                    container.setAttribute('role', 'presentation');
                    containerIdIncriment += 1;
                    //append the container element
                    body.appendChild(container);
                    return container;
                }
            }
            return undefined;
        }

        function getNearestChar(text, maxWidth, sl) {

            if (!text || !text.length) {
                return 0;
            }

            var difference,
                getWidth = sl.getWidthFunction(),
                charLen = 0,
                increment = 0,
                oriWidth = getWidth(text),
                avgWidth = oriWidth / text.length;

            difference = maxWidth;
            charLen = Math.ceil(maxWidth / avgWidth);

            if (oriWidth < maxWidth) {
                return (text.length - 1);
            }

            if (charLen > text.length) {
                difference = maxWidth - oriWidth;
                charLen = text.length;
            }

            while (difference > 0) {
                difference = maxWidth - getWidth(text.substr(0, charLen));
                increment = Math.floor(difference / avgWidth);
                if (increment) {
                    charLen += increment;
                } else {
                    return charLen;
                }
            }

            while (difference < 0) {
                difference = maxWidth - getWidth(text.substr(0, charLen));
                increment = Math.floor(difference / avgWidth);
                if (increment) {
                    charLen += increment;
                } else {
                    return charLen;
                }
            }
            return charLen;
        }

        // Set the line height in the style object in case
        function setLineHeight (styleObj) {
            var fSize = styleObj.fontSize = (styleObj.fontSize || '12px');
            styleObj.lineHeight =
                styleObj.lineHeight || styleObj['line-height'] || ((parseInt(fSize, 10) * 1.2) + 'px');
        }

        function ContainerManager (parentContainer, maxContainers) {
            // Limit the maximum container between MAXC and MINC.
            maxContainers = maxContainers > 5 ? maxContainers : 5;
            maxContainers = maxContainers < 20 ? maxContainers : 20;

            this.maxContainers = maxContainers;
            this.first = null;
            this.last = null;
            this.containers = {};
            this.length = 0;
            this.rootNode = parentContainer;

            if (isBrowserLess) {
                var svg = doc.createElementNS('http://www.w3.org/2000/svg','svg');
                svg.setAttributeNS('http://www.w3.org/2000/svg','xlink','http://www.w3.org/1999/xlink');
                svg.setAttributeNS('http://www.w3.org/2000/svg','height','0');
                svg.setAttributeNS('http://www.w3.org/2000/svg','width','0');
                this.svgRoot = svg;
                this.rootNode.appendChild(svg);
            }
        }

        ContainerManager.prototype = {
            get: function (style) {
                var o = this,
                    containers = o.containers,
                    len = o.length,
                    max = o.maxContainers,
                    diff,
                    key,
                    keyStr = '',
                    canvasStr = '',
                    isCanvas = false,
                    containerObj;

                if (canvasStr = o.getCanvasFont(style)) {
                    isCanvas = true;
                }

                for (key in supportedStyle) {
                    if (style[key] !== undefined) {
                        keyStr += supportedStyle[key] + ':' + style[key] + ';';
                    }
                }

                if (!keyStr) {
                    return false;
                }

                if (containers[keyStr]) {
                    // move to the beginning of the chain.
                    containerObj = containers[keyStr];
                    if (o.first !== containerObj) {
                        containerObj.prev && (containerObj.prev.next = containerObj.next);
                        containerObj.next && (containerObj.next.prev = containerObj.prev);
                        containerObj.next = o.first;
                        containerObj.next.prev = containerObj;
                        (o.last === containerObj) && (o.last = containerObj.prev);
                        containerObj.prev = null;
                        o.first = containerObj;
                    }
                }
                else {
                    if (len >= max) {
                        diff = (len - max) + 1;
                        // +1 is to remove an extra entry to make space for the new container to be added.
                        while (diff--) {
                            o.removeContainer(o.last);
                        }
                    }
                    containerObj = o.addContainer(keyStr, canvasStr);
                }

                return containerObj;
            },
            getCanvasFont: function (style) {
                var key,
                    fontArr = [];

                // Check if canvas tag is supported or not.
                if (!(hasCanvas && hasMeasureText)) {
                    return false;
                }

                // Check if there are any non-canvas styles present.
                // If present, return false.
                /*  for (key in style) {
                        if (!supportedCanvasStyle[key]) {
                            return false;
                        }
                    }
                 */

                for (key in supportedCanvasStyle) {
                    if (style[key] !== undefined) {
                        fontArr.push(style[key]);
                    }
                }

                return fontArr.join(' ');
            },
            setMax: function (maxContainers) {
                var o = this,
                    len = o.length,

                    diff;

                maxContainers = maxContainers > 5 ? maxContainers : 5;
                maxContainers = maxContainers < 20 ? maxContainers : 20;

                if (maxContainers < len) {
                    /** @todo remove additional containerObjects */
                    diff = len - maxContainers;
                    while (diff--) {
                        o.removeContainer(o.last);
                    }
                    o.length = maxContainers;
                }

                o.maxContainers = maxContainers;
            },
            addContainer: function (keyStr, canvasStr) {
                var o = this,
                    node,
                    context,
                    container;

                o.containers[keyStr] = container = {
                    next: null,
                    prev: null,
                    node: null,
                    ellipsesWidth: 0,
                    lineHeight: 0,
                    dotWidth: 0,
                    avgCharWidth: 4,
                    keyStr: keyStr,
                    canvasStr: canvasStr,
                    charCache: {}
                };

                // Since the container objects are arranged from
                // most recent to least recent order, we need to add the new object
                // at the beginning of the list.
                container.next = o.first;
                container.next && (container.next.prev = container);
                o.first = container;
                if (!o.last) {
                    (o.last = container);
                }
                o.length += 1;

                node = container.node = doc.createElement('div');
                o.rootNode.appendChild(node);

                if (isIE && !hasSVG) {
                    node.style.setAttribute('cssText', keyStr);
                }
                else {
                    node.setAttribute('style', keyStr);
                }

                node.setAttribute('aria-hidden', 'true');
                node.setAttribute('role', 'presentation');
                node.style.display = 'inline-block';

                node.innerHTML = testStrAvg; // A test string.
                container.lineHeight = node.offsetHeight;
                container.avgCharWidth = (node.offsetWidth / 3);

                if (isBrowserLess) {
                    node = container.svgText = doc.createElementNS('http://www.w3.org/2000/svg', 'text');
                    node.setAttribute('style', keyStr);
                    o.svgRoot.appendChild(node);

                    node.textContent = testStrAvg; // A test string.
                    container.lineHeight = node.getBBox().height;
                    container.avgCharWidth = ((node.getBBox().width - SVG_BBOX_CORRECTION) / 3);

                    node.textContent = '...';
                    container.ellipsesWidth = node.getBBox().width - SVG_BBOX_CORRECTION;
                    node.textContent = '.';
                    container.dotWidth = node.getBBox().width - SVG_BBOX_CORRECTION;
                }
                else if (canvasStr) {
                    node = container.canvas = doc.createElement('canvas');
                    node.style.height = node.style.width = '0px';
                    o.rootNode.appendChild(node);

                    container.context = context = node.getContext('2d');
                    context.font = canvasStr;

                    container.ellipsesWidth = context.measureText('...').width;
                    container.dotWidth = context.measureText('.').width;
                }
                else {
                    node.innerHTML = '...';
                    container.ellipsesWidth = node.offsetWidth;
                    node.innerHTML = '.';
                    container.dotWidth = node.offsetWidth;
                    node.innerHTML = '';
                }

                return container;

            },
            removeContainer: function (cObj) {
                var o = this,
                    keyStr = cObj.keyStr;

                if (!keyStr || !o.length || !cObj) {
                    return;
                }
                o.length -= 1;

                cObj.prev && (cObj.prev.next = cObj.next);
                cObj.next && (cObj.next.prev = cObj.prev);
                (o.first === cObj) && (o.first = cObj.next);
                (o.last === cObj) && (o.last = cObj.prev);

                cObj.node.parentNode.removeChild(cObj.node);
                if (cObj.canvas) {
                    cObj.canvas.parentNode.removeChild(cObj.canvas);
                }

                delete o.containers[keyStr];
            },
            dispose: function () {
                var o = this,
                    key,
                    containers = o.containers;

                o.maxContainers = null;
                for (key in containers) {
                    o.removeContainer(containers[key]);
                }

                o.rootNode.parentNode.removeChild(o.rootNode);

                o.rootNode = null;
                o.first = null;
                o.last = null;
            }
        };

        ContainerManager.prototype.constructor = ContainerManager;

        function SmartLabelManager(id, container, useEllipses) {

            if (typeof id === 'undefined' || typeof id === 'object') {
                return;
            }

            this.id = id;
            var wrapper,
                prop;

            if (typeof container === 'string') {
                container = doc.getElementById(container);
            }

            wrapper = this.parentContainer = createContainer(container);

            wrapper.innerHTML = testStrAvg;
            if (isHeadLess || (!wrapper.offsetHeight && !wrapper.offsetWidth)) {
                isBrowserLess = true;
            }
            wrapper.innerHTML = '';

            // Apply the fixed styles.
            for (prop in fixedStyle) {
                wrapper.style[prop] = fixedStyle[prop];
            }

            this.containerManager = new ContainerManager(wrapper, 10);

            this.showNoEllipses = !useEllipses;
            this.init = true;
            //create the blank style obj
            this.style = {};
            this.setStyle();
        }

        SmartLabelManager.prototype = {

            dispose: function () {
                var label = this;

                if (!label.init) {
                    return;
                }

                label.containerManager.dispose();

                delete label.container;
                delete label.context;
                delete label.cache;
                delete label.containerManager;
                delete label.containerObj;
                delete label.id;
                delete label.style;
                delete label.parentContainer;
                delete label.showNoEllipses;
            },

            useEllipsesOnOverflow: function (useEllipses) {
                if (!this.init) {
                    return;
                }
                this.showNoEllipses = !useEllipses;
            },

            getWidthFunction: function () {
                var sl = this,
                    contObj = sl.containerObj,
                    context = sl.context,
                    container = sl.container,
                    svgText = contObj.svgText;

                if (svgText) {
                    return function (str) {
                        var bbox,
                            width;

                        svgText.textContent = str;
                        bbox = svgText.getBBox();
                        width = (bbox.width - SVG_BBOX_CORRECTION);
                        if (width < 1) {
                            width = bbox.width;
                        }

                        return width;
                    };
                }
                else if (context) {
                    return function (str) {
                        return context.measureText(str).width;
                    };
                }
                else {
                    return function (str) {
                        container.innerHTML = str;
                        return container.offsetWidth;
                    };
                }
            },

            getSmartText: function (text, maxWidth, maxHeight, noWrap) {
                if (!this.init) {
                    return false;
                }

                //fix for undefined or null string
                if (text === undefined || text === null) {
                    text = '';
                }

                //now smartify the string
                //create smart label object
                var sl = this,
                    smartLabel = {
                        text : text,
                        maxWidth : maxWidth,
                        maxHeight : maxHeight,
                        width : null,
                        height : null,
                        oriTextWidth : null,
                        oriTextHeight : null,
                        oriText : text,
                        isTruncated : false
                    },
                    hasHTMLTag = false,
                    len,
                    trimStr,
                    maxStrWidth = 0,
                    tempArr,
                    maxWidthWithEll,
                    toolText,
                    oriWidth,
                    oriHeight,
                    lastDash = -1,
                    lastSpace = -1,
                    lastIndexBroken = -1,
                    newCharIndex,
                    container = sl.container,
                    context = sl.context,
                    strWidth = 0,
                    strHeight = 0,
                    nearestChar,
                    tempChar,
                    getWidth,
                    initialLeft,
                    initialTop,
                    oriTextArr = [],
                    i = 0,
                    ellipsesStr = (sl.showNoEllipses ? '' : '...'),
                    lineHeight = sl.lineHeight,
                    spanArr, x, y,
                    elem, chr, elemRightMostPoint, elemLowestPoint,
                    lastBR, removeFromIndex, removeFromIndexForEllipses,
                    characterArr = [], dashIndex = -1, spaceIndex = -1,
                    fastTrim = function (str) {
                        str = str.replace(/^\s\s*/, '');
                        var ws = /\s/, i = str.length;
                        while (ws.test(str.charAt(i -= 1))) { /* jshint noempty:false */ }
                        return str.slice(0, i + 1);
                    },
                    lastLineBreak = -1;

                getWidth = sl.getWidthFunction();

                if (container) {
                    if (!isBrowserLess) {
                        //To get text size set the text as innerhtml
                        container.innerHTML = text;

                        //add oriTextWidth & oriTextHeight
                        smartLabel.oriTextWidth = oriWidth = container.offsetWidth;
                        smartLabel.oriTextHeight = oriHeight = container.offsetHeight;

                        // fix for screenreader
                        //container.innerHTML = "";

                        if (oriHeight <= maxHeight && oriWidth <= maxWidth) {
                            smartLabel.width = smartLabel.oriTextWidth = oriWidth;
                            smartLabel.height = smartLabel.oriTextHeight = oriHeight;
                            return smartLabel;
                        }

                        if (lineHeight > maxHeight) {
                            smartLabel.text = '';
                            smartLabel.width = smartLabel.oriTextWidth = 0;
                            smartLabel.height = smartLabel.oriTextHeight = 0;
                            return smartLabel;
                        }
                    }

                    text = fastTrim(text).replace(/(\s+)/g, ' ');
                    hasHTMLTag = xmlTagRegEx.test(text);
                    //hasHTMLTag = false;
                    maxWidthWithEll = this.showNoEllipses ? maxWidth : (maxWidth - ellipsesWidth);

                    if (!hasHTMLTag) {

                        oriTextArr = text.split('');
                        len = oriTextArr.length;
                        trimStr = '', tempArr = [];
                        tempChar = oriTextArr[0];

                        if (sl.cache[tempChar]) {
                            minWidth = sl.cache[tempChar].width;
                        }
                        else {
                            minWidth = getWidth(tempChar);
                            sl.cache[tempChar] = {
                                width: minWidth
                            };
                        }

                        if (maxWidthWithEll > minWidth) {
                            tempArr = text.substr(0, getNearestChar(text, maxWidthWithEll, sl)).split('');
                            i = tempArr.length;
                        }
                        else if (minWidth > maxWidth) {
                            // fix for screenreader
                            //container.innerHTML = "";

                            smartLabel.text = '';
                            smartLabel.width = smartLabel.oriTextWidth =
                                smartLabel.height = smartLabel.oriTextHeight = 0;
                            return smartLabel;
                        }
                        else if (ellipsesStr) {
                            maxWidthWithEll = maxWidth - (2 * dotWidth);
                            if (maxWidthWithEll > minWidth) {
                                ellipsesStr = '..';
                            } else {
                                maxWidthWithEll = maxWidth - dotWidth;
                                if (maxWidthWithEll > minWidth) {
                                    ellipsesStr = '.';
                                } else {
                                    maxWidthWithEll = 0;
                                    ellipsesStr = '';
                                }
                            }
                        }

                        strWidth = getWidth(tempArr.join(''));
                        strHeight = sl.lineHeight;

                        if (noWrap) {
                            for (; i < len; i += 1) {
                                tempChar = tempArr[i] = oriTextArr[i];
                                if (sl.cache[tempChar]) {
                                    minWidth = sl.cache[tempChar].width;
                                }
                                else {
                                    minWidth = getWidth(tempChar);
                                    sl.cache[tempChar] = {
                                        width: minWidth
                                    };
                                }
                                strWidth += minWidth;
                                if (strWidth > maxWidthWithEll) {
                                    if (!trimStr) {
                                        trimStr = tempArr.slice(0, -1).join('');
                                    }
                                    if (strWidth > maxWidth) {
                                        smartLabel.text = fastTrim(trimStr) + ellipsesStr;
                                        smartLabel.tooltext = smartLabel.oriText;
                                        smartLabel.width = getWidth(smartLabel.text);
                                        smartLabel.height = sl.lineHeight;
                                        return smartLabel;
                                    }
                                }
                            }

                            // fix for screenreader
                            //container.innerHTML = "";

                            smartLabel.text = tempArr.join('');
                            smartLabel.width = strWidth;
                            smartLabel.height = sl.lineHeight;
                            return smartLabel;

                        } else {

                            for (; i < len; i += 1) {

                                tempChar = tempArr[i] = oriTextArr[i];
                                if (tempChar === ' ' && !context) {
                                    tempChar = '&nbsp;';
                                }

                                if (sl.cache[tempChar]) {
                                    minWidth = sl.cache[tempChar].width;
                                }
                                else {
                                    minWidth = getWidth(tempChar);
                                    sl.cache[tempChar] = {
                                        width: minWidth
                                    };
                                }
                                strWidth += minWidth;

                                if (strWidth > maxWidthWithEll) {
                                    if (!trimStr) {
                                        trimStr = tempArr.slice(0, -1).join('');
                                    }
                                    if (strWidth > maxWidth) {
                                        /** @todo use regular expressions for better performance. */
                                        lastSpace = text.substr(0, tempArr.length).lastIndexOf(' ');
                                        lastDash = text.substr(0, tempArr.length).lastIndexOf('-');
                                        if (lastSpace > lastIndexBroken) {
                                            strWidth = getWidth(tempArr.slice(lastIndexBroken + 1, lastSpace).join(''));
                                            tempArr.splice(lastSpace, 1, '<br/>');
                                            lastIndexBroken = lastSpace;
                                            newCharIndex = lastSpace + 1;
                                        } else if (lastDash > lastIndexBroken) {
                                            if (lastDash === tempArr.length - 1) {
                                                strWidth =
                                                    getWidth(tempArr.slice(lastIndexBroken + 1, lastSpace).join(''));
                                                tempArr.splice(lastDash, 1, '<br/>-');
                                            } else {
                                                strWidth =
                                                    getWidth(tempArr.slice(lastIndexBroken + 1, lastSpace).join(''));
                                                tempArr.splice(lastDash, 1, '-<br/>');
                                            }
                                            lastIndexBroken = lastDash;
                                            newCharIndex = lastDash + 1;
                                        } else {
                                            tempArr.splice((tempArr.length - 1), 1, '<br/>' + oriTextArr[i]);
                                            lastLineBreak = tempArr.length - 2;
                                            strWidth = getWidth(tempArr.slice(lastIndexBroken + 1,
                                                lastLineBreak + 1).join(''));
                                            lastIndexBroken = lastLineBreak;
                                            newCharIndex = i;
                                        }
                                        strHeight += sl.lineHeight;
                                        if (strHeight > maxHeight) {
                                            // fix for screenreader
                                            //container.innerHTML = "";

                                            smartLabel.text = fastTrim(trimStr) + ellipsesStr;
                                            smartLabel.tooltext = smartLabel.oriText;
                                            //The max width among all the lines will be the width of the string.
                                            smartLabel.width = maxWidth;
                                            smartLabel.height = (strHeight - sl.lineHeight);
                                            return smartLabel;
                                        } else {
                                            maxStrWidth = mathMax(maxStrWidth, strWidth);
                                            trimStr = null;
                                            nearestChar =
                                                getNearestChar(text.substr(newCharIndex), maxWidthWithEll, sl);
                                            strWidth = getWidth(text.substr(newCharIndex, nearestChar || 1));
                                            if (tempArr.length < newCharIndex + nearestChar) {
                                                tempArr = tempArr.concat(
                                                    text.substr(
                                                        tempArr.length,
                                                        newCharIndex + nearestChar - tempArr.length
                                                    ).split('')
                                                );
                                                i = tempArr.length - 1;
                                            }
                                        }
                                    }
                                }
                            }

                            maxStrWidth = mathMax(maxStrWidth, strWidth);

                            // fix for screenreader
                            //container.innerHTML = "";

                            smartLabel.text = tempArr.join('');
                            smartLabel.width = maxStrWidth;
                            smartLabel.height = strHeight;
                            return smartLabel;
                        }
                    }
                    else {
                        toolText = text.replace(spanAdditionRegx, '$2');
                        text = text.replace(spanAdditionRegx, spanAdditionReplacer);
                        text = text.replace(
                            /(<br\s*\/*\>)/g,
                            '<span class="' + [className, ' ', className2].join('') + '">$1</span>'
                        );

                        container.innerHTML = text;

                        spanArr = container[ChildRetriverFN](ChildRetriverSTRING);

                        for (x = 0, y = spanArr.length; x < y; x += 1) {
                            elem = spanArr[x];
                            //chech whether this span is temporary inserted span from it's class
                            if (noClassTesting || classNameReg.test(elem.className)) {
                                chr = elem.innerHTML;
                                if (chr !== '') {
                                    if (chr === ' ') {
                                        spaceIndex = characterArr.length;
                                    } else if ( chr === '-') {
                                        dashIndex = characterArr.length;
                                    }

                                    characterArr.push({
                                        spaceIdx: spaceIndex,
                                        dashIdx: dashIndex,
                                        elem: elem
                                    });
                                    oriTextArr.push(chr);
                                }
                            }
                        }

                        i = 0;
                        len = characterArr.length;
                        minWidth = characterArr[0].elem.offsetWidth;

                        if (minWidth > maxWidth) {
                            // fix for screenreader
                            //container.innerHTML = "";

                            smartLabel.text = '';
                            smartLabel.width = smartLabel.oriTextWidth =
                                smartLabel.height = smartLabel.oriTextHeight = 0;
                            return smartLabel;
                        } else if (minWidth > maxWidthWithEll && !this.showNoEllipses) {

                            maxWidthWithEll = maxWidth - (2 * dotWidth);
                            if (maxWidthWithEll > minWidth) {
                                ellipsesStr = '..';
                            } else {
                                maxWidthWithEll = maxWidth - dotWidth;
                                if (maxWidthWithEll > minWidth) {
                                    ellipsesStr = '.';
                                } else {
                                    maxWidthWithEll = 0;
                                    ellipsesStr = '';
                                }
                            }
                        }

                        initialLeft = characterArr[0].elem.offsetLeft;
                        initialTop = characterArr[0].elem.offsetTop;

                        if (noWrap) {
                            for (; i < len; i += 1) {
                                elem = characterArr[i].elem;
                                elemRightMostPoint = (elem.offsetLeft - initialLeft) + elem.offsetWidth;

                                if (elemRightMostPoint > maxWidthWithEll) {
                                    if (!removeFromIndexForEllipses) {
                                        removeFromIndexForEllipses = i;
                                    }
                                    if (container.offsetWidth > maxWidth) {
                                        removeFromIndex = i;
                                        i = len;
                                    }
                                }
                            }
                        } else {
                            for (; i < len; i += 1) {
                                elem = characterArr[i].elem;
                                elemLowestPoint = elem.offsetHeight + (elem.offsetTop - initialTop);
                                elemRightMostPoint = (elem.offsetLeft - initialLeft) + elem.offsetWidth;

                                lastBR = null;

                                if (elemRightMostPoint > maxWidthWithEll) {
                                    if (!removeFromIndexForEllipses) {
                                        removeFromIndexForEllipses = i;
                                    }

                                    if (elemRightMostPoint > maxWidth) {
                                        lastSpace = characterArr[i].spaceIdx;
                                        lastDash = characterArr[i].dashIdx;
                                        if (lastSpace > lastIndexBroken) {
                                            characterArr[lastSpace].elem.innerHTML = '<br/>';
                                            lastIndexBroken = lastSpace;
                                        } else if (lastDash > lastIndexBroken) {
                                            if (lastDash === i) { // in case the overflowing character itself is the '-'
                                                characterArr[lastDash].elem.innerHTML = '<br/>-';
                                            } else {
                                                characterArr[lastDash].elem.innerHTML = '-<br/>';
                                            }
                                            lastIndexBroken = lastDash;
                                        } else {
                                            elem.parentNode.insertBefore(lastBR = doc.createElement('br'), elem);
                                        }

                                        //check whether this break made current element outside the area height
                                        if ((elem.offsetHeight + elem.offsetTop) > maxHeight) {
                                            //remove the lastly inserted line break
                                            if (lastBR) {
                                                lastBR.parentNode.removeChild(lastBR);
                                            }
                                            else if (lastIndexBroken === lastDash) {
                                                characterArr[lastDash].elem.innerHTML = '-';
                                            } else {
                                                characterArr[lastSpace].elem.innerHTML = ' ';
                                            }
                                            removeFromIndex = i;
                                            //break the looping condition
                                            i = len;
                                        } else {
                                            removeFromIndexForEllipses = null;
                                        }
                                    }

                                } else {
                                    //check whether this break made current element outside the area height
                                    if (elemLowestPoint > maxHeight) {
                                        removeFromIndex = i;
                                        i = len;
                                    }
                                }
                            }
                        }

                        if (removeFromIndex < len) {
                            //set the trancated property of the smartlabel
                            smartLabel.isTruncated = true;

                            /** @todo is this really needed? */
                            removeFromIndexForEllipses = removeFromIndexForEllipses ?
                            removeFromIndexForEllipses : removeFromIndex;

                            for (i = len - 1; i >= removeFromIndexForEllipses; i -= 1) {
                                elem = characterArr[i].elem;
                                //chech whether this span is temporary inserted span from it's class
                                elem.parentNode.removeChild(elem);
                            }

                            for (; i >= 0; i -= 1) {
                                elem = characterArr[i].elem;
                                if (classNameBrReg.test(elem.className)) {
                                    //chech whether this span is temporary inserted span from it's class
                                    elem.parentNode.removeChild(elem);
                                } else {
                                    i = 0;
                                }
                            }
                        }

                        //get the smart text
                        smartLabel.text = container.innerHTML.replace(spanRemovalRegx, '$1');
                        if (smartLabel.isTruncated) {
                            smartLabel.text += ellipsesStr;
                            smartLabel.tooltext = toolText;
                        }
                    }

                    smartLabel.height = container.offsetHeight;
                    smartLabel.width = container.offsetWidth;

                    // fix for screenreader
                    //container.innerHTML = "";

                    return smartLabel;
                }
                else {
                    smartLabel.error = new Error('Body Tag Missing!');
                    return smartLabel;
                }
            },

            setStyle : function (style) {

                if (!this.init) {
                    return false;
                }

                var sCont;

                if (style === this.style && !this.styleNotSet) {
                    return;
                }

                if (!style) {
                    style = this.style;
                }

                setLineHeight(style);
                this.style = style;

                this.containerObj = sCont = this.containerManager.get(style);

                if (this.containerObj) {
                    this.container = sCont.node;
                    this.context = sCont.context;
                    this.cache = sCont.charCache;
                    this.lineHeight = sCont.lineHeight;
                    ellipsesWidth = sCont.ellipsesWidth;
                    dotWidth =  sCont.dotWidth;
                    avgCharWidth = sCont.dotWidth;
                    this.styleNotSet = false;
                } else {
                    this.styleNotSet = true;
                }
            },

            getTextSize : function (text, maxWidth, maxHeight) {
                if (!this.init) {
                    return false;
                }
                var smartLabel = {
                        text : text,
                        width : null,
                        height : null,
                        oriTextWidth : null,
                        oriTextHeight : null,
                        isTruncated : false
                    },
                    container = this.container;

                if (container) {
                    //To get text size set the text as innerhtml
                    container.innerHTML = text;
                    //add oriTextWidth & oriTextHeight
                    smartLabel.oriTextWidth = container.offsetWidth;
                    smartLabel.oriTextHeight = container.offsetHeight;
                    smartLabel.width = Math.min(smartLabel.oriTextWidth, maxWidth);
                    smartLabel.height = Math.min(smartLabel.oriTextHeight, maxHeight);
                    if (smartLabel.width < smartLabel.oriTextWidth || smartLabel.height < smartLabel.oriTextHeight) {
                        smartLabel.isTruncated = true;
                    }
                }
                return smartLabel;
            },

            getOriSize: function(text) {
                if (!this.init) {
                    return false;
                }

                var sl = this,
                    smartLabel = {
                        text : text,
                        width : null,
                        height : null
                    },
                    container = sl.container,
                    getWidth = sl.getWidthFunction(),
                    textLines,
                    maxW = 0,
                    i;

                if (isBrowserLess) {
                    /** @todo: Avoid assuming non-formatted string here */
                    textLines = text.split(/(<br\s*\/*\>)/g);
                    i = textLines.length;
                    smartLabel.height = (sl.lineHeight * i);
                    while (i--) {
                        maxW = mathMax(maxW, getWidth(textLines[i]));
                    }
                    smartLabel.width = maxW;
                }
                else if (container) {
                    //To get text size set the text as innerhtml
                    container.innerHTML = text;

                    //add oriTextWidth & oriTextHeight
                    smartLabel.width = container.offsetWidth;
                    smartLabel.height = container.offsetHeight;
                }
                return smartLabel;
            }
        };

        SmartLabelManager.prototype.constructor = SmartLabelManager;

        return SmartLabelManager;
    }());

    lib.SmartLabelManager = SmartLabelManager;

}]);
/**
 * @private
 * @module fusioncharts.renderer.javascript.numberformatter
 * @requires fusioncharts.renderer.javascript.lib
 */
FusionCharts.register('module', ['private', 'modules.renderer.js-numberformatter', function () {
    var global = this,
        lib = global.hcLib,
        pluckNumber = lib.pluckNumber,
        extend2 = lib.extend2,
        getValidValue = lib.getValidValue,
        pluck = lib.pluck,
        getFirstValue = lib.getFirstValue,
        mathAbs = Math.abs,
        mathPow = Math.pow,
        mathRound = Math.round,
        ONESTRING = '1',
        BLANK = '',
        ZEROSTRING = '0',
        DECIMALSTRING = '.',
        COMMASTRING = ',',
        MINUSSTR = '-',

        regescape = function(text) {
            return text && text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
        },
        //store for all number formater indexed by it's configuration hash key
        NFStore = {},
        /**
         * @note object that is maped to a hash key will only have string type value for all property
         *
         * @param {object} obj object with all string type property value only
         * @returns {string} derived hash key from the object
         */
        objToHash = function (obj) {
            var hashArr = [],
                    i;
            for (i in obj) {
                hashArr.push(i + '_' + obj[i]);
            }
            hashArr.sort();
            return hashArr.join(',');
        },
        /**
         * @note This method create a clone object with all property name in lower case.
         *       This don't works for nasted object property.
         *
         * @param {object} obj object with all string type property value only
         * @returns {object} Cloned object.
         */
        objToLowerCase = function (obj) {
            var clone = {},
                    i;
            for (i in obj) {
                clone[i.toLowerCase()] =  obj[i];
            }
            return clone;
        };

    lib.NumberFormatter = (function () {

        /** @todo Use predefined Strings. */
        var TWOSTRING = '2',
        AUTOSTRING = 'auto',
        formatNumber,

        numberFormatDefaults = {
            formatnumber: ONESTRING,
            formatnumberscale: ONESTRING,
            defaultnumberscale: BLANK,
            numberscaleunit: ['K', 'M'],//'K,M',
            numberscalevalue: [1000, 1000], //'1000,1000',
            numberprefix: BLANK,
            numbersuffix: BLANK,
            // Decimals default value is different in different charts
            decimals: BLANK,
            forcedecimals: ZEROSTRING,
            yaxisvaluedecimals: TWOSTRING,
            decimalseparator: DECIMALSTRING,
            thousandseparator: COMMASTRING,
            // thousandSeparatorPosition new attribute added in numberFormatter
            // this defines the placement of thousandSeparator, defaultValue = 3
            // accepts comma separated value
            thousandseparatorposition: [3],
            indecimalseparator: BLANK,
            inthousandseparator: BLANK,
            sformatnumber: ONESTRING,
            sformatnumberscale: ZEROSTRING,
            sdefaultnumberscale: BLANK,
            snumberscaleunit: ['K','M'],
            snumberscalevalue: [1000, 1000],
            snumberprefix: BLANK,
            snumbersuffix: BLANK,
            sdecimals: TWOSTRING,
            sforcedecimals: ZEROSTRING,
            syaxisvaluedecimals: TWOSTRING,

            xFormatNumber : ZEROSTRING,
            xFormatNumberScale : ZEROSTRING,
            xDefaultNumberScale : BLANK,
            xNumberScaleUnit : ['K','M'],
            xNumberScaleValue : [1000, 1000],
            xNumberPrefix : BLANK,
            xNumberSuffix : BLANK
        },

        numberFormatOverrides = {
            mscombidy2d: {
                formatnumberscale: ONESTRING
            }
        },

        /*
         *  NumberFormatter function
         */
        NumberFormatter = function (chartObj, chartAPI, isMultyAxis) {
            var numberscaleunit,
                snumberscaleunit, xnumberscaleunit, ticknumberscaleunit, ynumberscaleunit,
                numberscalevalue, xnumberscalevalue, ticknumberscalevalue, ynumberscalevalue,
                chartName = chartAPI.name,
                // chartSpecificConf
                csConf = extend2({}, numberFormatDefaults),//,
                thousandseparatorposition,
                snumberscalevalue,
                paramLabels,
                paramLabels2,
                param1,
                param2,
                baseConf,
                length,
                value,
                lastValue,
                scaleRecursively,
                sScaleRecursively,
                xScaleRecursively,
                maxScaleRecursion,
                sMaxScaleRecursion,
                xMaxScaleRecursion,
                scaleSeparator,
                sScaleSeparator,
                xScaleSeparator,
                overrideConf = numberFormatOverrides[chartName];

            if (overrideConf) {
                csConf = extend2(csConf, overrideConf);
            }
            this.csConf = csConf;
            this.chartAPI = chartAPI;

            // Converting user given numberScaleUnit into array
            if (getValidValue(chartObj.numberscaleunit)) {
                numberscaleunit = chartObj.numberscaleunit.split(COMMASTRING);
            }
            if ((snumberscaleunit = getValidValue(chartObj.snumberscaleunit, chartObj.numberscaleunit))) {
                snumberscaleunit = snumberscaleunit.split(COMMASTRING);
            }
            if ((xnumberscaleunit = getValidValue(chartObj.xnumberscaleunit, chartObj.numberscaleunit))) {
                xnumberscaleunit = xnumberscaleunit.split(COMMASTRING);
            }
            if ((ticknumberscaleunit = getValidValue(chartObj.ticknumberscaleunit, chartObj.numberscaleunit))) {
                ticknumberscaleunit = ticknumberscaleunit.split(COMMASTRING);
            }
            if ((ynumberscaleunit = getValidValue(chartObj.ynumberscaleunit, chartObj.numberscaleunit))) {
                ynumberscaleunit = ynumberscaleunit.split(COMMASTRING);
            }

            // Converting user given numberScaleValue into array
            if (getValidValue(chartObj.numberscalevalue)) {
                numberscalevalue = chartObj.numberscalevalue.split(COMMASTRING);
            }
            if ((snumberscalevalue = getValidValue(chartObj.snumberscalevalue, chartObj.numberscalevalue))) {
                snumberscalevalue = snumberscalevalue.split(COMMASTRING);
            }
            if ((xnumberscalevalue = getValidValue(chartObj.xnumberscalevalue, chartObj.numberscalevalue))) {
                xnumberscalevalue = xnumberscalevalue.split(COMMASTRING);
            }
            if ((ticknumberscalevalue = getValidValue(chartObj.ticknumberscalevalue, chartObj.numberscalevalue))) {
                ticknumberscalevalue = ticknumberscalevalue.split(COMMASTRING);
            }
            if ((ynumberscalevalue = getValidValue(chartObj.ynumberscalevalue, chartObj.numberscalevalue))) {
                ynumberscalevalue = ynumberscalevalue.split(COMMASTRING);
            }
            // Converting user given numberScaleValue into array
            if(getValidValue(chartObj.thousandseparatorposition)) {
                thousandseparatorposition = chartObj.thousandseparatorposition.split(COMMASTRING);
                length = thousandseparatorposition.length;
                lastValue = numberFormatDefaults.thousandseparatorposition[0];
                // Filtering the user given values
                while (length--) {
                    value = parseInt(thousandseparatorposition[length], 10);
                    if ((value <= 0)) {
                        value = lastValue;
                    }
                    lastValue = thousandseparatorposition[length] = value;
                    //thSepPosREGX = DECIMALSEPSTR + value + CLOSEBRACESSTR + thSepPosREGX;
                }
            }

            if (!chartAPI) {
                chartAPI = {};
            }

            scaleRecursively = pluckNumber(chartObj.scalerecursively, 0);
            sScaleRecursively = pluckNumber(chartObj.sscalerecursively, scaleRecursively);
            xScaleRecursively = pluckNumber(chartObj.xscalerecursively, scaleRecursively);
            maxScaleRecursion = pluckNumber(chartObj.maxscalerecursion, -1);
            sMaxScaleRecursion = pluckNumber(chartObj.smaxscalerecursion, maxScaleRecursion);
            xMaxScaleRecursion = pluckNumber(chartObj.xmaxscalerecursion, maxScaleRecursion);
            scaleSeparator = getValidValue(chartObj.scaleseparator, ' ');
            sScaleSeparator = getValidValue(chartObj.sscaleseparator, scaleSeparator);
            xScaleSeparator = getValidValue(chartObj.xscaleseparator, scaleSeparator);
            if (!maxScaleRecursion) {
                maxScaleRecursion = -1;
            }

            //create base number formater
            this.baseConf = baseConf = {
                cacheStore: [],
                formatnumber: pluck(chartObj.formatnumber, chartAPI.formatnumber, csConf.formatnumber),
                formatnumberscale: pluck(chartObj.formatnumberscale, chartAPI.formatnumberscale,
                    csConf.formatnumberscale),
                defaultnumberscale: getFirstValue(chartObj.defaultnumberscale, chartAPI.defaultnumberscale,
                    csConf.defaultnumberscale),
                numberscaleunit: pluck(numberscaleunit, chartAPI.numberscaleunit, csConf.numberscaleunit).concat(),
                numberscalevalue: pluck(numberscalevalue, chartAPI.numberscalevalue, csConf.numberscalevalue).concat(),
                numberprefix: getFirstValue(chartObj.numberprefix, chartAPI.numberprefix, csConf.numberprefix),
                numbersuffix: getFirstValue(chartObj.numbersuffix, chartAPI.numbersuffix, csConf.numbersuffix),
                decimalprecision: parseInt(chartObj.decimals === AUTOSTRING ? csConf.decimalprecision :
                    pluck(chartObj.decimals, chartObj.decimalprecision, chartAPI.decimals, csConf.decimals,
                    chartAPI.decimalprecision, csConf.decimalprecision), 10),
                forcedecimals: pluck(chartObj.forcedecimals, chartAPI.forcedecimals, csConf.forcedecimals),
                decimalseparator: pluck(chartObj.decimalseparator, chartAPI.decimalseparator, csConf.decimalseparator),
                thousandseparator: pluck(chartObj.thousandseparator, chartAPI.thousandseparator,
                    csConf.thousandseparator),
                thousandseparatorposition: pluck(thousandseparatorposition, chartAPI.thousandseparatorposition,
                    csConf.thousandseparatorposition),
                indecimalseparator: getFirstValue(chartObj.indecimalseparator, chartAPI.indecimalseparator,
                    csConf.indecimalseparator),
                inthousandseparator: getFirstValue(chartObj.inthousandseparator, chartAPI.inthousandseparator,
                    csConf.inthousandseparator),
                scalerecursively: scaleRecursively,
                maxscalerecursion: maxScaleRecursion,
                scaleseparator: scaleSeparator
            };

            //create the regex for inthousendseperator
            if (getValidValue(baseConf.inthousandseparator)) {
                this.baseConf._REGinthousandseparator = new RegExp(regescape(baseConf.inthousandseparator), 'g');
            }
            if (getValidValue(baseConf.indecimalseparator)) {
                this.baseConf._REGindecimalseparator = new RegExp(regescape(baseConf.indecimalseparator));
            }

            this.Y = [];

            /**
             * @todo Do all Multi-Y-Axis calculations.
             */
            if (!isMultyAxis) {
                // Parameters passed with this function
                paramLabels = {
                    cacheStore: [],
                    formatnumber: baseConf.formatnumber,
                    formatnumberscale: baseConf.formatnumberscale,
                    //defaultnumberscale  : pluck(chartObj.defaultnumberscale, (numberFormatOverrides[chartName] &&
                    //numberFormatOverrides[chartName].defaultnumberscale)) || numberFormatDefaults.defaultnumberscale,
                    defaultnumberscale: baseConf.defaultnumberscale,
                    numberscaleunit: baseConf.numberscaleunit.concat(),
                    numberscalevalue: baseConf.numberscalevalue.concat(),
                    numberprefix: baseConf.numberprefix,
                    numbersuffix: baseConf.numbersuffix,
                    decimalprecision: baseConf.decimalprecision,
                    forcedecimals: baseConf.forcedecimals,
                    decimalseparator: baseConf.decimalseparator,
                    thousandseparator: baseConf.thousandseparator,
                    thousandseparatorposition: baseConf.thousandseparatorposition,
                    indecimalseparator: baseConf.indecimalseparator,
                    inthousandseparator: baseConf.inthousandseparator,
                    scalerecursively: scaleRecursively,
                    maxscalerecursion: maxScaleRecursion,
                    scaleseparator: scaleSeparator
                };
                // scaleRecursively will use only by Widgets.
                if (!chartAPI.useScaleRecursively || ((paramLabels.numberscalevalue &&
                    paramLabels.numberscalevalue.length) != (paramLabels.numberscaleunit &&
                    paramLabels.numberscaleunit.length))) {
                    paramLabels.scalerecursively = scaleRecursively = 0;
                }

                param1 = {
                    cacheStore: [],
                    formatnumber: paramLabels.formatnumber,
                    formatnumberscale: paramLabels.formatnumberscale,
                    defaultnumberscale: paramLabels.defaultnumberscale,
                    numberscaleunit: paramLabels.numberscaleunit.concat(),
                    numberscalevalue: paramLabels.numberscalevalue.concat(),
                    numberprefix: paramLabels.numberprefix,
                    numbersuffix: paramLabels.numbersuffix,
                    decimalprecision: parseInt(pluck(chartObj.yaxisvaluedecimals, paramLabels.decimalprecision, 2), 10),
                    forcedecimals: pluck(chartObj.forceyaxisvaluedecimals, paramLabels.forcedecimals),
                    decimalseparator: paramLabels.decimalseparator,
                    thousandseparator: paramLabels.thousandseparator,
                    thousandseparatorposition: paramLabels.thousandseparatorposition.concat(),
                    indecimalseparator: paramLabels.indecimalseparator,
                    inthousandseparator: paramLabels.inthousandseparator,
                    scalerecursively: scaleRecursively,
                    maxscalerecursion: maxScaleRecursion,
                    scaleseparator: scaleSeparator
                };


                // Parameters for sScale (secondary axis)
                param2 = {
                    cacheStore: [],
                    formatnumber: pluck(chartObj.sformatnumber, chartAPI.sformatnumber,
                        numberFormatDefaults.sformatnumber),
                    formatnumberscale: pluck(chartObj.sformatnumberscale, chartAPI.sformatnumberscale,
                        numberFormatDefaults.sformatnumberscale),
                    defaultnumberscale: getFirstValue(chartObj.sdefaultnumberscale, chartAPI.sdefaultnumberscale,
                        paramLabels.defaultnumberscale),
                    numberscaleunit: pluck(snumberscaleunit, chartAPI.snumberscaleunit,
                        numberFormatDefaults.snumberscaleunit).concat(),
                    numberscalevalue: pluck(snumberscalevalue, chartAPI.snumberscalevalue,
                        numberFormatDefaults.snumberscalevalue).concat(),
                    numberprefix: getFirstValue(chartObj.snumberprefix, chartAPI.snumberprefix,
                        numberFormatDefaults.snumberprefix),
                    numbersuffix: getFirstValue(chartObj.snumbersuffix, chartAPI.snumbersuffix,
                        numberFormatDefaults.snumbersuffix),
                    decimalprecision: parseInt(pluck(chartObj.syaxisvaluedecimals, chartObj.sdecimals,
                        chartObj.decimals, chartAPI.sdecimals, numberFormatDefaults.sdecimals), 10),
                    forcedecimals: pluck(chartObj.forcesyaxisvaluedecimals, chartObj.sforcedecimals,
                        chartObj.forcedecimals, chartAPI.sforcedecimals, numberFormatDefaults.sforcedecimals),
                    decimalseparator: pluck(chartObj.decimalseparator, chartAPI.decimalseparator,
                        numberFormatDefaults.decimalseparator),
                    thousandseparator: pluck(chartObj.thousandseparator, chartAPI.thousandseparator,
                        numberFormatDefaults.thousandseparator),
                    thousandseparatorposition: paramLabels.thousandseparatorposition.concat(),
                    indecimalseparator: pluck(chartObj.indecimalseparator, chartAPI.indecimalseparator,
                        numberFormatDefaults.indecimalseparator),
                    inthousandseparator: pluck(chartObj.inthousandseparator, chartAPI.inthousandseparator,
                        numberFormatDefaults.inthousandseparator),
                    scalerecursively: sScaleRecursively,
                    maxscalerecursion: sMaxScaleRecursion,
                    scaleseparator: sScaleSeparator
                };

            // MultiAxisLine chart secondary yAxis numberFormatter attribute mapping wrt primary yAxis
//              if (/^(multiaxisline)$/.test(chartName)) {
//                  param2.formatnumber = pluck(chartObj.sformatnumber, chartObj.formatnumber, chartAPI.sformatnumber,
//                  numberFormatDefaults.sformatnumber);
//                  param2.formatnumberscale = pluck(chartObj.sformatnumberscale, chartObj.formatnumberscale,
//                  chartAPI.sformatnumberscale, numberFormatDefaults.sformatnumberscale);
//                  param2.defaultnumberscale = getFirstValue(chartObj.sdefaultnumberscale, chartObj.defaultnumberscale,
//                   chartAPI.sdefaultnumberscale, paramLabels.defaultnumberscale);
//                  param2.numberprefix = getFirstValue(chartObj.snumberprefix, chartObj.numberprefix,
//                  chartAPI.snumberprefix, numberFormatDefaults.snumberprefix);
//                  param2.numbersuffix = getFirstValue(chartObj.snumbersuffix, chartObj.numbersuffix,
//                  chartAPI.snumbersuffix, numberFormatDefaults.snumbersuffix);
//                  param2.decimalprecision = parseInt(pluck(chartObj.syaxisvaluedecimals, chartObj.yaxisvaluedecimals,
//                  chartObj.sdecimals, chartObj.decimals, chartAPI.sdecimals, numberFormatDefaults.sdecimals), 10);
//                  param2.forcedecimals = pluck(chartObj.forcesyaxisvaluedecimals, chartObj.forceyaxisvaluedecimals,
//                  chartObj.sforcedecimals, chartObj.forcedecimals, chartAPI.sforcedecimals,
//                  numberFormatDefaults.sforcedecimals);
//              }
                // For secondary yAxis datalabels
                paramLabels2 = extend2({}, param2);
                paramLabels2.decimalprecision = parseInt(pluck(chartObj.sdecimals, chartObj.decimals,
                    chartObj.syaxisvaluedecimals, chartAPI.sdecimals, numberFormatDefaults.sdecimals), 10);
                paramLabels2.forcedecimals = pluck(chartObj.sforcedecimals, chartObj.forcedecimals,
                    chartObj.forcesyaxisvaluedecimals, chartAPI.sforcedecimals, numberFormatDefaults.sforcedecimals);
                //add new cache store
                paramLabels2.cacheStore = [];

                // scaleRecursively will use only by Widgets.
                if (!chartAPI.useScaleRecursively || ((param2.numberscalevalue && param2.numberscalevalue.length) !=
                        (param2.numberscaleunit && param2.numberscaleunit.length))) {
                    param2.scalerecursively = sScaleRecursively = 0;
                }



                /** @todo Instead of testing chart-name, use default values or testing using chart API
                 // Adding special attributes for yAxis (scatter and bubble) charts */
                if (/^(bubble|scatter|selectscatter)$/.test(chartName)) {
                    param1.formatnumber = pluck(chartObj.yformatnumber, param1.formatnumber);
                    param1.formatnumberscale = pluck(chartObj.yformatnumberscale, param1.formatnumberscale);
                    param1.defaultnumberscale = getFirstValue(chartObj.ydefaultnumberscale, param1.defaultnumberscale);
                    param1.numberscaleunit = pluck(ynumberscaleunit, param1.numberscaleunit);
                    param1.numberscalevalue = pluck(ynumberscalevalue, param1.numberscalevalue);
                    param1.numberprefix = pluck(chartObj.ynumberprefix, param1.numberprefix);
                    param1.numbersuffix = pluck(chartObj.ynumbersuffix, param1.numbersuffix);
                    //
                    paramLabels.formatnumber = pluck(chartObj.yformatnumber, paramLabels.formatnumber);
                    paramLabels.formatnumberscale = pluck(chartObj.yformatnumberscale, paramLabels.formatnumberscale);
                    paramLabels.defaultnumberscale = getFirstValue(chartObj.ydefaultnumberscale,
                        paramLabels.defaultnumberscale);
                    paramLabels.numberscaleunit = pluck(chartObj.ynumberscaleunit,
                        paramLabels.numberscaleunit.concat());
                    paramLabels.numberscalevalue = pluck(chartObj.ynumberscalevalue,
                        paramLabels.numberscalevalue.concat());
                    paramLabels.numberprefix = pluck(chartObj.ynumberprefix, paramLabels.numberprefix);
                    paramLabels.numbersuffix = pluck(chartObj.ynumbersuffix, paramLabels.numbersuffix);
                }

                // Adding special attributes for secondary yAxis
                if (/^(mscombidy2d|mscombidy3d)$/.test(chartName)) {
                    param2.formatnumberscale = pluckNumber(chartObj.sformatnumberscale);
                }

                // Fix for some chart decimals default value different
                if (/^(pie2d|pie3d|doughnut2d|doughnut3d|marimekko|pareto2d|pareto3d)$/.test(chartName)) {
                    paramLabels.decimalprecision = pluck(chartObj.decimals, TWOSTRING);
                }

                // Adjusting numberScaleValue and numberScaleUnit array to be use in
                // the calculation of scaleRecursively
                if (scaleRecursively) {
                    paramLabels.numberscalevalue.push(1);
                    paramLabels.numberscaleunit.unshift(paramLabels.defaultnumberscale);

                    param1.numberscalevalue.push(1);
                    param1.numberscaleunit.unshift(param1.defaultnumberscale);
                }
                if (sScaleRecursively) {
                    param2.numberscalevalue.push(1);
                    param2.numberscaleunit.unshift(param2.defaultnumberscale);

                    paramLabels2.numberscalevalue.push(1);
                    paramLabels2.numberscaleunit.unshift(paramLabels2.defaultnumberscale);
                }

                this.Y[0] = {
                    yAxisLabelConf: param1,
                    dataLabelConf: paramLabels
                };
                this.Y[1] = {
                    yAxisLabelConf: param2,
                    dataLabelConf: paramLabels2
                } ;
                //for backword compatibility issue
                /** @todo: have to be removed after removing all dependency */
                this.paramLabels = paramLabels;
                this.param1 = param1;
                this.param2 = param2;
                this.paramLabels2 = paramLabels2;
            }

            /** @todo: create paramX & paramScale only if requird  */

            //xAxis Label formatter for scatter type X-y plot charts
             // Parameters for xScale
            this.paramX = {
                cacheStore: [],
                formatnumber: pluck(chartObj.xformatnumber, baseConf.formatnumber),
                formatnumberscale: pluck(chartObj.xformatnumberscale, baseConf.formatnumberscale),
                defaultnumberscale: getFirstValue(chartObj.xdefaultnumberscale, baseConf.defaultnumberscale),
                numberscaleunit: pluck(xnumberscaleunit, baseConf.numberscaleunit.concat()),
                numberscalevalue: pluck(xnumberscalevalue, baseConf.numberscalevalue.concat()),
                numberprefix: pluck(chartObj.xnumberprefix, baseConf.numberprefix),
                numbersuffix: pluck(chartObj.xnumbersuffix, baseConf.numbersuffix),
                decimalprecision: parseInt(pluck(chartObj.xaxisvaluedecimals, chartObj.xaxisvaluesdecimals,
                    baseConf.decimalprecision, 2), 10),
                forcedecimals: pluck(chartObj.forcexaxisvaluedecimals, 0),
                decimalseparator: baseConf.decimalseparator,
                thousandseparator: baseConf.thousandseparator,
                thousandseparatorposition: baseConf.thousandseparatorposition.concat(),
                indecimalseparator: baseConf.indecimalseparator,
                inthousandseparator: baseConf.inthousandseparator,
                scalerecursively: xScaleRecursively,
                maxscalerecursion: xMaxScaleRecursion,
                scaleseparator: xScaleSeparator
            };

            this.paramLegend = extend2(extend2({}, baseConf), {
                cacheStore: [],
                decimalprecision: parseInt(pluckNumber(chartObj.legendvaluedecimals, baseConf.decimalprecision, 2), 10),
                forcedecimals: pluckNumber(chartObj.legendvalueforcedecimals, baseConf.forcedecimals, 0),
                formatnumberscale: pluck(chartObj.legendvalueformatnumberscale, baseConf.formatnumberscale),
                formatnumber: pluck(chartObj.legendvalueformatnumber, baseConf.formatnumber)
            });

            // scaleRecursively will use only by Widgets.
            if (!chartAPI.useScaleRecursively || ((this.paramX.numberscalevalue &&
                this.paramX.numberscalevalue.length) != (this.paramX.numberscaleunit &&
                this.paramX.numberscaleunit.length))) {
                this.paramX.scalerecursively = xScaleRecursively = 0;
            }

            if (xScaleRecursively) {
                this.paramX.numberscalevalue.push(1);
                this.paramX.numberscaleunit.unshift(this.paramX.defaultnumberscale);
            }

            this.paramScale = {
                cacheStore: [],
                formatnumber: pluck(chartObj.tickformatnumber, baseConf.formatnumber),
                formatnumberscale: pluck(chartObj.tickformatnumberscale, baseConf.formatnumberscale),
                defaultnumberscale: getFirstValue(chartObj.tickdefaultnumberscale, baseConf.defaultnumberscale),
                numberscaleunit: pluck(ticknumberscaleunit, baseConf.numberscaleunit.concat()),
                numberscalevalue: pluck(ticknumberscalevalue, baseConf.numberscalevalue.concat()),
                numberprefix: pluck(chartObj.ticknumberprefix, baseConf.numberprefix),
                numbersuffix: pluck(chartObj.ticknumbersuffix, baseConf.numbersuffix),
                decimalprecision: parseInt(pluck(chartObj.tickvaluedecimals, baseConf.decimalprecision, TWOSTRING), 10),
                forcedecimals: pluck(chartObj.forcetickvaluedecimals, baseConf.forcedecimals, 0),
                decimalseparator: baseConf.decimalseparator,
                thousandseparator: baseConf.thousandseparator,
                thousandseparatorposition: baseConf.thousandseparatorposition.concat(),
                indecimalseparator: baseConf.indecimalseparator,
                inthousandseparator: baseConf.inthousandseparator,
                scalerecursively: scaleRecursively,
                maxscalerecursion: maxScaleRecursion,
                scaleseparator: scaleSeparator
            };

            // Adjusting numberScaleValue and numberScaleUnit array to be use in
            // the calculation of scaleRecursively
            if (scaleRecursively) {
                this.paramScale.numberscalevalue.push(1);
                this.paramScale.numberscaleunit.unshift(this.paramScale.defaultnumberscale);
            }

            //dateTime parser conf
            this.timeConf = {
                inputDateFormat: pluck(chartObj.inputdateformat, chartObj.dateformat, 'mm/dd/yyyy'),
                outputDateFormat: pluck(chartObj.outputdateformat, chartObj.inputdateformat, chartObj.dateformat,
                    'mm/dd/yyyy'),
                days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',
                        'October', 'November', 'December'],
                daySuffix: ['', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'th',
                   'th', 'th', 'th', 'th', 'th', 'th', 'st', 'nd', 'rd', 'th', 'th', 'th', 'th', 'th', 'th', 'th', 'st']
            };

            // setting an object level cache store for percent value and clean value, since setting
            // them at prototype level will not force them to be cleared during new object creation.
            this.cleaneValueCacheStore = {};
            this.percentStrCacheStore = {};
        };

        NumberFormatter.prototype = {
            /**@todo  These two cache stores can be removed from the prototype ideally, since these two stores are
            set object level now. But in case some part of the code is accessing the numberformatter via the
            prototype instead of object it might fail.*/
            cleaneValueCacheStore: {},
            percentStrCacheStore: {},
            //delete all object ref and cache store
            dispose: function () {
                var Numberformatter = this;
                //delete y axis params
                if (Numberformatter.Y){
                    delete Numberformatter.Y;
                }
                //delete cleaneValueCacheStore
                if (Numberformatter.cleaneValueCacheStore){
                    delete Numberformatter.cleaneValueCacheStore;
                }
                //delete cleaneValueCacheStore
                if (Numberformatter.percentStrCacheStore){
                    delete Numberformatter.percentStrCacheStore;
                }
                //delete baseConf
                if (Numberformatter.paramLabels){
                    delete Numberformatter.paramLabels;
                }
                //delete baseConf
                if (Numberformatter.param1){
                    delete Numberformatter.param1;
                }
                //delete baseConf
                if (Numberformatter.param2){
                    delete Numberformatter.param2;
                }
                //delete baseConf
                if (Numberformatter.paramLabels2){
                    delete Numberformatter.paramLabels2;
                }
                //delete baseConf
                if (Numberformatter.csConf){
                    delete Numberformatter.csConf;
                }
                //delete baseConf
                if (Numberformatter.chartAPI){
                    delete Numberformatter.chartAPI;
                }
                //delete baseConf
                if (Numberformatter.baseConf){
                    delete Numberformatter.baseConf;
                }
                //delete timeConf
                if (Numberformatter.timeConf){
                    delete Numberformatter.timeConf;
                }
                //delete paramX
                if (Numberformatter.paramX){
                    delete Numberformatter.paramX;
                }
                //delete paramScale
                if (Numberformatter.paramScale){
                    delete Numberformatter.paramScale;
                }
            },
            parseMLAxisConf: function (axisObj, index){
                var baseConf = this.baseConf,
                    csConf = this.csConf,
                    chartAPI = this.chartAPI,
                    scaleRecursively = pluckNumber(axisObj.scalerecursively, baseConf.scalerecursively),
                    maxScaleRecursion = pluckNumber(axisObj.maxscalerecursion, baseConf.maxscalerecursion),
                    scaleSeparator = getValidValue(axisObj.scaleseparator, baseConf.scaleseparator),
                    paramLabels,
                    numberscaleunit,
                    numberscalevalue,
                    param,
                    thousandseparatorposition,
                    length,
                    value,
                    lastValue;

                index = pluckNumber(index, this.Y.length);

                if (getValidValue(axisObj.numberscaleunit)) {
                    numberscaleunit = axisObj.numberscaleunit.split(COMMASTRING);
                }
                // Converting user given numberScaleValue into array
                if (getValidValue(axisObj.numberscalevalue)) {
                    numberscalevalue = axisObj.numberscalevalue.split(COMMASTRING);
                }
                if (!maxScaleRecursion) {
                    maxScaleRecursion = -1;
                }
                // Converting user given numberScaleValue into array
                if(getValidValue(axisObj.thousandseparatorposition)) {
                    thousandseparatorposition = axisObj.thousandseparatorposition.split(COMMASTRING);
                    length = thousandseparatorposition.length;
                    //value;
                    lastValue = numberFormatDefaults.thousandseparatorposition[0];
                    // Filtering the user given values
                    while (length--) {
                        value = pluckNumber(mathAbs(thousandseparatorposition[length]));
                        if (!value) {
                            value = lastValue;
                        } else {
                            lastValue = value;
                        }
                        thousandseparatorposition[length] = value;
                    }
                }
                // Parameters passed with this function
                paramLabels = {
                    cacheStore: [],
                    formatnumber: pluck(axisObj.formatnumber, baseConf.formatnumber),
                    formatnumberscale: pluck(axisObj.formatnumberscale, baseConf.formatnumberscale),
                    //defaultnumberscale  : pluck(chartObj.defaultnumberscale, (numberFormatOverrides[chartName] &&
                    //numberFormatOverrides[chartName].defaultnumberscale)) || numberFormatDefaults.defaultnumberscale,
                    defaultnumberscale: getFirstValue(axisObj.defaultnumberscale, baseConf.defaultnumberscale),
                    numberscaleunit: pluck(numberscaleunit, baseConf.numberscaleunit).concat(),
                    numberscalevalue: pluck(numberscalevalue, baseConf.numberscalevalue).concat(),
                    numberprefix: getFirstValue(axisObj.numberprefix, baseConf.numberprefix),
                    numbersuffix: getFirstValue(axisObj.numbersuffix, baseConf.numbersuffix),
                    forcedecimals: pluck(axisObj.forcedecimals, baseConf.forcedecimals),
                    decimalprecision:parseInt(axisObj.decimals === AUTOSTRING ? csConf.decimalprecision :
                                pluck(axisObj.decimals, baseConf.decimalprecision), 10),
                    decimalseparator: pluck(axisObj.decimalseparator, baseConf.decimalseparator),
                    thousandseparator: pluck(axisObj.thousandseparator, baseConf.thousandseparator),
                    thousandseparatorposition:  pluck(thousandseparatorposition, baseConf.thousandseparatorposition),
                    indecimalseparator: getFirstValue(axisObj.indecimalseparator, baseConf.indecimalseparator),
                    inthousandseparator: getFirstValue(axisObj.inthousandseparator, baseConf.inthousandseparator),
                    scalerecursively: scaleRecursively,
                    maxscalerecursion: maxScaleRecursion,
                    scaleseparator: scaleSeparator
                };
                // scaleRecursively will use only by Widgets.
                if (!chartAPI.useScaleRecursively || ((paramLabels.numberscalevalue &&
                        paramLabels.numberscalevalue.length) != (paramLabels.numberscaleunit &&
                        paramLabels.numberscaleunit.length))) {
                    paramLabels.scalerecursively = scaleRecursively = 0;
                }

                param = {
                    cacheStore: [],
                    formatnumber: paramLabels.formatnumber,
                    formatnumberscale: paramLabels.formatnumberscale,
                    defaultnumberscale: paramLabels.defaultnumberscale,
                    numberscaleunit: paramLabels.numberscaleunit.concat(),
                    numberscalevalue: paramLabels.numberscalevalue.concat(),
                    numberprefix: paramLabels.numberprefix,
                    numbersuffix: paramLabels.numbersuffix,
                    decimalprecision: parseInt(pluck(axisObj.yaxisvaluedecimals, paramLabels.decimalprecision, 2), 10),
                    forcedecimals: pluck(axisObj.forceyaxisvaluedecimals, paramLabels.forcedecimals),
                    decimalseparator: paramLabels.decimalseparator,
                    thousandseparator: paramLabels.thousandseparator,
                    thousandseparatorposition: paramLabels.thousandseparatorposition.concat(),
                    indecimalseparator: paramLabels.indecimalseparator,
                    inthousandseparator: paramLabels.inthousandseparator,
                    scalerecursively: scaleRecursively,
                    maxscalerecursion: maxScaleRecursion,
                    scaleseparator: scaleSeparator
                };

                // Adjusting numberScaleValue and numberScaleUnit array to be use in
                // the calculation of scaleRecursively
                if (scaleRecursively) {
                    paramLabels.numberscalevalue.push(1);
                    paramLabels.numberscaleunit.unshift(paramLabels.defaultnumberscale);

                    param.numberscalevalue.push(1);
                    param.numberscaleunit.unshift(param.defaultnumberscale);
                }

                this.Y[index] = {
                    dataLabelConf: paramLabels,
                    yAxisLabelConf: param
                };
            },
            percentValue : function (num) {//don't use 2'nd argument it may conflict with yAxis()'s 2'nd arg
                var rtn = this.percentStrCacheStore[num],
                        precision;
                if (rtn === undefined) {
                    precision = isNaN(this.paramLabels.decimalprecision) ? '2' : this.paramLabels.decimalprecision;
                    rtn = this.percentStrCacheStore[num] = formatCommas (formatDecimals(num, precision,
                        this.paramLabels.forcedecimals), this.paramLabels.decimalseparator,
                        this.paramLabels.thousandseparator, this.paramLabels.thousandseparatorposition) + '%';
                }
                return rtn;
            },
            // configuration of getCleanValue will be same across all dataset/axis
            getCleanValue: function (numStr, abs) {
                var rtn = this.cleaneValueCacheStore[numStr],
                        num;
                if (rtn === undefined){
                    num = convertNumberSeps(numStr, this.baseConf);
                    this.cleaneValueCacheStore[numStr] = rtn = isNaN(num) ? null : (abs ? mathAbs(num) : num);
                }
                return rtn;
            },
            dataLabels: function (num, axisIndex) {
                var formatterConf = this.Y[axisIndex] || (axisIndex ? this.Y[1] : this.Y[0]),
                        rtn;
                formatterConf = (formatterConf && formatterConf.dataLabelConf) || this.baseConf;
                rtn = formatterConf.cacheStore[num];
                if (rtn === undefined){
                    rtn = formatterConf.cacheStore[num] = formatNumber(num, formatterConf);
                }
                return rtn;
            },
            yAxis: function (num, axisIndex) {
                var formatterConf = this.Y[axisIndex] || (axisIndex ? this.Y[1] : this.Y[0]),
                        rtn;
                formatterConf = (formatterConf && formatterConf.yAxisLabelConf) || this.baseConf;
                rtn = formatterConf.cacheStore[num];
                if (rtn === undefined){
                    // Last parameter denotes whether value is axis value or not
                    rtn = formatterConf.cacheStore[num] = formatNumber(num, formatterConf, true);
                }
                return rtn;
            },
            //don't use 2'nd argument it may conflict with y axis 2'nd arg
            //refer to use of numberformater during trendline parsing
            xAxis: function (num) {
                var rtn = this.paramX.cacheStore[num];
                if (rtn === undefined){
                    // Last parameter denotes whether value is axis value or not
                    rtn = this.paramX.cacheStore[num] = formatNumber(num, this.paramX, true);
                }
                return rtn;
            },
            sYAxis: function (num) {
                var formatterConf = this.Y[1],
                        rtn;
                formatterConf = (formatterConf && formatterConf.yAxisLabelConf) || this.baseConf;
                rtn = formatterConf.cacheStore[num];
                if (rtn === undefined){
                    rtn = formatterConf.cacheStore[num] = formatNumber(num, formatterConf);
                }
                return rtn;
            },
            scale: function (num) {
                var rtn = this.paramScale.cacheStore[num];
                if (rtn === undefined){
                    rtn = this.paramScale.cacheStore[num] = formatNumber(num, this.paramScale);
                }
                return rtn;
            },
            //for time type date
            getCleanTime: function(date){
                var dateObj;
                if (this.timeConf.inputDateFormat && Date.parseExact) {
                    dateObj = Date.parseExact(date, this.timeConf.inputDateFormat);
                }
                //store all dateobj and converted values as index for further fast access

                return dateObj && dateObj.getTime();
            },

            legendValue: function (num) {
                var rtn = this.paramLegend.cacheStore[num];
                if (rtn === undefined) {
                    rtn = this.paramLegend.cacheStore[num] = formatNumber(num, this.paramLegend);
                }
                return rtn;
            },

            legendPercentValue : function (num) {
                var rtn = this.percentStrCacheStore[num],
                    paramLegend = this.paramLegend,
                    precision;
                if (rtn === undefined) {
                    precision = isNaN(paramLegend.decimalprecision) ? '2' : paramLegend.decimalprecision;
                    rtn = this.percentStrCacheStore[num] = formatCommas(formatDecimals(num, precision,
                        paramLegend.forcedecimals), paramLegend.decimalseparator, paramLegend.thousandseparator,
                        paramLegend.thousandseparatorposition) + '%';
                }
                return rtn;
            },


            /**
             * getDateValue is the date formatter function which converts date
             * to milliseconds
             *
             * @param {string} date Date to be converted
             * @returns {object} Object with the key ms containing milliseconds
             * and date containing date object
             */
            getDateValue: function (date) {
                var dataObj,
                    hour,
                    min,
                    sec,
                    ms;

                // Convert the date provided in argument from any format to
                // supported in 'inputDateFormat' configuration to a standard
                // JavaScript date parseable format
                date = /^dd/.test(this.timeConf.inputDateFormat) && date &&
                    date.replace(/(\d{1,2})\/(\d{1,2})\/(\d{2,4})/, '$2/$1/$3') || date;

                dataObj = new Date(date);
                ms = dataObj.getTime();

                // If date is in time format (hh:mm:ss)
                if (!ms && date && /\:/.test(date)) {
                    // Extract hour, min and seconds
                    date = date.split(':');
                    hour = pluckNumber(date[0], 0);
                    min = pluckNumber(date[1], 0);
                    sec = pluckNumber(date[2], 0);

                    // validate hour, min and sec
                    hour = (hour > 23) ? ((hour === 24 && min === 0 &&
                        sec === 0) ? hour : 23) : hour;
                    min = (min > 59) ? 59 : min;
                    sec = (sec > 59) ? 59 : sec;

                    // Using JS Date object to get the milliseconds
                    // value of the time
                    dataObj = new Date();
                    dataObj.setHours(hour);
                    dataObj.setMinutes(min);
                    dataObj.setSeconds(sec);
                    ms = dataObj.getTime();
                }

                return {
                    ms: ms,
                    date: dataObj
                };
            },

            getFormattedDate: function (date, format) {
                var D = typeof date === 'object' && date || new Date(date),
                    timeConf = this.timeConf,
                    output = pluck(format, timeConf.outputDateFormat),
                    year = D.getFullYear(),
                    month = D.getMonth(),
                    day = D.getDate(),
                    nday = D.getDay(),
                    min = D.getMinutes(),
                    sec = D.getSeconds(),
                    hours = D.getHours();

                min = min > 9 ? BLANK + min : ZEROSTRING + min;
                sec = sec > 9 ? BLANK + sec : ZEROSTRING + sec;
                hours = hours > 9 ? BLANK + hours : ZEROSTRING + hours;

                output.match(/dnl/) && (output = output.replace(/dnl/ig, timeConf.days[nday]));
                output.match(/dns/) && (output = output.replace(/dns/ig,
                    timeConf.days[nday] && timeConf.days[nday].substr(0, 3)));
                output.match(/dd/) && (output = output.replace(/dd/ig, day));

                output.match(/mnl/) && (output = output.replace(/mnl/ig, timeConf.months[month]));
                output.match(/mns/) && (output = output.replace(/mns/ig,
                    timeConf.months[month] && timeConf.months[month].substr(0, 3)));
                output.match(/mm/) && (output = output.replace(/mm/ig, month + 1));

                output.match(/yyyy/) && (output = output.replace(/yyyy/ig, year));
                output.match(/yy/) && (output = output.replace(/yy/ig, ((year % 1000 % 100) + '').replace(/^(\d)$/,
                    '0$1')));

                output.match(/hh12/) && (output = output.replace(/hh12/ig, hours % 12 || 12));
                output.match(/hh/) && (output = output.replace(/hh/ig, hours));

                output.match(/mn/) && (output = output.replace(/mn/ig, min));
                output.match(/ss/) && (output = output.replace(/ss/ig, sec));
                output.match(/ampm/) && (output = output.replace(/ampm/ig, hours < 12 ? 'AM' : 'PM'));
                output.match(/ds/) && (output = output.replace(/ds/ig, timeConf.daySuffix[day]));

                return output;
            }

        };

        NumberFormatter.prototype.constructor = NumberFormatter;

        formatNumber = function (num, attributes, isAxisValue) {
            // We convert the number to a valid number
            // If inDecimalsSeparator and in thousandSeparator is given
            // we replace the thousandSeparator and decimalSeparator with
            // proper valid number format
            //num = convertNumberSeps(num, attributes.indecimalseparator, attributes.inthousandseparator);

            // Change for JS Charts:
            // After initial return from getCleanValue, we get either null or a
            // number. So, we validate presence of null only.
            if (num === null) {
                return; //throw TypeError('Not a Valid number');
            }

            // Failsafe conversion of value to proper type.
            num = Number(num);

            //First, if number is to be scaled, scale it
            //Number in String format
            var strNum = num + BLANK,

            //Number Scale
               strScale,
               numList,
               scaleList,
               upperIndex,
               tempNum , tempStr,
               i,
               valueArr, decimalPlaceLen,
               objNum;
            if (attributes.formatnumberscale == 1) {
                strScale = attributes.defaultnumberscale;
            }
            else {
                strScale = BLANK;
            }

            // Fix to show the decimal place
            // if there is more than 2 decimal place in data
            // Finding the decimal place in value
            valueArr = strNum.split(DECIMALSTRING)[1];
            decimalPlaceLen = valueArr ? valueArr.length : attributes.forcedecimals ? TWOSTRING : BLANK;


            // Whether to add K (thousands) and M (millions) to a number
            if (attributes.formatnumberscale == 1) {
                //Get the formatted scale and number
                objNum = formatNumberScale (num, attributes.defaultnumberscale, attributes.numberscalevalue,
                    attributes.numberscaleunit, attributes.scalerecursively);
                //Store from return in local primitive variables

                strNum = objNum.value;
                num = objNum.value;
                strScale = objNum.scale;
            }

            if (attributes.scalerecursively && attributes.formatnumberscale !== 0 &&
             attributes.formatnumberscale !== '0') {
                //Store the list of numbers and scales.
                numList = objNum.value;
                scaleList = objNum.scale;

                //Based on max scale recursion, we decide the upper index to which we've to iterate
                upperIndex = ((attributes.maxscalerecursion == -1) ? numList.length : Math.min(numList.length,
                    attributes.maxscalerecursion));
                //Now, based on whether we've to format decimals and commas.
                if (attributes.formatnumber == 1) {
                    //If recursive scaling was applied and format number is true, we need to :
                    //- format comma of all values
                    //- format decimals of just the last value (last based on max recursion or actual).
                    strNum = '';
                    for (i = 0; i < upperIndex; i++) {
                        //Convert all but first number to absolute values.
                        tempNum = (i === 0) ? numList[i] : Math.abs(numList[i]);
                        tempStr = tempNum + BLANK;
                        //If it's the last value, format decimals
                        if (i == upperIndex-1) {
                            tempStr = formatDecimals(tempNum, pluck(attributes.decimalprecision, decimalPlaceLen),
                                attributes.forcedecimals);
                        }
                        //Append to strNum after formatting commas
                        //We separate the scales using scale separator. The last token doesn't append
                        //the scale separator, as we append number suffix after that.
                        strNum = strNum +
                        formatCommas(tempStr, attributes.decimalseparator, attributes.thousandseparator,
                            attributes.thousandseparatorposition) + scaleList[i] + (i<upperIndex-1 ?
                            attributes.scaleseparator : '');
                    }
                } else {
                    strNum = '';
                    for (i = 0; i < upperIndex; i++) {
                        //Convert all but first number to absolute values and append to strNum.
                        //We separate the scales using scale separator. The last token doesn't append
                        //the scale separator, as we append number suffix after that.
                        strNum = strNum+((i === 0) ? numList[i] : Math.abs(numList[i]) + BLANK)+scaleList[i]+
                            (i<upperIndex-1 ? attributes.scaleseparator : '');
                    }
                }
                //Now, add scale, number prefix and suffix
                //strNum = numberPrefix + strNum + strScale + numberSuffix;
                strNum = (attributes.numberprefix || BLANK) + strNum + (attributes.numbersuffix || BLANK);
            } else {
                //Now, if we've to format the decimals and commas
                if (attributes.formatnumber == 1) {
                    //Format decimals
                    strNum = formatDecimals (num, pluck(attributes.decimalprecision, decimalPlaceLen),
                        attributes.forcedecimals);
                    //Format commas now
                    strNum = formatCommas (strNum, attributes.decimalseparator, attributes.thousandseparator,
                        attributes.thousandseparatorposition, isAxisValue);
                }

                //Now, add scale, number prefix and suffix
                //strNum = numberPrefix + strNum + strScale + numberSuffix;
                strNum = (attributes.numberprefix || BLANK) + strNum + strScale + (attributes.numbersuffix || BLANK);
            }
            return strNum;
        };

        /**
         * formatNumberScale formats the number as per given scale.
         * For example, if number Scale Values are 1000,1000 and
         * number Scale Units are K,M, this method will divide any
         * value over 1000000 using M and any value over 1000 (less than 1M) using K
         * so as to give abbreviated figures.
         * Number scaling lets you define your own scales for numbers.
         * To clarify further, let's consider an example. Say you're plotting
         * a chart which indicates the time taken by a list of automated
         * processes. Each process in the list can take time ranging from a
         * few seconds to few days. And you've the data for each process in
         * seconds itself. Now, if you were to show all the data on the chart
         * in seconds only, it won't appear too legible. What you can do is
         * build a scale of yours and then specify it to the chart. A scale,
         * in human terms, would look something as under:
         * 60 seconds = 1 minute
         * 60 minute = 1 hr
         * 24 hrs = 1 day
         * 7 days = 1 week
         * First you would need to define the unit of the data which you're providing.
         * Like, in this example, you're providing all data in seconds. So, default
         * number scale would be represented in seconds. You can represent it as under:
         * <graph defaultNumberScale='s' ...>
         * Next, the scale for the chart is defined as under:
         * <graph numberScaleValue='60,60,24,7' numberScaleUnit='min,hr,day,wk' >
         * If you carefully see this and match it with our range, whatever numeric
         * figure was present on the left hand side of the range is put in
         * numberScaleValue and whatever unit was present on the right side of
         * the scale has been put under numberScaleUnit - all separated by commas.
         * @param intNum The number to be scaled.
         * @param defaultNumberScale Scale of the number provided.
         * @param numScaleValues Incremental list of values (divisors) on
         * which the number will be scaled.
         * @param
         */
        function formatNumberScale (intNum, defaultNumberScale, numScaleValues, numScaleUnits, scaleRecursively) {
            //Create an object, which will be returned
            var objRtn = {},
            //Scale Unit to be stored (assume default)
            strScale = defaultNumberScale,
            i = 0,
            numScaleValue,
            THOUSAND = 1000,
            //Array of values & scales to be returned.
            arrValues = [],
            arrScales = [],
            carry;
            if (scaleRecursively) {
                for (i = 0; i < numScaleValues.length; i++) {
                    // Garbage handling, if comma  separated value of
                    // numberScaleValues is not a number or 0, we use 1000 as the value
                    numScaleValue = pluckNumber(numScaleValues[i]) || THOUSAND;
                    if (Math.abs(Number(intNum)) >= numScaleValue &&  i < numScaleValues.length - 1) {
                        //Carry over from division
                        carry = intNum % numScaleValue;
                        //Deduct carry over and then divide.
                        intNum = (intNum-carry) / numScaleValue;
                        //Push to return array if carry is non 0
                        if (carry !== 0) {
                            arrValues.push(carry);
                            arrScales.push(numScaleUnits[i]);
                        }
                    } else {
                        //This loop executes for first token value (l to r) during recusrive scaling
                        //Or, if original number < first number scale value.
                        arrValues.push(intNum);
                        arrScales.push(numScaleUnits[i]);
                        break;
                    }
                }
                //Reverse the arrays - So that lead value stays at 0 index.
                arrValues.reverse();
                arrScales.reverse();
                objRtn.value = arrValues;
                objRtn.scale = arrScales;
            } else {
                //If the scale unit or values have something fed in them
                //we manipulate the scales.
                if (numScaleValues.length === numScaleUnits.length) {
                    for (i = 0; i < numScaleValues.length; i ++) {
                        // Garbage handling, if comma  separated value of
                        // numberScaleValues is not a number or 0, we use 1000 as the value
                        numScaleValue = pluckNumber(numScaleValues[i]) || THOUSAND;
                        if (numScaleValue && Math.abs (Number (intNum)) >= numScaleValue) {
                            strScale = numScaleUnits[i] || BLANK;
                            intNum = Number (intNum) / numScaleValue;
                        }
                        else {
                            break;
                        }
                    }
                }
                //Set the values as properties of objRtn
                objRtn.value = intNum;
                objRtn.scale = strScale;
            }
            return objRtn;
        }
        /**
        * parseNumberScale method checks whether we've been provided
        * with number scales. If yes, we parse them and store them in
        * local containers.
        * @return Nothing.
        */

        // function parseNumberScale(numberScaleValues, numberScaleUnits) {
        //     var bNumberScaleDefined, scaleRecursively;
        //     //Check if either has been defined
        //     if (numberScaleValues.length == 0 || numberScaleUnits.length == 0) {
        //         //Set flag to false
        //         bNumberScaleDefined = false;
        //         scaleRecursively = false;
        //     } else {
        //         //Set flag to true
        //         bNumberScaleDefined = true;
        //         //Split the data into arrays
        //         attributes.numberscalevalues = new Array();
        //         attributes.numberscaleunits = new Array();
        //         //Parse the number scale value
        //         attributes.numberscalevalues = numberScaleValues.split(',');
        //         //Convert all number scale values to numbers as they're
        //         //currently in string format.
        //         var i;
        //         for (i=0; i<attributes.numberscalevalues.length; i++) {
        //             attributes.numberscalevalues[i] = Number(attributes.numberscalevalues[i]);
        //             //If any of numbers are NaN, set defined to false
        //             if (isNaN(attributes.numberscalevalues[i])) {
        //                 bNumberScaleDefined = false;
        //                 scaleRecursively = false;
        //             }
        //         }
        //         //Parse the number scale unit
        //         attributes.numberscaleunits = numberScaleUnits.split(',');
        //         //If the length of two arrays do not match, set defined to false.
        //         if (attributes.numberscaleunits.length != attributes.numberscalevalues.length) {
        //             bNumberScaleDefined = false;
        //             scaleRecursively = false;
        //         }
        //         //Push the default scales at start - Value as 1 (universal divisor)
        //         attributes.numberscalevalues.push(1);
        //         attributes.numberscaleunits.unshift(this.defaultNumberScale);
        //         //If number scale is not defined, clear up
        //         if (!bNumberScaleDefined) {
        //             delete attributes.numberscaleunits;
        //             delete attributes.numberscalevalues;
        //         }
        //     }
        // }

        /**
         * formatDecimals method formats the decimal places of a number.
         * Requires the following to be defined:
         * params.decimalSeparator
         * params.thousandSeparator
         * @param intNum Number on which we've to work.
         * @param decimalPrecision Number of decimal places to which we've
         * to format the number to.
         * @param forceDecimals Boolean value indicating whether to add decimal
         * padding to numbers which are falling as whole
         * numbers?
         * @return A number with the required number of decimal places
         * in String format. If we return as Number, Flash will remove
         * our decimal padding or un-wanted decimals.
         */
        function formatDecimals (intNum, decimalPrecision, forceDecimals) {
            var tenToPower, strRounded, parts, paddingNeeded, i;

            // if negative decimal precision is sent, we set it to 0, as per
            // FusionCharts Policy
            if(decimalPrecision <= 0) {
                return mathRound (intNum) + BLANK;
            //decimalPrecision = 0;
            }
            //If no decimal places are needed, just round the number and return
            if (isNaN(decimalPrecision)) {
                intNum = intNum + BLANK;
                if (intNum.length > 12 && intNum.indexOf(DECIMALSTRING) != -1) {
                    decimalPrecision = 12 - intNum.split(DECIMALSTRING)[0].length;
                    tenToPower = mathPow (10, decimalPrecision);
                    strRounded = mathRound (intNum * tenToPower) / tenToPower + BLANK;
                    intNum = strRounded;
                }
                return intNum;
            //return mathRound (intNum) + BLANKSTRING;
            }
            //Round the number to specified decimal places
            //e.g. 12.3456 to 3 digits (12.346)
            //Step 1: Multiply by 10^decimalPrecision - 12345.6
            //Step 2: Round it - i.e., 12346
            //Step 3: Divide by 10^decimalPrecision - 12.346
            tenToPower = mathPow (10, decimalPrecision);
            strRounded = (mathRound (intNum * tenToPower) / tenToPower) + BLANK;

            //Now, strRounded might have a whole number or a number with required
            //decimal places. Our next job is to check if we've to force Decimals.
            //If yes, we add decimal padding by adding 0s at the end.
            if (forceDecimals == 1) {
                //Add a decimal point if missing
                //At least one decimal place is required (as we split later on .)
                //10 -> 10.0
                if (strRounded.indexOf (DECIMALSTRING) == - 1) {
                    strRounded += '.0';
                }
                //Finally, we start add padding of 0s.
                //Split the number into two parts - pre & post decimal
                parts = strRounded.split (DECIMALSTRING);
                //Get the numbers falling right of the decimal
                //Compare digits in right half of string to digits wanted
                paddingNeeded = decimalPrecision - parts [1].length;
                //Number of zeros to add
                for (i = 1; i <= paddingNeeded; i ++) {
                    //Add them
                    strRounded += ZEROSTRING;
                }
            }
            return (strRounded);
        }

        /**
         * formatCommas method adds proper commas to a number in blocks of 3
         * i.e., 123456 would be formatted as 123,456
         * @param strNum The number to be formatted (as string).
         * Why are numbers taken in string format?
         * Here, we are asking for numbers in string format
         * to preserve the leading and padding 0s of decimals
         * Like as in -20.00, if number is just passed as number,
         * Flash automatically reduces it to -20. But, we've to
         * make sure that we do not disturb the original number.
         * @return Formatted number with commas.
         */
        function formatCommas (strNum, decimalseparator, thousandseparator, thSepPos, isAxisValue) {

            //intNum would represent the number in number format
            var intNum = Number (strNum),
                strDecimalPart = BLANK,
                boolIsNegative = false,
                strNumberFloor = BLANK,
                formattedNumber = BLANK,
                startPos = 0,
                endPos = 0,
                minExponentialValue = 1e+15,
                fractionDigits,
                strNumberLen,
                sepPosLen,
                sepDigit;

            //If the number is invalid, return an empty value
            if (isNaN (intNum)){
                return BLANK;
            }

            //If the number is greater than 10^15, we return the exponential form.
            //Fraction digits are determined based on whether number is an axis value or data label.
            //This is done considering the behaviour in flash version of chart
            if (intNum > minExponentialValue) {
                if (isAxisValue) {
                    fractionDigits = 1;
                } else {
                    fractionDigits = 14;
                }
                return (intNum.toExponential(fractionDigits));
            }

            //Define startPos and endPos
            startPos = 0;
            endPos = strNum.length;

            //Extract the decimal part
            if (strNum.indexOf (DECIMALSTRING) != - 1) {
                strDecimalPart = strNum.substring (strNum.indexOf (DECIMALSTRING) + 1, strNum.length);
                endPos = strNum.indexOf (DECIMALSTRING);
            }
            //Now, if the number is negative, get the value into the flag
            if (intNum < 0) {
                boolIsNegative = true;
                startPos = 1;
            }
            //Now, extract the floor of the number
            strNumberFloor = strNum.substring (startPos, endPos);

            strNumberLen = strNumberFloor.length;
            sepPosLen = thSepPos.length - 1;
            sepDigit = thSepPos[sepPosLen];
            if (strNumberLen < sepDigit) {
                formattedNumber = strNumberFloor;
            } else {
                while (strNumberLen >= sepDigit) {
                    formattedNumber = (strNumberLen-sepDigit ?  thousandseparator : BLANK) +
                    strNumberFloor.substr( strNumberLen-sepDigit, sepDigit) + formattedNumber;
                    strNumberLen -= sepDigit;
                    sepDigit = (sepPosLen-=1) <= 0 ? thSepPos[0] : thSepPos[sepPosLen];
                    if (strNumberLen < sepDigit) {
                        formattedNumber =  strNumberFloor.substring(strNumberLen, 0) + formattedNumber;
                    }
                }
            }

            // Now, append the decimal part back
            if (strDecimalPart != BLANK) {
                formattedNumber = formattedNumber + decimalseparator + strDecimalPart;
            }
            //Now, if neg num
            if (boolIsNegative === true) {
                formattedNumber = MINUSSTR + formattedNumber;
            }

            //Return
            return formattedNumber;
        }

        /**
         * convertNumberSeps method helps us convert the separator (thousands and decimal)
         * character from the user specified input separator characters to normal numeric
         * values that Flash can handle. In some european countries, commas are used as
         * decimal separators and dots as thousand separators. In XML, if the user specifies
         * such values, it will give a error while converting to number. So, we accept the
         * input decimal and thousand separator from user, so thatwe can covert it accordingly
         * into the required format.
         * If the number is still not a valid number after converting the characters, we log
         * the error and return 0.
         * @param num Number in string format containing user defined separator characters.
         * @return Number in numeric format.
         */
        // convertNumberSeps function modified on [12-04-2011] to fix the issue [FCXTCOMMON-37]
        /** @todo OLD convertNumberSeps has been commented below, and have to remove after the testing
        // of numberFormatter */
        function convertNumberSeps (num, conf) {
            // convert the given number to string
            num = num + BLANK;
            if (conf._REGinthousandseparator) {
                num = num.replace(conf._REGinthousandseparator, BLANK);
            }
            // Replace the indecimalseparator value with decimal to perform numeric operations
            if (conf._REGindecimalseparator) {
                num = num.replace(conf._REGindecimalseparator, DECIMALSTRING);
            }
            num = parseFloat(num);
            // parseFloat is used here instead of Number so that parseFloat()'s
            // returning of NaN on blank string can be utilized.
            return isFinite(num) ? num : NaN;
        }
        /*
        function convertNumberSeps (num, indecimalseparator, inthousandseparator) {
            // Replace the indecimalseparator value with decimal to perform numeric operations
            num = indecimalseparator !== BLANKSTRING ?
            num.toString().replace(indecimalseparator, DECIMALSTRING) : num;

            if (inthousandseparator && inthousandseparator.toString) {
                inthousandseparator = inthousandseparator.toString().replace(/(\W)/ig, '\\$1')
            }

            // Replace the inthousandseparator value with decimal to perform numeric operations
            var re = new RegExp(inthousandseparator, 'g');
            num = inthousandseparator !== BLANKSTRING ?
            num.toString().replace(re, BLANKSTRING) : num;

            // old code: intNum = !strNum && strNum !== false && strNum !== 0 ?
            //NaN : Number(strNum);

            return !isNaN(num = parseFloat(num)) && isFinite(num) ? num : NaN;
        }
         */
        return NumberFormatter;

    })();

    global.extend(global.core, {
        formatNumber: function(num, config) {
            config = (config && objToLowerCase(config)) || {};
            var hashKey = objToHash(config),
                    NF,
                    formatedStr;
            if (NFStore[hashKey]) {
                NF = NFStore[hashKey];
            }
            else {
                NFStore[hashKey] = NF = new lib.NumberFormatter(config, {useScaleRecursively: true});
            }
            formatedStr = NF.dataLabels(num);
            return formatedStr;
        }
    }, false);


/*
 * add number formater to FusionCharts instance
 * ~todo add dispose methodology for all numberformater created by this method
 * ~param {number} num :Number that will be formatted
 * ~param {string} type: [Optional] predefined set of type described in Notes tab.
 * ~param {object} config : [Optional] Object to override number formatter configurations
 * ~param {number} yAxisIndex : [Optional] Axis index for DY-Axis or Multy-Axis charts.
 */
    global.extend(global.core, /** @lends FusionCharts */ {
        /**
         * FusionCharts formats input number based on configurations passed in chart attributes. It may be needed to
         * similarly format other non-chart elements on page using same algorithm. This function is available to be used
         * globally on {@link FusionCharts} object or on a specific instance of FusionCharts Suite XT.
         *
         * When called on the FusionCharts object (`FusionCharts.formatNumber()`,) the default number configuration
         * settings are utilised. These can be overridden by passing additional number format configuration settings
         * as the second parameter. Refer to chart attributes for various number format configurations.
         *
         * When called on an instance of a chart, gauge or map, the number formatting as set by the data of the chart is
         * used. As such, the second parameter (`type`) accepts `xAxisValues`, `yAxisValues` or `dataLabels` to allow
         * formatting to be done specific to them.
         *
         * @group framework
         *
         * @param {number} num - The number that needs to be formatted.
         *
         * @param {string=} [type=datalabels] - A chart can be configured to format numbers differently depending upon
         * where it is being used. The formatting of data values can be different than that of x-axis labels. As such,
         * passing `yaxisvalues`, `xaxisvalues` or `datalabels` as a value of this parameter returns the formatted
         * number accordingly. __Note that this parameter is not available when `formatNumber` is executed on
         * `FusionCharts` object instead of chart instances.
         *
         * @param {object=} [config] - One can optionally pass additional number formatting attributes as the `config`
         * parameter to override the default number formatting options of a chart. While calling `formatNumber` on
         * `FusionCharts` object, this becomes the second parameter.
         *
         * @returns {string}
         *
         * @example
         * console.log(FusionCharts.formatNumber(1234.5)); // logs "1.2K"
         *
         * console.log(FusionCharts.formatNumber(1234.5, {
         *     numberPrefix: "$"
         * })); // logs "$1.2K"
         *
         * @example
         * // Calling number formatter on a chart instance when `renderComplete` event is fired.
         * FusionCharts.ready(function () {
         *     // Render a chart within a chart container `div` element.
         *     var chart = new FusionCharts({
         *         type: 'column2d',
         *         renderAt: 'chart-container-div',
         *         dataFormat: 'json',
         *         dataSource: {
         *             chart: {
         *                 caption: "Quarterly sales summary",
         *                 numberPrefix: "$",
         *                 decimals: "2",
         *                 forceDecimals: "1"
         *             }
         *             data: [
         *                 { label: "Q1", value: "213345"},
         *                 { label: "Q2", value: "192672"},
         *                 { label: "Q3", value: "201238"},
         *                 { label: "Q4", value: "209881"},
         *             ]
         *         },
         *
         *         events: {
         *             renderComplete: function (eventObj) {
         *                 // Call the formatNumber function of the specific chart we rendered.
         *                 console.log(eventObj.sender.formatNumber(1234.5)); // logs "$1.23K"
         *             }
         *         }
         *     });
         *     chart.render();
         * });
         */
        formatNumber: function(num, type, config, yAxisIndex) {
            config = (config && objToLowerCase(config)) || {};
            var chartObj = this,
            jsVars = chartObj.jsVars,
            chartInstance = jsVars.instanceAPI || {},
            numberFormatter = chartInstance.numberFormatter,
            dataComp,
            dataObj,
            dataChartTagJSON,
            configHashKey = objToHash(config),
            hashKey,
            NF,
            formatedStr;
            if (configHashKey === BLANK ){
                if(numberFormatter){
                    NF = numberFormatter;
                }
                else {
                    dataComp = chartObj.getChartData(global.dataFormats.JSON, true),
                    dataObj = dataComp.data || {},
                    dataChartTagJSON = dataObj .chart || {},
                    hashKey = objToHash(dataChartTagJSON);
                    if (NFStore[hashKey]) {
                        NF = NFStore[hashKey];
                    }
                    else {
                        NFStore[hashKey] = NF = new lib.NumberFormatter(dataChartTagJSON, chartInstance);
                    }
                }
            }
            else {
                dataComp = chartObj.getChartData(global.dataFormats.JSON, true),
                dataObj = dataComp.data || {},
                dataChartTagJSON = dataObj .chart || {},
                dataChartTagJSON = extend2(extend2({}, dataChartTagJSON), config);
                hashKey = objToHash(dataChartTagJSON);
                if (NFStore[hashKey]) {
                    NF = NFStore[hashKey];
                }
                else {
                    NFStore[hashKey] = NF = new lib.NumberFormatter(dataChartTagJSON, chartInstance);
                }
            }
            switch((type && type.toLowerCase ? type : BLANK).toLowerCase()){
                case 'yaxisvalues':
                    formatedStr = NF.yAxis(num, yAxisIndex);
                    break;
                case 'xaxisvalues':
                    formatedStr = NF.xAxis(num);
                    break;
                case 'scale':
                    formatedStr = NF.scale(num);
                    break;
                default:
                    formatedStr = NF.dataLabels(num, yAxisIndex);
                    break;
            }
            return formatedStr;
        }
    }, true);



}]);
/**
 * FusionCharts JavaScript Library
 * FusionCharts DOM event and Animation module.
 * @private
 *
 * @module fusioncharts.renderer.javascript.dom
 * @requires fusioncharts.renderer.javascript.lib
 */
FusionCharts.register('module', ['private', 'modules.renderer.js-dom', function () {

    var global = this,
        lib = global.hcLib,
        SPACE = ' ',
        win = global.window,
        doc = win.document,
        extend2 = lib.extend2,
        hasTouch = ('ontouchstart' in win);

    /*
     * Closure to contain the DOM Event Manager framework.
     *
     * ~param {object} parent The parent object in which to store the instance
     * of the DOMEventManager
     */
    (function (parent) {

        var
            /*
             * Basic Events
             * ~type {object} BE
             */
            BE = {
                click: 'click',
                touchstart: 'touchstart',
                touchend: 'touchend',
                touchmove: 'touchmove',
                mousedown: 'mousedown',
                mouseup: 'mouseup',
                mousemove: 'mousemove',
                mouseout: 'mouseout',
                mouseover: 'mouseover',
                keydown: 'keydown'
            },
            /*
             * An abstraction layer
             * ~type {object} gestures
             */
            gestures = (function () {

                var retObj = {},
                    gesture;

                retObj.pointerdrag = {
                    start: [BE.mousedown],
                    end: [BE.mouseup],
                    onStart: [BE.mousemove],
                    postHandlers: {},
                    preHandlers: {}
                };

                retObj.pointerhover = {
                    start: [BE.mouseover],
                    end: [BE.mouseout]
                };

                retObj.click = {
                    start: [BE.click]
                };

                /*retObj.drag = {
                    start: [retObj.pointerdrag, retObj.touchdrag]
                };

                retObj.hover = {
                    start: [retObj.pointerhover]
                };*/

                retObj.escape = {
                    start: [BE.keydown],
                    preHandlers: {
                        start: function (event) {
                            /**
                             * @todo check the event keyCode and return true is it corresponds to
                             * escape key.
                             */
                            event = event || win.event;
                            if (event.keyCode && event.keyCode === 27) {
                                return true;
                            }
                            return false;
                        }
                    }
                };

                if (hasTouch) {
                    gesture = retObj.pointerdrag;

                    gesture.start.push(BE.touchstart);
                    gesture.end.push(BE.touchend);
                    gesture.onStart.push(BE.touchmove);

                    gesture.postHandlers.onStart = function (event) {
                        if (event.preventDefault) {
                            event.preventDefault();
                        }
                        else {
                            event.returnValue = false;
                        }
                    };

                    gesture = retObj.click;
                    gesture.start.push(BE.touchstart);
                }

                return retObj;

            }()),
            gDefs;

        /*
         * Define generic gestures in terms of sequence of DOM events depending on the
         * browser.
         */
        function defineGestures () {

            var gestureMap = extend2({}, gestures); /** @todo reduce dependency on lib functions as much as possible */
                //browType = getBrowserClass();

            // switch (browType) {

            //      // Add browser vendor specific code here defining each gesture as a
            //      // sequence of events.

            //     default:
            //         break;
            // }

            return gestureMap;
        }

        gDefs = defineGestures();

        /*
         * Gets the class of browser.
         *
         * ~returns {string} class
         *
         * ~todo classification parameters have to be decided upon.
         */
        // function getBrowserClass() {
        //     var browType = '';

        //     return browType;
        // }

        /*
         * Creates a new instance of the DOM Event wrapper.
         * ~constructor
         * ~todo Enable handling of custom events.
         */
        function DOMEventFx() {
            var
                /*
                 * ~private {object} eventHandlerMap A map of all the handlers
                 * created per event type.
                 */
                eventHandlerMap = {},

                /*
                 * ~private {object} gestureHandlerMap A map of all the handlers
                 * created per gesture type.
                 */
                gestureHandlerMap = {},

                /*
                 * Binds a DOM event to a handler function.
                 *
                 * ~param {Element} elem The DOM element pertaining to the event.
                 * ~param {string} event Event type that needs to be listened to.
                 * ~param {function} handlerFn The function that gets called when the event
                 * is triggered.
                 *
                 * ~returns {undefined}
                 */
                addHandler = (doc.addEventListener ? function (elem, event, handlerFn) {
                        elem.addEventListener(event, handlerFn, false);
                    } : function (elem, event, handlerFn) {
                        elem.attachEvent('on'+event, handlerFn);
                    }),

                /*
                 * Removes the binding of the event handler with the DOM.
                 *
                 * ~param {Element} elem The DOM element pertaining to the event.
                 * ~param {string} event Event type for which the existing handler
                 * must be detached.
                 * ~param {function} handlerFn The handler function.
                 *
                 * ~returns {undefined}
                 */
                removeHandler = (doc.removeEventListener ? function (elem, event, handlerFn) {
                        elem.removeEventListener(event, handlerFn, false);
                    } : function (elem, event, handlerFn) {
                        elem.detachEvent('on'+event, handlerFn);
                    }),

                /*
                 * Converts the gesture in to a sequence of events and adds handlers
                 * to the events.
                 *
                 * ~param {DOM Element} elem The target element.
                 * ~param {string} gesture The name of the gesture.
                 * ~param {object} handlerObj The object containing all the binding
                 * related information.
                 *
                 * ~returns {array} unlisteners An array of functions that can be
                 * invoked to unbind the handlers.
                 */
                addGestureHandler = function (elem, gesture, handlerObj) {
                    var unlisteners = [],
                        eventArr,
                        each,
                        i,
                        def;

                    def = gDefs[gesture];

                    /*
                     * The handler wrapper that must be called when the event
                     * corresponding to the start to the gesture is triggered.
                     *
                     * ~param {object} event The browser event object.
                     *
                     * ~return {undefined}
                     */
                    handlerObj.start = function (event) {
                        event = event || win.event;

                        var onStartArr = def.onStart,
                            endArr = def.end,
                            startUn = [],
                            endUn = [],
                            i = (onStartArr && onStartArr.length) || 0;

                        // startUn and endUn are arrays that contain functions to
                        // unbind the handlers that were bound at the start of the
                        // gesture.
                        while (i--) {
                            startUn.push(addEventHandler(elem, onStartArr[i], handlerObj, 'onStart'));
                        }

                        i = (endArr && endArr.length) || 0;

                        while (i--) {
                            endUn.push(addEventHandler(elem, endArr[i], handlerObj, 'end'));
                        }

                        // Storing in the handlerObj
                        handlerObj.startUn = handlerObj.startUn ? handlerObj.startUn.concat(startUn) : startUn;
                        handlerObj.endUn = handlerObj.endUn ? handlerObj.endUn.concat(endUn) : endUn;
                        handlerObj.state = 'start';
                        handlerObj.closure(event);

                    };

                    handlerObj.onStart = function (event) {
                        event = event || win.event;
                        handlerObj.state = 'on';

                        if (handlerObj.gDef && handlerObj.gDef.preHandlers &&
                            (typeof handlerObj.gDef.preHandlers.onStart === 'function')) {
                            handlerObj.gDef.preHandlers.onStart(event);
                        }

                        handlerObj.closure(event);

                        if (handlerObj.gDef && handlerObj.gDef.postHandlers &&
                            (typeof handlerObj.gDef.postHandlers.onStart === 'function')) {
                            handlerObj.gDef.postHandlers.onStart(event);
                        }
                    };

                    /*
                     * The handler wrapper that must be called when the event
                     * corresponding to the end to the gesture is triggered.
                     *
                     * ~param {object} event The browser event object.
                     *
                     * ~return {undefined}
                     */
                    handlerObj.end = function (event) {
                        event = event || win.event;

                        var startUn = handlerObj.startUn,
                            endUn = handlerObj.endUn,
                            i = (startUn && startUn.length) || 0;

                        // Unbinding the events that were bound to when the gesture
                        // had started.
                        while (i--) {
                            startUn[i]();
                        }
                        delete handlerObj.startUn;
                        handlerObj.startUn = [];

                        i = (endUn && endUn.length) || 0;

                        while (i--) {
                            endUn[i]();
                        }
                        delete handlerObj.endUn;
                        handlerObj.endUn = [];

                        handlerObj.state = 'end';
                        handlerObj.closure(event);
                    };

                    // Gesture
                    if (def) {
                        eventArr = def.start;
                        i = eventArr.length;

                        while (i--) {
                            each = eventArr[i];
                            if (each) {
                                // Listen to only the event that corresponds to the
                                // start of the gesture.
                                unlisteners.push(addEventHandler(elem, each, handlerObj, 'start'));
                            }
                        }
                    }

                    return unlisteners;
                },

                /*
                 * Unbinding the handler/gesture.
                 *
                 * ~param {DOM Element} elem The target element.
                 * ~param {string} gesture The name of the gesture.
                 * ~param {object} handlerObj The object containing all the binding
                 * related information.
                 *
                 */
                removeGestureHandler = function (elem, gesture, handlerObj) {
                    var eventArr,
                        each,
                        i,
                        def;

                    def = gDefs[gesture];

                    // Gesture
                    if (def) {
                        eventArr = def.start;
                        i = eventArr.length;

                        while (i--) {
                            each = eventArr[i];
                            if (each) {
                                removeHandler(elem, each, handlerObj.start);
                            }
                        }
                    }
                },

                /*
                 * Function that finally calls the addHandler to bind the event with
                 * a wrapper handler(start/end/closure).
                 *
                 * ~param {DOM Element} elem
                 * ~param {string} event
                 * ~param {object} handlerObj
                 * ~param {string} [attachTo=closure] The wrapper to which to bind.
                 *
                 * ~return {function} The unbinding function.
                 */
                addEventHandler = function (elem, event, handlerObj, attachTo) {
                    /**
                     * @todo event can later be an array once we start supporting
                     * complex gestures.
                     */
                    var unlistener;
                    attachTo = attachTo || 'closure';

                    // Attach the handler to the DOM element.
                    addHandler(elem, event, handlerObj[attachTo]);
                    unlistener = function () {
                        removeHandler(elem, event, handlerObj[attachTo]);
                    };

                    return unlistener;
                },

                getHandlerClosure = function (handlerObj) {
                    return function (event) {
                        event = event || win.event;
                        var ctxt = handlerObj.context || handlerObj.elem,
                            eventObj = {
                                data: handlerObj.data,
                                type: handlerObj.type,
                                state: handlerObj.state,
                                isGesture: handlerObj.isGesture,
                                target: (event.target || event.srcElement),
                                originalEvent: event
                                // more properties to be added here
                            };

                        handlerObj.handler.call(ctxt, eventObj);
                    };
                };

                /*
                 * Clean up the eventHandlerMap if and when elements get deleted. (or
                 * handlers get reassigned or overwritten?)
                 * ~returns {undefined}
                 */
                //garbageCollector = function () {
                    /**
                     * @todo Go through all the existing handler objects and delete
                     * the ones that do not have a proper elem or handler property.
                     *
                     * @todo Try to listen to events that are fired when DOM tree changes.
                     * and start the garbageCollector then.
                     *
                     */
                //};

            return {

                /*
                 * External API to attach the handler to DOM element
                 * ~param {DOM} elem The element to which the event listener
                 * has to be attached.
                 * ~param {string} gestures Gestures are a sequence of events.
                 * ~param {function} handlers A single handler or if it is
                 * an array will have a one-to-one mapping with gestures.
                 * ~param {object} data The data that should be passed to the
                 * handler when it is invoked
                 * ~param {type} context The context in which the handler should
                 * be invoked.
                 *
                 * ~returns {object} An object containing the method to detach
                 * the handlers that have been bound to elem.
                 */
                listen: function (elem, gestures, handlers, data, context) {

                    var dem = this,
                        gestureArr = (typeof gestures === 'string' ? gestures.split(SPACE) : gestures),
                        i = gestureArr.length,
                        unlisteners = [],
                        addToUnlistener = function (elem, type, handler) {
                            unlisteners.push(function () {
                                dem.unlisten(elem, type, handler);
                            });
                        },
                        handlerMap,
                        gesture,
                        handlerObj,
                        isGesture,
                        handler;

                    if (!elem.ownerDocument || elem.ownerDocument !== doc) {
                        // elem is a not a DOM element.
                        while (i--) {
                            gesture = gestureArr[i];
                            handler = (typeof handlers === 'function' ? handlers : handlers[i]);

                            // Internal object maintained by the event fx.
                            // Should not be exposed outside.
                            handlerObj = {
                                handler: handler,
                                elem: elem,
                                type: gesture,
                                isGesture: isGesture,
                                data: data,
                                context: context,
                                start: [],
                                end: [],
                                links: {
                                    prev: null,
                                    next: null
                                }
                            };

                            // Encapsulate the actual handler call within a closure so that it is
                            // easier to invoke the handler in a particular context and pass
                            // parameters to it.
                            handlerObj.closure = getHandlerClosure(handlerObj);

                            handlerMap = eventHandlerMap[gesture];
                            if (!handlerMap) {
                                handlerMap = eventHandlerMap[gesture] = [];
                            }
                            handlerMap.push(handlerObj);

                            addEventHandler(elem, gesture, handlerObj);

                            // Adding the unlisteners in a closure to
                            // unlisten each of individual events.
                            addToUnlistener(elem, gesture, handler);
                        }
                    }
                    else {
                        while (i--) {
                            gesture = gestureArr[i];
                            isGesture = Boolean(gDefs[gesture]);
                            handler = (typeof handlers === 'function' ? handlers : handlers[i]);

                            // Internal object maintained by the event fx.
                            // Should not be exposed outside.
                            handlerObj = {
                                handler: handler,
                                elem: elem,
                                type: gesture,
                                isGesture: isGesture,
                                gDef: (isGesture ? gDefs[gesture] : null),
                                data: data,
                                context: context,
                                start: [],
                                end: [],
                                links: {
                                    prev: null,
                                    next: null
                                }
                            };

                            // Encapsulate the actual handler call within a closure so that it is
                            // easier to invoke the handler in a particular context and pass
                            // parameters to it.
                            handlerObj.closure = getHandlerClosure(handlerObj);

                            // If the listener is supposed to listen to a gesture
                            if (isGesture) {
                                handlerMap = gestureHandlerMap[gesture];
                                if (!handlerMap) {
                                    handlerMap = gestureHandlerMap[gesture] = [];
                                }
                                handlerMap.push(handlerObj);

                                addGestureHandler(elem, gesture, handlerObj);
                            }
                            // else listening to a DOM event (future: custom event)
                            else {
                                handlerMap = eventHandlerMap[gesture];
                                if (!handlerMap) {
                                    handlerMap = eventHandlerMap[gesture] = [];
                                }
                                handlerMap.push(handlerObj);

                                addEventHandler(elem, gesture, handlerObj);
                            }

                            // Adding the unlisteners in a closure to
                            // unlisten each of individual events.
                            addToUnlistener(elem, gesture, handler);
                        }
                    }

                    // Pass an object containing a method to unbind the handler for
                    // ease of use.
                    return {
                        unlisten: function () {
                            var i = unlisteners.length;
                            while (i--) {
                                unlisteners[i]();
                            }
                            // clear the unlisteners
                            unlisteners.length = 0;
                            unlisteners = null;
                        }
                    };
                },

                /*
                 * External API to detach the handler from the DOM element.
                 *
                 * ~param {DOM} elem
                 * ~param {string} gesture
                 * ~param {function} handler
                 *
                 * ~returns {boolean} retVal
                 */
                unlisten: function (elem, gesture, handler) {

                    var isGesture = Boolean(gDefs[gesture]),
                        eventHandlers,
                        retVal = false,
                        i,
                        hObj;

                    // Iterate over the array of handler objects for the event type
                    // and remove when the element and handler of a handler object
                    // matches the ones passed as arguments.
                    if (!isGesture) {
                        eventHandlers = eventHandlerMap[gesture],
                        i = (eventHandlers && eventHandlers.length) || 0;

                        while (i--) {
                            hObj = eventHandlers[i];
                            if (hObj.handler === handler && hObj.elem === elem) {
                                removeHandler(elem, gesture, hObj.closure);
                                eventHandlers.splice(i, 1);
                                retVal = true;
                            }
                        }
                    }
                    else {
                        eventHandlers = gestureHandlerMap[gesture],
                        i = (eventHandlers && eventHandlers.length) || 0;

                        while (i--) {
                            hObj = eventHandlers[i];
                            if (hObj.handler === handler && hObj.elem === elem) {
                                removeGestureHandler(elem, gesture, hObj);
                                eventHandlers.splice(i, 1);
                                retVal = true;
                            }
                        }
                    }

                    return retVal;
                },

                /*
                 * External API to fire an event on a particular DOM element.
                 * ~param {object} elem
                 * ~param {string} event
                 * ~param {object} eventArguments
                 * ~param {function} defaultFunction
                 *
                 * ~returns {undefined}
                 */
                fire: function (elem, event, eventArguments, defaultFunction) {
                    var eventHandlers,
                        i,
                        hObj,
                        eventObj;

                    // If elem is a custom object
                    if (!elem.ownerDocument || elem.ownerDocument !== doc) {
                        eventHandlers = eventHandlerMap[event],
                        i = (eventHandlers && eventHandlers.length) || 0;

                        while (i--) {
                            hObj = eventHandlers[i];
                            if (hObj.elem === elem) {
                                hObj.closure(eventArguments);
                            }
                        }
                    }
                    else {
                        // For non-IE browsers
                        if (doc.createEvent) {
                            eventObj = doc.createEvent('HTMLEvents');
                            eventObj.initEvent(event, true, true);
                            if (eventArguments) {
                                if (eventArguments.originalEvent) {
                                    eventArguments.originalEvent = eventObj;
                                }
                                else {
                                    extend2(eventObj, eventArguments);
                                }
                            }

                            // If the event can be called as a function on the element
                            // like blur, focus etc then first call them.
                            if (typeof elem[event] === 'function') {
                                elem[event].call(elem);
                            }

                            elem.dispatchEvent(eventObj);
                            if (defaultFunction && !eventObj.returnValue) {
                                defaultFunction(eventObj);
                            }
                        }
                        // IE
                        else {
                            eventObj = doc.createEventObject();
                            eventObj.eventType = event;
                            if (eventArguments) {
                                if (eventArguments.originalEvent) {
                                    eventArguments.originalEvent = eventObj;
                                }
                                else {
                                    extend2(eventObj, eventArguments);
                                }
                            }

                            // If the event can be called as a function on the element
                            // like blur, focus etc then first call them.
                            if (typeof elem[event] === 'function') {
                                elem[event].call(elem);
                            }

                            elem.fireEvent('on' + event, eventObj);
                            if (defaultFunction && !eventObj.returnValue) {
                                defaultFunction(eventObj);
                            }
                        }
                    }
                }
            };
        }

        parent.dem = new DOMEventFx();

    }(lib || win));
    /* End of DOM Event Mananger */



    /*
     * DOM Animation Manager
     *
     * ~param {object} parent The parent object in which the instance of the
     * Animation framework will be stored
     */
    (function (parent) {

        var
            animatable = {
                width: {
                    suffix: 'px'
                },
                height: {
                    suffix: 'px'
                },
                opacity: true,
                top: {
                    suffix: 'px'
                },
                left: {
                    suffix: 'px'
                }
            },
            predefinedAnimations = {

            },
            effects = {
                linear: function (diff, iterations) {
                    var
                        returnArr = [],
                        increment = (diff / iterations),
                        i = 0;

                    for (;i < iterations; i += 1) {
                        returnArr[i] = increment * (i + 1);
                    }

                    return returnArr;
                }
            },
            isIE = /msie/i.test(win.navigator.userAgent) && !win.opera,
            UNIT_INTERVAL = 40,
            doAnimation;

        /*
         *
         * ~param {type} ele
         * ~param {type} rule
         * ~returns {number} strValue The current numeric value of the css rule.
         */
        function getAppliedStyle(ele, rule){
            var strValue = '';
            if(doc.defaultView && doc.defaultView.getComputedStyle){
                strValue = doc.defaultView.getComputedStyle(ele, '').getPropertyValue(rule);
            }
            else if(ele.currentStyle){
                rule = rule.replace(/\-(\w)/g, function (strMatch, p1){
                            return p1.toUpperCase();
                        });
                strValue = ele.currentStyle[rule];
            }
            strValue = parseInt(strValue, 10);

            return isNaN(strValue) ? 0 : strValue;
        }

        /*
         *
         * ~param {type} element
         * ~param {type} duration
         * ~param {type} start
         * ~param {type} end
         * ~param {type} rule
         * ~param {type} effect
         * ~param {type} callback
         * ~param {type} suff
         * ~returns {undefined}
         */
        function animatorStyle (element, duration, start, end, rule, effect, callback, suff) {
            var
                iterations = (duration / UNIT_INTERVAL),
                diff = (end - start),
                incrementArr = effects[effect || 'linear'](diff, iterations),
                counter = 0,
                stepFn = function () {
                    var val, value;
                    if (counter < iterations) {
                        val = incrementArr[counter];
                        element.style[rule] = (start + val) + suff;
                        if (isIE && rule === 'opacity') {
                            value = Number(val) * 100;
                            element.style.filter = 'progid:DXImageTransform.Microsoft.Alpha(Opacity=' +
                                value + ')';
                        }

                        counter += 1;
                        setTimeout(stepFn, UNIT_INTERVAL);
                    }
                    else {
                        callback && callback();
                    }
                };

            suff = suff || '';
            setTimeout(stepFn, UNIT_INTERVAL);
        }

        /*
         *
         * ~param {type} element
         * ~param {type} toAnimate
         * ~param {type} duration
         * ~param {type} effect
         * ~param {type} callback
         * ~returns {undefined}
         */
        doAnimation = function (element, stylesToAnimate, duration, effect, callback) {
            // 1. validate the styles
            var
                finalStyle = {},
                currentStyle = {},
                iCB = function () {
                    finished += 1;
                    if (finished === total) {
                        (typeof callback === 'function') && callback();
                    }
                },
                total = 0,
                finished = 0,
                suff,
                rule;

            if (duration < UNIT_INTERVAL) {
                // If the duration of animation is less than the
                // minimum frame length then apply the styles directly.
                for (rule in stylesToAnimate) {
                    element.style[rule] = stylesToAnimate[rule];
                }

                callback && callback();
                return;
            }

            for (rule in stylesToAnimate) {
                if(animatable[rule]) {
                    total += 1;
                    finalStyle[rule] = stylesToAnimate[rule];
                    currentStyle[rule] = getAppliedStyle(element, rule);
                    suff = (typeof animatable[rule] === 'object') && animatable[rule].suffix;

                    animatorStyle(element, duration, currentStyle[rule], finalStyle[rule], rule, 'linear', iCB, suff);

                }
            }
        };

        parent.danimate = extend2({
            animate: doAnimation
        }, predefinedAnimations);

    }(lib || win));
}]);
/**
 * @private
 * @module fusioncharts.renderer.javascript.colormanager
 * @requires fusioncharts.renderer.javascript.lib
 */
FusionCharts.register('module', ['private', 'modules.renderer.js-colormanager', function () {
    var global = this,
        lib = global.hcLib,
        pluckNumber = lib.pluckNumber,
        getDarkColor = lib.graphics.getDarkColor,
        getLightColor = lib.graphics.getLightColor,
        BLANK = '',
        COMMASTRING = ',',
        defined = function  (obj) {
            return obj !== undefined && obj !== null;
        },
        BGRATIOSTRING = '0,100',
        COLOR_WHITE = 'FFFFFF',
        HUNDREDSTRING = '100',

        extend = function (a, b) { /** @todo refactor dependency */
            var n;
            if (!a) {
                a = {};
            }
            for (n in b) {
                a[n] = b[n];
            }
            return a;
        },

        paletteColors = ['AFD8F8', 'F6BD0F', '8BBA00', 'FF8E46', '008E8E',
            'D64646', '8E468E', '588526', 'B3AA00', '008ED6',
            '9D080D', 'A186BE', 'CC6600', 'FDC689', 'ABA000',
            'F26D7D', 'FFF200', '0054A6', 'F7941C', 'CC3300',
            '006600', '663300', '6DCFF6'],

        gaugePaletteColors = ['8BBA00', 'F6BD0F', 'FF654F', 'AFD8F8', 'FDB398',
            'CDC309', 'B1D0D2', 'FAD1B9', 'B8A79E', 'D7CEA5', 'C4B3CE',
            'E9D3BE', 'EFE9AD', 'CEA7A2', 'B2D9BA'],

        defaultPaletteOptions = lib.defaultPaletteOptions = {
            //Palette color arrays
            // ------------- For 2D Chart ---------------//
            /** @todo HC indexing issue have check when it is solved */
            paletteColors: [paletteColors, paletteColors, paletteColors, paletteColors,
                paletteColors],
            bgColor : ['CBCBCB,E9E9E9', 'CFD4BE,F3F5DD', 'C5DADD,EDFBFE', 'A86402,FDC16D', 'FF7CA0,FFD1DD'],
            bgAngle : [270, 270, 270, 270, 270],
            bgRatio : [BGRATIOSTRING, BGRATIOSTRING, BGRATIOSTRING, BGRATIOSTRING, BGRATIOSTRING],
            bgAlpha : ['50,50', '60,50', '40,20', '20,10', '30,30'],
            canvasBgColor : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            canvasBgAngle : [0, 0, 0, 0, 0],
            canvasBgAlpha : [HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING],
            canvasBgRatio : [BLANK, BLANK, BLANK, BLANK, BLANK],
            canvasBorderColor : ['545454', '545454', '415D6F', '845001', '68001B'],
            canvasBorderAlpha : [100, 100, 100, 90, 100],
            showShadow : [0, 1, 1, 1, 1],
            divLineColor : ['717170', '7B7D6D', '92CDD6', '965B01', '68001B'],
            divLineAlpha : [40, 45, 65, 40, 30],
            altHGridColor : ['EEEEEE', 'D8DCC5', '99C4CD', 'DEC49C', 'FEC1D0'],
            altHGridAlpha : [50, 35, 10, 20, 15],
            altVGridColor : ['767575', 'D8DCC5', '99C4CD', 'DEC49C', 'FEC1D0'],
            altVGridAlpha : [10, 20, 10, 15, 10],
            anchorBgColor : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            toolTipBgColor : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            toolTipBorderColor : ['545454', '545454', '415D6F', '845001', '68001B'],
            baseFontColor : ['555555', '60634E', '025B6A', 'A15E01', '68001B'],
            borderColor : ['767575', '545454', '415D6F', '845001', '68001B'],
            borderAlpha : [50, 50, 50, 50, 50],
            legendBgColor : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            legendBorderColor : ['545454', '545454', '415D6F', '845001', 'D55979'],
            plotGradientColor : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            plotBorderColor : ['333333', '8A8A8A', COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            plotFillColor : ['767575', 'D8DCC5', '99C4CD', 'DEC49C', 'FEC1D0'],
            // -------------- For 3D Chart --------------//
            bgColor3D : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            bgAlpha3D : [HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING, HUNDREDSTRING],
            bgAngle3D : [90, 90, 90, 90, 90],
            bgRatio3D : [BLANK, BLANK, BLANK, BLANK, BLANK],
            canvasBgColor3D : ['DDE3D5', 'D8D8D7', 'EEDFCA', 'CFD2D8', 'FEE8E0'],
            canvasBaseColor3D : ['ACBB99', 'BCBCBD', 'C8A06C', '96A4AF', 'FAC7BC'],
            divLineColor3D : ['ACBB99', 'A4A4A4', 'BE9B6B', '7C8995', 'D49B8B'],
            divLineAlpha3D : [100, 100, 100, 100, 100],
            legendBgColor3D : ['F0F3ED', 'F3F3F3', 'F7F0E8', 'EEF0F2', 'FEF8F5'],
            legendBorderColor3D : ['C6CFB8', 'C8C8C8', 'DFC29C', 'CFD5DA', 'FAD1C7'],
            toolTipbgColor3D : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE],
            toolTipBorderColor3D : ['49563A', '666666', '49351D', '576373', '681C09'],
            baseFontColor3D : ['49563A', '4A4A4A', '49351D', '48505A', '681C09'],
            anchorBgColor3D : [COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE]
        },

        colorManager = lib.colorManager = function(FCObj, iapi) {
            var cm = this,
                FCChartObj = FCObj.chart,
                pO = cm.paletteOptions =
                    extend(lib.extend2({}, defaultPaletteOptions),
                        iapi.defaultPaletteOptions || {}),
                themeColor = cm.themeEnabled = FCChartObj.palettethemecolor;

            cm.paletteIndex = (FCChartObj.palette > 0 &&
                    FCChartObj.palette < 6 ? FCChartObj.palette :
                    pluckNumber(iapi.paletteIndex, 1)) - 1;
            cm.iterator = 0;

            cm.paletteColors = pO.paletteColors[cm.themeEnabled ? 0 :
                    cm.paletteIndex];
            if (defined(FCChartObj.palettecolors) && FCChartObj.palettecolors !== BLANK) {
                cm.paletteColors = FCChartObj.palettecolors.split(/\s*\,\s*/);
            }
            cm.paletteLen = cm.paletteColors.length;
            cm.useFlatColors = pluckNumber(FCChartObj.useflatdataplotcolor,
                iapi.useFlatColor, 0);

            if (themeColor) {
                cm.paletteIndex = 5;
                // Color
                pO.bgColor.push(getLightColor(themeColor, 35) + COMMASTRING +
                        getLightColor(themeColor, 10));
                pO.bgAngle.push(270);
                pO.bgRatio.push(BGRATIOSTRING);
                pO.bgAlpha.push('50,50');
                pO.canvasBgColor.push(COLOR_WHITE);
                pO.canvasBgAngle.push(0);
                pO.canvasBgAlpha.push(HUNDREDSTRING);
                pO.canvasBgRatio.push(BLANK);
                // Color
                pO.canvasBorderColor.push(getDarkColor(themeColor, 80));
                pO.canvasBorderAlpha.push(100);
                pO.showShadow.push(1);
                // Color???
                pO.divLineColor.push(getDarkColor(themeColor, 20));
                pO.divLineAlpha.push(40);
                // Color
                pO.altHGridColor.push(getLightColor(themeColor, 20));
                pO.altHGridAlpha.push(15);
                // Color
                pO.altVGridColor.push(getLightColor(themeColor, 80));
                pO.altVGridAlpha.push(10);
                pO.anchorBgColor.push(COLOR_WHITE);
                pO.toolTipBgColor.push(COLOR_WHITE);
                // Color
                pO.toolTipBorderColor.push(getDarkColor(themeColor, 80));
                // Color
                pO.baseFontColor.push(themeColor.split && themeColor.split(COMMASTRING)[0]);
                // Color
                pO.borderColor.push(getDarkColor(themeColor, 60));
                pO.borderAlpha.push(50);
                pO.legendBgColor.push(COLOR_WHITE);
                // Color
                pO.legendBorderColor.push(getDarkColor(themeColor, 80));
                pO.plotGradientColor.push(COLOR_WHITE);
                // Color
                pO.plotBorderColor.push(getDarkColor(themeColor, 85));
                // Color
                pO.plotFillColor.push(getDarkColor(themeColor, 85));
                // -------------- For 3D Chart --------------//
                pO.bgColor3D.push(COLOR_WHITE);
                pO.bgAlpha3D.push(HUNDREDSTRING);
                pO.bgAngle3D.push(90);
                pO.bgRatio3D.push(BLANK);
                // Color ???
                pO.canvasBgColor3D.push(getLightColor(themeColor, 20));
                // Color ???
                pO.canvasBaseColor3D.push(getLightColor(themeColor, 40));
                // Color ???
                pO.divLineColor3D.push(getDarkColor(themeColor, 20));
                pO.divLineAlpha3D.push(40);
                // Color ???
                pO.legendBgColor3D.push(COLOR_WHITE);
                // Color ???
                pO.legendBorderColor3D.push(getDarkColor(themeColor, 80));
                pO.toolTipbgColor3D.push(COLOR_WHITE);
                // Color ???
                pO.toolTipBorderColor3D.push(getDarkColor(themeColor, 80));
                // Color ???
                pO.baseFontColor3D.push(themeColor.split && themeColor.split(COMMASTRING)[0]);
                pO.anchorBgColor3D.push(COLOR_WHITE);

                // Gauges
                pO.tickColor && pO.tickColor.push(getDarkColor(themeColor, 90));
                pO.trendDarkColor && pO.trendDarkColor.push(getDarkColor(themeColor, 90));
                pO.trendLightColor && pO.trendLightColor.push(getLightColor(themeColor,
                    pO.TrendLightShadeOffset));
                pO.msgLogColor && pO.msgLogColor.push(getLightColor(themeColor, 80));
                // Chart specific colors
                // Angular Gauge Chart
                pO.dialColor && pO.dialColor.push(getDarkColor(themeColor, 95) + ',FFFFFF,' +
                        getDarkColor(themeColor, 95));
                pO.dialBorderColor && pO.dialBorderColor.push(getDarkColor(themeColor, 95) + ',FFFFFF,' +
                        getDarkColor(themeColor, 95));
                pO.pivotColor && pO.pivotColor.push(getLightColor(themeColor, 95) + ',FFFFFF,' +
                        getLightColor(themeColor, 95));
                pO.pivotBorderColor && pO.pivotBorderColor.push(getDarkColor(themeColor, 95) + ',FFFFFF,' +
                        getDarkColor(themeColor, 95));
                // Linear Gauge
                pO.pointerBorderColor && pO.pointerBorderColor.push(getDarkColor(themeColor, 75));
                pO.pointerBgColor && pO.pointerBgColor.push(getDarkColor(themeColor, 75));
                // Thermometer gauge
                pO.thmBorderColor && pO.thmBorderColor.push(getDarkColor(themeColor, 90));
                pO.thmFillColor && pO.thmFillColor.push(getLightColor(themeColor, 55));
                // Cylinder gauge
                pO.cylFillColor && pO.cylFillColor.push(getLightColor(themeColor, 55));
                pO.periodColor && pO.periodColor.push(getLightColor(themeColor, 10));
                // Methods for win loss chart only ???
                pO.winColor && pO.winColor.push('666666');
                pO.lossColor && pO.lossColor.push('CC0000');
                pO.drawColor && pO.drawColor.push('666666');
                pO.scorelessColor && pO.scorelessColor.push('FF0000');

                // Gantt Chart
                pO.gridColor && pO.gridColor.push(getLightColor(themeColor, 30));
                pO.categoryBgColor && pO.categoryBgColor.push(getLightColor(themeColor, 10));
                pO.dataTableBgColor && pO.dataTableBgColor.push(getLightColor(themeColor, 10));
                pO.gridResizeBarColor && pO.gridResizeBarColor.push(getDarkColor(themeColor, 90));
                pO.scrollBarColor && pO.scrollBarColor.push(getLightColor(themeColor, 50));
            }
        };

    colorManager.prototype = {
        /*
         * getColor find the relevant required color from a given entity/element
         * key eg. bgColor, canvasBgColor, plotBorderColor etc.
         * ~param {string} key the name of entity/element to retrieve color
         * ~type string hexcolor
         */
        getColor: function(key) {
            // Return color
            return this.paletteOptions[key][this.paletteIndex];
        },
        /*
         * getPlotColor find the relevant required color for chart's dataplot
         * from a given index or auto generate after incrementing index by 1
         * ~param {number} index of the color in paletteColors Array
         * ~type string hexcolor
         */
        getPlotColor: function(index) {
            var cm = this,
                paletteColors = cm.paletteColors,
                strColor = cm.useFlatColors ? cm.getColor('plotFillColor') :
                    paletteColors[index % cm.paletteLen];

            //Get the color
            if (!strColor) {
                //If iterator is out of bound, reset it to 0
                if (cm.iterator === cm.paletteLen) {
                    cm.iterator = 0;
                }
                strColor = paletteColors[cm.iterator];
                //Increment iterator
                cm.iterator += 1;
            }
            //Return color
            return strColor;
        },
        /*
         * parseColorMix method parses the color mix formula and returns
         * an array of colors depending of the constituents specified in
         * the formula.
         * ~param aColor Actual color on which calculations will be based on.
         * ~param mix Formula containing the mix of colors.
         * Example: ('943A0A','{light-50},FFFFFF,{color},{dark-25}')
         * ~return Array of colors containing the required mix of colors (in RGB) - not HEX
         */
        parseColorMix: function (aColor, mix) {
            //Create a return array
            var rtnArr = [],
            dashIndex,
            intensity,
                //Now, split into main tokens
                tokens,
                colors,
                j,
                defToken,
                defColor,
                token,
                color,
                removeBrecReg,
                i;

            //Remove all spaces from the formula
            mix = mix.replace(/\s/g, BLANK);
            //Convert to lower case for case insensitive comparison
            mix = mix.toLowerCase();
            //If mix is blank, undefined or null, return the single color
            if (mix === '' || mix === null || mix === undefined) {
                rtnArr = [aColor];
            } else {
                //Now, split into main tokens
                tokens = mix.split(COMMASTRING);
                //split COlors into Array
                colors = aColor.split(COMMASTRING);
                j = Math.max(tokens.length, colors.length, 1);
                defToken = tokens[0];
                defColor = colors[0];
                removeBrecReg = /[\{\}]/ig;

                //Iterate through each token to check what it is.
                for (i=0; i<j; i++) {
                    //Remove { and } from token.
                    token = (tokens[i] || defToken).replace(removeBrecReg, BLANK);
                    color = colors[i] || defColor;
                    //Now, based on what token is, we take action
                    if (token == 'color') {
                        //If actual color
                        rtnArr.push(color);
                    } else if (token.substr(0, 5) == 'light') {
                        //Need to find lighter shade
                        //First find the intensity, which the user has specified.
                        //Get dash index
                        dashIndex = token.indexOf('-');
                        intensity = ((dashIndex == -1) ? 1 : (token.substr(dashIndex+1, token.length-dashIndex)));
                        //Now in actual method, 0 means lightest and 1 means normal. So, we've to reverse
                        intensity = 100 - intensity;
                        //Push the lighter color in array
                        rtnArr.push(getLightColor(color, intensity));
                    } else if (token.substr(0, 4) == 'dark') {
                        //Need to find darker shade
                        //First find the intensity, which the user has specified.
                        //Get dash index
                        dashIndex = token.indexOf('-');
                        intensity = (dashIndex == -1) ? 1 : (token.substr(dashIndex+1, token.length-dashIndex));
                        //Now in actual method, 0 means darkest and 1 means normal. So, we've to reverse
                        intensity = 100 - intensity;
                        //Push the darker color in array
                        rtnArr.push(getDarkColor(color, intensity));
                    } else {
                        //User has himself given a normal hex color code.
                        //So, convert and append
                        rtnArr.push(token);
                    }
                }
            }
            //Return array
            return rtnArr;
        },
        /*
         * parseAlphaList method takes a list of alphas separated
         * by comma and returns an array of the individual alphas
         * ~param    strAlphas    List of alphas separated by comma e.g.,
         * 20,30,40 etc.
         * ~param numColors Number of colors for which we've to build
         * the alpha list
         * ~returns An array whose each cell contains a single
         * alpha value (validated).
         */
        parseAlphaList: function (strAlphas, numColors) {
            //Input list of alpha
            //Extract the input alphas
            var arrInputAlphas = strAlphas.split(','),
            //Final list
            arrAlphas = [],
            //Count of valid alphas
            alpha,
            usedAlpha = 100,
            //Loop variable
            i;
            //Change the alpha matrix to number (from string base)
            for (i=0; i<numColors; i++) {
                //Get the alpha
                alpha = pluckNumber(arrInputAlphas[i]);
                //Now, if the alpha is non-numeric or undefined, we set our own values
                //alpha = (isNaN(alpha) || (alpha == undefined)) ? 100 : Number(alpha);
                if (defined(alpha)) {
                    usedAlpha = alpha;
                }
                //Store it in the array
                arrAlphas[i] = usedAlpha;
            }
            //Return the array
            return arrAlphas.join();
        },
        /*
         * parseRatioList method takes a list of color division ratios
         * (on base of 100%) separated by comma and returns an array of
         * the individual ratios (on base of 255 hex).
         * ~param strRatios List of ratios (on base of 100%) separated by
         * comma e.g., 20,40,40 or 5,5,90 etc.
         * ~param numColors Number of colors for which we've to build
         * the ratio list
         * ~returns An array whose each cell contains a single
         * ratio value (on base of 255 hex).
         */
        parseRatioList: function(strRatios, numColors) {
            //Arrays to store input and final ratio
            //Split the user input ratios
            var arrInputRatios = strRatios.split(','),
            arrRatios = [],
            //Sum of ratios
            sumRatio = 0,
            ratio,
            //Loop variable
            i;
            //First, check if all ratios are numbers and calculate sum
            for (i=0; i<numColors; i++) {
                //Get the ratio
                ratio = arrInputRatios[i];
                //Now, if the ratio is non-numeric or undefined, we set our own values
                ratio = (isNaN(ratio) || (ratio === undefined)) ? 0 : Math.abs(Number(ratio));
                //If ratio is greater than 100, restrict it to 100
                ratio = (ratio>100) ? 100 : ratio;
                //Allot it to final array
                arrRatios[i] = ratio;
                //Add to sum
                sumRatio += ratio;
            }
            //Total ratio inputted by user should not exceed 100
            sumRatio = (sumRatio>100) ? 100 : sumRatio;
            //If more colors are present than the number of ratios, we need to
            //proportionately append the rest of values
            if (arrInputRatios.length<numColors) {
                for (i=arrInputRatios.length; i<numColors; i++) {
                    arrRatios[i] = (100-sumRatio)/(numColors-arrInputRatios.length);
                }
            }
            //Now, convert ratio percentage to actual values from 0 to 255 (Hex base)
            arrRatios[-1] = 0;

            //Return the ratios array
            return arrRatios.join();
        }
    };

    colorManager.prototype.constructor = colorManager;

    lib.defaultGaugePaletteOptions = {
        //Store colors now
        //Dark variation of green-yellow-blue: '339900', 'DD9B02', '943A0A'
        paletteColors: [gaugePaletteColors, gaugePaletteColors,
            gaugePaletteColors, gaugePaletteColors, gaugePaletteColors],
        //Store other colors
        // ------------- For 2D Chart ---------------//
        //We're storing 5 combinations, as we've 5 defined palettes.
        bgColor: ['CBCBCB,E9E9E9', 'CFD4BE,F3F5DD', 'C5DADD,EDFBFE', 'A86402,FDC16D', 'FF7CA0,FFD1DD'],
        bgAngle: [270, 270, 270, 270, 270],
        bgRatio: ['0,100', '0,100', '0,100', '0,100', '0,100'],
        bgAlpha: ['50,50', '60,50', '40,20', '20,10', '30,30'],

        toolTipBgColor: ['FFFFFF', 'FFFFFF', 'FFFFFF', 'FFFFFF', 'FFFFFF'],
        toolTipBorderColor: ['545454', '545454', '415D6F', '845001', '68001B'],
        baseFontColor: ['555555', '60634E', '025B6A', 'A15E01', '68001B'],

        tickColor: ['333333', '60634E', '025B6A', 'A15E01', '68001B'],
        trendDarkColor: ['333333', '60634E', '025B6A', 'A15E01', '68001B'],
        trendLightColor: ['f1f1f1','F3F5DD','EDFBFE','FFF5E8','FFD1DD'],

        pointerBorderColor: ['545454', '60634E', '415D6F', '845001', '68001B'],
        pointerBgColor: ['545454', '60634E', '415D6F', '845001', '68001B'],

        canvasBgColor: ['FFFFFF', 'FFFFFF', 'FFFFFF', 'FFFFFF', 'FFFFFF'],
        canvasBgAngle: [0, 0, 0, 0, 0],
        canvasBgAlpha: ['100', '100', '100', '100', '100'],
        canvasBgRatio: ['', '', '', '', ''],
        canvasBorderColor: ['545454', '545454', '415D6F', '845001', '68001B'],
        canvasBorderAlpha: [100, 100, 100, 90, 100]     ,

        altHGridColor: ['EEEEEE', 'D8DCC5', '99C4CD', 'DEC49C', 'FEC1D0'],
        altHGridAlpha: [50, 35, 10, 20, 15],
        altVGridColor: ['767575', 'D8DCC5', '99C4CD', 'DEC49C', 'FEC1D0'],
        altVGridAlpha: [10, 20, 10, 15, 10],

        borderColor: ['767575', '545454', '415D6F', '845001', '68001B'],
        borderAlpha: [50, 50, 50, 50, 50],
        legendBgColor: ['ffffff', 'ffffff', 'ffffff', 'ffffff', 'ffffff'],
        legendBorderColor: ['545454', '545454', '415D6F', '845001', 'D55979'],
        plotFillColor: ['767575', 'D8DCC5', '99C4CD', 'DEC49C', 'FEC1D0'],
        plotBorderColor: ['999999', '8A8A8A', '6BA9B6', 'C1934D', 'FC819F'],
        msgLogColor: ['717170', '7B7D6D', '92CDD6', '965B01', '68001B'],

        TrendLightShadeOffset: 30
    };
}]);
/**
 * @private
 * @module fusioncharts.renderer.javascript.annotations
 * @requires fusioncharts.renderer.javascript.lib
 */
FusionCharts.register('module', ['private', 'modules.renderer.js-annotations', function () {

    var global = this,
        core = global.core,
        lib = global.hcLib,
        win = global.window,
        userAgent = win.navigator.userAgent,
        isIE = /msie/i.test(userAgent) && !win.opera,
        addEvent = lib.addEvent,
        removeEvent = lib.removeEvent,
        hasTouch = lib.hasTouch,
        toNum = win.Number,

        // Lots and lots and lots of constants!
        DEFAULT_DYNAMIC_MACRO_TOKEN_SPLITTER = '.',
        DEFAULT_COLOR = '#ff0000',
        DEFAULT_ALPHA = 100,
        ANNOTATIONS = 'annotations',
        DEFAULT_THICKNESS_PX = 2,
        DEFAULT_POLYGON_SIDES = 5,
        DEFAULT_START_ANGLE = 0,
        DEFAULT_END_ANGLE = 360,
        MINIMUM_TRACKERSTROKE_PX = hasTouch ? 6 : 5,
        HALF = 0.5,
        ONE = '1',
        ZERO = '0',
        BOLD = 'bold',
        NORMAL = 'normal',
        ITALIC = 'italic',
        HIDDEN = 'hidden',
        NONE = 'none',
        ROUND = 'round',
        RADIAL = 'radial',
        DOLLAR = '$',
        PLUSDOLLAR = '+$',
        MINUSDOLLAR = '-$',
        BLANK = '',
        PX = 'px',
        M = 'M',
        A = 'A',
        Z = 'Z',
        L = 'L',
        X = 'x',
        Y = 'y',
        T = 'T',
        S = 'S',
        // NINETY = '90',
        SHAPE_RENDERING = 'shape-rendering',
        STROKE_WEIGHT = 'stroke-weight',
        STROKE_LINECAP = 'stroke-linecap',
        STROKE_WIDTH = 'stroke-width',
        STROKE_DASHARRAY = 'stroke-dasharray',
        TEXT_ANCHOR = 'text-anchor',
        TEXT_BOUND = 'text-bound',
        POLYPATH = 'polypath',
        RINGPATH = 'ringpath',
        VERTICAL_ALIGN = 'vertical-align',
        OBJECT_BOUNDING_BOX = 'objectBoundingBox',
        // POLY = 'poly_',
        POSITION_TOP = 'top',
        // POSITION_RIGHT = 'right',
        POSITION_BOTTOM = 'bottom',
        POSITION_LEFT = 'left',
        POSITION_CENTER = 'center',
        POSITION_MIDDLE = 'middle',
        FUNCTION = 'function',
        OBJECT = 'object',
        SOLID = 'solid',
        CRISP = 'crisp',
        // COMMA = ",",
        // COLON = ":",
        HYPHEN = '-',
        TRACKER_FILL = 'rgba(192,192,192,' + (isIE ? 0.002 : 0.000001) + ')', // invisible but clickable

        // All the mathematical stuffs that we will need.
        math = win.Math,
        // mathAbs = math.abs,
        mathMin = math.min,
        mathMax = math.max,
        mathSin = math.sin,
        mathCos = math.cos,
        mathPI = math.PI,
        deg2rad = mathPI / 180,

        // All the library functions that needs us!
        extend = global.extend,
        pluck = lib.pluck,
        pluckNumber = lib.pluckNumber,
        convertColor = lib.graphics.convertColor,
        getValidValue = lib.getValidValue,
        parseUnsafeString = lib.parseUnsafeString,
        setImageDisplayMode = lib.setImageDisplayMode,
        parseColor = lib.graphics.parseColor,
        setLineHeight = lib.setLineHeight,
        getMouseCoordinate = lib.getMouseCoordinate,

        // Style object that indicates that there are no styles!
        superDefaultStyle = {
            style: {}
        },

        toRaphaelColor = lib.toRaphaelColor,

        normalizeAngles = function (startAngle, endAngle) {
            return {
                start: -endAngle,
                end: -startAngle,
                angle: (startAngle - endAngle)
            };
        },

        /**
         * Create an object by replicating the numeric values within a reference
         * object and duplicating the positive and negative variants.
         *
         * @param {object} hash Reference object containing numeric values.
         * @param {string} positive ID prefix for positive variants.
         * @param {string} neutral ID prefix for unchanged variants.
         * @param {string} negative ID prefix for negatuve variants.
         *
         * @type object
         */
        prepareExpressionLiterals = function (hash, positive, neutral, negative) {

            var rehash = {},
                key;
            // Iterate through the source hash and store the different variants
            // within a rehash object.
            for (key in hash) {
                switch (typeof hash[key]) {
                case OBJECT:

                case FUNCTION:
                    rehash[negative + key] = rehash[neutral + key] =
                        rehash[positive + key] = hash[key];
                    break;

                default:
                    rehash[neutral + key] = rehash[positive + key] = hash[key];
                    rehash[negative + key] = hash[key] * -1;
                }
            }
            return rehash;
        },

        /**
         * Parses a single token and evaluates it piece by piece, each piece being
         * by a dot (.) or whatever character specified, to return a dynamically generated value.
         *
         * @param {string} token - The token to be evaluated.
         * @param {object} hash - The object containing the information about how each
         *  piece of the token ought to be processed further.
         * @param {boolean} isBelow -  Indicates whether the shape in which this
         * token is part of is drawn above or below the chart
         *
         * @returns {number} tokenValue The evaluated value to the provided token.
         */
        evaluateToken = function (token, hash, isBelow) {
            var subtokens = token.split(DEFAULT_DYNAMIC_MACRO_TOKEN_SPLITTER),
                subtoken, // will contain items from subtokens
                evaluator, // will contain the value or fn or obj per subtoken
                value = 0,
                isDynamicMacro;

            while (subtoken = subtokens.shift()) {
                switch (typeof (evaluator = hash[subtoken])) {
                case OBJECT:
                    // If object is found we replace hash with it so that all
                    // subsequent lookups can be performed within it.
                    hash = evaluator[subtoken];
                    break;

                case FUNCTION:
                    // When function is found, it is executed and rest of subtokens passed.
                    // the result is stored in the variable to be taken up by default case.
                    evaluator = evaluator(subtokens, isBelow);
                    // In case token starts with negative, we change the value to negative.
                    if (token.charAt() === HYPHEN) {
                        evaluator *= -1;
                    }
                    isDynamicMacro = true;
                    /* falls through */
                default:
                    // If not obj or num, we simply cast it to num and proceed.
                    value += toNum(evaluator) || 0;
                    subtokens.length = 0; // clear array to exit loop
                }
            }

            // Return an object with isDynamicMacro property
            // so that it can be deduced that the shape which has this macro contains a dynamic macro
            // and value property which has the actual value
            return {
                value: value,
                isDynamicMacro: isDynamicMacro
            };
        },

        /**
         * Parses an expression having both numeric constants and string variables.
         * The parsed result has the numeric portion scaled and the non numeric
         * portion added to the scaled value.
         *
         * @param {string} expr Is the source expression.
         * @param {number} scale Contains the numeric multiplier for the scalable
         * portion of the expression.
         * @param {number} def The default value to be returned in case the
         * expression is blank.
         * @param {object} hash The source expression literals. Expected to have
         * been created via prepareExpressionLiterals function.
         * @param {boolean} isBelow The shape in which this macro is used
         * is drawn below of above the chart, which is required for 3D charts
         *
         * @type number
         */
        parseHybridScale = function (expr, scale, def, hash, isBelow) {

            var scalable = 0, // initial value of accumulator set to zero
                unscalable = 0, // initial value of accumulator set to zero
                // if scale is undefined then scale is assumed to be no-scale (1)
                multiplier = (scale === undefined || scale === null) ? 1 : scale,
                tokens,
                i,
                hasDynamicMacros,
                buf;

            // Validate whether to return default value. Reduces parsing performance
            // overhead
            if (!expr || !expr.toString) {
                return {
                    value: def,
                    hasDynamicMacros: false
                };
            }
            expr = expr.toString();
            // Sanitize expression by removing all white-spaces across it.
            expr = expr.toLowerCase().replace(/\s/g, BLANK);

            // Calculate static elements.
            tokens = expr.match(/^[\+\-]?\d+(\.\d+)?|[\+\-]\d+(\.\d+)?/g);
            if (tokens) {
                for (i = 0; i < tokens.length; i += 1) {
                    scalable = scalable + (Number(tokens[i]) || 0);
                }
                scalable = scalable * multiplier;
            }

            // Calculate dynamic macro elements.
            tokens = expr.match(/^[\+\-]?(\$[a-z0-9\.]+)|[\+\-](\$[a-z0-9\.]+)/g);
            if (tokens) {
                for (i = 0; i < tokens.length; i += 1) {
                    buf = evaluateToken(tokens[i], hash, isBelow);
                    if (buf.isDynamicMacro) {
                        //If there is dynamic macro set the hasDynamicMacros flag to be false
                        hasDynamicMacros = true;
                    }
                    unscalable += buf.value;
                }

            }

            // Calculate dynamic numeric elements.
            tokens = expr.match(/^[\+\-]?\$\d+(\.\d+)?|[\+\-]\$\d+(\.\d+)?/g);
            if (tokens) {
                for (i = 0; i < tokens.length; i += 1) {
                    unscalable = unscalable +
                        Number(tokens[i].replace(DOLLAR, BLANK)) || 0;
                }
            }

            // Add the two components and return an object with a property hasDynamicMacros,value
            // the hasDynamicMacros can be used by the caller to verify if there is a dynamic
            // macro or not
            return {
                value: scalable + unscalable,
                hasDynamicMacros: hasDynamicMacros
            };
        },

        raiseShapeGlobalEvent = function (name, wrapper, event) {
            if (wrapper.removed) {
                return;
            }

            var shape = wrapper.data('annotation'),
                renderer = shape.getRenderer(),
                coords = getMouseCoordinate(renderer.container, event),
                shapeOptions = coords.annotationOptions = shape.options,
                groupOptions = coords.groupOptions = shape.group.options;

            coords._shape = shape;
            ('id' in shapeOptions) && (coords.annotationId = shapeOptions.id);
            ('id' in groupOptions) && (coords.groupId = groupOptions.id);
            global.raiseEvent(name, coords, renderer.fusionCharts, event);
        },

        Annotations,
        Group,
        Shape;

    /**
     * A group of shapes
     * @constructor
     * @alias AnnotationGroup
     *
     * @param {type} options
     * @param {type} sharedOptions
     * @param {type} snapPoints
     * @param {type} store
     */
    Group = function (options, sharedOptions, snapPoints, store, annotations) {
        var items,
            itemOptions,
            i,
            ii;

        /**
         * Options
         */
        this.options = options;
        this.attrs = {};
        this.css = {};
        this.bounds = {};
        this.shared = sharedOptions;
        this.snaps = snapPoints || {};
        this.annotations = annotations;
        /**
         * @type {FusionCharts~Annotation.AnnotationGroup[]}
         */
        this.items = items = []; // store all shapes
        this._idstore = store;
        if (options.id) {
            this._id = options.id;
            store[options.id] = this;
        }

        // create annotations from configuration within options
        if ((itemOptions = options.items)) {
            for (i = 0, ii = itemOptions.length; i < ii; i += 1) {
                items.push(new Shape(itemOptions[i], this));
            }
        }
    };

    extend(Group.prototype, {
        scaleImageX: 1,
        scaleImageY: 1,
        scaleText: 1,
        scaleValue: 1,
        scaleValueComplement: 1,
        scaleX: 1,
        scaleY: 1
    });

    Group.prototype.setup = function () {
        var group = this,
            options = group.options,
            shared = group.shared,
            renderer = group.getRenderer();

        if (!renderer) {
            return;
        }

        group.isBelow = pluckNumber(options.showbelow, options.showbelowchart,
                shared.showbelow) !== 0;

        group.useTracker = !group.isBelow && renderer.layers.tracker &&
                group.shared.useTracker;

        group.raiseOwnEvents = shared.interactionevents;
    };

    Group.prototype.scale = function () {
        var group = this,
            options = group.options,
            shared = group.shared,
            bounds = group.bounds,
            snaps = group.snaps,
            renderer = group.getRenderer(),

            // Keep reference for xscale and yscale values calculated only from
            // shared options (root annotations tag). This is done to perform
            // xscale and yscale operations on x-y positions of groups but
            // ignore x-y position scaling when xscale and yscale is provided
            // at group level.
            rxs = shared.rootxscale,
            rys = shared.rootyscale,

            // Get current scaling factor for x and y directions.
            xs = bounds.xs = pluckNumber(options.xscale, shared.xscale, 100) / 100,
            ys = bounds.ys = pluckNumber(options.yscale, shared.yscale, 100) / 100,

            constrained,
            ow,
            oh,
            scaleW,
            scaleH,
            scaleValue,
            scaleValueComplement,
            scaleX,
            scaleY;

        if (!renderer) {
            return;
        }

        // Set scale for images and text.
        // They are again auto-calculated in autoScale if-block.
        group.scaleText = group.scaleText * ys;
        group.scaleImageX = group.scaleImageX * xs;
        group.scaleImageY = group.scaleImageY * ys;

        // Check whether autoscaling is turned off. If yes, then we do not need
        // to perform scaling.
        if (pluckNumber(options.autoscale, shared.autoscale) !== 0) {

            // Procure origibal width as provided in group or shared options.
            // The shared options is expected to include original-width and
            // original-height of chart element.
            ow = pluckNumber(options.origw, shared.origw);
            oh = pluckNumber(options.origh, shared.origh);

            // Calculate scale factor with respect to current chart width and
            // height.
            scaleW = renderer.chartWidth / ow;
            scaleH = renderer.chartHeight / oh;

            // Calculate flag that checks whether scaling is done in a
            // constrained or unconstrained fashion.
            constrained = (pluckNumber(options.constrainedscale,
                shared.constrainedscale) !== 0);

            // Select the primary scaling axis.
            scaleValue = scaleW < scaleH ? scaleW : scaleH;
            // Select the secondary scaling axis (but only when unconstrained
            // scaling is performed.)
            scaleValueComplement = constrained ? scaleValue :
                    (scaleW < scaleH ? scaleH : scaleW);

            // Finally select the x and y scaling factors based on constrain
            // value.
            scaleX = constrained ? scaleValue : scaleW;
            scaleY = constrained ? scaleValue : scaleH;

            // Update the primary and secondary scale values within the group
            // object.
            group.scaleValue = Group.prototype.scaleValue * scaleValue;
            group.scaleValueComplement = Group.prototype.scaleValueComplement *
                scaleValueComplement;
            group.scaleX = Group.prototype.scaleX * scaleX;
            group.scaleY = Group.prototype.scaleX * scaleY;

            // Update the scale components within the bounds object.
            xs = bounds.xs = bounds.xs * scaleX;
            ys = bounds.ys = bounds.ys * scaleY;

            // Update the root-scaling values.
            rxs = rxs * scaleX;
            rys = rys * scaleY;

            // In case text scaling is turned on, use the y-scaling value to
            // control its font-size
            if (pluck(options.scaletext, shared.scaletext) == ONE) {
                group.scaleText = Group.prototype.scaleText * scaleY;
            }

            // If image scaling is turned on, update the corresponding image
            // scaling numbers.
            if (pluck(options.scaleimages, shared.scaleimages) == ONE) {
                group.scaleImageX = Group.prototype.scaleImageX * scaleX;
                group.scaleImageY = Group.prototype.scaleImageY * scaleY;
            }
        }

        // Compute the xy position of the group bounds.
        bounds.x = parseHybridScale(pluck(options.x, options.xpos),
            rxs, 0, snaps, group.isBelow).value +
            pluckNumber(options.grpxshift, shared.grpxshift, 0);
        bounds.y = parseHybridScale(pluck(options.y, options.ypos),
            rys, 0, snaps, group.isBelow).value +
            pluckNumber(options.grpyshift, shared.grpyshift, 0);

        // Update the xy shifting values.
        group.xshift = pluckNumber(options.xshift, shared.xshift, 0);
        group.yshift = pluckNumber(options.yshift, shared.yshift, 0);
    };

    Group.prototype.draw = function () {
        var group = this,
            renderer = group.getRenderer(),
            options = group.options,
            bounds = group.bounds,
            items = group.items,
            reflayer = (renderer && renderer.layers.dataset),
            wrapper = group.wrapper,
            shape,
            i,
            l;

        if (!renderer) {
            return;
        }

        if (!wrapper) {
            group.wrapper = wrapper = renderer.paper.group(ANNOTATIONS);
            if (reflayer) {
                group.isBelow ? wrapper.insertBefore(reflayer) :
                        wrapper.insertAfter(renderer.layers.datalabels || reflayer);
            }
        }

        group.wrapper.attr({
            x: 0,
            y: 0,
            visibility: pluckNumber(options.visible, 1) ? BLANK : HIDDEN
        }).translate(bounds.x, bounds.y);

        // create annotations from configuration within options
        for (i = 0, l = items.length; i < l; i += 1) {
            shape = items[i];
            shape.scale(true);
            if (shape.queueDraw) {
                shape.queue();
            }
            else {
                shape.setup();
                shape.draw();
            }
            //shape.scale();

        }

        return group;
    };

    Group.prototype.destroy = function () {
        var group = this,
            wrapper = group.wrapper,
            items = group.items,
            item;

        // destroy every annotation
        while ((item = items.shift())) {
            item = item.destroy();
        }

        // destroy wrapper group
        if (wrapper) {
            wrapper = group.wrapper = wrapper.remove();
        }

        if (group._idstore[group._id] === group) {
            delete group._idstore[group._id];
        }

        return undefined;
    };

    Group.prototype.addItem = function (shapeOptions, drawImmediately) {
        var group = this,
            items = group.items,
            store = group._idstore,
            shape;

        items.push(shape = new Shape(shapeOptions, group, store));

        if (drawImmediately && (group.getRenderer() !== null)) {
            shape.scale();
            shape.setup();
            shape.draw();
        }

        return shape;
    };

    Group.prototype.removeItem = function (id) {
        var group = this,
            items = group.items,
            i = items.length;

        while (i--) {
            if (id === items[i]._id) {
                return items.splice(i, 1);
            }
        }
    };

    Group.prototype.getRenderer = function () {
        return ((this.annotations && this.annotations.getRenderer()) || null);
    };

    /**
     * A group of shapes
     * @constructor
     * @alias AnnotationShape
     *
     * @param {object} options
     * @param {FusionCharts~annotations.AnnotationGroup} group
     */
    Shape = function (options, group) {

        var hasEvents = false,
            eventName;

        /**
         * @type {object}
         */
        this.options = options;
        /**
         * @type {FusionCharts~annotations.AnnotationGroup}
         */
        this.group = group;
        this.args = [];
        this.attrs = {};
        this.attrsTracker = {};
        this.style = {};
        this.bounds = {};
        this._idstore = group._idstore;
        if (options.id) {
            this._id = options.id;
            group._idstore[options.id] = this;
        }

        this.type = options.type && options.type.toLowerCase &&
            options.type.toLowerCase();

        for (eventName in Shape.eventNames) {
            if (typeof options[eventName] === FUNCTION) {
                this[eventName] = options[eventName];
                hasEvents = true;
            }
        }
        this.hasEvents = hasEvents;

        // Since onload is non-dom event, we address this separately.
        if (typeof options.onload === FUNCTION) {
            this.onload = options.onload;
        }
    };

    global.extend(Shape.prototype, /** @lends FusionCharts~Annotation.AnnotationShape# */ {
        getAbsoluteBounds: function () {
            var shape = this,
                bounds = shape.bounds,

                x1 = bounds.x1,
                y1 = bounds.y1,
                x2 = bounds.x2,
                y2 = bounds.y2,
                x = mathMin(x1, x2),
                y = mathMin(y1, y2),
                w = mathMax(x1, x2) - x,
                h = mathMax(y1, y2) - y;

            return {
                x: x,
                width: w,
                y: y,
                height: h,
                r: bounds.r,
                unscaled: {
                    width: w / bounds.xs,
                    height: h / bounds.ys
                }
            };
        },

        queue: function () {
            var shape = this;
            shape.group.annotations.shapesToDraw.push(shape);
        },

        scale: function (verify) {
            var shape = this,
                group = shape.group,
                groupBounds = group.bounds,
                bounds = shape.bounds,
                options = shape.options,
                snaps = group.snaps,

                x1 = pluck(options.x, options.xpos),
                y1 = pluck(options.y, options.ypos),
                x2 = pluck(options.tox, options.toxpos),
                y2 = pluck(options.toy, options.toypos),

                xs = bounds.xs = groupBounds.xs,
                ys = bounds.ys = groupBounds.ys,
                dx = pluckNumber(options.xshift, group.xshift, 0),
                dy = pluckNumber(options.yshift, group.yshift, 0),
                parseHybridScaleAndVerify;

            parseHybridScaleAndVerify = function (expr, scale, def, hash) {
                var parsedVal = parseHybridScale(expr, scale, def, hash, group.isBelow);
                // Flag the shape only if verify is called, so that it will not be queued verify is false.
                parsedVal.hasDynamicMacros && verify && (shape.queueDraw = true);

                return parsedVal.value;
            };

            // validate dimension
            shape.hasDimension = true;
            shape.hasDimensionX = true;
            shape.hasDimensionY = true;
            bounds.x1 = parseHybridScaleAndVerify(x1, xs, 0, snaps) + dx;
            if (x2 === undefined) {
                shape.hasDimension = false;
                shape.hasDimensionX = false;
                bounds.x2 = bounds.x1;
            }
            else {
                bounds.x2 = parseHybridScaleAndVerify(x2, xs, 0, snaps) + dx;
            }
            bounds.y1 = parseHybridScaleAndVerify(y1, ys, 0, snaps) + dy;

            if (y2 === undefined) {
                shape.hasDimension = false;
                shape.hasDimensionY = false;
                bounds.y2 = bounds.y1;
            }
            else {
                bounds.y2 = parseHybridScaleAndVerify(y2, ys, 0, snaps) + dy;
            }

            if (Shape.angularShapeTypes[shape.type]) {
                bounds.angles = normalizeAngles(
                    parseHybridScaleAndVerify(options.startangle, 1, DEFAULT_START_ANGLE, snaps),
                    parseHybridScaleAndVerify(options.endangle, 1, DEFAULT_END_ANGLE, snaps));
            }

            bounds.r = parseHybridScaleAndVerify(options.radius, group.scaleValue, 0, snaps);
        },
        setup: function () {
            var shape = this,
                options = shape.options,
                group = shape.group,
                groupOptions = group.options,
                attrs = shape.attrs,
                css = shape.style,

                scale = group.scaleValue,

                groupAlpha = pluckNumber(groupOptions.fillalpha, groupOptions.alpha, DEFAULT_ALPHA),
                fillAlpha = shape.fillAlpha = pluck(options.fillalpha, options.alpha, groupAlpha),
                fillColor = shape.fillColor = pluck(options.fillcolor, options.color, groupOptions.color),
                fillPattern = shape.fillPattern = pluck(options.fillpattern &&
                    options.fillpattern.toLowerCase &&
                    options.fillpattern.toLowerCase(), groupOptions.fillpattern &&
                    groupOptions.fillpattern.toLowerCase &&
                    groupOptions.fillpattern.toLowerCase()),

                bordered = shape.bordered = (pluckNumber(options.showborder,
                    Shape.borderedShapeTypes[shape.type],
                    !!getValidValue(options.bordercolor))),
                borderColor = shape.borderColor = pluck(options.bordercolor,
                    groupOptions.bordercolor, fillColor),
                borderAlpha = shape.borderAlpha =
                    pluckNumber(options.borderalpha, options.alpha,
                            groupOptions.borderalpha, groupAlpha),
                dashed = shape.dashed = !!pluckNumber(options.dashed, 0),
                borderThickness = pluckNumber(options.borderthickness,
                    options.thickness, DEFAULT_THICKNESS_PX) * scale;

            shape.link = pluck(options.link, groupOptions.link);
            shape.shadow = (pluck(options.showshadow, groupOptions.showshadow) == ONE);

            // When no fill color can be derived, we derive default color or not
            // based on the shape's default bordered visibility mode. Similarly, we
            // set the border color to default color in the opposite scenario.
            if (fillColor === undefined) {
                fillColor = Shape.borderedShapeTypes[shape.type] && NONE || DEFAULT_COLOR;
                if (borderColor === undefined) {
                    borderColor = DEFAULT_COLOR;
                }
            }

            // Compute stroke related attributes only when shape has visible stroke.
            if (bordered && borderThickness) {
                // Merge border color and alpha to form stroke property.
                attrs.stroke = convertColor(borderColor, borderAlpha);
                attrs[STROKE_LINECAP] = ROUND;
                attrs[STROKE_WIDTH] = borderThickness;
                if (dashed) {
                    attrs[STROKE_DASHARRAY] = [pluckNumber(options.dashlen, 5) * scale,
                        pluckNumber(options.dashgap, 3) * scale];
                }
            }
            // If stroke is not needed, set it to none in order to avoid default
            // stroke of graphics library.
            else {
                attrs.stroke = NONE;
            }

            shape.fillOptions = {
                gradientUnits : OBJECT_BOUNDING_BOX,
                color: fillColor,
                alpha: fillAlpha,
                ratio: pluck(options.fillratio, groupOptions.fillratio),
                angle: 360 - pluckNumber(options.fillangle, 0),
                radialGradient: fillPattern === RADIAL
            };

            if (shape.link) {
                css.cursor = 'pointer';
                css._cursor = 'hand';
            }

            attrs.visibility = pluckNumber(options.visible, 1) ? BLANK : HIDDEN;

            shape.useTracker = group.useTracker;

            shape.toolText = parseUnsafeString(pluck(options.tooltext,
                    groupOptions.tooltext));

            if (shape.useTracker || shape.link || shape.toolText) {
                extend(shape.attrsTracker, {
                    stroke: TRACKER_FILL,
                    fill: TRACKER_FILL
                });
                shape.link && (shape.attrsTracker.ishot = +new Date());
            }

            shape.raiseOwnEvents = group.raiseOwnEvents;
        },

        draw: function () {
            var shape = this,
                renderer = shape.getRenderer(),
                type = shape.type,
                attrs = shape.attrs,
                style = shape.style,
                paper = renderer && renderer.paper,
                typeName = Shape.types[type] && Shape.types[type].call &&
                    Shape.types[type].call(shape, renderer),
                isImage = Shape.imageShapeTypes[typeName],
                isText = Shape.textShapeTypes[typeName],
                hasPlaceHolderTracker = isImage || isText ||
                    Shape.trackerShapeTypes[typeName],
                needsNativeEvents = shape.link  || shape.toolText,
                wrapper = shape.wrapper,
                tracker = shape.tracker,
                trackerGroup = (renderer && renderer.layers.tracker) || shape.group.wrapper,
                wasLoaded = false,
                bbox,
                eventSubject = tracker || wrapper,
                eventNames = Shape.eventNames,
                ownEvents = Shape.ownEvents,
                eventName,
                event;

            if (!renderer) {
                return;
            }

            if (typeName) {
                // Perform destruction or update in case of redraw
                if (wrapper) {
                    // destroy old wrapper if type changes
                    // note that similar destruction is in destroy method
                    if (wrapper.elemType !== typeName) {
                        if (shape.ownEventsAttached) {
                            for (event in ownEvents) {
                                eventSubject['un' + event].apply(wrapper, ownEvents[event]);
                            }
                            shape.ownEventsAttached = false;
                        }
                        wrapper = wrapper.remove();
                    }
                    // remove events and other stuffs if re-using previous wrapper
                    else if (shape.hasEvents) {
                        for (eventName in eventNames) {
                            if ((event = shape[eventName]) && event.eventAttached) {
                                removeEvent(eventSubject.node, eventNames[eventName],
                                        event);
                                event.eventAttached = false;
                            }
                        }
                    }
                }


                // Build the fill options just before drawing so that it is always
                // updated.
                if (!isImage /*&& attrs.fill === undefined*/) { // images cannot have fill
                    attrs.fill = toRaphaelColor(shape.fillOptions);
                }

                if (!wrapper) {

                    // Push reference to group as last argument.
                    shape.args.push(shape.group.wrapper);

                    wrapper = shape.wrapper =
                       paper[typeName].apply(paper, shape.args).attr(attrs).css(style);
                    wrapper.elemType = typeName;
                    wrapper.data('annotation', shape);
                    // Mark that this wrapper was newly created, so that we can fire
                    // the loaded event later.
                    wasLoaded = true;

                    // Remove the pushed group argument
                    shape.args.pop();
                }
                else {
                    wrapper.attr(attrs).css(style);
                }

                // Since shadow needs to be added post append of the element, we
                // would handle it here.
                if (shape.shadow && !shape.shadowAdded && !(isImage || isText)) {
                    wrapper.shadow((shape.shadowAdded = true),
                        mathMax(shape.borderAlpha, shape.fillOptions.alpha) / 100);
                }
                else {
                    wrapper.shadow((shape.shadowAdded = false));
                }

                // Add tracker only when useTracker is marked as true and has
                // requisite attributes.
                if (needsNativeEvents) {
                    if (shape.useTracker) {
                        if (!tracker) {
                            // Push reference to group as last argument.
                            shape.args.push(trackerGroup);
                            tracker = shape.tracker = (hasPlaceHolderTracker ?
                                paper.rect(0, 0, 0, 0, 0, trackerGroup) :
                                paper[typeName].apply(paper, shape.args));
                            // Remove the pushed group argument
                            shape.args.pop();
                        }

                        // Configure the tracker.
                        tracker.attr(attrs).attr(shape.attrsTracker);
                    }
                }
                // Tracker not needed
                else if (tracker) {
                    tracker = tracker.remove();
                }

                // Pick the element that receives all events.
                eventSubject = tracker || wrapper;

                // Raise events consumed upon interaction with shapes.
                if (shape.raiseOwnEvents && !shape.ownEventsAttached) {
                    for (event in ownEvents) {
                        eventSubject[event].apply(wrapper, ownEvents[event]);
                    }
                    shape.ownEventsAttached = true;
                }

                // Attach the click event to handle link-formats.
                if (shape.link) {
                    eventSubject.click(renderer.linkClickFN, shape);
                }

                // Add tooltip events in case it has tooltext or click event.
                if (shape.toolText) {
                    eventSubject.tooltip(shape.toolText || BLANK);
                    shape.group.wrapper.trackTooltip(true);
                }

                // Attach other custom events
                if (shape.hasEvents) {
                    for (eventName in eventNames) {
                        if ((event = shape[eventName]) && !event.eventAttached) {
                            addEvent(eventSubject.node, eventNames[eventName],
                                    event, shape);
                            event.eventAttached = true;
                        }
                    }
                }

                // For all nonimage elements, we need to perform tracker alignment
                // and fire loaded event. Images have these done on its own "loaded"
                // event handler
                if (!isImage) {
                    // re-align the tracker as per updated wrapper position.
                    if (tracker && hasPlaceHolderTracker) {
                        bbox = wrapper.getBBox();
                        tracker.attr({
                            x: bbox.x,
                            y: bbox.y,
                            width: bbox.width,
                            height: bbox.height
                        });
                    }

                    // Raise onload event for all shapes except that of image. This
                    // is because image callback is called from type-definition.
                    if (wasLoaded) {
                        shape.onload && shape.onload(attrs);
                    }
                }
            }

            return shape;
        },

        destroy: function () {
            var shape = this,
                wrapper = shape.wrapper,
                tracker = shape.tracker,
                eventSubject = tracker || wrapper,
                eventNames = Shape.eventNames,
                ownEvents = Shape.ownEvents,
                eventName,
                event;

            if (wrapper) {
                if (shape.ownEventsAttached) {
                    for (event in ownEvents) {
                        eventSubject['un' + event].apply(wrapper, ownEvents[event]);
                    }
                    shape.ownEventsAttached = false;
                }
                if (shape.hasEvents) {
                    for (eventName in eventNames) {
                        if ((event = shape[eventName]) && event.eventAttached) {
                            removeEvent(eventSubject.node, eventNames[eventName],
                                    event);
                            event.eventAttached = false;
                        }
                    }
                }
                if (tracker) {
                    shape.tracker = tracker.remove();
                }
                shape.wrapper = wrapper.remove();
            }

            if (shape._idstore[shape._id] === shape) {
                delete shape._idstore[shape._id];
            }

            return undefined;
        },

        getRenderer: function () {
            return ((this.group && this.group.getRenderer()) || null);
        }
    });

    global.extend(Shape, /** @lends FusionCharts~Annotation.AnnotationShape */ {
        imageShapeTypes: {
            image: true
        },

        angularShapeTypes: {
            circle: true,
            arc: true
        },

        textShapeTypes: {
            text: true
        },

        trackerShapeTypes: {
            image: true,
            text: true
        },

        borderedShapeTypes: {
            path: true,
            line: true
        },

        eventNames: {
            'onmouseover': hasTouch ? 'touchstart' : 'mouseover',
            'onmouseout': 'mouseout',
            'onmousemove': hasTouch ? 'touchmove' : 'mousemove',
            'onclick': 'click'
        },

        ownEvents: {
            'click': [function (event) {
                /**
                 * Fired when an annotation is clicked
                 * @event FusionCharts~annotations#annotationClick
                 *
                 * @param {number} chartX - x-coordinate of the pointer relative to the chart.
                 * @param {number} chartY - y-coordinate of the pointer relative to the chart.
                 * @param {number} pageX - x-coordinate of the pointer relative to the page.
                 * @param {number} pageY - y-coordinate of the pointer relative to the page.
                 * @param {string} annotationId - Specifies the Id of the annotation (if provided during annotation
                 * creation).
                 * @param {object} annotationOptions - contains all the options that are set on the annotations.
                 * @param {string} groupId - Specifies the Id of the annotation group (if provided during annotation
                 * creation) within which the annotation exists.
                 * @param {object} groupOptions - contains all the options that are set on the annotation group.
                 */
                raiseShapeGlobalEvent('annotationClick', this, event);
            }],

            'hover': [function (event) {
                /**
                 * Fired when the pointer moves over an annotation
                 * @event FusionCharts~annotations#annotationRollOver
                 *
                 * @param {number} chartX - x-coordinate of the pointer relative to the chart.
                 * @param {number} chartY - y-coordinate of the pointer relative to the chart.
                 * @param {number} pageX - x-coordinate of the pointer relative to the page.
                 * @param {number} pageY - y-coordinate of the pointer relative to the page.
                 * @param {string} annotationId - Specifies the Id of the annotation (if provided during annotation
                 * creation).
                 * @param {object} annotationOptions - contains all the options that are set on the annotations.
                 * @param {string} groupId - Specifies the Id of the annotation group (if provided during annotation
                 * creation) within which the annotation exists.
                 * @param {object} groupOptions - contains all the options that are set on the annotation group.
                 */
                raiseShapeGlobalEvent('annotationRollOver', this, event);
            }, function (event) {
                /**
                 * Fired when the pointer moves out of an annotation
                 * @event FusionCharts~annotations#annotationRollOut
                 *
                 * @param {number} chartX - x-coordinate of the pointer relative to the chart.
                 * @param {number} chartY - y-coordinate of the pointer relative to the chart.
                 * @param {number} pageX - x-coordinate of the pointer relative to the page.
                 * @param {number} pageY - y-coordinate of the pointer relative to the page.
                 * @param {string} annotationId - Specifies the Id of the annotation (if provided during annotation
                 * creation).
                 * @param {object} annotationOptions - contains all the options that are set on the annotations.
                 * @param {string} groupId - Specifies the Id of the annotation group (if provided during annotation
                 * creation) within which the annotation exists.
                 * @param {object} groupOptions - contains all the options that are set on the annotation group.
                 */
                raiseShapeGlobalEvent('annotationRollOut', this, event);
            }]
        },

        textAlignOptions: {
            'left': 'start',
            'right' : 'end',
            'center': 'middle'
        },

        textVerticalAlignOptions: {
            'top': POSITION_BOTTOM,
            'middle' : POSITION_MIDDLE,
            'bottom': POSITION_TOP
        },

        textRotationOptions: {
            '0' : '0',
            '1': '270',
            'right': '90',
            'cw': '90',
            'left': '270',
            'ccw': '270'
        },

        types: {
            rectangle: function () {
                var shape = this,
                    args = shape.args,
                    attrs = shape.attrs,
                    absBounds = shape.getAbsoluteBounds(),
                    halfWidth = absBounds.width * HALF;

                // Validate radius.
                if (absBounds.r > halfWidth) {
                    absBounds.r = halfWidth;
                }

                args[0] = attrs.x = absBounds.x;
                args[1] = attrs.y = absBounds.y;
                args[2] = attrs.width = absBounds.width;
                args[3] = attrs.height = absBounds.height;
                args[4] = attrs.r = absBounds.r;

                return 'rect';
            },

            /** @todo Calculate tangentially increased thickness of line when scaled. */
            line: function () {
                var shape = this,
                    args = shape.args,
                    attrs = shape.attrs,
                    bounds = shape.bounds;

                // Prepare path arguments.
                args[0] = attrs.path = [M, bounds.x1, bounds.y1, L, bounds.x2, bounds.y2];

                // In case line is 1 pixel, we need to set the edges to be sharp.
                if (attrs[STROKE_WIDTH] === 1) {
                    attrs[SHAPE_RENDERING] = CRISP;
                }

                if (attrs[STROKE_WIDTH] < MINIMUM_TRACKERSTROKE_PX) {
                    shape.attrsTracker[STROKE_WIDTH] = MINIMUM_TRACKERSTROKE_PX;
                }

                if (shape.bordered && shape.dashed) {
                    shape.attrsTracker[STROKE_DASHARRAY] = SOLID;
                }

                return 'path';
            },

            path: function () {
                var shape = this,
                    args = shape.args,
                    options = shape.options,
                    attrs = shape.attrs,
                    bounds = shape.bounds;

                // Prepare path arguments.
                args[0] = attrs.path = options.path;

                // Transform the shape to the bounds
                attrs.transform = [T, bounds.x1, bounds.y1,
                    S, bounds.xs, bounds.ys, bounds.x1, bounds.y1];

                // In case line is 1 pixel, we need to set the edges to be sharp.
                if (attrs[STROKE_WIDTH] === 1) {
                    attrs[SHAPE_RENDERING] = CRISP;
                }

                return 'path';
            },

            polygon: function () {
                var shape = this,
                    args = shape.args,
                    attrs = shape.attrs,
                    options = shape.options,
                    bounds = shape.bounds,
                    group = shape.group,
                    snaps = group.snaps;



                // Reptrieve the path of the polygin from the renderer.
                args[0] = parseHybridScale(options.sides, 1, DEFAULT_POLYGON_SIDES, snaps, group.isBelow).value;
                args[1] = bounds.x1;
                args[2] = bounds.y1;
                args[3] = bounds.r;
                args[4] = parseHybridScale(options.startangle, 1, DEFAULT_START_ANGLE, snaps, group.isBelow).value;
                args[5] = 0; // indicating closed polygon and not spoke.

                attrs[POLYPATH] = args.slice(0);

                return POLYPATH;
            },

            circle: function (renderer) {
                var shape = this,
                    args = shape.args,
                    attrs = shape.attrs,
                    options = shape.options,
                    bounds = shape.bounds,
                    cw = renderer.chartWidth,
                    ch = renderer.chartHeight,
                    scaleC = shape.group.scaleValueComplement,
                    snaps = shape.group.snaps,
                    angles = bounds.angles,
                    group =  shape.group,
                    r1 = bounds.r,
                    r2,
                    startAngle,
                    endAngle,
                    arcAngle,
                    modAngle,
                    cx,
                    cy,
                    sx,
                    sy,
                    ex,
                    ey,
                    // This poor little variable will carry the path if arc.
                    path;

                // In case radius is not provided, autocalculate one based on 30%
                // of constrained scaling of chart dimensions.
                if (!pluck(options.radius)) {
                    // The radius, when re-calculated, is ensured to be scaled as
                    // per scale values.
                    bounds.r = cw < ch ? (cw * bounds.xs) : (ch * bounds.ys);
                    bounds.r = r1 = bounds.r * 0.3; // 30% of chart dimension
                }

                // Select y-radius, for ovals. In case one is not provided, use the
                // normal radius. Ensure That the yradius picked is scaled as well.
                r2 = parseHybridScale(options.yradius, scaleC, r1, snaps, group.isBelow).value;

                // For circle based shapes, if the gradient color fill pattern is
                // not provided, we will have to set the default to radial. The
                // actual default (as set in 'setup' of any shape) is linear.
                if (!shape.fillPattern) {
                    shape.fillOptions.radialGradient = true;
                    shape.fillPattern = RADIAL;
                }

                // Set gradient focus position in case it is radial
                if (shape.fillPattern === RADIAL) {
                    /** @todo requires verification */
                    shape.fillOptions.cx = shape.fillOptions.cy = HALF;
                }

                modAngle = angles.angle % 360;
                // In case there is no fancy configuration and the shape has not
                // turned out to be oval, we can use the simple circle drawing API.
                // Else the process is much more complex.
                if (!modAngle && (r1 === r2)) {
                    args[0] = attrs.cx = bounds.x1;
                    args[1] = attrs.cy = bounds.y1;
                    args[2] = attrs.r = bounds.r;

                    return 'circle';
                }

                // Do drawing precaution of 360 degrees.
                if (!modAngle) {
                    angles.start = angles.start - 0.001;
                }

                // Convert all the angles to radians.
                startAngle = angles.start * deg2rad;
                endAngle = angles.end * deg2rad;
                arcAngle = angles.angle * deg2rad;

                // Convert the polar system of coordinates to xy system.
                cx = bounds.x1;
                cy = bounds.y1;
                sx = cx + mathCos(startAngle) * r1;
                sy = cy + mathSin(startAngle) * r2;
                ex = cx + mathCos(endAngle) * r1;
                ey = cy + mathSin(endAngle) * r2;

                // Connect arc base and draw the arc.
                path = [M, sx, sy, A, r1, r2, 0, 0, (arcAngle >= mathPI ? 0 : 1),
                    ex, ey, Z];

                args[0] = attrs.path = path;
                return 'path';
            },

            arc: function (renderer) {
                var shape = this,
                    options = shape.options,
                    args = shape.args,
                    attrs = shape.attrs,
                    bounds = shape.bounds,
                    cw = renderer.chartWidth,
                    ch = renderer.chartHeight,
                    group = shape.group,
                    scale = group.scaleValue,
                    angles = bounds.angles;

                // In case radius is not provided, autocalculate one based on 30%
                // of constrained scaling of chart dimensions.
                if (!pluck(options.radius)) {
                    // The radius, when re-calculated, is ensured to be scaled as
                    // per scale values.
                    bounds.r = cw < ch ? (cw * bounds.xs) : (ch * bounds.ys);
                    bounds.r = bounds.r * 0.3; // 30% of chart dimension
                }

                // Bounds inner radius
                bounds.innerR = parseHybridScale(options.innerradius, scale,
                    bounds.r * 0.8, shape.group.snaps, group.isBelow).value;

                // Swap if inner and outer radii are inconsistent.
                // Yes, even this is possible!
                if (bounds.innerR > bounds.r) {
                    bounds.innerR = bounds.innerR + bounds.r;
                    bounds.r = bounds.innerR - bounds.r;
                    bounds.innerR = bounds.innerR - bounds.r;
                }

                // For circle based shapes, if the gradient color fill pattern is
                // not provided, we will have to set the default to radial. The
                // actual default (as set in 'setup' of any shape) is linear.
                if (!shape.fillPattern) {
                    shape.fillOptions.radialGradient = true;
                    shape.fillPattern = RADIAL;
                }

                // Set gradient focus position in case it is radial
                if (shape.fillPattern === RADIAL) {
                    shape.fillOptions.cx = shape.fillOptions.cy = HALF;
                }

                args[0] = bounds.x1;
                args[1] = bounds.y1;
                args[2] = bounds.r;
                args[3] = bounds.innerR;
                args[4] = angles.start * deg2rad;
                args[5] = angles.end * deg2rad;

                attrs[RINGPATH] = args.slice(0);

                return RINGPATH;
            },

            text: function (renderer) {
                var shape = this,
                    args = shape.args,
                    css = shape.style,
                    attrs = shape.attrs,
                    group = shape.group,
                    bounds = shape.bounds,
                    options = shape.options,

                    absBounds = shape.getAbsoluteBounds(),

                    align = pluck(options.align, group.options.textalign,
                        POSITION_CENTER).toLowerCase(),
                    valign = pluck(options.valign, group.options.textvalign,
                        POSITION_MIDDLE).toLowerCase(),

                    text = parseUnsafeString(pluck(options.text, options.label)),
                    smartLabel = renderer.logic.smartLabel,
                    smartText,

                    wrap = pluckNumber(options.wrap, group.options.wraptext, 1),
                    wrapW,
                    wrapH,

                    rotateTextOption = pluck(options.rotatetext, group.options.rotatetext, ZERO)
                        .toLowerCase(),
                    rotation = Shape.textRotationOptions[rotateTextOption],
                    rotate = (rotation !== ZERO),
                    // xOrY = rotate ? X : Y,
                    yOrX = rotate ? Y : X,

                    orphanStyles = renderer.options.orphanStyles,
                    defaultStyle = extend({}, orphanStyles.defaultStyle.style || {}),
                    userStyle = (group.id && orphanStyles[group.id.toLowerCase()]) || superDefaultStyle,
                    // userStyleColor = userStyle.style.color,
                    rootStyle = extend(defaultStyle, userStyle.style),
                    rootFontSize = parseFloat(rootStyle.fontSize),
                    // rotateFactor = rotation == NINETY ? -1 : 1,
                    fontFamily = pluck(options.font, group.options.font,
                        rootStyle.fontFamily),
                    fontSize = pluckNumber(options.fontsize, group.options.fontsize,
                        rootFontSize) * group.scaleText;

                if (wrap) {
                    wrapW = pluckNumber(options.wrapwidth, shape.hasDimensionX ?
                            absBounds.width / bounds.xs : undefined);
                    wrapH = pluckNumber(options.wrapheight, shape.hasDimensionY ?
                            absBounds.height / bounds.ys : undefined);
                    // do the scaling for wrapping width
                    wrapW && (wrapW = wrapW * bounds.xs);
                    wrapH && (wrapH = wrapH * bounds.ys);
                }

                css.fontFamily = fontFamily;
                css.fontWeight = pluckNumber(options.bold, options.isbold, 0) ?
                        BOLD : NORMAL;

                if (pluckNumber(options.italic, options.isitalic, 0)) {
                    css.fontStyle = ITALIC;
                }

                if (options.bgcolor) {
                    !attrs[TEXT_BOUND] && (attrs[TEXT_BOUND] = []);
                    attrs[TEXT_BOUND][0] = parseColor(options.bgcolor);
                }

                if (options.bordercolor) {
                    !attrs[TEXT_BOUND] && (attrs[TEXT_BOUND] = []);
                    attrs[TEXT_BOUND][1] = parseColor(options.bordercolor);
                    attrs[TEXT_BOUND][2] = pluckNumber(options.borderthickness, 1);
                    attrs[TEXT_BOUND][3] = pluckNumber(options.padding, 1);
                }

                /**
                 * @note `fontColor` has been deprecated for version 3.4.0
                 * @todo  Remove this if-block when deprecation cycle of v3.4.0 completes.
                 */
                if (options.fontcolor) {
                    attrs.fill = parseColor(options.fontcolor);
                    shape.fillOptions && (shape.fillOptions.color = attrs.fill);
                }

                css.fontSize = fontSize + PX;
                if (fontSize === rootFontSize) {
                    css.lineHeight = rootStyle.lineHeight;
                }
                else {
                    setLineHeight(css);
                }

                attrs[TEXT_ANCHOR] = Shape.textAlignOptions[align] ||
                        Shape.textAlignOptions.center;

                smartLabel.setStyle(css);
                smartText = smartLabel.getSmartText(text, wrapW, wrapH, false);


                attrs[VERTICAL_ALIGN] = Shape.textVerticalAlignOptions[valign] ||
                    Shape.textVerticalAlignOptions.middle;

                // left margin when left align or centered
                if (attrs[TEXT_ANCHOR] === Shape.textAlignOptions.left) {
                    absBounds[yOrX] = absBounds[yOrX] +
                        pluckNumber(options.leftmargin, 0);
                }
                else if (attrs[TEXT_ANCHOR] === Shape.textAlignOptions.center) {
                    absBounds[yOrX] = absBounds[yOrX] +
                        pluckNumber(options.leftmargin, 0) * HALF;
                }

                if (rotation !== '0') {
                    attrs.rotation = [parseFloat(rotation), absBounds.x, absBounds.y];
                }

                args[0] = attrs.x = absBounds.x;
                args[1] = attrs.y = absBounds.y;
                args[2] = attrs.text = smartText.text;

                smartText.tooltext && (attrs.title = smartText.tooltext);

                delete attrs.stroke;
                delete attrs[STROKE_WEIGHT];

                return 'text';
            },

            image: function (renderer) {
                var shape = this,
                    css = shape.style,
                    chartWidth = renderer.chartWidth,
                    chartHeight = renderer.chartHeight,
                    options = shape.options,
                    attrs = shape.attrs,
                    args = shape.args,
                    url = getValidValue(options.url),

                    // scaleX and scaleY for image shape types have a special ability
                    // to apply xscale and yscale options at the lowest shape level.
                    // Thus, we compute the special scaling here instead of the
                    // standard scale() function.
                    scaleX = shape.group.scaleImageX *
                        pluck(Number(options.xscale), 100) / 100,
                    scaleY = shape.group.scaleImageY *
                        pluck(Number(options.yscale), 100) / 100,

                    // Procure the absolute (original unscaled) dimensions of the
                    // shape so that we can re-apply scaling here based on the
                    // original dimension of the image being loaded.
                    absBounds = shape.getAbsoluteBounds(),

                    // This object will hold the default attributes for positioning
                    // and scaling the image. (return value of setImageDisplayMode
                    // library function.)
                    xattr = {
                        width: 1,
                        height: 1
                    },
                    // This variable will hold the reference image that we need to
                    // load in order to procure the dimensions of the image being
                    // loaded.
                    imageRef;

                // In case no URL is provided, load a dummy rectangle and exit
                // function.
                if (!url) {
                    args[0] = attrs.x = absBounds.x;
                    args[1] = attrs.y = absBounds.y;
                    args[2] = attrs.width = absBounds.width;
                    args[3] = attrs.height = absBounds.height;
                    args[4] = attrs.r = absBounds.r;

                    return 'rect';
                }

                // Create a reference image. We do it this way because the renderer
                // does not have the capability to load image and size it at the
                // same time.
                imageRef = new win.Image();

                // Create event handler to re-compute/scale image when it has
                // loaded.
                imageRef.onload = function () {

                    // Compute the image dimensions.
                    xattr = setImageDisplayMode(NONE,
                            POSITION_TOP, POSITION_LEFT, 100, 0, chartWidth,
                            chartHeight, imageRef);

                    // Since position is fixed at top left, we need to ignore
                    // the xy sent by setImageDisplayMode function.
                    delete xattr.x;
                    delete xattr.y;

                    // Now that we know the original dimensions, scale it!
                    xattr = extend(xattr, {
                        width: (shape.hasDimensionX ?
                            absBounds.unscaled.width : xattr.width) * scaleX,
                        height: (shape.hasDimensionY ?
                            absBounds.unscaled.height : xattr.height) * scaleY
                    });

                    // Set-timeout is done so that when loaded from cache (in IE),
                    // the onload event remains async.
                    setTimeout(function () {
                        var wrapper,
                            tracker,
                            bbox;

                        // apply the updated dimensions...
                        if ((wrapper = shape.wrapper)) {
                            wrapper.attr(xattr);

                            // re-position tracker upon new image dimensions.
                            if ((tracker = shape.tracker)) {
                                bbox = wrapper.getBBox();
                                tracker.attr({
                                    x: bbox.x,
                                    y: bbox.y,
                                    width: bbox.width,
                                    height: bbox.height
                                });
                            }
                            // Opacity / alpha of the image needs to be set using CSS.
                            // shape.fillAlpha already uses the common "alpha" attribute and
                            // thus we do not need to specifically look for alpha.
                            wrapper.css({
                                opacity: (css.opacity = mathMax(pluckNumber(shape.fillAlpha,
                                    shape.borderAlpha), shape.borderAlpha) / 100)
                            });
                        }

                        // Execute the image onload function if it is defined within
                        // provided options parameter.
                        shape.onload && shape.onload(xattr);
                    }, 0);
                };
                imageRef.src = url; // request load of image.

                // Create construction parameters for the image object. We need to
                // compute scaling here as well because IE6 treats image.onload in
                // a synchronous manner.
                args[0] = attrs.src = url;
                args[1] = attrs.x = absBounds.x;
                args[2] = attrs.y = absBounds.y;
                args[3] = attrs.width = (shape.hasDimensionX ?
                    absBounds.unscaled.width : xattr.width) * scaleX;
                args[4] = attrs.height = (shape.hasDimensionY ?
                    absBounds.unscaled.height : xattr.height) * scaleY;

                // Opacity / alpha of the image needs to be set using CSS.
                // shape.fillAlpha already uses the common "alpha" attribute and
                // thus we do not need to specifically look for alpha.
                css.opacity = mathMax(pluckNumber(shape.fillAlpha, shape.borderAlpha),
                        shape.borderAlpha) / 100;

                // Remove the attributes that cause issue while rendering image
                // type of object.
                delete attrs.stroke;
                delete attrs.fill;
                delete attrs[STROKE_LINECAP]; // Weird!

                return 'image';
            }
        }
    });

    /**
     * Annotations let you create your own custom objects within charts. One can create various shapes like polygons,
     * rectangles, circles, arcs, etc., render annotation text at required positions, load external images and much
     * more.
     * @constructor
     * @namespace FusionCharts~annotations
     */
    Annotations = function () {
        /**
         * The list of all the groups that have been rendered using the given instance of the annotations class.
         *
         * @type {FusionCharts~annotations~Groups[]}
         * @memberOf FusionCharts~annotations
         */
        this.groups = [];
        this._idstore = {};
        this._options = {};
    };
    lib.Annotations = Annotations;

    global.extend(Annotations.prototype, /** @lends FusionCharts~annotations# */ {
        /**
         * This method is used to clear any existing groups and shapes that have may have been added to given instance
         * of the annotations object. Once cleared, if a new set of groups have been specified then these groups are
         * added to the annotations instance.
         *
         * @param {object} definition Contains an array of objects that is referenced using the `groups` key where each
         * object corresponds to a new group that is to be added to the annotations.
         * @param {object} options Contains the options that is to be shared across all the groups that are being added.
         * @param {object} snapliterals Contains the object that contains the values corresponding to the various macros
         * pertaining to the chart within which the annotations are being rendered.
         *
         * @private
         */
        reset: function (definition, options, snapliterals) {
            var groups = this.groups,
                literals,
                h;

            this.clear();
            // Prepare the snapping points for the annotations (primarily for
            // macros.)
            if (snapliterals) {
                literals = this._literals = prepareExpressionLiterals(snapliterals,
                    PLUSDOLLAR, DOLLAR, MINUSDOLLAR);
            }

            // Store a copy of the options for further reuse during addition of shapes and groups.
            if (options) {
                this._options = options;
            }

            // Iterate through definition and create groups and their underlying
            // shapes.
            if (definition && definition.groups && groups) {
                for (h = 0; h < definition.groups.length; h += 1) {
                    groups.push(new Group(definition.groups[h], options, literals, this._idstore, this));
                }
            }
        },

        /**
         * Returns the renderer that is associated with the particular instance of Annotations. Set during the draw
         * function.
         *
         * @returns {object} The renderer.
         * @private
         */
        getRenderer: function () {
            return this._renderer;
        },

        /**
         * Adds a group in the annotations that acts as a container for the shapes that have to be drawn within the
         * group. The shapes drawn within a group generally share some properties or characteristics.
         *
         * @param {object} options The options that pertain to the new group element to be added.
         *
         * @returns {object} newGroup The created group object.
         */
        addGroup: function (options) {
            var newGroup,
                renderer = this.getRenderer();

            this.groups.push(newGroup = (new Group(options, this._options, this._literals,
                this._idstore, this)));

            if (renderer) {
                newGroup.setup();
                newGroup.scale();
                newGroup.draw();
            }

            return newGroup;
        },

        /**
         * Adds an item to either a specific group or creates a new group and adds the item to it.
         *
         * @param {string=} [groupId] If the item has to be added to a particular group then, the id of that group is
         * required.
         * @param {object} options The options that have to used to create the item.
         */
        addItem: function (groupId, options, drawImmediately) {
            var newItem,
                group,
                renderer = this.getRenderer();

            // If drawImmediately is true then the item will be drawn immediately, else the item will be drawn
            // the next time the group is updated.
            if (typeof groupId === 'string') {
                group = this._idstore[groupId];
            }
            else {
                drawImmediately = options;
                options = groupId;
            }

            if (group && group.addItem) {
                // get the group item and add the item to the group
                if (!renderer && drawImmediately) {
                    // Cannot draw without a valid renderer assigned to the group.
                    global.raiseWarning(this, '04031411430', 'run', 'Annotations~addItem()', 'Cannot draw the shape' +
                        'if the group has not been drawn. Use Annotations~draw() to draw the group and pass the ' +
                        'renderer to it.');
                    return;
                }
                newItem = group.addItem(options, drawImmediately);
            }
            else {
                // Create a group and add the item to the group.
                newItem = this.addGroup({}).addItem(options, drawImmediately);
            }

            return newItem;
        },

        /**
         * Draws / redraws the groups within the annotation object and the corresponding shapes.
         *
         * @param {object} renderer
         *
         * @private
         */
        draw: function (renderer) {
            var groups = this.groups,
                group,
                i,
                ii;

            if (!groups) {
                return;
            }


            this._renderer = renderer || this._renderer;

            if (!this._renderer) {
                return;
            }

            for (i = 0, ii = groups.length; i < ii; i++) {
                group = groups[i];
                group.setup();
                group.scale();
                group.draw();
            }
        },

        /**
         * Clears all groups and the contained shapes that belong to the annotation object.
         */
        clear: function () {
            var groups = this.groups,
                item;

            if (!groups) {
                return;
            }
            while ((item = groups.shift())) {
                item = item.destroy();
            }
            //cleaning up the queued shapes
            this.shapesToDraw = [];
        },

        /**
         * Destroys the annotation object and frees up the memory being consumed by it.
         *
         * @private
         */
        dispose: function () {
            var item;

            this.disposing = true;
            this.clear();

            for (item in this) {
                delete this[item];
            }
            this.disposed = true;
        },

        /**
         * Hides the item (group or shape) with the given id.
         *
         * @param {string} id
         */
        hide: function (id) {
            var obj = this._idstore[id];
            if (obj) {
                obj.attrs.visibility = HIDDEN;
                obj.wrapper && obj.wrapper.hide();
                return obj;
            }
        },

        /**
         * Shows the item (group or shape) with the given id.
         *
         * @param {string} id
         */
        show: function (id) {
            var obj = this._idstore[id];
            if (obj) {
                obj.attrs.visibility = BLANK;
                obj.wrapper && obj.wrapper.show();
                return obj;
            }
        },

        /**
         * Method to dynamically update a shape or group with an id.
         *
         * @param {string} id The id of the annotation shape or group.
         * @param {string | object} key The option that is to be updated.
         * @param {string} value The new value to be assigned to the option.
         */
        update: function (id, key, value) {
            var obj = this._idstore[id],
                k;

            if (obj && key) {
                if (typeof key === 'object') {
                    key.id && (delete key.id);
                    key.type && (delete key.type);
                    for (k in key) {
                        obj.options[(k + BLANK).toLowerCase()] = key[k] + BLANK;
                    }

                    if (obj.wrapper) {
                        obj.scale();
                        obj.setup();
                        obj.draw();
                    }
                    return obj;
                }
                else {
                    obj.options[(key + BLANK).toLowerCase()] = value + BLANK;
                    if (obj.wrapper) {
                        obj.scale();
                        obj.setup();
                        obj.draw();
                    }
                    return obj;
                }
            }
        },

        /**
         * Destros a particular item (group or shape) with the given id.
         *
         * @param {string} id
         */
        destroy: function (id) {
            var obj = this._idstore[id],
                group = obj.group;

            if (obj && typeof obj.destroy === 'function') {
                if (group) {
                    group.removeItem(id);
                }
                obj.destroy();
            }
        },

        /**
         * An array which will maintain all the shapes that need to be drawn after dynamci macros get correctly
         * evaluated.
         * @private
         */
        shapesToDraw: []
    });

    global.core.addEventListener('beforeinitialize', function (event) {
        if (event.sender.options.renderer === 'javascript') {
            /**
             * Annotations are a set of customisable shapes (squares, circles, texts, images) that can be created and
             * positioned anywhere on charts. Whenever a new FusionCharts object is created, one instance of the class
             * {@link FusionCharts~annotations} is created. Whenever annotation definitions are added via data, this
             * object is updated with the same.
             * @memberOf FusionCharts#
             * @alias annotations
             * @type FusionCharts~annotations
             */
            event.sender.annotations = new Annotations();
        }
    });

    global.core.addEventListener('disposed', function (event) {
        if (event.sender.annotations) {
            event.sender.annotations.dispose();
        }
    });

    global.addEventListener('internal.animationComplete', function (event) {
        var annotations = event.sender.annotations,
            queuedShapes = annotations && annotations.shapesToDraw,
            queuedShapesLength = queuedShapes && queuedShapes.length,
            shape,
            i;

        if (queuedShapesLength) {
            for (i = 0; i < queuedShapesLength; i++) {
                shape = queuedShapes[i];
                shape.queueDraw = false;
                shape.scale();
                shape.setup();
                shape.draw();
            }
            //empty the queued annotations again
            annotations.shapesToDraw = [];
        }
    });

    // Add event handler to manage extra interface functions and other routines
    // required when chart completes rendering process.
    core.addEventListener('rendered', function (event, args) {

        // filter non js renderer
        if (args.renderer !== 'javascript') {
            return;
        }

        var chartObj = event.sender,
            vars = chartObj.jsVars || {},
            hcObj = vars.hcObj,
            api = vars.instanceAPI;

        // We have nothing to do if chartApi does not say annotation is
        // required and if no annotation object has been found.
        if (!(hcObj && api && api.drawAnnotations)) {
            delete chartObj.showAnnotation;
            delete chartObj.hideAnnotation;
            return;
        }

        // Add legacy API for showin and hiding annotations.
        if (!chartObj.showAnnotation) {
            chartObj.showAnnotation = function () {
                chartObj.annotations.show.apply(chartObj.annotations, arguments);
            };
        }
        if (!chartObj.hideAnnotation) {
            chartObj.hideAnnotation = function () {
                chartObj.annotations.hide.apply(chartObj.annotations, arguments);
            };
        }
    });
}]);
/**
 * @private
 * @module fusioncharts.renderer.javascript.logic
 * @requires fusioncharts.renderer.javascript.smartlabel
 * @requires fusioncharts.renderer.javascript.numberformatter
 * @requires fusioncharts.renderer.javascript.dom
 * @requires fusioncharts.renderer.javascript.colormanager
 * @requires fusioncharts.renderer.javascript.annotations
 */
FusionCharts.register('module', ['private', 'modules.renderer.js-base', function () {

    var global = this,
        lib = global.hcLib,
        win = global.window,
        doc = win.document,
        //strings
        BLANKSTRING = lib.BLANKSTRING,
        createTrendLine = lib.createTrendLine,
        DEFAULT_EXPORT_URL = win.location.protocol === 'https:' ?
            'https://export.api3.fusioncharts.com/' :
            'http://export.api3.fusioncharts.com/',
        //add the tools thats are requared
        pluck = lib.pluck,
        getValidValue = lib.getValidValue,
        pluckNumber = lib.pluckNumber,
        getFirstValue = lib.getFirstValue,
        getDefinedColor = lib.getDefinedColor,
        parseUnsafeString = lib.parseUnsafeString,
        FC_CONFIG_STRING = lib.FC_CONFIG_STRING,
        extend2 = lib.extend2, //old: jarendererExtend / margecolone
        getDashStyle = lib.getDashStyle, // returns dashed style of a line series
        parseTooltext = lib.parseTooltext,
        toPrecision = lib.toPrecision,
        percentMacro = '$percentValue',
        dropHash = lib.regex.dropHash,
        HASHSTRING = lib.HASHSTRING,
        getSentenceCase = lib.getSentenceCase,
        extend = function(a, b) { /** @todo refactor dependency */
            var n;
            if (!a) {
                a = {};
            }
            for (n in b) {
                a[n] = b[n];
            }
            return a;
        },
        addEvent = lib.addEvent,
        pInt = function(s, mag) {
            return parseInt(s, mag || 10);
        },
        UNDEFINED,
        defined = function(obj) {
            return obj !== UNDEFINED && obj !== null;
        },
        PX = 'px',
        math = win.Math,
        TOUCH_THRESHOLD_PIXELS = lib.TOUCH_THRESHOLD_PIXELS,
        CLICK_THRESHOLD_PIXELS = lib.CLICK_THRESHOLD_PIXELS,
        mathMin = math.min,
        mathMax = math.max,
        mathAbs = math.abs,
        mathCeil = math.ceil,
        mathFloor = math.floor,
        mathLog = math.log,
        mathPow = math.pow,
        mathRound = math.round,
        getColumnColor = lib.graphics.getColumnColor,
        getFirstColor = lib.getFirstColor,
        setLineHeight = lib.setLineHeight,
        pluckFontSize = lib.pluckFontSize, // To get the valid font size (filters negative values)
        getFirstAlpha = lib.getFirstAlpha,
        getDarkColor = lib.graphics.getDarkColor,
        getLightColor = lib.graphics.getLightColor,
        convertColor = lib.graphics.convertColor,
        COLOR_TRANSPARENT = lib.COLOR_TRANSPARENT,
        POSITION_CENTER = lib.POSITION_CENTER,
        POSITION_TOP = lib.POSITION_TOP,
        POSITION_BOTTOM = lib.POSITION_BOTTOM,
        POSITION_RIGHT = lib.POSITION_RIGHT,
        POSITION_LEFT = lib.POSITION_LEFT,
        parsexAxisStyles = lib.parsexAxisStyles,
        POSITION_MIDDLE = 'middle',
        POSITION_START = 'start',
        POSITION_END = 'end',
        INT_ZERO = 0,
        ChartAPI = lib.chartAPI,
        chartAPI = ChartAPI,
        mapSymbolName = lib.graphics.mapSymbolName,
        singleSeriesAPI = chartAPI.singleseries,
        multiSeriesAPI = chartAPI.multiseries,
        COMMASTRING = lib.COMMASTRING,
        STRINGUNDEFINED = lib.STRINGUNDEFINED,
        ZEROSTRING = lib.ZEROSTRING,
        ONESTRING = lib.ONESTRING,
        HUNDREDSTRING = lib.HUNDREDSTRING,
        PXSTRING = lib.PXSTRING,
        COMMASPACE = lib.COMMASPACE,
        isIOS = win.navigator.userAgent.match(/(iPad|iPhone|iPod)/g),
        creditLabel = false && !/fusioncharts\.com$/i.test(win.location.hostname),
        TEXT_ANCHOR_MAP = {
            left : 'start',
            right: 'end',
            center: 'middle'
        },

        //strings
        BLANKSTRINGPLACEHOLDER = lib.BLANKSTRINGPLACEHOLDER,
        BGRATIOSTRING = lib.BGRATIOSTRING,
        COLOR_WHITE = lib.COLOR_WHITE,/** @todo replace all white color code whith this */
        TESTSTR = lib.TESTSTR,
        getAngle = lib.graphics.getAngle,
        AxisLabelAdder = lib.axisLabelAdder,
        falseFN = lib.falseFN,

        //add the tools thats are requared
        NumberFormatter = lib.NumberFormatter,
        getLinkAction = lib.getLinkAction,
        getAxisLimits = lib.getAxisLimits,

        CreateDialog = lib.createDialog,

        logOf = function (value, base) {
            return (value > 0) ? (mathLog(value) / mathLog(base || 10)) : null;
        },

        hasTouch = lib.hasTouch = doc.documentElement.ontouchstart !== undefined,

        /**
         * Fire an event on a custom object
         * @param {object} el
         * @param {string} type
         * @param {object} eventArguments
         * @param {function} defaultFunction
         */
        fireEvent = lib.fireEvent = function(el, type, eventArguments, defaultFunction) {
            lib.dem.fire(el, type, eventArguments, defaultFunction);
        },

        styleValueMap = {
            fontWeight : {
                '1' : 'bold',
                '0': 'normal'
            },
            fontStyle : {
                '1' : 'italic',
                '0': 'normal'
            },
            textDecoration : {
                '1' : 'underline',
                '0': 'none'
            }
        },

        fontStyleMap = {//create the map function for every fontstyle attribute
            font: function (value, obj) {
                obj.style.fontFamily = value;
            },
            size: function (value, obj) {
                if (value) {
                    obj.style.fontSize = pluckFontSize(value) + PXSTRING;
                }

            },
            color: function (value, obj, isDataValues) {
                obj.style.color = value && value.replace && value.replace(dropHash, HASHSTRING) || BLANKSTRING;
                if (isDataValues) {
                    obj.color = obj.style.color;
                }
            },
            /* align has been suppressed until better implementation.
            align: function (value, obj) {

                 if (value.toLowerCase) {
                    obj.align = value.toLowerCase();
                }
            },*/
            bgcolor: function (value, obj) {
                obj.style.backgroundColor = value && value.replace && value.replace(dropHash, HASHSTRING) ||
                    BLANKSTRING;
            },
            bordercolor: function (value, obj) {
                obj.style.border = '1px solid';
                obj.style.borderColor = value && value.replace && value.replace(dropHash, HASHSTRING) || BLANKSTRING;
            },
            ishtml: BLANKSTRING,
            leftmargin: function (value, obj) {
                obj.style.marginLeft =  pluckNumber(value, 0) + PXSTRING;
            },
            letterspacing: function (value, obj) {
                obj.style.letterSpacing = pluckNumber(value, 0) + PXSTRING;
            },
            bold: function (value, obj) {
                obj.style.fontWeight = styleValueMap.fontWeight[value] || '';
            //obj.style.fontWeight = value == '1' ? 'bold' : '';
            },
            italic: function (value, obj) {
                obj.style.fontStyle = styleValueMap.fontStyle[value] || '';
            },
            underline: function (value, obj) {
                obj.style.textDecoration = styleValueMap.textDecoration[value] || '';
            }
        },

        // Palette string and 3d chart palette string
        chartPaletteStr = lib.chartPaletteStr = {
            chart2D: {
                bgColor : 'bgColor',
                bgAlpha : 'bgAlpha',
                bgAngle : 'bgAngle',
                bgRatio : 'bgRatio',
                canvasBgColor : 'canvasBgColor',
                canvasBaseColor : 'canvasBaseColor',
                divLineColor : 'divLineColor',
                legendBgColor : 'legendBgColor',
                legendBorderColor : 'legendBorderColor',
                toolTipbgColor : 'toolTipbgColor',
                toolTipBorderColor : 'toolTipBorderColor',
                baseFontColor : 'baseFontColor',
                anchorBgColor : 'anchorBgColor'
            },
            chart3D : {
                bgColor : 'bgColor3D',
                bgAlpha : 'bgAlpha3D',
                bgAngle : 'bgAngle3D',
                bgRatio : 'bgRatio3D',
                canvasBgColor : 'canvasBgColor3D',
                canvasBaseColor : 'canvasBaseColor3D',
                divLineColor : 'divLineColor3D',
                divLineAlpha : 'divLineAlpha3D',
                legendBgColor : 'legendBgColor3D',
                legendBorderColor : 'legendBorderColor3D',
                toolTipbgColor : 'toolTipbgColor3D',
                toolTipBorderColor : 'toolTipBorderColor3D',
                baseFontColor : 'baseFontColor3D',
                anchorBgColor : 'anchorBgColor3D'
            }
        },

        handleContainerResize = (function () {
            var store = {},
                intervalId,
            trackResize = function () {
                var item,
                    itemObj,
                    itemVar,
                    parentEle,
                    count = 0,
                    ref,
                    s,
                    offW,
                    INTERVALMS = parseInt(global.core.options.resizeTrackingInterval, 10) || 300,
                    offH;

                for (item in store) {
                    count += 1;
                    itemObj = store[item];
                    itemVar = itemObj.jsVars,
                    ref = itemObj.ref;

                    if (!itemObj.disposed && (parentEle = ref && ref.parentNode) &&
                            (s = ref.style) &&
                            (/\%/g.test(s.width) || /\%/g.test(s.height))) {
                        offW = parentEle.offsetWidth;
                        offH = parentEle.offsetHeight;

                        if (!itemVar.resizeLocked &&
                            ((offW && itemVar._containerOffsetW !== offW) ||
                                (offH && itemVar._containerOffsetH !== offH))) {
                            itemObj.resizeTo && itemObj.resizeTo();
                            itemVar._containerOffsetW = offW;
                            itemVar._containerOffsetH = offH;
                        }
                    }
                    else {
                        delete store[item];
                        count -= 1;
                    }
                }

                if (!count) {
                    intervalId = clearTimeout(intervalId);
                }
                else {
                    intervalId = setTimeout(trackResize, INTERVALMS);
                }
            };

            return function (sender, container) {
                var vars = sender.jsVars,
                    element = container || sender.ref && sender.ref.parentNode || {};

                vars._containerOffsetW = element.parentNode.offsetWidth;
                vars._containerOffsetH = element.parentNode.offsetHeight;
                store[sender.id] = sender;

                if (!intervalId) {
                    intervalId = setTimeout(trackResize,
                        parseInt(global.core.options.resizeTrackingInterval, 10) || 300);
                }
            };
        })(),

        privateAPIMethods = /** @lends FusionCharts# */{
            getExternalInterfaceMethods: function () {
                var vars = this.jsVars,
                api = chartAPI[vars.type],
                eiMethods = api && api.eiMethods,
                eiMethodString =
                    'saveAsImage,print,exportChart,getXML,hasRendered,signature,cancelExport,getSVGString,lockResize,' +
                    'showChartMessage,',
                method;

                if (typeof eiMethods === 'string') {
                    eiMethodString += eiMethods + COMMASTRING;
                }
                else if (eiMethods !== undefined || eiMethods !== null) {
                    for (method in eiMethods) {
                        eiMethodString += method + COMMASTRING;
                    }
                }

                return eiMethodString.substr(0, eiMethodString.length -1);
            },

            drawOverlayButton: function (args) {
                var vars = this.jsVars,
                    backBtn = vars.overlayButton,
                    cssObj,
                    item,
                    text;

                if (args && args.show) {
                    if (!backBtn) {
                        backBtn = vars.overlayButton = doc.createElement('span');

                        lib.dem.listen(backBtn, 'click', function () {
                            /**
                             * On clicking the data plot items of a parent chart, the associated linked chart is opened.
                             * To go back to the parent chart, the overlay *back* button is used.
                             * `OverlayButtonClick` is fired when the overlay *back* button of the linked chart is
                             * clicked.
                             * This will close the child linked chart and reload the parent chart.
                             *
                             * @event FusionCharts#overlayButtonClick
                             * @param {string} id Id of the button
                             * @param {boolean} show `True` if we want to show the overlay button in the parent chart.
                             * `False` if we want to disable the overlay button.
                             */
                            global.raiseEvent('OverlayButtonClick', args, vars.fcObj);
                        });
                    }

                    text = args.message ? args.message : 'Back';
                    // Remove all child nodes of the overlay button, before appending new child nodes
                    while (backBtn.firstChild) {
                        backBtn.removeChild(backBtn.firstChild);
                    }
                    backBtn.appendChild(doc.createTextNode(text));
                    vars.overlayButtonMessage = text; // #FCXT-217

                    // Create the visual layout of the element.
                    cssObj = {
                        border: '1px solid ' + (args.borderColor ?
                            args.borderColor.replace(dropHash, HASHSTRING) : '#7f8975'),
                        backgroundColor: (args.bgColor ? args.bgColor.replace(dropHash, HASHSTRING) : '#edefec'),
                        fontFamily: args.font ? args.font : 'Verdana,sans',
                        color: '#' + args.fontColor ? args.fontColor: '49563a',
                        fontSize: (args.fontSize ? args.fontSize : '10') + PXSTRING,
                        padding: (args.padding ? args.padding : '3') + PXSTRING,
                        fontWeight: parseInt(args.bold, 10) === 0 ? 'normal' : 'bold',
                        position: 'absolute',
                        top: '0',
                        right: '0',
                        '_cursor': 'hand',
                        cursor: 'pointer'
                    };

                    for (item in cssObj) {
                        backBtn.style[item] = cssObj[item];
                    }

                    vars.hcObj.container.appendChild(backBtn);
                    vars.overlayButtonActive = true;
                }
                else if (backBtn) {
                    vars.overlayButton = backBtn.parentNode.removeChild(backBtn);
                    vars.overlayButtonActive = false;
                    delete vars.overlayButtonMessage;
                }
            },

            /**
             * You can use this function to print individual charts. This function hides all elements on the page except
             * the chart in concern and then invokes the page printing function (`window.print()`).
             *
             * > This function works only for charts that have rendered completely, i.e. after
             * {@link FusionCharts#event:renderComplete} event has fired.
             *
             * @param {object=} [options] - Printing options
             * @param {boolean=} [options.hideButtons=true] - Hides all buttons on the chart.
             * @group export
             * @example
             * // In this snippet of code, we will render a chart on a page and
             * // call the print method on the chart on click of a button.
             * FusionCharts.ready(function () {
             *    FusionCharts.render({
             *        type: 'column2d',
             *        dataFormat: 'jsonurl',
             *        dataSource: 'data.json',
             *
             *        // assuming an HTML div element exists on the page
             *        renderAt: 'chart-container-div'
             *
             *        events: {
             *            renderComplete: function (event) {
             *                // assuming a button exists on page with a specific id
             *                var button = document.getElementById('print-button');
             *                button.onclick = function () {
             *                    event.sender.print();
             *                };
             *            }
             *        }
             *
             *    });
             * });
             *
             * @fires FusionCharts#beforePrint
             * @fires FusionCharts#printComplete
             * @fires FusionCharts#printCancelled
             */
            print: function (options) {
                return this.jsVars.hcObj && this.jsVars.hcObj.hasRendered && this.jsVars.hcObj.print(options);
            },

            /**
             * Exports a chart to image or PDF document using this function. The function can be configured to export
             * a chart and present it as a file download. Exporting of a chart is not enabled by default. The chart's
             * data must have the `exportEnabled` chart attribute explicitly set to `1`.
             *
             * When exporting of a chart is enabled, it is exported using a set of default options. These options can be
             * overridden by configuring the chart data. That would allow you to configure the behavior of the export
             * related context-menu drawn on the chart. However, in the event that exporting is done programmatically,
             * the export parameters can be customized using this function.
             *
             * > The exporting process can only be initiated after the {@link FusionCharts#event:renderComplete} event
             * > has been fired. The function itself remains undefined until the {@link FusionCharts#event:loaded} event
             * > is raised by the chart.
             *
             * @group export
             * @see FusionCharts#event:beforeExport
             * @see FusionCharts#event:exported
             * @see FusionCharts#event:exportCancelled
             * @tutorial interactivity-export-to-image-or-pdf-configuring-for-export
             * @tutorial interactivity-export-to-image-or-pdf-set-your-export-server
             *
             * @param {object=} [options] -
             * @param {string=} [options.exportFormat=png] - A chart can be exported in one of the following formats:
             *
             * | Export Format  | Description                                               |
             * |----------------|-----------------------------------------------------------|
             * | `png`          | Exports the charts in high quality lossless PNG format    |
             * | `jpg`          | Exports the chart as high quality JPEG image format       |
             * | `pdf`          | Exports the chart as a PDF document                       |
             *
             * @param {string=} [options.exportFileName=FusionCharts] - Using this attribute you can specify the name
             * (excluding the extension) of the file to be exported. The extension is automatically appended depending
             * on the `exportFormat` specified.
             * @param {string=} [options.exportTargetWindow=_self] - When using `download` as `exportAction`, this lets
             * you configure whether the return image or PDF will open in same window (as an attachment for download),
             * or whether it will open in a new browser window (`_blank`).
             * @param {string=} [options.exportHandler] - URL of the export server.
             * @param {string=} [options.exportAction=download] - Specifies whether the exported image will be sent
             * back to the browser as download, or whether it will be saved on to the server.
             *
             * | Action Value    | Description                                                      |
             * |-----------------|------------------------------------------------------------------|
             * | `download`      | Causes the exported chart image or PDF to be downloaded as file. |
             * | `save`          | Causes the exported chart to be saved on server.                 |
             *
             * For the charts to be saved on server, you would need to setup your own export handling server.
             *
             * @param {function=} [options.exportCallback=FC_Exported] - This attribute specifies the name of the
             * callback JavaScript function which will be called when the export event is complete. The function
             * `window.FC_Exported` is the default method that will be called when no value specified.
             *
             * @returns {boolean} The function returns `true` if export process of the chart was successfully triggered,
             * otherwise it returns `false`.
             */
            exportChart: function (options) { //export the chart
                var vars = this.jsVars,
                    hcObj = vars.hcObj;

                // check whether exporting is enabled or not
                if (hcObj && hcObj.options && hcObj.options.exporting &&
                    hcObj.options.exporting.enabled) {
                    return hcObj.exportChart(options);
                }
                return false;
            },

            /**
             * Fetch the SVG of a chart as a string. This function returns the SVG that has been created by FusionCharts
             * when rendering the chart.
             * > Note that this function is only available for a chart that has already been rendered.
             *
             * @group export
             *
             * @returns {string} - SVG string
             */
            getSVGString: function () {
                return this.jsVars && this.jsVars.hcObj &&
                    this.jsVars.hcObj.paper && this.jsVars.hcObj.paper.toSVG();
            },

            resize: function () {
                var vars = this.jsVars,
                    container = vars.container,
                    hcObj = vars.hcObj;

                if (!hcObj) {
                    return;
                }

                // destroy old chart
                if (hcObj && hcObj.destroy) {
                    hcObj.destroy();
                }

                lib.createChart(vars.fcObj, container, vars.type, undefined,
                    undefined, false, true);

                delete vars.isResizing;
            },

            /**
             * Controls a chart's automatic resizing ability when its dimension is in percentage.
             *
             * This function has to be called before a chart has rendered. Using {@link FusionCharts#hasRendered} can be
             * useful here.
             *
             * If this function is called without parameter, it returns the current state of resize lock.
             *
             * @group chart:resize
             *
             * @param {boolean=} [state] - Sending `true` for this parameter causes the automatic percentage based
             * resize to be turned off. If resize is already locked, sending `false` unlocks it.
             *
             * @returns {boolean} - Returns whether the chart's automatic resize feature has been locked or not.
             */
            lockResize: function (state) {
                if (typeof state !== 'boolean') {
                    return !!this.jsVars.resizeLocked;
                }

                return (this.jsVars.resizeLocked = state);
            },

            /**
             * Shows a text message on a chart.
             *
             * @param {string} text The text message that needs to be displayed.
             * @param {boolean=} [modal=false] Boolean value whether to show the message on an overlay or on the chart.
             * Defaults to `false`.
             * @param {boolean=} [cancelable=false] Boolean value applicable only if modal is `true`. If set to true
             * the modal can be closable on click. Defaults to `false`.
             */
            showChartMessage: function (text, modal, cancelable) {
                var vars = this.jsVars,
                    hcObj = vars.hcObj,
                    fcObj = vars.fcObj,
                    options = fcObj.options;

                if (vars.msgStore[text]) {
                    text = vars.msgStore[text];
                }

                if (modal && hcObj && hcObj.hasRendered) {
                    text ? hcObj.showMessage(text, cancelable) : hcObj.hideLoading();
                }
                else {
                    // destroy old chart
                    if (hcObj && hcObj.destroy) {
                        hcObj.destroy();
                    }

                    // Set chart message styling
                    fcObj._chartMessageStyle = {
                        color: options.baseChartMessageColor,
                        fontFamily: options.baseChartMessageFont,
                        fontSize: options.baseChartMessageFontSize
                    };
                    // create new dialog json and render chart
                    lib.createChart(vars.fcObj, vars.container, vars.type, undefined, text);
                }
                return text;
            },

            signature: function () {
                return 'FusionCharts/3.4.0 (XT)';
            }
        },

        //this function will create a default FCC object
        /** @todo have to modify the function for various formatter */
        hcStub = lib.HCstub = function (fc, width, height, iapi) {
            var chartAttr = fc.chart,
                borderThickness = pluckNumber(chartAttr.showborder, 1) ? pluckNumber(chartAttr.borderthickness, 1) : 0,
                marginTop = pluckNumber(chartAttr.charttopmargin, iapi.charttopmargin, 15) + borderThickness,
                marginRight = pluckNumber(chartAttr.chartrightmargin, iapi.chartrightmargin, 15) + borderThickness,
                marginBottom = pluckNumber(chartAttr.chartbottommargin, iapi.chartbottommargin, 15) + borderThickness,
                marginLeft = pluckNumber(chartAttr.chartleftmargin, iapi.chartleftmargin, 15) + borderThickness,
                verticalMargin = marginTop + marginBottom,
                horizontalMargin = marginLeft + marginRight,
                maxVMargin = (0.7 * height),
                maxHMargin = (0.7 * width),
                stubHC;


            // failsafe in case some user gives an arbitrarily high value for chart margins
            if (verticalMargin > maxVMargin) {
                marginTop -=
                    (((verticalMargin - maxVMargin) * marginTop) / verticalMargin);
                marginBottom -=
                    (((verticalMargin - maxVMargin) * marginBottom) / verticalMargin);
            }

            if (horizontalMargin > maxHMargin) {
                marginLeft -=
                    (((horizontalMargin - maxHMargin) * marginLeft) / horizontalMargin);
                marginRight -=
                    (((horizontalMargin - maxHMargin) * marginRight) / horizontalMargin);
            }

            stubHC = {
                '_FCconf': {
                    0 : {
                        stack : {}
                    },
                    1 : {
                        stack : {}
                    },
                    x : {
                        stack : {}
                    },
                    oriCatTmp : [],
                    noWrap : false,//wrap a text if there has no space in width
                    marginLeftExtraSpace : 0,
                    marginRightExtraSpace : 0,
                    marginBottomExtraSpace : 0,
                    marginTopExtraSpace : 0,
                    marimekkoTotal : 0//total for marimekko charts
                },
                chart: {
                    alignTicks: false,
                    //renderTo: BLANKSTRING,
                    ignoreHiddenSeries: false,
                    events: {
                    },
                    reflow: false,
                    spacingTop: marginTop,
                    spacingRight: marginRight,
                    spacingBottom: marginBottom,
                    spacingLeft: marginLeft,
                    marginTop: marginTop,
                    marginRight: marginRight,
                    marginBottom: marginBottom,
                    marginLeft: marginLeft,
                    borderRadius: 0,
                    plotBackgroundColor : '#FFFFFF',
                    style : {},
                    animation: !pluckNumber(chartAttr.defaultanimation, chartAttr.animation, 1) ? false : {
                        duration: pluckNumber(chartAttr.animationduration, 1) * 500
                    }
                },
                /** @todo HC indexing issue have check when it is solved */
                colors: ['AFD8F8', 'F6BD0F', '8BBA00', 'FF8E46', '008E8E',
                'D64646', '8E468E', '588526', 'B3AA00', '008ED6',
                '9D080D', 'A186BE', 'CC6600', 'FDC689', 'ABA000',
                'F26D7D', 'FFF200', '0054A6', 'F7941C', 'CC3300',
                '006600', '663300', '6DCFF6'],
                credits: {
                    href: lib.CREDIT_HREF,
                    text: lib.CREDIT_STRING,
                    enabled: creditLabel
                },
                global: {},
                labels: {
                    items: []
                },
                lang: {},
                legend: {
                    enabled : true,
                    symbolWidth: 12,
                    borderRadius: 1,
                    backgroundColor: '#FFFFFF',
                    initialItemX : 0,
                    title : {
                        text : BLANKSTRING,
                        x : 0,
                        y : 0,
                        padding : 2
                    },
                    scroll : {},
                    itemStyle: {}
                },
                loading: {},
                plotOptions: {
                    series: {
                        pointPadding: 0,
                        borderColor : '#333333',
                        events: {},
                        animation: !pluckNumber(chartAttr.animation,
                            chartAttr.defaultanimation, 1) ? false : {
                                duration: pluckNumber(chartAttr.animationduration, 1) * 1000
                            },
                            states: {
                                hover: {
                                    enabled: false
                                },
                                select: {
                                    enabled: false
                                }
                            },
                            dataLabels : {
                                enabled : true,
                                color: '#555555',
                                style: {},
                                formatter : function () {
                                    if(this.point.showPercentValues) {
                                        return iapi.numberFormatter.percentValue(this.percentage);
                                    }
                                    else {
                                        return this.point.displayValue;
                                    }
                                }
                            },
                            point: {
                                events: {}
                            }
                        },
                        area: {
                            states: {
                                hover: {
                                    enabled: false
                                }
                            },
                            marker: {
                                lineWidth: 1,
                                radius: 3,
                                states: {
                                    hover: {
                                        enabled: false
                                    },
                                    select: {
                                        enabled: false
                                    }
                                }
                            }
                        },
                        radar: {
                            states: {
                                hover: {
                                    enabled: false
                                }
                            },
                            marker: {
                                lineWidth: 1,
                                radius: 3,
                                states: {
                                    hover: {
                                        enabled: false
                                    },
                                    select: {
                                        enabled: false
                                    }
                                }
                            }
                        },
                        areaspline: {
                            states: {
                                hover: {
                                    enabled: false
                                }
                            },
                            marker: {
                                lineWidth: 1,
                                radius: 3,
                                states: {
                                    hover: {
                                        enabled: false
                                    },
                                    select: {
                                        enabled: false
                                    }
                                }
                            }
                        },
                        line: {
                            shadow: true,

                            states: {
                                hover: {
                                    enabled: false
                                }
                            },
                            marker: {
                                lineWidth: 1,
                                radius: 3,
                                states: {
                                    hover: {
                                        enabled: false
                                    },
                                    select: {
                                        enabled: false
                                    }
                                }
                            }
                        },
                        scatter: {
                            states: {
                                hover: {
                                    enabled: false
                                }
                            },
                            marker: {
                                lineWidth: 1,
                                radius: 3,
                                states: {
                                    hover: {
                                        enabled: false
                                    },
                                    select: {
                                        enabled: false
                                    }
                                }
                            }
                        },
                        bubble: {
                            states: {
                                hover: {
                                    enabled: false
                                }
                            },
                            marker: {
                                lineWidth: 1,
                                radius: 3,
                                states: {
                                    hover: {
                                        enabled: false
                                    },
                                    select: {
                                        enabled: false
                                    }
                                }
                            }
                        },
                        spline: {
                            states: {
                                hover: {
                                    enabled: false
                                }
                            },
                            marker: {
                                lineWidth: 1,
                                radius: 3,
                                states: {
                                    hover: {
                                        enabled: false
                                    },
                                    select: {
                                        enabled: false
                                    }
                                }
                            }
                        },
                        pie: {
                            size: '80%',
                            allowPointSelect: true,
                            cursor: 'pointer',
                            point: {
                                events: {
                                    legendItemClick: chartAttr.interactivelegend ===
                                    ZEROSTRING ? falseFN  : function () {
                                        this.slice();
                                    }
                                }
                            }
                        },
                        pie3d: {
                            size: '80%',
                            allowPointSelect: true,
                            cursor: 'pointer',
                            point: {
                                events: {
                                    legendItemClick: chartAttr.interactivelegend ===
                                    ZEROSTRING ? falseFN  : function () {
                                        this.slice();
                                    }
                                }
                            }
                        },
                        column: {},
                        floatedcolumn : {},
                        column3d: {},
                        bar : {},
                        bar3d : {}
                    },
                    point: {},
                    series: [],
                    subtitle: {
                        text: BLANKSTRING,
                        style : {}
                    },
                    symbols: [],
                    title: {
                        text : BLANKSTRING,
                        style : {}
                    },
                    toolbar: {},
                    tooltip: {
                        style: {}
                    },
                    xAxis: {
                        steppedLabels: {
                            style: {}
                        },
                        labels: {
                            x : 0,
                            style: {},
                            enabled : false
                        },
                        lineWidth: 0,
                        plotLines: [],
                        plotBands: [],
                        title : {
                            style: {},
                            text: BLANKSTRING
                        },
                        tickWidth: 0,
                        scroll : {
                            enabled : false
                        }
                    },
                    yAxis: [{
                        startOnTick: false,
                        endOnTick : false,
                        title : {
                            style: {},
                            text : BLANKSTRING
                        },
                        tickLength  : 0,
                        labels: {
                            x : 0,
                            style: {}
                        },
                        plotBands: [],
                        plotLines: []
                    }, {
                        tickLength  : 0,
                        gridLineWidth: 0,
                        startOnTick: false,
                        endOnTick : false,
                        title : {
                            style: {},
                            text : BLANKSTRING
                        },
                        labels: {
                            x: 0,
                            style: {},
                            enabled : false,
                            formatter : function () {
                                if (this.value !== BLANKSTRINGPLACEHOLDER){
                                    return this.value;
                                }
                                else {
                                    return BLANKSTRING;
                                }
                            }
                        },
                        opposite: true,
                        plotBands: [],
                        plotLines: []
                    }],
                    exporting: {
                        buttons: {
                            exportButton: {},
                            printButton: {
                                enabled: false
                            }
                        }
                    }
                };
            if (chartAttr.palettecolors && typeof chartAttr.palettecolors === 'string') {
                stubHC.colors = chartAttr.palettecolors.split(/\s*\,\s*/);
            }

            iapi.hcJSON = stubHC;

            return stubHC;

        },

        // Block that will configure a y axis (i.e. add min max and create cat
        /**
         * This function will add plotLines and plotBands For gridLine and
         * alrentenGrid Color
         * Added configuartion for not adding auto calculated X axis
         * labels when there has category at the same position
         */
        configureAxis = function (FCChartObj, hcJSON, axisObj,
            axisConf, showLimits, showDivLineValues, labelsStep, numberFormatter,
            isSeconderyAxis, isXaxis, mlAxisIndex) {

            var iapi = this,
                min = axisObj.min,
                max = axisObj.max,
                interval = axisObj.tickInterval,
                numFormatterStr = isXaxis ? 'xAxis' : (axisConf.stacking100Percent ?
                    'percentValue' :  'yAxis'),
                lastValue = min,
                labelIndex = 1,
                gridLineColor = axisObj.gridLineColor,
                gridLineWidth = axisObj.gridLineWidth,
                gridLineDashStyle = axisObj.gridLineDashStyle,
                hasZeroPlane = min < INT_ZERO && max > INT_ZERO ? true : false,
                minOnLimit = min === INT_ZERO,
                maxOnLimit = max === INT_ZERO,
                userHidesZeroPlaneValue = pluckNumber(axisConf.showzeroplanevalue,
                    FCChartObj.showzeroplanevalue) === 0,
                showZeroPlane = true,
                showZeroPlaneValue,
                defaultZIndex = 1,
                forceDivLines = pluckNumber(FCChartObj.numdivlines, 0) > 0,
                axisGridManager = hcJSON[FC_CONFIG_STRING].axisGridManager,
                colorM = iapi.colorManager,
                is3D = this.is3D,
                // If showCanvasBorder is disabled, force enables the limit grid lines
                forceLimitGridLinesEnabled = pluckNumber(FCChartObj.showaxislimitgridlines,
                    iapi.showAxisLimitGridLines),
                showLimitGridLines = pluckNumber(forceLimitGridLinesEnabled,
                    is3D || hcJSON.chart.plotBorderWidth ? 0 : 1),
                inversedAxis =  iapi.inversed,
                xAxisObj = hcJSON.xAxis,
                value,
                zeroPlaneWidth,
                zeroPlaneColor,
                zeroPlaneAlpha,
                zeroPlaneDefaultWidth,
                text,
                zeroPlaneDefaultAlpha,
                plotLineOptions;

            //for non-MLAxis charts
            mlAxisIndex = pluckNumber(mlAxisIndex, isSeconderyAxis ? 1 : 0);

            //remove all previous configuration for fresh calculation
            delete axisObj._altGrid;
            delete axisObj._lastValue;

            //for x axis make sure there has catOccupied obj
            if (isXaxis && !axisConf.catOccupied) {
                axisConf.catOccupied = {};
            }

            // create the Zero plane
            if (hasZeroPlane && (!isXaxis || !axisConf.catOccupied[0])) {
                if (isXaxis) {
                    showZeroPlane = pluckNumber(FCChartObj.showvzeroplane, 1);
                    showZeroPlaneValue = pluckNumber(FCChartObj.showvzeroplanevalue,
                        showDivLineValues);
                    zeroPlaneWidth = pluckNumber(FCChartObj.vzeroplanethickness, 1);
                    zeroPlaneAlpha = pluck(FCChartObj.vzeroplanealpha,
                        FCChartObj.vdivlinealpha,
                        colorM.getColor('divLineAlpha'));
                    zeroPlaneColor = zeroPlaneWidth > 0 ?
                        convertColor(pluck(FCChartObj.vzeroplanecolor,
                                gridLineColor), zeroPlaneAlpha) :
                        COLOR_TRANSPARENT;
                }
                else {
                    zeroPlaneDefaultAlpha = pluckNumber(FCChartObj.divlinealpha,
                        colorM.getColor('divLineAlpha'));
                    showZeroPlaneValue = pluckNumber(axisConf.showzeroplanevalue,
                        FCChartObj.showzeroplanevalue, showDivLineValues);
                    // For spline line and Kagi charts showzeroplane is enabled
                    if (iapi.defaultZeroPlaneHighlighted === false) {
                        showZeroPlane = pluckNumber(axisConf.showzeroplane,
                            FCChartObj.showzeroplane,
                            !(iapi.defaultZeroPlaneHidden && !forceDivLines));
                        zeroPlaneDefaultWidth = gridLineWidth;
                    }
                    else {
                        zeroPlaneDefaultWidth = gridLineWidth === 1 ?
                        2 : gridLineWidth;
                        defaultZIndex = 5;
                        zeroPlaneDefaultAlpha = mathMin(zeroPlaneDefaultAlpha * 2,
                            100);
                    }
                    zeroPlaneWidth = pluckNumber(axisConf.zeroplanethickness,
                        FCChartObj.zeroplanethickness,
                        zeroPlaneDefaultWidth);

                    zeroPlaneAlpha = pluck(axisConf.zeroplanealpha,
                        FCChartObj.zeroplanealpha, zeroPlaneDefaultAlpha);

                    zeroPlaneColor = zeroPlaneWidth > 0 ?
                        convertColor(pluck(axisConf.zeroplanecolor,
                            FCChartObj.zeroplanecolor, gridLineColor), zeroPlaneAlpha) :
                        COLOR_TRANSPARENT;
                }

                if (showZeroPlane) {
                    text = showZeroPlaneValue ? numberFormatter[numFormatterStr](0, mlAxisIndex) : BLANKSTRING;
                    plotLineOptions = axisGridManager.addAxisGridLine(axisObj, 0, text,
                        zeroPlaneWidth, gridLineDashStyle, zeroPlaneColor,
                        defaultZIndex, isXaxis);
                    plotLineOptions && (plotLineOptions.isZeroPlane = true);
                }

                // Store zero plane's visibility in config. effects positioning of
                // column and bar
                axisObj.effectiveZeroPlaneThickness = showZeroPlane &&
                        parseInt(zeroPlaneAlpha, 10) && zeroPlaneWidth;
            }

            //min label
            if (!isXaxis || !axisConf.catOccupied[min]) {
                if (!showLimits || (minOnLimit && userHidesZeroPlaneValue)) {
                    text = BLANKSTRING;
                }
                else {
                    text = numberFormatter[numFormatterStr](min, mlAxisIndex);
                }
                if (forceLimitGridLinesEnabled || (showLimitGridLines && (inversedAxis || !xAxisObj.showLine))) {
                    plotLineOptions = axisGridManager.addAxisGridLine(axisObj, min, text, gridLineWidth,
                        gridLineDashStyle, gridLineColor || COLOR_TRANSPARENT, 2, isXaxis);
                } else {
                    plotLineOptions = axisGridManager.addAxisGridLine(axisObj, min, text, 0.1, undefined,
                        COLOR_TRANSPARENT, 2, isXaxis);
                }
                plotLineOptions && (plotLineOptions.isMinLabel = true);
            }
            //for zero plane  of width 0 make color TRANSPARENT
            if (gridLineWidth <= 0) {
                gridLineWidth = 0.1;
                gridLineColor = COLOR_TRANSPARENT;
            }


            //calculate divLines
            //Issue #1680 fixed using toPrecision
            value = Number(toPrecision(lastValue + interval, 10));
            for (; value < max; value = Number(toPrecision(value + interval, 10)),
                labelIndex += 1) {
                //if the zero plane layes between lastValue and value
                if (hasZeroPlane && lastValue < INT_ZERO && value > INT_ZERO &&
                    !isSeconderyAxis) {
                    //add altGrid
                    axisGridManager.addAxisAltGrid(axisObj, 0);
                    labelIndex += 1;
                }
                //if it is not zero plane
                if (value !== INT_ZERO &&
                    (!isXaxis || !axisConf.catOccupied[value])) {
                    text = showDivLineValues === 1 &&
                    labelIndex % labelsStep === INT_ZERO ?
                    numberFormatter[numFormatterStr](value, mlAxisIndex) : BLANKSTRING;
                    axisGridManager.addAxisGridLine(axisObj, value, text,
                        gridLineWidth, gridLineDashStyle, gridLineColor, 2,
                        isXaxis);
                }
                lastValue = value;
                //add altGrid
                if (!isSeconderyAxis) {
                    axisGridManager.addAxisAltGrid(axisObj, value);
                }
            }
            //add altGrid
            if (!isSeconderyAxis) {
                axisGridManager.addAxisAltGrid(axisObj, max);
            }

            //max label
            if (labelIndex % labelsStep === INT_ZERO &&
                (!isXaxis || !axisConf.catOccupied[max])) {
                if (!showLimits || (maxOnLimit && userHidesZeroPlaneValue)) {
                    text = BLANKSTRING;
                }
                else {
                    text = numberFormatter[numFormatterStr](max, mlAxisIndex);
                }
                if (forceLimitGridLinesEnabled || (showLimitGridLines && (!inversedAxis || !xAxisObj.showLine))) {
                    plotLineOptions = axisGridManager.addAxisGridLine(axisObj, max, text, gridLineWidth,
                        gridLineDashStyle, gridLineColor || COLOR_TRANSPARENT, 2, isXaxis);
                } else {
                    plotLineOptions = axisGridManager.addAxisGridLine(axisObj, max, text, 0.1,
                        gridLineDashStyle, COLOR_TRANSPARENT, 2, isXaxis);
                }
                plotLineOptions && (plotLineOptions.isMaxLabel = true);
            }
            //store the default value to use in realtime update
            if (iapi.realtimeEnabled) {
                axisObj.labels._enabled = axisObj.labels.enabled;
                axisObj._gridLineWidth = axisObj.gridLineWidth;
                axisObj._alternateGridColor = axisObj.alternateGridColor;
            }
            //disable default labels and grid
            axisObj.labels.enabled = false;
            axisObj.gridLineWidth = INT_ZERO;
            axisObj.alternateGridColor = COLOR_TRANSPARENT;

            // sorting yAxis to fix negative values in bar chart
            axisObj.plotLines.sort(plotLineSortFN);
        },

        //this function will configure the axis and calculate the originaly space requared for the axis eliments
        /** @todo have to implement all text style
        hacve check for inverse axis chart
        formatNumber type = 2 hard coded have to modularize and map with axis type */
        yxAxisConfigurer = function (HCObj, FCObj) {
            var conf = HCObj[FC_CONFIG_STRING], xAxisObj = HCObj.xAxis,
            FCchartObj = FCObj.chart,
            is3D = HCObj.chart.is3D,
            yAxisObj, yAxisConf, yAxisMaxValue, yAxisMinValue, stopMaxAtZero,
            setMinAsZero, setadaptiveymin,
            numDivLines, adjustDiv, showYAxisValues, showLimits, showDivLineValues,
            showAxisLines = 0, //defaults to zero.
            showYAxisLine, showXAxisLine, showSYAxisLine,
            axisLineColor, xAxisLineColor, yAxisLineColor, sYAxisLineColor,
            axisLineThickness, xAxisLineThickness, yAxisLineThickness, sYAxisLineThickness,
            axisLineAlpha, xAxisLineAlpha, yAxisLineAlpha, sYAxisLineAlpha,
            numberFormatter = this.numberFormatter,
            syncAxisLimits = pluckNumber(FCchartObj.syncaxislimits, 0),
            yaxisvaluesstep,
            sAxisMaxValue,
            sAxisMinValue,
            sAxisConf,
            pAxisObj,
            sMin,
            sMax;

            /**
             * configure x axis
             */

            //add xaxisTitle
            xAxisObj.title.text = parseUnsafeString(FCchartObj.xaxisname);

            /**
             * configure y axis
             */

            yaxisvaluesstep =
                pluckNumber(parseInt(FCchartObj.yaxisvaluesstep, 10), parseInt(FCchartObj.yaxisvaluestep, 10), 1);
            yaxisvaluesstep = yaxisvaluesstep < 1 ? 1 : yaxisvaluesstep;


            yAxisObj = HCObj.yAxis[0], yAxisConf = conf[0];
            if (conf.isDual) {//Dual

                yAxisMaxValue = numberFormatter.getCleanValue(FCchartObj.pyaxismaxvalue);
                yAxisMinValue = numberFormatter.getCleanValue(FCchartObj.pyaxisminvalue);

                // add axis Names
                yAxisObj.title.text = parseUnsafeString(FCchartObj.pyaxisname);

                //fix for #FCXT-169
                if (syncAxisLimits && !yAxisConf.stacking100Percent) {
                    sAxisConf = conf[1];
                    sMax = pluckNumber(sAxisConf.max);
                    sMin = pluckNumber(sAxisConf.min);
                    //set max data range
                    if (sMax !== undefined && sMin !== undefined) {
                        yAxisConf.min = mathMin(yAxisConf.min, sMin);
                        yAxisConf.max = mathMax(yAxisConf.max, sMax);
                    }
                    sAxisMaxValue = numberFormatter.getCleanValue(FCchartObj.syaxismaxvalue);
                    sAxisMinValue = numberFormatter.getCleanValue(FCchartObj.syaxisminvalue);
                    if (sAxisMinValue !== null) {
                        yAxisMinValue = yAxisMinValue !== null ? mathMin(yAxisMinValue, sAxisMinValue) : sAxisMinValue;
                    }
                    if (sAxisMaxValue !== null) {
                        yAxisMaxValue = yAxisMaxValue !== null ? mathMax(yAxisMaxValue, sAxisMaxValue) : sAxisMaxValue;
                    }
                }
                else {
                    syncAxisLimits = 0;//catch the case of stacking100Percent
                }
            }
            else {//single
                yAxisMaxValue = numberFormatter.getCleanValue(FCchartObj.yaxismaxvalue);
                yAxisMinValue = numberFormatter.getCleanValue(FCchartObj.yaxisminvalue);

                // add axis Names
                yAxisObj.title.text = parseUnsafeString(FCchartObj.yaxisname);
            }

            // adaptiveymin is available for non-stack charts
            setadaptiveymin = pluckNumber(this.isStacked ? 0 : this.setAdaptiveYMin,
                FCchartObj.setadaptiveymin, this.defSetAdaptiveYMin, 0);

            setMinAsZero = stopMaxAtZero = !setadaptiveymin;
            numDivLines = pluckNumber(conf.numdivlines, FCchartObj.numdivlines, this.numdivlines, 4);
            adjustDiv = FCchartObj.adjustdiv !== ZEROSTRING;
            showYAxisValues = pluckNumber(this.showYAxisValues, FCchartObj.showyaxisvalues,
                FCchartObj.showyaxisvalue, 1);
            showLimits = pluckNumber(FCchartObj.showyaxislimits, FCchartObj.showlimits, showYAxisValues);
            showDivLineValues = pluckNumber(FCchartObj.showdivlinevalue, FCchartObj.showdivlinevalues,
                showYAxisValues);

            //check whether to show lines for the axis.
            //Only for the non-3D charts.
            if(!is3D){
                showAxisLines = pluckNumber(FCchartObj.showaxislines, FCchartObj.drawAxisLines, 0);
                axisLineThickness = pluckNumber(FCchartObj.axislinethickness, 1);
                axisLineAlpha = pluckNumber(FCchartObj.axislinealpha, 100);
                (axisLineAlpha > 100) && (axisLineAlpha = 100);
                axisLineColor = convertColor(pluck(FCchartObj.axislinecolor, '#000000'), axisLineAlpha);
                //for bar charts x and y axis configuration will change
                showYAxisLine = yAxisObj.showLine =
                        pluckNumber(FCchartObj.showyaxisline, showAxisLines);
                showXAxisLine = xAxisObj.showLine =
                        pluckNumber(FCchartObj.showxaxisline, showAxisLines);

                xAxisLineThickness = xAxisObj.lineThickness =
                            pluckNumber(FCchartObj.xaxislinethickness, axisLineThickness);
                yAxisLineThickness = yAxisObj.lineThickness =
                            pluckNumber(FCchartObj.yaxislinethickness, axisLineThickness);
                xAxisLineAlpha = xAxisObj.lineAlpha =
                            pluckNumber(FCchartObj.xaxislinealpha, axisLineAlpha);
                (xAxisLineAlpha > 100) && (xAxisLineAlpha = xAxisObj.lineAlpha = 100);
                yAxisLineAlpha = yAxisObj.lineAlpha =
                            pluckNumber(FCchartObj.yaxislinealpha, axisLineAlpha);
                (yAxisLineAlpha > 100) && (yAxisLineAlpha = yAxisObj.lineAlpha = 100);

                xAxisLineColor = xAxisObj.lineColor =
                        convertColor(pluck(FCchartObj.xaxislinecolor,
                                                        axisLineColor), xAxisLineAlpha);
                yAxisLineColor = yAxisObj.lineColor =
                        convertColor(pluck(FCchartObj.yaxislinecolor,
                                                        axisLineColor), yAxisLineAlpha);

                // Store a flag for later use in renderers whether axis line is
                // visible. This will ensure that there is no gap while drawing
                // column or area.
                HCObj.chart.xAxisLineVisible = showXAxisLine &&
                        !!xAxisLineThickness && (xAxisLineAlpha > 0);
            }

            //////////////////////calculate the axis min max and the div interval for y axis ///////////////////
            this.axisMinMaxSetter (yAxisObj, yAxisConf, yAxisMaxValue, yAxisMinValue, stopMaxAtZero,
                setMinAsZero, numDivLines, adjustDiv);

            // create label category and remove trend obj if out side limit
            this.configurePlotLines(FCchartObj, HCObj, yAxisObj, yAxisConf, showLimits, showDivLineValues,
                yaxisvaluesstep, conf.numberFormatter, false);

            if (yAxisObj.reversed && yAxisObj.min >= 0) {
                HCObj.plotOptions.series.threshold = yAxisObj.max;
            }


            //manage secondary axis ////////
            if (conf.isDual) {
                yAxisObj = HCObj.yAxis[1];
                yAxisConf = conf[1];
                showLimits = pluckNumber(FCchartObj.showsecondarylimits, showLimits);
                showDivLineValues = pluckNumber(FCchartObj.showdivlinesecondaryvalue, showYAxisValues);

                if (syncAxisLimits) {
                    pAxisObj = HCObj.yAxis[0];
                    yAxisObj.min = pAxisObj.min;
                    yAxisObj.max = pAxisObj.max;
                    yAxisObj.tickInterval = pAxisObj.tickInterval;

                    // Delete the min max.
                    delete yAxisConf.max;
                    delete yAxisConf.min;
                }
                else {
                    yAxisMaxValue = numberFormatter.getCleanValue(FCchartObj.syaxismaxvalue);
                    yAxisMinValue = numberFormatter.getCleanValue(FCchartObj.syaxisminvalue);
                    setadaptiveymin = pluckNumber(FCchartObj.setadaptivesymin, setadaptiveymin);
                    setMinAsZero = stopMaxAtZero = !setadaptiveymin;
                    //////////////////////calculate the axis min max and the div interval for y axis ///////////////////
                    this.axisMinMaxSetter (yAxisObj, yAxisConf, yAxisMaxValue, yAxisMinValue, stopMaxAtZero,
                        setMinAsZero, numDivLines, adjustDiv);
                }

                //check whether secondary axis line needs to be shown (non-3D charts)
                if(!is3D){
                    showSYAxisLine = yAxisObj.showLine = pluckNumber(FCchartObj.showsyaxisline, showAxisLines);
                    sYAxisLineThickness = yAxisObj.lineThickness =
                            pluckNumber(FCchartObj.syaxislinethickness, axisLineThickness);
                    sYAxisLineAlpha = yAxisObj.lineAlpha =
                            pluckNumber(FCchartObj.syaxislinealpha, axisLineAlpha);
                    (sYAxisLineAlpha > 100) && (sYAxisLineAlpha = 100);
                    sYAxisLineColor = yAxisObj.lineColor =
                            convertColor(pluck(FCchartObj.syaxislinecolor, axisLineColor), sYAxisLineAlpha);
                }

                // create label category and remove trend obj if out side limit
                this.configurePlotLines(FCchartObj, HCObj, yAxisObj, yAxisConf, showLimits, showDivLineValues,
                    yaxisvaluesstep, conf.numberFormatter, true);

                // add axis Names
                yAxisObj.title.text = parseUnsafeString(FCchartObj.syaxisname);
            }

        },

        pointValueWatcher = function (HCObj, value, yAxisIndex, isStacked, index,
            stackIndex, seriesName) {
            var obj, stackObj, FCconf = HCObj[FC_CONFIG_STRING], oldStackReturn, seriesArr, seriesStackArr,
                pointIndexObj;
            if ( value !== null) {

                yAxisIndex = pluckNumber(yAxisIndex, 0);

                if (!FCconf[yAxisIndex]) {
                    FCconf[yAxisIndex] = {};
                }
                obj = FCconf[yAxisIndex];
                if (isStacked) {
                    if (this.distributedColumns) {
                        FCconf.marimekkoTotal += value;
                    }

                    stackObj = obj.stack;

                    index = pluckNumber(index, 0);
                    stackIndex = pluckNumber(stackIndex, 0);
                    seriesName = pluck(seriesName, STRINGUNDEFINED);
                    if (!stackObj[seriesName]) {
                        stackObj[seriesName] = [];
                    }
                    seriesArr = stackObj[seriesName];

                    if (!seriesArr[stackIndex]) {
                        seriesArr[stackIndex] = [];
                    }
                    seriesStackArr = seriesArr[stackIndex];
                    if (!seriesStackArr[index]) {
                        seriesStackArr[index] = {};
                    }
                    pointIndexObj = seriesStackArr[index];

                    if (value >= 0) {
                        if (pointIndexObj.p) {
                            oldStackReturn = pointIndexObj.p;
                            value =  pointIndexObj.p += value;
                        }
                        else {
                            pointIndexObj.p = value;
                        }
                    }
                    else {
                        if (pointIndexObj.n) {
                            oldStackReturn = pointIndexObj.n;
                            value =  pointIndexObj.n += value;
                        }
                        else {
                            pointIndexObj.n = value;
                        }
                    }


                }
                obj.max = obj.max > value ? obj.max : value;
                obj.min = obj.min < value ? obj.min : value;

                return oldStackReturn;
            }
        },

        /*
         *this function will place a vertical axis
         *this function will return the used width
         */
        placeVerticalAxis = lib.placeVerticalAxis = function (axisObj, axisConf,
            hcJSON, fcJSON, axisHeight, maxWidthCanUse, isOnRight, isDual, chartWidth, marginUsed) {

            var conf = hcJSON[FC_CONFIG_STRING],

            SmartLabel = conf.smartLabel, smartifiedTextObj,

            titleWidth, titleHeight, titleText, titleLineHeight, titleMinWidth,
            titleWidthUsed = 0, minTextWidth = 20,

            marginRightExtraSpace = conf.marginRightExtraSpace,
            marginLeftExtraSpace = conf.marginLeftExtraSpace,

            pSameSideGridText = {}, pSameSideNonGridText = {}, pOppSideText = {},
            plotLines = axisObj.plotLines,
            plotBands = axisObj.plotBands,

            verticalAxisValuesPadding = axisConf.verticalAxisValuesPadding,
            fixedValuesPadding = (!isNaN(axisConf.fixedValuesPadding) ?
                axisConf.fixedValuesPadding : 0),
            flexibleValuesPadding = verticalAxisValuesPadding - fixedValuesPadding,
            verticalAxisOppValuesPadding = axisConf.verticalAxisValuesPadding,
            verticalAxisNamePadding = axisConf.verticalAxisNamePadding,
            verticalAxisNameWidth = axisConf.verticalAxisNameWidth,

            titleRotation = axisConf.rotateVerticalAxisName && String(axisConf.rotateVerticalAxisName).toLowerCase(),
            isTitleRotate = titleRotation !== 'none',
            axisOffset = (axisObj.offset ? axisObj.offset : 0),

            axisSameSideWidth = 0, axisOppSideWidth = 0, surplusWidth = 0,
            labelTotal = 0, samesideText = 0, oppText = 0, samesideLabelWidth = 0,

            index, length, lastUsedStyle, labelObj, tempRight,
            tempLeft, difference, temp, lessPadding, heightCorrection = 2,
            titleCorrection = (isOnRight ? marginRightExtraSpace + 5 : marginLeftExtraSpace + 4),
            canvasBorderThickness = mathMax(pluckNumber(hcJSON.chart.plotBorderWidth, 1), 0),
            yAxixLineThickNess = axisObj.showLine ? axisObj.lineThickness : canvasBorderThickness,

            analyseAxisElements = function (plotObj, index) {
                var textActualWidth, textWidthWithPadding;
                if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {
                    labelObj = plotObj.label;
                    //if the style not implemented then implement it
                    if (labelObj.style && labelObj.style !== lastUsedStyle) {
                        lastUsedStyle = labelObj.style;
                        SmartLabel.setStyle(lastUsedStyle);
                    }
                    //get the text Size
                    smartifiedTextObj = SmartLabel.getOriSize(plotObj.label.text);
                    textActualWidth = smartifiedTextObj.width;
                    textWidthWithPadding = textActualWidth ? (textActualWidth + 2) : 0;
                    if (plotObj.isGrid) {
                        pSameSideGridText[index] = {
                            width : textActualWidth,
                            height: smartifiedTextObj.height,
                            label : labelObj
                        };
                        if (labelTotal <= textWidthWithPadding) {
                            labelTotal = textWidthWithPadding;
                            axisConf.lYLblIdx = index;
                        }

                    } else if (plotObj.isTrend) {
                        if ((isOnRight && labelObj.textAlign === POSITION_LEFT) ||
                            (labelObj.textAlign === POSITION_RIGHT)) {
                            pSameSideNonGridText[index] = {
                                width : textActualWidth,
                                height: smartifiedTextObj.height,
                                label : labelObj
                            };
                            samesideText = mathMax(samesideText, textWidthWithPadding);
                        } else {
                            pOppSideText[index] = {
                                width : textActualWidth,
                                height: smartifiedTextObj.height,
                                label : labelObj
                            };
                            oppText = mathMax(oppText, textWidthWithPadding);
                        }
                    }
                }
            },

            checkAndReallocateSpace = function () {
                // There has not sufficient space
                if (axisOppSideWidth + axisSameSideWidth > maxWidthCanUse) {
                    difference = axisOppSideWidth + axisSameSideWidth - maxWidthCanUse;

                    if (axisOppSideWidth) {
                        if (verticalAxisOppValuesPadding >= difference) {
                            verticalAxisOppValuesPadding -= difference;
                            return;
                        } else {
                            difference -= verticalAxisOppValuesPadding;
                            verticalAxisOppValuesPadding = 0;
                        }
                    }

                    if ((flexibleValuesPadding + verticalAxisNamePadding) >= difference) {
                        if (verticalAxisNamePadding >= difference) {
                            verticalAxisNamePadding -= difference;
                            return;
                        } else {
                            flexibleValuesPadding -= (difference - verticalAxisNamePadding);
                            verticalAxisNamePadding = 0;
                            return;
                        }
                    } else {
                        difference -= (flexibleValuesPadding + verticalAxisNamePadding);
                        flexibleValuesPadding = 0;
                        verticalAxisNamePadding = 0;

                        if (oppText > minTextWidth) {
                            if (samesideText > labelTotal) {
                                if ((oppText - samesideText) >= difference) {
                                    oppText -= difference;
                                    return;
                                } else if ((samesideText - oppText) >= difference) {
                                    samesideText -= difference;
                                    return;
                                } else {
                                    if (samesideText > oppText) {
                                        difference -= (samesideText - oppText);
                                        samesideText = oppText;
                                    } else {
                                        difference -= (oppText - samesideText);
                                        oppText = samesideText;
                                    }

                                    if (2 * (samesideText - labelTotal) >= difference) {
                                        oppText -= (difference / 2);
                                        samesideText -= (difference / 2);
                                        return;
                                    } else {
                                        difference -= 2 * (samesideText - labelTotal);
                                        samesideText = labelTotal;
                                        oppText = labelTotal;
                                    }
                                }
                            } else if ((oppText - minTextWidth) >= difference) {
                                oppText -= difference;
                                return;
                            } else {
                                difference -= (oppText - minTextWidth);
                                oppText = minTextWidth;
                            }
                        }

                        if (samesideText > labelTotal) {
                            if ((samesideText - labelTotal) >= difference) {
                                samesideText -= difference;
                                return;
                            } else {
                                difference -= (samesideText - labelTotal);
                                samesideText = labelTotal;
                            }
                        }

                        if (titleWidthUsed - titleMinWidth >= difference) {
                            titleWidthUsed -= difference;
                            return;
                        } else {
                            difference -= (titleWidthUsed - titleMinWidth);
                            titleWidthUsed = titleMinWidth;

                            if (oppText >= difference) {
                                oppText = 0;
                                return;
                            } else {
                                difference -= oppText;
                                oppText = 0;
                            }

                            if (titleWidthUsed >= difference) {
                                titleWidthUsed = 0;
                                return;
                            } else {
                                difference -= titleWidthUsed;
                                titleWidthUsed = 0;
                            }

                            if (labelTotal >= difference) {
                                labelTotal -= difference;
                                samesideText = labelTotal;
                                return;
                            }
                        }
                    }
                }
                return;
            },

            renderOppSideText = function (surplusWidth, isBubble) {
                //place the axis labels
                var tempSmartLabel, maxActualWidth = 0,
                workingWidth = isBubble ? (oppText - 2) : (oppText + surplusWidth - 2),
                index;

                if (oppText > 0) {
                    for (index in pOppSideText) {
                        labelObj = pOppSideText[index].label;
                        if (pOppSideText[index].width > workingWidth) {
                            if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                lastUsedStyle = labelObj.style;
                                SmartLabel.setStyle(lastUsedStyle);
                            }
                            tempSmartLabel = SmartLabel.getSmartText(labelObj.text,
                                workingWidth, axisHeight, true);
                            labelObj.text = tempSmartLabel.text;
                            tempSmartLabel.tooltext && (labelObj.originalText = tempSmartLabel.tooltext);

                            pOppSideText[index].height = tempSmartLabel.height;
                            maxActualWidth = mathMax(maxActualWidth, tempSmartLabel.width);
                        } else {
                            maxActualWidth = mathMax(maxActualWidth, pOppSideText[index].width);
                        }
                    }
                    return (isBubble ? (workingWidth - maxActualWidth) + surplusWidth
                        : (workingWidth - maxActualWidth));

                } else {
                    for (index in pOppSideText) {
                        pOppSideText[index].label.text = BLANKSTRING;
                    }
                    return 0;
                }
            },

            renderTitle = function (surplusWidth, isBubble) {

                var actualWidth,
                    workingWidth = isBubble ? titleWidthUsed : (titleWidthUsed + surplusWidth),
                    titleStyle = axisObj.title.style;

                // Fix for issue #FCXT-329
                titleText = titleText || {};

                if (workingWidth > 0) {
                    if (isTitleRotate){
                        if (workingWidth < titleText.height) {
                            //now get the title space
                            SmartLabel.setStyle(titleStyle);
                            titleText = SmartLabel.getSmartText(axisObj.title.text, axisHeight, workingWidth);
                        }
                        actualWidth = titleText.height;
                    }
                    else {
                        if (workingWidth < titleText.width) {
                            SmartLabel.setStyle(titleStyle);
                            titleText = SmartLabel.getSmartText(axisObj.title.text, workingWidth, axisHeight);
                        }
                        actualWidth = titleText.width;
                    }
                    axisObj.title._actualWidth = actualWidth;
                    axisObj.title.text = titleText.text;
                    titleText.tooltext && (axisObj.title.originalText = titleText.tooltext);

                    return (isBubble ? (workingWidth - actualWidth) + surplusWidth
                        : (workingWidth - actualWidth));
                } else {
                    //remove the text
                    axisObj.title.text = BLANKSTRING;
                    return 0;
                }
            },

            renderSameSideText = function (surplusWidth) {
                //place the axis labels
                var tempSmartLabel, maxActualWidth = 0,
                workingWidth = (mathMax(labelTotal, samesideText) + surplusWidth - 2),
                index;

                if (workingWidth > 0) {
                    for (index in pSameSideGridText) {
                        labelObj =  pSameSideGridText[index].label;
                        if (pSameSideGridText[index].width > workingWidth) {
                            if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                lastUsedStyle = labelObj.style;
                                SmartLabel.setStyle(lastUsedStyle);
                            }
                            tempSmartLabel = SmartLabel.getSmartText(labelObj.text, workingWidth,
                                axisHeight, true);
                            labelObj.text = tempSmartLabel.text;
                            tempSmartLabel.tooltext && (labelObj.originalText = tempSmartLabel.tooltext);

                            pSameSideGridText[index].height = tempSmartLabel.height;
                            maxActualWidth = mathMax(maxActualWidth, tempSmartLabel.width);
                        } else {
                            maxActualWidth = mathMax(maxActualWidth, pSameSideGridText[index].width);
                        }
                    }

                    for (index in pSameSideNonGridText) {
                        labelObj =  pSameSideNonGridText[index].label;
                        if (pSameSideNonGridText[index].width > workingWidth) {
                            if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                lastUsedStyle = labelObj.style;
                                SmartLabel.setStyle(lastUsedStyle);
                            }
                            tempSmartLabel = SmartLabel.getSmartText(labelObj.text, workingWidth,
                                axisHeight, true);
                            labelObj.text = tempSmartLabel.text;
                            tempSmartLabel.tooltext && (labelObj.originalText = tempSmartLabel.tooltext);

                            pSameSideNonGridText[index].height = tempSmartLabel.height;
                            maxActualWidth = mathMax(maxActualWidth, tempSmartLabel.width);
                        } else {
                            maxActualWidth = mathMax(maxActualWidth, pSameSideNonGridText[index].width);
                        }
                    }

                    return (workingWidth - maxActualWidth);
                } else {
                    for (index in pSameSideGridText) {
                        pSameSideGridText[index].label.text = BLANKSTRING;
                    }

                    for (index in pSameSideNonGridText) {
                        pSameSideNonGridText[index].label.text = BLANKSTRING;
                    }

                    return 0;
                }
            },

            setLabelsXY = function (labelContainerObj, x, y) {
                var index;
                for (index in labelContainerObj) {
                    labelContainerObj[index].label.x = x;
                    labelContainerObj[index].label.y = y;
                }
            },
            maxLabelWidth,
            mlwp;

            //iterate through plotLines and find the divlines
            for (index = 0, length = plotBands.length; index < length; index += 1) {
                analyseAxisElements(plotBands[index], index);
            }

            //iterate through plotLines and find the divlines
            for (index = 0, length = plotLines.length; index < length; index += 1) {
                analyseAxisElements(plotLines[index], index);
            }

            if (axisObj.title && axisObj.title.text != BLANKSTRING) {
                lastUsedStyle = axisObj.title.style;
                SmartLabel.setStyle(lastUsedStyle);
                //now get the title space
                titleLineHeight = SmartLabel.getOriSize(TESTSTR).height;
                axisObj.title._originalText = axisObj.title.text;
                if (isTitleRotate) {
                    axisObj.title.rotation = (titleRotation === 'cw') ? 90 : 270;
                    titleWidth = axisHeight;
                    titleHeight = maxWidthCanUse;
                    titleText = SmartLabel.getSmartText(axisObj.title.text, titleWidth, titleHeight);
                    titleWidthUsed = titleText.height;
                    titleMinWidth = titleLineHeight;
                } else {
                    axisObj.title.rotation = 0;
                    titleWidth = verticalAxisNameWidth !== undefined ?
                        verticalAxisNameWidth : maxWidthCanUse;
                    titleHeight = axisHeight;
                    titleText = SmartLabel.getSmartText(axisObj.title.text, titleWidth, titleHeight);
                    titleWidthUsed = titleText.width;
                    titleMinWidth = minTextWidth;
                }
            }

            if (oppText > 0) {
                axisOppSideWidth = oppText + verticalAxisOppValuesPadding;
            }

            if (chartWidth) { // is a bar chart
                mlwp = pluckNumber(fcJSON.chart.maxlabelwidthpercent, 0);
                if (mlwp >= 1 && mlwp <= 100) {
                    maxLabelWidth = (mlwp * chartWidth / 100);
                    if (labelTotal > maxLabelWidth) {
                        labelTotal = maxLabelWidth;
                    }
                }
            }

            axisSameSideWidth = mathMax(samesideText, labelTotal);
            axisSameSideWidth += (axisSameSideWidth ? (flexibleValuesPadding + fixedValuesPadding) : 0);

            if (titleWidthUsed > 0) {
                axisSameSideWidth += (titleWidthUsed + verticalAxisNamePadding + titleCorrection);
            }

            checkAndReallocateSpace();

            surplusWidth = renderOppSideText(0, true);
            surplusWidth = renderTitle(surplusWidth, true);
            surplusWidth = renderSameSideText(surplusWidth);
            surplusWidth = renderTitle(surplusWidth);

            lessPadding = axisConf.verticalAxisNamePadding - verticalAxisNamePadding;
            if (surplusWidth && lessPadding) {
                if (surplusWidth > lessPadding) {
                    verticalAxisNamePadding += lessPadding;
                    surplusWidth -= lessPadding;
                } else {
                    verticalAxisNamePadding += surplusWidth;
                    surplusWidth = 0;
                }
            }

            lessPadding = axisConf.verticalAxisValuesPadding - (flexibleValuesPadding + fixedValuesPadding);
            if ( surplusWidth && lessPadding) {
                if (surplusWidth > lessPadding) {
                    flexibleValuesPadding += lessPadding;
                    surplusWidth -= lessPadding;
                } else {
                    flexibleValuesPadding += surplusWidth;
                    surplusWidth = 0;
                }
            }

            lessPadding = axisConf.verticalAxisValuesPadding - verticalAxisOppValuesPadding;
            if ( surplusWidth && lessPadding) {
                if (surplusWidth > lessPadding) {
                    verticalAxisOppValuesPadding += lessPadding;
                    surplusWidth -= lessPadding;
                } else {
                    verticalAxisOppValuesPadding += surplusWidth;
                    surplusWidth = 0;
                }
            }

            if (oppText > 0) {
                axisOppSideWidth = oppText + verticalAxisOppValuesPadding;
            }

            axisSameSideWidth = mathMax(samesideText, labelTotal);
            axisSameSideWidth += (axisSameSideWidth ? (flexibleValuesPadding + fixedValuesPadding) : 0);

            if (titleWidthUsed > 0) {
                axisSameSideWidth += (titleWidthUsed + verticalAxisNamePadding + titleCorrection);
            }

            //all element's space is calculated now place them
            temp = mathMax(samesideText, labelTotal);
            temp += (temp > 0 ? (flexibleValuesPadding + fixedValuesPadding) : 0);

            //place title
            //**don't update the style as it is the last used style
            if (titleWidthUsed > 0) {

                if (isTitleRotate){
                    if (titleWidthUsed < titleText.height) {
                        //now get the title space
                        titleText = SmartLabel.getSmartText(axisObj.title.text, axisHeight, titleWidthUsed);
                    }

                }
                else {
                    if (titleWidthUsed < titleText.width) {
                        titleText = SmartLabel.getSmartText(axisObj.title.text, titleWidthUsed, axisHeight);
                    }
                    axisObj.title.y = - ((titleText.height - titleLineHeight) / 2); // 4 is for <br/> correction
                }
                axisObj.title.text = titleText.text;
                titleText.tooltext && (axisObj.title.originalText = titleText.tooltext);

                // TitleCorrection: 8 is a correction factor that had to be introduced after migration to
                // ex-renderer 2.1.9.
                axisObj.title.margin = temp + verticalAxisNamePadding + titleCorrection +
                    (isTitleRotate ? titleWidthUsed - titleLineHeight : titleWidthUsed / 2);
            }
            else {
                //remove the text
                axisObj.title.text = BLANKSTRING;
            }

            /*
             *new logic: store only the text width of plotlines and the plot bands
             *during final sizing zust loop through the plotLined and the plot
             *Band then decide it is label/same text/ opp text
             *then configure it
             */
            //text padding 2px
            tempLeft = -(flexibleValuesPadding + fixedValuesPadding + axisOffset + marginLeftExtraSpace + 2);
            //text padding 2px
            tempRight = marginRightExtraSpace + verticalAxisOppValuesPadding + axisOffset + 2;
            samesideLabelWidth = mathMax(samesideText, labelTotal);
            if (axisObj.labels.style) {
                heightCorrection = parseInt(axisObj.labels.style.fontSize, 10) * 0.35;
            }

            //place the axis labels
            if (isOnRight) {
                if (oppText > 0) {
                    setLabelsXY(pOppSideText, tempLeft, heightCorrection);
                }

                if (samesideLabelWidth > 0) {
                    setLabelsXY(pSameSideGridText, tempRight, heightCorrection);
                    setLabelsXY(pSameSideNonGridText, tempRight, heightCorrection);
                }
            } else {
                if (oppText > 0) {
                    setLabelsXY(pOppSideText, tempRight, heightCorrection);
                }

                if (samesideLabelWidth > 0) {
                    setLabelsXY(pSameSideGridText, tempLeft, heightCorrection);
                    setLabelsXY(pSameSideNonGridText, tempLeft, heightCorrection);
                }
            }

            //fix for #FWXT-781
            axisObj.labels._textY = heightCorrection;
            axisObj.labels._righttX = tempRight;
            axisObj.labels._leftX = tempLeft;
            //if ther has no label then apply axis line width
            axisSameSideWidth = axisSameSideWidth || yAxixLineThickNess;
            axisOppSideWidth = axisOppSideWidth || (isDual ? 0 : canvasBorderThickness);

            if (marginUsed) {
                hcJSON.chart.marginLeft += isOnRight ? axisOppSideWidth : (axisSameSideWidth - marginUsed);
                hcJSON.chart.marginRight += isOnRight ? (axisSameSideWidth - marginUsed) : axisOppSideWidth;
            } else {
                hcJSON.chart.marginLeft += isOnRight ? axisOppSideWidth : axisSameSideWidth;
                hcJSON.chart.marginRight += isOnRight ? axisSameSideWidth : axisOppSideWidth;
            }
            return axisOppSideWidth + axisSameSideWidth;
        },

        /*
         *This function willplace the title to a speciffied width & height
         */
        titleSpaceManager = lib.titleSpaceManager = function (hcJSON, fcJSON, canvasWidth,
            allowedHeight) {
            var iapi = this,
                //trap error by asigining blank object
                snapLiterals = iapi.snapLiterals || (iapi.snapLiterals = {}),
                fcChartObj = fcJSON.chart,
                titleText = parseUnsafeString(fcChartObj.caption),
                subTitleText = parseUnsafeString(fcChartObj.subcaption),
                captionPadding = pluckNumber(fcChartObj.captionpadding, 10),
                oriCapPadding = captionPadding,
                conf = hcJSON[FC_CONFIG_STRING],
                SmartLabel = iapi.smartLabel || conf.smartLabel,
                isPaddingReduced = false,
                captionObj,
                subcaptionObj,
                totalHeight = 0,
                capStyle,
                subCapStyle,
                difference = 0,
                extraSpace = 0,
                captionLineHeight = 0,
                subCaptionLineHeight = 0,
                topGutterWidth = 5,
                titleObj = hcJSON.title,
                subTitleObj = hcJSON.subtitle,
                canvasBorderThickness = mathMax(pluckNumber(hcJSON.chart.plotBorderWidth, 1), 0),
                captionWidth = 0,
                subCaptionWidth = 0;

            // text below 3px is not properly visible
            if (allowedHeight > 3) {

                if (captionPadding < canvasBorderThickness) {
                    captionPadding = canvasBorderThickness + 2;
                }

                if (titleText !== BLANKSTRING) {//calculatethe single line's height
                    capStyle = titleObj.style;
                    captionLineHeight = mathCeil(pluckNumber(parseFloat(capStyle.fontHeight, 10),
                            parseFloat(capStyle.lineHeight, 10), 12));
                }
                if (subTitleText !== BLANKSTRING) {
                    subCapStyle = subTitleObj.style;
                    subCaptionLineHeight = pluckNumber(parseInt(subCapStyle.fontHeight, 10),
                        parseInt(subCapStyle.lineHeight, 10), 12);
                }

                if (captionLineHeight > 0 || subCaptionLineHeight > 0) {
                    //calculate the min height required
                    allowedHeight = mathMax(allowedHeight, 0);
                    totalHeight = captionLineHeight + subCaptionLineHeight + captionPadding;
                    //now decide whether it has space shgaortfall or excess
                    if (totalHeight > allowedHeight) {
                        difference = allowedHeight - totalHeight;
                        isPaddingReduced = true;
                        //first reduce the padding
                        if (difference < captionPadding) {
                            captionPadding = mathMax(difference, 5);
                        }
                        else {//if the difference is more then padding then remove the subcap also
                            difference -= captionPadding;
                            captionPadding = 0;
                            //if the subcap is gretter then diff add the remaning space to the extraSpace
                            if (subCaptionLineHeight > difference) {
                                extraSpace = (subCaptionLineHeight - difference) + 10;
                                subCaptionLineHeight = 0;
                                subTitleObj._originalText = subTitleObj.text;
                                subTitleObj.text = '';
                            }
                            else {
                                difference -= subCaptionLineHeight;
                                subCaptionLineHeight = 0;
                                //now remove the caption also
                                if (captionLineHeight > difference) {
                                    extraSpace = captionLineHeight - difference;
                                }
                            }
                        }
                    }
                    else {
                        extraSpace = allowedHeight - totalHeight;
                    }

                    ////// now place the elements

                    if (captionLineHeight > 0) {
                        //set the caption style and get the caption's requared space
                        SmartLabel.setStyle(capStyle);
                        captionLineHeight += extraSpace;
                        captionObj = SmartLabel.getSmartText(titleText, canvasWidth, captionLineHeight);
                        extraSpace = captionLineHeight - captionObj.height;
                        titleObj.height = captionLineHeight = captionObj.height;
                        titleObj.text = captionObj.text;
                        captionObj.tooltext && (titleObj.originalText = captionObj.tooltext);
                        captionWidth = captionObj.width;
                        //titleObj.y = (captionLineHeight / 2) + hcJSON.chart.marginTop;
                    }
                    if (subCaptionLineHeight > 0) {
                        //set the caption style and get the caption's requared space
                        SmartLabel.setStyle(subCapStyle);
                        subCaptionLineHeight += extraSpace;
                        subcaptionObj = SmartLabel.getSmartText(subTitleText, canvasWidth, subCaptionLineHeight);
                        extraSpace = subCaptionLineHeight - subcaptionObj.height;
                        subCaptionLineHeight = subcaptionObj.height;
                        subTitleObj.text = subcaptionObj.text;
                        subTitleObj.height = subcaptionObj.height;
                        subcaptionObj.tooltext && (subTitleObj.originalText = subcaptionObj.tooltext);
                        subCaptionWidth = subcaptionObj.width;
                        //subTitleObj.y = (subCaptionLineHeight / 2) + captionLineHeight + hcJSON.chart.marginTop;
                    }
                    if (isPaddingReduced && extraSpace > 0) {
                        captionPadding += mathMin(oriCapPadding - captionPadding, extraSpace);
                    }
                    ////now add the top margin
                    totalHeight = captionLineHeight + subCaptionLineHeight + captionPadding;
                }
                totalHeight = totalHeight || canvasBorderThickness;
                if (titleObj.isOnTop) {
                    snapLiterals.captionstarty = hcJSON.chart.marginTop;
                    hcJSON.chart.marginTop += totalHeight;
                }
                else {
                    hcJSON.chart.marginBottom += totalHeight;
                    snapLiterals.captionstarty = titleObj.y = (conf.height - hcJSON.chart.marginBottom +
                        captionPadding);

                    hcJSON.chart.marginTop += topGutterWidth;
                    totalHeight += topGutterWidth;
                }
                // Add neccessary variables in titleObj,subtitleObj which will be used for calculation
                // of annotation snap literals later.
                titleObj._captionWidth = captionWidth;
                subTitleObj._subCaptionWidth = subCaptionWidth;
                titleObj._lineHeight = captionLineHeight;
                subTitleObj._lineHeight = subCaptionLineHeight;
            }
            else {
                subTitleObj && (subTitleObj.text = '');
                titleObj && (titleObj.text = '');
            }
            return totalHeight;
        },

        /** @todo implement none(no management), for opp trend adjust title margin, for
        line limits reduce canvas and adjust y axis lbels(may be done by total axis shifting) */
        stepYAxisNames = lib.stepYAxisNames = function (canvasHeight, hcJSON, fcJSONChart, axisObj, labelIdx, isBar) {
            var i = 0, plotLines = axisObj.plotLines, gridLines = [], startIdx, marker,
            length = axisObj.plotLines.length, plotObj, stepValue, perLabelHeight,
            testStr = 'W', SmartLabel = hcJSON[FC_CONFIG_STRING].smartLabel, lineHeight,
            fontSize = parseFloat(pluckFontSize(fcJSONChart.basefontsize, 10)), prevPlot;

            for (; i < length; i += 1) {
                plotObj = plotLines[i];
                if (plotObj.isGrid && plotObj.label && plotObj.label.text) {
                    gridLines.push(plotObj);
                    if (plotObj.value === 0) {
                        startIdx = gridLines.length - 1;
                    }
                }
            }

            length = gridLines.length;

            if (length) {
                if (axisObj.labels.style) {
                    SmartLabel.setStyle(axisObj.labels.style);
                } else if (gridLines[0].label && gridLines[0].label.style) {
                    SmartLabel.setStyle(axisObj.labels.style);
                }


                lineHeight = SmartLabel.getOriSize(testStr).height;

                if (!isBar) {
                    // padding in case of non bar charts to make the labels look visiually aesthetic
                    lineHeight += (fontSize * 0.4);
                }

                perLabelHeight = canvasHeight / (length - 1);

                if (perLabelHeight < lineHeight) {
                    stepValue = mathMax(1, mathCeil(lineHeight / perLabelHeight));

                    marker = startIdx;
                    for (i = startIdx; i < length; i += 1) {
                        plotObj = gridLines[i];
                        if (i === labelIdx) {
                            if (((i - marker) % stepValue) && prevPlot) {
                                prevPlot.label.text = '';
                            }
                            marker = labelIdx;
                        }
                        if (plotObj && plotObj.label) {
                            if ((i - marker) % stepValue) {
                                plotObj.label.text = BLANKSTRING;
                            } else {
                                prevPlot = plotObj;
                            }
                        }
                    }

                    marker = startIdx;
                    for (i = startIdx; i >= 0; i -= 1) {
                        plotObj = gridLines[i];
                        if (i === labelIdx) {
                            if (((marker - i) % stepValue) && prevPlot) {
                                prevPlot.label.text = '';
                            }
                            marker = labelIdx;
                        }
                        if (plotObj && plotObj.label) {
                            if ((marker - i) % stepValue) {
                                plotObj.label.text = BLANKSTRING;
                            } else {
                                prevPlot = plotObj;
                            }
                        }
                    }
                }
            }
        },

        placeHorizontalAxis = lib.placeHorizontalAxis =  function (axisObj, axisConf, hcJSON,
            fcJSON, width, maxHeight, minCanWidth) {

            var conf = hcJSON[FC_CONFIG_STRING],
                FCChartObj = fcJSON && fcJSON.chart || {},
                textObj, plotObj, index, titleText, labelObj,
                lastUsedStyle, minWidth, temp, maxStaggerLines, tempLabelWidth,
                labelTextWidth, labelTextPadding = 4, autoWrapLimit,

                rotation = 0, titleHeightUsed = 0, labelHeight = 10, stepValue = 1,
                labelY = 0, nameLineHeight = 0, catCount = 0, testStr = 'W',
                titleHeight = 0,

                noWrap = false, isStagger = false, isNone = false,

                isStepped = pluckNumber(FCChartObj.labelstep, 0),
                minUserWidth = pluckNumber(FCChartObj.xaxisminlabelwidth, 0),
                maxLabelHeight = pluckNumber(FCChartObj.maxlabelheight, maxHeight),

                labelDisplay = axisConf.labelDisplay,
                rotateLabels = axisConf.rotateLabels,
                labelPadding = axisConf.horizontalLabelPadding,

                marginBottomExtraSpace = conf.marginBottomExtraSpace,
                availableSpaceLeft = hcJSON.chart.marginLeft,
                availableSpaceRight = hcJSON.chart.marginRight,

                SmartLabel = conf.smartLabel,
                setBorderWidth = conf.plotBorderThickness,
                catLen = axisConf.catCount,
                slantLabels = axisConf.slantLabels,
                unitWidth = width / (axisObj.max - axisObj.min),

                /** @todo need not to make this an Object if there is no width needed. */
                tedendHeight = 0, oppTrendHeight = 0, labelSize = {
                    w: 0,
                    h: 0
                },

                options = (fcJSON && fcJSON.chart) || {},
                refresh = pluckNumber(options.updateinterval, options.refreshinterval) * 1000,
                dataUrl = options.datastreamurl,
                realtimeEnabled = Boolean(this.realtimeEnabled && refresh && (dataUrl !== undefined)),
                catLinesArr,
                lowerThreshold,
                upperThreshold,
                newObj,
                leadingEdge,
                trailingEdge,
                nextItem, rem,
                firstCat,
                lastCat,
                nextCat,
                prevCat,
                plotPx,
                len,
                reductionFactor,
                gridLineObj,
                lineIndex,
                prevCatMap,
                prevGrid,
                leftSpace,
                rightSpace,
                nextGrid,
                lastEdge,
                nextEdge,
                labelWidth,
                nextIdx = null,
                prevIdx = null,
                difference,
                reducePadding,
                totalSpace,
                axisMin,
                axisMax,
                labelEdge,
                leftModify,
                rightModify,
                excessWidth,
                i,
                plotLinesArr,
                plotBandsArr,
                gridLinesArr = [],
                nonGridLinesArr = [],
                chartPlotWidth,
                firstDifference = 0,
                lastDifference = 0,
                lastGridIndex,
                gridLinesLen,
                perCatWidth,
                canvasLeftSpace,
                canvasRightSpace,
                totalDifference,
                length,
                xAxisNamePadding = axisConf.horizontalAxisNamePadding,
                labelSpace = 0,
                staggerLines = axisConf.staggerLines,
                bottomSpace = tedendHeight,
                isXYPlot = false,
                widthToAdd,
                padWidth,
                nCWidth,
                paddingGiven = false,
                setSuccessiveCategoryWidths,
                plotRight,
                plotLeft,
                nextPlot,
                labelX,
                trendTextY,
                yShipment,
                perLabelH,
                perLabelW,
                xShipment,
                adjustedPx,
                aoppTrendHeight,
                atedendHeight,
                textAlign;

            // Need to run a loop and find the autoWrapLimit Value as per the biggest label
            // 1. segregate the grid plot lines from the non grid plot lines
            plotLinesArr = axisObj.plotLines;
            labelHeight = i = 0;
            for (length = plotLinesArr.length; i < length; i += 1) {
                plotObj = plotLinesArr[i];
                if (plotObj && plotObj.label && !plotObj.isTrend &&
                        labelHeight < pInt(plotObj.label.style.lineHeight)) {
                    labelHeight = pInt(plotObj.label.style.lineHeight);
                    lastUsedStyle = plotObj.label.style;
                }
            }

            if (lastUsedStyle || axisObj.labels.style) {
                lastUsedStyle = lastUsedStyle || axisObj.labels.style;
                SmartLabel.setStyle(lastUsedStyle);
                temp = SmartLabel.getOriSize(testStr);
                labelHeight = SmartLabel.lineHeight;
                minWidth = temp.width + labelTextPadding;
                autoWrapLimit = SmartLabel.getOriSize('WWW').width + labelTextPadding;
            }

            if (axisObj.title && axisObj.title.text != BLANKSTRING) {
                lastUsedStyle = axisObj.title.style;
                SmartLabel.setStyle(lastUsedStyle);
                nameLineHeight = SmartLabel.getOriSize(testStr).height;
                //now get the title space
                axisObj.title.rotation = 0;
                titleText = SmartLabel.getSmartText(axisObj.title.text, width, maxHeight);
                titleHeightUsed = titleText.height;
            }

            if (availableSpaceLeft != parseInt(FCChartObj.chartleftmargin, 10)) {
                leftModify = true;
            }
            if (availableSpaceRight != parseInt(FCChartObj.chartrightmargin, 10)) {
                rightModify = true;
            }
            if (FCChartObj.canvaspadding !== undefined && FCChartObj.canvaspadding !== '') {
                paddingGiven = true;
            }
            // if the chartmargin is to be changed to accomodate the first and last labels
            // then excessWidth is the limit upto which the total chartmargins can be changed.
            excessWidth = width - minCanWidth;

            switch (labelDisplay) {
                case 'none':
                    isNone = true;
                    noWrap = true;
                    if (rotateLabels) {
                        if (slantLabels) {
                            rotation = 300;
                        } else {
                            rotation = 270;
                        }
                        temp = labelHeight;
                        labelHeight = minWidth;
                        minWidth = temp;
                    }
                    break;
                case 'rotate':
                    if (slantLabels) {
                        rotation = 300;
                    } else {
                        rotation = 270;
                    }
                    temp = labelHeight;
                    labelHeight = minWidth;
                    minWidth = temp;
                    noWrap = true;
                    break;
                case 'stagger':
                    noWrap = true;
                    isStagger = true;
                    maxStaggerLines = mathFloor((maxHeight - nameLineHeight) / labelHeight);
                    if (maxStaggerLines < staggerLines) {
                        staggerLines = maxStaggerLines;
                    }
                    break;
                default: //auto
                    if (rotateLabels) {
                        if (slantLabels) {
                            rotation = 300;
                        } else {
                            rotation = 270;
                        }
                        temp = labelHeight;
                        labelHeight = minWidth;
                        minWidth = temp;
                    }
            }

            if (conf.isBar) {
                noWrap = true;
            }
            // if the chart is not scatter chart
            i = 0;
            plotLinesArr = axisObj.plotLines;

            if (typeof hcJSON._FCconf.isXYPlot === STRINGUNDEFINED && !conf.isBar) {

                // 1. segregate the grid plot lines from the non grid plot lines
                for (length = plotLinesArr.length; i < length; i += 1) {
                    plotObj = plotLinesArr[i];
                    if (plotObj) {
                        if (plotObj.isGrid) {
                            gridLinesArr.push(plotObj);
                        } else if (plotObj.isTrend) {
                            nonGridLinesArr.push(plotObj);
                        }
                    }
                }

                plotBandsArr = axisObj.plotBands;

                for (i = 0, length = plotBandsArr.length; i < length; i += 1) {
                    plotObj = plotBandsArr[i];
                    if (plotObj) {
                        nonGridLinesArr.push(plotObj);
                    }
                }

                lastGridIndex = gridLinesArr.length - 1;
                gridLinesLen = gridLinesArr.length;

                if (isStagger) {
                    if (staggerLines > gridLinesLen) {
                        staggerLines = gridLinesLen;
                    } else if (staggerLines < 2) {
                        staggerLines = 2;
                    }
                }

                if (gridLinesLen) {
                    if (axisObj.scroll && axisObj.scroll.viewPortMin && axisObj.scroll.viewPortMax) {
                        axisMin = axisObj.scroll.viewPortMin;
                        axisMax = axisObj.scroll.viewPortMax;
                        leftModify = false;
                        rightModify = false;
                    } else {
                        axisMin = axisObj.min;
                        axisMax = axisObj.max;
                    }
                    // 2. calculate width for each label
                    chartPlotWidth = (gridLinesArr[lastGridIndex].value - gridLinesArr[0].value) * unitWidth;
                    perCatWidth = chartPlotWidth / (catLen - 1);
                    canvasLeftSpace = (gridLinesArr[0].value - axisMin) * unitWidth;
                    canvasRightSpace = (axisMax - gridLinesArr[lastGridIndex].value) * unitWidth;

                    if (labelDisplay === 'auto') {
                        if (perCatWidth < autoWrapLimit) {
                            if (slantLabels) {
                                rotation = 300;
                            } else {
                                rotation = 270;
                            }
                            temp = labelHeight;
                            labelHeight = minWidth;
                            minWidth = temp;
                            noWrap = true;
                        }
                    } else if (labelDisplay === 'stagger') {
                        perCatWidth *= staggerLines;
                    }

                    if (this.defaultSeriesType !== 'line') {
                        /** @todo check drawfullareaborder in case of area charts */
                        if (this.defaultSeriesType === 'area') {
                            if (conf.drawFullAreaBorder) {
                                if (setBorderWidth > canvasLeftSpace) {
                                    axisMin = axisObj.min -= (setBorderWidth / (2 * unitWidth));
                                    canvasLeftSpace += (gridLinesArr[0].value - axisMin) * unitWidth;
                                }

                                if (setBorderWidth > canvasRightSpace) {
                                    axisMax = axisObj.max += (setBorderWidth /  (2 * unitWidth));
                                    canvasRightSpace += (axisMax - gridLinesArr[lastGridIndex].value) * unitWidth;
                                }
                            }
                        }
                        else {
                            if (setBorderWidth > canvasLeftSpace) {
                                axisMin = axisObj.min -= (setBorderWidth / (2 * unitWidth));
                                canvasLeftSpace += (gridLinesArr[0].value - axisMin) * unitWidth;
                            }

                            if (setBorderWidth > canvasRightSpace) {
                                axisMax = axisObj.max += (setBorderWidth /  (2 * unitWidth));
                                canvasRightSpace += (axisMax - gridLinesArr[lastGridIndex].value) * unitWidth;
                            }
                        }
                    }

                    if (minWidth < minUserWidth) {
                        minWidth = minUserWidth;
                    }

                    if (!isStagger && !isNone) {
                        stepValue = mathMax(1, isStepped, mathCeil(minWidth / perCatWidth));
                    }
                    else {
                        stepValue = mathMax(1, isStepped);
                    }

                    if (conf.x) {
                        conf.x.stepValue = stepValue;
                    }
                    perCatWidth *= stepValue;

                    // 4. calculate width for first label
                    tempLabelWidth = (canvasLeftSpace + availableSpaceLeft) * 2;

                    // if the distance b/w the first data point and min is greater than the distace between two adjacent
                    // data points
                    labelObj = plotLinesArr[0].label;
                    if (labelObj && labelObj.text) {
                        if (labelObj.style) {
                            SmartLabel.setStyle(labelObj.style);
                        }
                        if (rotation === 270) {
                            labelTextWidth =
                                mathMin(perCatWidth, SmartLabel.getOriSize(labelObj.text).height + labelTextPadding);
                        }
                        else {
                            labelTextWidth =
                                mathMin(perCatWidth, SmartLabel.getOriSize(labelObj.text).width + labelTextPadding);
                        }
                        // if the label doesnt fit in the given space
                        if (labelTextWidth > tempLabelWidth) {
                            if (!isNone) {
                                firstDifference = (labelTextWidth - tempLabelWidth) / 2;
                            }

                            if (!leftModify) {
                                if (paddingGiven) {
                                    firstDifference = 0;
                                }
                                perCatWidth -= (firstDifference / (catLen - 1));
                                nCWidth = perCatWidth * (catLen - 1);
                                unitWidth = perCatWidth;
                                widthToAdd = (chartPlotWidth - nCWidth) / unitWidth;
                                axisMax = axisObj.max += widthToAdd;
                                axisMin = axisObj.min -= widthToAdd;
                                firstDifference = 0;
                                chartPlotWidth = nCWidth;
                                canvasLeftSpace = (gridLinesArr[0].value - axisMin) * unitWidth;
                                canvasRightSpace = (axisMax - gridLinesArr[lastGridIndex].value) * unitWidth;
                            }
                        }
                    }

                    // 5. calculate width for the last label
                    tempLabelWidth = (canvasRightSpace + availableSpaceRight) * 2;

                    // if the distance b/w the first data point and min is greater than the distace between two adjacent
                    // data points
                    labelObj = plotLinesArr[lastGridIndex].label;
                    if (labelObj && labelObj.text) {
                        if (labelObj.style) {
                            SmartLabel.setStyle(labelObj.style);
                        }
                        if (rotation === 270) {
                            labelTextWidth =
                                mathMin(perCatWidth, SmartLabel.getOriSize(labelObj.text).height + labelTextPadding);
                        }
                        else {
                            labelTextWidth =
                                mathMin(perCatWidth, SmartLabel.getOriSize(labelObj.text).width + labelTextPadding);
                        }
                        // if the label doesnt fit in the given space
                        if (labelTextWidth > tempLabelWidth) {
                            if (!isNone) {
                                lastDifference = (labelTextWidth - tempLabelWidth) / 2;
                            }

                            if (!rightModify) {
                                if (paddingGiven) {
                                    lastDifference = 0;
                                }
                                perCatWidth -= (lastDifference / (catLen - 1));
                                nCWidth = perCatWidth * (catLen - 1);
                                unitWidth = perCatWidth;
                                widthToAdd = (chartPlotWidth - nCWidth) / unitWidth;
                                //fix for RED-327 which is a replicated issue of
                                //FCXTCOMMON-311.same fix applied.
                                //axisMax = axisObj.max += widthToAdd;
                                //axisMin = axisObj.min -= widthToAdd;
                                lastDifference = 0;
                                chartPlotWidth = nCWidth;
                                canvasLeftSpace = (gridLinesArr[0].value - axisMin) * unitWidth;
                                canvasRightSpace = (axisMax - gridLinesArr[lastGridIndex].value) * unitWidth;
                            }
                        }
                    }

                    // 6. do we need to change chart margin or canvas padding?
                    totalDifference = firstDifference + lastDifference;
                    if (totalDifference > 0) {
                        if (excessWidth > totalDifference) { // change the chart margins
                            reductionFactor =  (lastDifference * width)/(lastDifference + width);
                            reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                            hcJSON.chart.marginRight += reductionFactor;
                            width -= reductionFactor;

                            reductionFactor =  (firstDifference * width)/(firstDifference + width);
                            reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                            hcJSON.chart.marginLeft += reductionFactor;
                            width -= reductionFactor;

                            unitWidth = width / (axisObj.max - axisObj.min);
                        } else { //change the padding
                            if (firstDifference < lastDifference) {
                                // try and remove the greater of the two from chart margin
                                if ((excessWidth >= lastDifference) && rightModify) {
                                    reductionFactor =  (lastDifference * width)/(lastDifference + width);
                                    reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                    hcJSON.chart.marginRight += reductionFactor;
                                    width -= reductionFactor;
                                    unitWidth = width / (axisObj.max - axisObj.min);

                                } else if (leftModify) {
                                    reductionFactor =  (firstDifference * width)/(firstDifference + width);
                                    reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                    hcJSON.chart.marginLeft += reductionFactor;
                                    width -= reductionFactor;
                                    unitWidth = width / (axisObj.max - axisObj.min);
                                }
                            } else {
                                if ((excessWidth >= firstDifference) && leftModify) {
                                    reductionFactor =  (firstDifference * width)/(firstDifference + width);
                                    reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                    hcJSON.chart.marginLeft += reductionFactor;
                                    width -= reductionFactor;
                                    unitWidth = width / (axisObj.max - axisObj.min);

                                } else if (rightModify) {
                                    reductionFactor =  (lastDifference * width)/(lastDifference + width);
                                    reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                    hcJSON.chart.marginRight += reductionFactor;
                                    width -= reductionFactor;
                                    unitWidth = width / (axisObj.max - axisObj.min);
                                }
                            }
                        }
                        chartPlotWidth = (gridLinesArr[lastGridIndex].value - gridLinesArr[0].value) * unitWidth;
                        perCatWidth = chartPlotWidth / (catLen - 1);

                        if (isStagger) {
                            perCatWidth *= staggerLines;
                        }

                        if (!isStagger && !isNone) {
                            if (rotation) {
                                stepValue = mathMax(1, isStepped, mathCeil(labelHeight / perCatWidth));
                            }
                            else {
                                stepValue = mathMax(1, isStepped, mathCeil(minWidth / perCatWidth));
                            }
                        }
                        else {
                            stepValue = mathMax(1, isStepped);
                        }

                        if (conf.x) {
                            conf.x.stepValue = stepValue;
                        }
                        perCatWidth *= stepValue;
                    }

                    // start setting the label dimensions
                    for(index = 0; index < gridLinesLen; index += 1) {

                        plotObj = gridLinesArr[index];

                        if ((index % stepValue) && plotObj.label) {
                            plotObj.stepped = true;
                            plotObj.label.style = axisObj.steppedLabels.style;
                            if (!realtimeEnabled) {
                                continue;
                            }
                        }
                        else {
                            plotObj.stepped = false;
                            // This overwrites the actual style of x-axis labels
                            // so we don't need this if are supporting individual label style
                            // plotObj.label.style = axisObj.labels.style;
                        }

                        if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                            labelObj = plotObj.label;
                            //if the style not implemented then implement it
                            if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                lastUsedStyle = labelObj.style;
                                SmartLabel.setStyle(lastUsedStyle);
                            }

                            if (rotation && isNone) {
                                textObj = SmartLabel.getOriSize(labelObj.text);
                                labelSize.w = mathMax(labelSize.w, textObj.width + labelTextPadding);
                                labelSize.h = mathMax(labelSize.h, textObj.height);
                            }
                            else if (!isNone) {
                                if (rotation || isStagger) {
                                    textObj = SmartLabel.getOriSize(labelObj.text);
                                }
                                else {//wrap
                                    // 4px is removed for label padding
                                    textObj = SmartLabel.getSmartText(labelObj.text, (perCatWidth - labelTextPadding),
                                        maxHeight, noWrap);
                                }
                                labelSize.w = mathMax(labelSize.w, textObj.width + labelTextPadding);
                                labelSize.h = mathMax(labelSize.h, textObj.height);
                            }
                        }
                    }
                }

                for(index = 0, length = nonGridLinesArr.length; index < length; index += 1) {

                    plotObj = nonGridLinesArr[index];

                    if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                        labelObj = plotObj.label;
                        //if the style not implemented then implement it
                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                            lastUsedStyle = labelObj.style;
                            SmartLabel.setStyle(lastUsedStyle);
                        }

                        textObj = SmartLabel.getOriSize(labelObj.text);
                        if (labelObj.verticalAlign === POSITION_BOTTOM) {
                            tedendHeight= mathMax(tedendHeight, textObj.height);
                        }
                        else {
                            oppTrendHeight = mathMax(oppTrendHeight, textObj.height);
                        }
                    }
                }

                if (axisObj.scroll && axisObj.scroll.enabled && !rotation && !isNone) {
                    widthToAdd = labelSize.w / 2;
                    if (hcJSON.chart.marginLeft < widthToAdd) {
                        padWidth = widthToAdd - hcJSON.chart.marginLeft;
                        if (excessWidth > padWidth) {
                            width -= padWidth;
                            excessWidth -= padWidth;
                            hcJSON.chart.marginLeft += padWidth;
                        }
                    }
                    if (hcJSON.chart.marginRight < widthToAdd) {
                        padWidth = widthToAdd - hcJSON.chart.marginRight;
                        if (excessWidth > padWidth) {
                            width -= padWidth;
                            excessWidth -= padWidth;
                            hcJSON.chart.marginRight += padWidth;
                        }
                    }
                }
            }
            else {
                // Variables for scatter and bar charts
                catLinesArr = {};
                leadingEdge = 0;
                trailingEdge = 0;
                firstCat = null;
                lastCat = null;
                prevCatMap = {};
                isXYPlot = true;

                unitWidth = width / (axisObj.max - axisObj.min);

                setSuccessiveCategoryWidths = function (categoryObj1, categoryObj2, isStrict) {

                    var px1, le1, te2, px2, labelWidth1, labelWidth2,
                    edgeDiff, plotDiff, plotObj1, plotObj2;

                    plotObj1 = categoryObj1.plotObj;
                    labelWidth1 = categoryObj1.labelTextWidth;

                    if (!labelWidth1) { // first label;
                        labelObj = plotObj1.label;
                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                            lastUsedStyle = labelObj.style;
                            SmartLabel.setStyle(lastUsedStyle);
                        }

                        labelWidth1 = SmartLabel.getOriSize(labelObj.text).width + labelTextPadding;
                        categoryObj1.oriWidth = labelWidth1;

                        if (labelWidth1 > lowerThreshold) {
                            labelWidth1 = lowerThreshold;
                        }

                        categoryObj1.labelTextWidth = labelWidth1;
                        categoryObj1.leftEdge = (plotObj1.value * unitWidth) - (labelWidth1 / 2);
                        categoryObj1.rightEdge = (plotObj1.value * unitWidth) + (labelWidth1 / 2);

                        if (isStrict) {
                            labelWidth1 = mathMin(labelWidth1,
                                2 * ((plotObj.value - axisObj.min) * unitWidth) + hcJSON.chart.marginLeft);
                            categoryObj1.labelTextWidth = labelWidth1;
                        }
                    }

                    if (typeof categoryObj2 !== STRINGUNDEFINED) {

                        plotObj2 = categoryObj2.plotObj;

                        labelObj = plotObj2.label;

                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                            lastUsedStyle = labelObj.style;
                            SmartLabel.setStyle(lastUsedStyle);
                        }

                        if (categoryObj2.oriWidth) {
                            labelWidth2 = categoryObj2.oriWidth;
                        } else {
                            labelWidth2 = SmartLabel.getOriSize(labelObj.text).width + labelTextPadding;
                            categoryObj2.oriWidth = labelWidth2;
                        }

                        if (labelWidth2 > lowerThreshold) {
                            labelWidth2 = lowerThreshold;
                        }

                        categoryObj2.labelTextWidth = labelWidth2;
                        categoryObj2.leftEdge = (plotObj2.value * unitWidth) - (labelWidth2 / 2);
                        categoryObj2.rightEdge = (plotObj2.value * unitWidth) + (labelWidth2 / 2);

                        px1 = plotObj1.value * unitWidth;
                        le1 = px1 + (labelWidth1 / 2);

                        px2 = plotObj2.value * unitWidth;
                        te2 = px2 - (labelWidth2 / 2);

                        if (te2 < le1) {
                            if ((px1 + minWidth) < ( px2 - minWidth)) {
                                edgeDiff = le1 - te2;
                                plotDiff = px2 - px1;
                                if (edgeDiff > plotDiff) {
                                    categoryObj1.labelTextWidth = mathMin(labelWidth1, plotDiff);
                                } else {
                                    categoryObj1.labelTextWidth = mathMax(minWidth, (labelWidth1 - (edgeDiff / 2)));
                                }
                                categoryObj2.labelTextWidth = 2 * (plotDiff - (categoryObj1.labelTextWidth / 2));

                                categoryObj1.leftEdge = (plotObj1.value * unitWidth) -
                                    (categoryObj1.labelTextWidth / 2);
                                categoryObj1.rightEdge = (plotObj1.value * unitWidth) +
                                    (categoryObj1.labelTextWidth / 2);

                                categoryObj2.leftEdge = (plotObj2.value * unitWidth) -
                                    (categoryObj2.labelTextWidth / 2);
                                categoryObj2.rightEdge = (plotObj2.value * unitWidth) +
                                    (categoryObj2.labelTextWidth / 2);

                            } else {
                                categoryObj2.labelTextWidth = 0;
                                plotObj2.label.text = BLANKSTRING;
                                return false;
                            }
                        }
                    } else if (isStrict){ // is lastLabel
                        labelWidth1 = mathMin(labelWidth1,
                            2 * ((axisObj.max - plotObj.value) * unitWidth) + hcJSON.chart.marginRight);
                        categoryObj1.labelTextWidth = labelWidth1;
                        categoryObj1.leftEdge = (plotObj1.value * unitWidth) - (labelWidth1 / 2);
                        categoryObj1.rightEdge = (plotObj1.value * unitWidth) + (labelWidth1 / 2);
                    }

                    categoryObj1.nextCat = categoryObj2;
                    return true;
                };

                // wrap or stagger
                if (isStagger) {
                    if (staggerLines > gridLinesLen) {
                        staggerLines = gridLinesLen;
                    } else if (staggerLines < 2) {
                        staggerLines = 2;
                    }
                } else {
                    staggerLines = 1;
                }

                for (length = plotLinesArr.length; i < length; i += 1) {
                    plotObj = plotLinesArr[i];
                    if (plotObj && plotObj.label && (typeof plotObj.label.text !== STRINGUNDEFINED)) {
                        if (plotObj.isGrid) {
                            newObj = {
                                plotObj: plotObj
                            };
                            if (plotObj.isCat) {
                                rem = i % staggerLines;
                                if (!catLinesArr[rem]) {
                                    catLinesArr[rem] = [];
                                }
                                if (!firstCat) {
                                    firstCat = newObj;
                                    // In case there is only one category label first and last are the same.
                                    lastCat = newObj;
                                    catLinesArr[rem].push(firstCat);
                                } else {
                                    lastCat = newObj;
                                    catLinesArr[rem].push(lastCat);
                                }
                            }
                            gridLinesArr.push(newObj);
                        } else if (plotObj.isTrend) {
                            nonGridLinesArr.push({
                                plotObj: plotObj
                            });
                        }
                    }
                }

                plotBandsArr = axisObj.plotBands;
                for (i = 0, length = plotBandsArr.length; i < length; i += 1) {
                    plotObj = plotBandsArr[i];
                    if (plotObj && plotObj.isTrend && plotObj.label &&
                            (typeof plotObj.label.text !== STRINGUNDEFINED)) {
                        nonGridLinesArr.push({
                            plotObj: plotObj
                        });
                    }
                }

                if (gridLinesArr.length) {
                    if (!isNone && !rotation) {
                        if (conf.distributedColumns) {

                            for (i = 0, length = gridLinesArr.length; i < length; i += 1) {

                                gridLineObj = gridLinesArr[i];
                                lineIndex = i % staggerLines;

                                plotObj = gridLineObj.plotObj;
                                if (!plotObj.label) {
                                    continue;
                                }

                                if (plotObj.isCat) {
                                    if (i - staggerLines >= 0) {
                                        prevCat = gridLinesArr[i - staggerLines];
                                        lastEdge = prevCat.plotObj.value * unitWidth +
                                            prevCat.plotObj._weight * unitWidth / 2;
                                    } else {
                                        prevCat = null;
                                        lastEdge = (axisObj.min * unitWidth) - availableSpaceLeft;
                                    }

                                    if (i + staggerLines < length) {
                                        nextCat = gridLinesArr[i + staggerLines];
                                        nextEdge = nextCat.plotObj.value * unitWidth -
                                            nextCat.plotObj._weight * unitWidth / 2;
                                    } else {
                                        nextCat = null;
                                        nextEdge = (axisObj.max * unitWidth) + availableSpaceRight;
                                    }

                                    labelObj = plotObj.label;
                                    if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                        lastUsedStyle = labelObj.style;
                                        SmartLabel.setStyle(lastUsedStyle);
                                    }

                                    plotPx = plotObj.value * unitWidth;
                                    plotLeft = plotPx - plotObj._weight * unitWidth / 2;
                                    plotRight = plotPx + plotObj._weight * unitWidth / 2;

                                    if (staggerLines > 1) {
                                        leftSpace = plotLeft - lastEdge;
                                        rightSpace = plotRight + nextEdge;
                                        labelWidth  = plotRight - plotLeft + mathMin(leftSpace, rightSpace);
                                    } else {
                                        labelWidth = plotRight - plotLeft;
                                    }

                                    labelObj = plotObj.label;

                                    if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                        SmartLabel.setStyle(labelObj.style);
                                    }

                                    if (labelWidth < minWidth &&
                                            minWidth < SmartLabel.getOriSize(labelObj.text).width) {
                                        plotObj.label.text = BLANKSTRING;
                                        gridLineObj.labelTextWidth = 0;
                                        continue;
                                    }

                                    gridLineObj.labelTextWidth = labelWidth;

                                    textObj = SmartLabel.getSmartText(labelObj.text, (labelWidth - labelTextPadding),
                                        maxHeight, noWrap);
                                    labelWidth = textObj.width + labelTextPadding;

                                    gridLineObj.labelTextWidth = labelWidth;
                                    labelSize.h = mathMax(labelSize.h, textObj.height);
                                }
                            }
                        } else {
                            gridLinesLen = gridLinesArr.length;
                            lastGridIndex = gridLinesArr.length - 1;

                            chartPlotWidth = (gridLinesArr[lastGridIndex].plotObj.value -
                                gridLinesArr[0].plotObj.value) * unitWidth;
                            if (chartPlotWidth) {
                                lowerThreshold = chartPlotWidth * 0.1;
                                upperThreshold = mathMax(chartPlotWidth * 0.2, chartPlotWidth / gridLinesLen);

                            } else { // there is only one grid label.
                                lowerThreshold = width;
                                upperThreshold = width;
                            }
                            //1. start calulating the widths of the category labels as they have higher priority
                            for (index in catLinesArr) {
                                i = 0;
                                len = catLinesArr[index].length;

                                while (i < len) {
                                    nextItem = i + 1;
                                    while (!setSuccessiveCategoryWidths(catLinesArr[index][i],
                                            catLinesArr[index][nextItem])) {
                                        nextItem += 1;
                                    }
                                    i = nextItem;
                                }
                            }

                            //2. find the trailing edge of first category label.
                            if (firstCat) {
                                trailingEdge = ((firstCat.plotObj.value - axisObj.min) * unitWidth) +
                                    availableSpaceLeft - (firstCat.labelTextWidth / 2);
                            }

                            //3. if the first grid label is not a category, find trailing edge of first grid label
                            plotObj = gridLinesArr[0].plotObj;
                            if (!firstCat || plotObj !== firstCat.plotObj) {
                                labelObj = plotObj.label;
                                if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                    lastUsedStyle = labelObj.style;
                                    SmartLabel.setStyle(lastUsedStyle);
                                }
                                labelTextWidth = SmartLabel.getOriSize(labelObj.text).width + labelTextPadding;

                                plotPx = ((plotObj.value - axisObj.min) * unitWidth) + availableSpaceLeft;

                                if (firstCat) {
                                    difference = trailingEdge - plotPx;
                                    if ((difference < labelTextWidth) && (difference > (minWidth / 2))) {
                                        labelTextWidth = difference * 2;
                                    } else {
                                        labelTextWidth = 0;
                                    }
                                }
                                gridLinesArr[0].labelTextWidth = labelTextWidth;

                                if (labelTextWidth > 0) {
                                    temp = plotPx - (labelTextWidth / 2);
                                }

                                if (temp < trailingEdge) {
                                    trailingEdge = temp;
                                }
                            }

                            //3. find the leading edge of last category label.
                            if (lastCat) {
                                labelTextWidth = lastCat.labelTextWidth;
                                leadingEdge = ((axisObj.max - lastCat.plotObj.value) * unitWidth) +
                                    availableSpaceRight - (labelTextWidth / 2);
                            }

                            //4. if the last grid label is not a category, find leading edge of last grid label
                            plotObj = gridLinesArr[lastGridIndex].plotObj;
                            if (!lastCat || plotObj !== lastCat.plotObj) {
                                labelObj = plotObj.label;
                                if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                    lastUsedStyle = labelObj.style;
                                    SmartLabel.setStyle(lastUsedStyle);
                                }

                                labelTextWidth = SmartLabel.getOriSize(labelObj.text).width + labelTextPadding;

                                plotPx = ((axisObj.max - plotObj.value) * unitWidth) + availableSpaceRight;

                                if (lastCat) {
                                    difference = plotPx - leadingEdge;
                                    if ((difference < labelTextWidth) && (difference > (minWidth / 2))) {
                                        labelTextWidth = difference *  2;
                                    } else {
                                        labelTextWidth = 0;
                                    }
                                }

                                gridLinesArr[lastGridIndex].labelTextWidth = labelTextWidth;

                                if (labelTextWidth > 0) {
                                    temp = plotPx - (labelTextWidth / 2);
                                }

                                if (temp < leadingEdge) {
                                    leadingEdge = temp;
                                }
                            }

                            if (trailingEdge < 0) {
                                firstDifference = - trailingEdge;
                            } else {
                                firstDifference = 0;
                            }

                            if (leadingEdge < 0) {
                                lastDifference = - leadingEdge;
                            } else {
                                lastDifference = 0;
                            }

                            // 6. do we need to change chart margin or canvas padding?
                            totalDifference = firstDifference + lastDifference;

                            if (totalDifference > 0) {
                                if (excessWidth > totalDifference) { // change the chart margins
                                    reductionFactor =  (lastDifference * width)/(lastDifference + width);
                                    reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                    hcJSON.chart.marginRight += reductionFactor;
                                    width -= reductionFactor;

                                    reductionFactor =  (firstDifference * width)/(firstDifference + width);
                                    reductionFactor = reductionFactor ? reductionFactor + 4 : 0; // for label padding;
                                    hcJSON.chart.marginLeft += reductionFactor;
                                    width -= reductionFactor;

                                    unitWidth = width / (axisObj.max - axisObj.min);
                                } else { //change the padding
                                    if (firstDifference < lastDifference) {
                                        // try and remove the greater of the two from chart margin
                                        if ((excessWidth >= lastDifference) && rightModify) {
                                            reductionFactor =  (lastDifference * width)/(lastDifference + width);
                                            // for label padding;
                                            reductionFactor = reductionFactor ? reductionFactor + 4 : 0;
                                            hcJSON.chart.marginRight += reductionFactor;
                                            width -= reductionFactor;
                                            unitWidth = width / (axisObj.max - axisObj.min);

                                        } else if (leftModify) {
                                            reductionFactor =  (firstDifference * width)/(firstDifference + width);
                                            // for label padding;
                                            reductionFactor = reductionFactor ? reductionFactor + 4 : 0;
                                            hcJSON.chart.marginLeft += reductionFactor;
                                            width -= reductionFactor;
                                            unitWidth = width / (axisObj.max - axisObj.min);
                                        }
                                    } else {
                                        if ((excessWidth >= firstDifference) && leftModify) {
                                            reductionFactor =  (firstDifference * width)/(firstDifference + width);
                                            // for label padding;
                                            reductionFactor = reductionFactor ? reductionFactor + 4 : 0;
                                            hcJSON.chart.marginLeft += reductionFactor;
                                            width -= reductionFactor;
                                            unitWidth = width / (axisObj.max - axisObj.min);

                                        } else if (rightModify) {
                                            reductionFactor =  (lastDifference * width)/(lastDifference + width);
                                            // for label padding;
                                            reductionFactor = reductionFactor ? reductionFactor + 4 : 0;
                                            hcJSON.chart.marginRight += reductionFactor;
                                            width -= reductionFactor;
                                            unitWidth = width / (axisObj.max - axisObj.min);
                                        }
                                    }
                                }
                                availableSpaceRight = hcJSON.chart.marginRight;
                                availableSpaceLeft = hcJSON.chart.marginLeft;
                                chartPlotWidth = (gridLinesArr[lastGridIndex].plotObj.value -
                                    gridLinesArr[0].plotObj.value) * unitWidth;
                                lowerThreshold = chartPlotWidth * 0.1;
                                upperThreshold = mathMax(chartPlotWidth * 0.2, chartPlotWidth / gridLinesLen);

                                for(index in catLinesArr) {
                                    i = 0;
                                    len = catLinesArr[index].length;

                                    while (i < len) {
                                        nextItem = i + 1;

                                        while (!setSuccessiveCategoryWidths(catLinesArr[index][i],
                                                catLinesArr[index][nextItem], true)) {
                                            nextItem += 1;
                                        }
                                        i = nextItem;
                                    }
                                    index += 1;
                                }
                            }


                            // Setting the grid labels between the category labels that are currently occupying at most
                            // lowerThreshold width.
                            for (i = 0, length = gridLinesArr.length; i < length; i += 1) {

                                gridLineObj = gridLinesArr[i];
                                lineIndex = i % staggerLines;

                                plotObj = gridLineObj.plotObj;
                                if (!plotObj.label) {
                                    continue;
                                }

                                if (plotObj.isCat) {
                                    if (gridLineObj.labelTextWidth) {
                                        prevCatMap[lineIndex] = gridLineObj;
                                    }
                                } else {

                                    prevCat = prevCatMap[lineIndex];
                                    if (prevCat) {
                                        nextCat = prevCat.nextCat;
                                    } else if (catLinesArr[lineIndex]) {
                                        nextCat = catLinesArr[lineIndex][0];
                                    } else {
                                        nextCat = null;
                                    }

                                    prevGrid = null;

                                    // get the previous visible label
                                    if (i >= staggerLines) {
                                        prevIdx = i - staggerLines;
                                        prevGrid = gridLinesArr[prevIdx];
                                        while (!prevGrid.labelTextWidth) {
                                            if (prevIdx >= staggerLines) {
                                                prevIdx -= staggerLines;
                                                prevGrid = gridLinesArr[prevIdx];
                                            } else {
                                                prevGrid = null;
                                                break;
                                            }
                                        }
                                    }

                                    if (prevGrid) {
                                        lastEdge = prevGrid.rightEdge;
                                    } else {
                                        lastEdge = (axisObj.min * unitWidth) - availableSpaceLeft;
                                    }

                                    if (nextCat) {
                                        nextEdge = nextCat.leftEdge;
                                    } else {
                                        nextEdge = (axisObj.max * unitWidth) + availableSpaceRight;
                                    }

                                    labelObj = plotObj.label;
                                    if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                        lastUsedStyle = labelObj.style;
                                        SmartLabel.setStyle(lastUsedStyle);
                                    }

                                    labelTextWidth = SmartLabel.getOriSize(labelObj.text).width + labelTextPadding;
                                    labelEdge = (plotObj.value * unitWidth) - (labelTextWidth / 2);

                                    if (conf.isBar && (i == length - 1) && prevGrid) {
                                        if (lastEdge > labelEdge) {
                                            prevGrid.plotObj.label.text = BLANKSTRING;
                                            prevGrid.labelTextWidth = 0;
                                            lastEdge = prevGrid.leftEdge;
                                        }
                                    } else {
                                        if ((lastEdge > labelEdge) || (nextEdge < (labelEdge + labelTextWidth))) {
                                            plotObj.label.text = BLANKSTRING;
                                            gridLineObj.labelTextWidth = 0;
                                            continue;
                                        }
                                    }

                                    lastEdge = mathMax(lastEdge, labelEdge);

                                    plotPx = plotObj.value * unitWidth;
                                    labelWidth = 2 * mathMin((plotPx - lastEdge), (nextEdge - plotPx));
                                    // hack to work around the javascript floating
                                    // point operations bug.
                                    if (labelWidth.toFixed) {
                                        labelWidth = (labelWidth.toFixed(2));
                                    }

                                    labelObj = plotObj.label;

                                    if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                        SmartLabel.setStyle(labelObj.style);
                                    }

                                    if (labelWidth < minWidth &&
                                            minWidth < SmartLabel.getOriSize(labelObj.text).width) {
                                        plotObj.label.text = BLANKSTRING;
                                        gridLineObj.labelTextWidth = 0;
                                        continue;
                                    }

                                    gridLineObj.labelTextWidth = labelWidth;

                                    textObj = SmartLabel.getSmartText(labelObj.text, (labelWidth - labelTextPadding),
                                        maxHeight, noWrap);
                                    labelWidth = textObj.width + labelTextPadding;

                                    gridLineObj.labelTextWidth = labelWidth;
                                    gridLineObj.leftEdge = plotPx - (labelWidth / 2);
                                    gridLineObj.rightEdge = plotPx + (labelWidth / 2);

                                    labelSize.h = mathMax(labelSize.h, textObj.height);
                                }
                            }

                            // After setting the grid labels we expand the category labels to occupying
                            // upto upperThreshold width.
                            nextGrid = null, prevGrid = null;
                            for (i = 0, length = gridLinesArr.length; i < length; i += 1) {

                                gridLineObj = gridLinesArr[i];
                                plotObj = gridLineObj.plotObj;
                                lineIndex = i % staggerLines;

                                if (plotObj.isCat && gridLineObj.labelTextWidth) {
                                    nextGrid = null, prevGrid = null;
                                    plotPx = plotObj.value * unitWidth;
                                    // get the previous visible label
                                    if (i >= staggerLines) {
                                        prevIdx = i - staggerLines;
                                        prevGrid = gridLinesArr[prevIdx];
                                        while (!prevGrid.labelTextWidth) {
                                            if (prevIdx > staggerLines) {
                                                prevIdx -= staggerLines;
                                                prevGrid = gridLinesArr[prevIdx];
                                            } else {
                                                prevGrid = null;
                                                break;
                                            }
                                        }
                                    }

                                    if (prevGrid) {
                                        leftSpace = plotPx - prevGrid.rightEdge;
                                    } else {
                                        leftSpace = plotPx - (axisObj.min * unitWidth) + hcJSON.chart.marginLeft;
                                    }

                                    // get the next visible label
                                    if ((i + staggerLines) < length) {
                                        nextIdx = i + staggerLines;
                                        nextGrid = gridLinesArr[nextIdx];
                                        while (!nextGrid.labelTextWidth) {
                                            if ((nextIdx + staggerLines) < (length - 1)) {
                                                nextIdx += staggerLines;
                                                nextGrid = gridLinesArr[nextIdx];
                                            } else {
                                                nextGrid = null;
                                                break;
                                            }
                                        }
                                    }

                                    if (nextGrid) {
                                        rightSpace = nextGrid.leftEdge - plotPx;
                                    } else {
                                        rightSpace = (axisObj.max * unitWidth) + hcJSON.chart.marginRight - plotPx;
                                    }


                                    labelWidth = mathMin(leftSpace, rightSpace) * 2;

                                    if (labelWidth > upperThreshold) {
                                        labelWidth = upperThreshold;
                                    }

                                    if (labelWidth > gridLineObj.oriWidth) {
                                        labelWidth = gridLineObj.oriWidth;
                                    }

                                    gridLineObj.labelTextWidth = labelWidth;

                                    labelObj = plotObj.label;
                                    if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                        SmartLabel.setStyle(labelObj.style);
                                    }

                                    textObj = SmartLabel.getSmartText(labelObj.text, labelWidth - labelTextPadding,
                                        maxHeight, noWrap);
                                    gridLineObj.labelTextWidth = textObj.width + labelTextPadding;
                                    labelSize.h = mathMax(labelSize.h, textObj.height);

                                    gridLineObj.rightEdge = plotPx + (gridLineObj.labelTextWidth / 2);
                                }
                            }
                        }

                    // setting the widths of non grid labels.
                    } else if (rotation) {
                        for (i = 0, length = gridLinesArr.length; i < length; i += 1) {
                            plotObj = gridLinesArr[i].plotObj;
                            if (plotObj && plotObj.label && plotObj.label.text) {
                                labelObj = plotObj.label;
                                if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                    lastUsedStyle = labelObj.style;
                                    SmartLabel.setStyle(lastUsedStyle);
                                }
                                index = 1;
                                if ((i + index) < length) {
                                    nextPlot = gridLinesArr[index + i].plotObj;
                                    while (nextPlot && ((nextPlot.value - plotObj.value) * unitWidth) < minWidth) {
                                        if (plotObj.isCat) {
                                            if (nextPlot.label) {
                                                nextPlot.label.text = BLANKSTRING;
                                                index += 1;
                                                if ((index + i) >= (length - 1)) {
                                                    break;
                                                }
                                                nextPlot = plotLinesArr[index + i].plotObj;
                                            }
                                        } else if (nextPlot.isCat) {
                                            plotObj.label.text = BLANKSTRING;
                                            plotObj = nextPlot;
                                            i += (index - 1);
                                            labelObj = plotObj.label;
                                            //if the style not implemented then implement it
                                            if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                                lastUsedStyle = labelObj.style;
                                                SmartLabel.setStyle(lastUsedStyle);
                                            }
                                            break;
                                        }
                                    }
                                }
                                labelSize.w = mathMax(labelSize.w, (SmartLabel.getOriSize(labelObj.text).width +
                                    labelTextPadding));
                            }
                        }
                    }
                }

                for (index = 0, length = nonGridLinesArr.length; index < length; index += 1) {

                    plotObj = nonGridLinesArr[index].plotObj;

                    if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                        labelObj = plotObj.label;
                        //if the style not implemented then implement it
                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                            lastUsedStyle = labelObj.style;
                            SmartLabel.setStyle(lastUsedStyle);
                        }

                        textObj = SmartLabel.getOriSize(labelObj.text);
                        if (labelObj.verticalAlign === POSITION_BOTTOM) {
                            tedendHeight = mathMax(tedendHeight, textObj.height);
                        } else {
                            oppTrendHeight = mathMax(oppTrendHeight, textObj.height);
                        }
                    }
                }
            }

            //now calculate the required space height
            if (isNone) {
                labelSpace = labelHeight;
                if (rotation) { // special rotation when labelDisplay=='none'
                    labelSpace = labelSize.w;
                }
            }
            else if (rotation) {
                labelSpace = labelSize.w;
            } else if (isStagger){
                labelSpace = staggerLines * labelSize.h;
            } else {
                labelSpace = labelSize.h;
            }

            if (labelSpace > 0) {
                // If total space acquired by x-axis label is more that maxLabelHeight
                // the reduce it to maxLabelHeight
                if ((labelSpace + labelPadding) >  maxLabelHeight) {
                    labelSpace = maxLabelHeight - labelPadding;
                    // For of staggered label reduce the no of stagger line
                    staggerLines = Math.floor(labelSpace / labelSize.h);
                }
                bottomSpace += labelPadding + labelSpace;
            }

            if (titleHeightUsed > 0) {
                bottomSpace += titleHeightUsed + xAxisNamePadding;
            }

            reducePadding = (labelPadding - 4), // the padding shud not go below 4px
            totalSpace = oppTrendHeight + bottomSpace + 2; /** @todo 2 has to be changed to borderthickness */

            temp = 0;

            /// Reduce the element size if required
            if (totalSpace > maxHeight) {
                difference = totalSpace - maxHeight;
                if (xAxisNamePadding > difference) {
                    xAxisNamePadding -= difference;
                    difference = 0;
                } else {
                    difference -= xAxisNamePadding;
                    xAxisNamePadding = 0;
                    if (reducePadding > difference) {
                        reducePadding -= difference;
                        difference = 0;
                    } else {
                        difference -= reducePadding;
                        reducePadding = 0;
                    }
                    labelPadding = reducePadding + 4;
                }

                // reduce the opposite side text or canvas text
                if (oppTrendHeight > difference) {
                    oppTrendHeight -= difference;
                    difference = 0;
                } else {
                    if (oppTrendHeight > 0) {
                        difference -= oppTrendHeight;
                        oppTrendHeight = 0;
                    }
                    if (difference > 0) {
                        if (tedendHeight > difference) {
                            tedendHeight -= difference;
                            difference = 0;
                        }
                        else {
                            if (tedendHeight > 0) {
                                difference -= tedendHeight;
                                tedendHeight = 0;
                            }
                            if (difference > 0) {
                                if ((temp = titleHeightUsed - nameLineHeight) > difference) {
                                    titleHeightUsed -= difference;
                                    difference = 0;
                                }
                                else {
                                    difference -= temp;
                                    titleHeightUsed = nameLineHeight;
                                    if (difference > 0) {
                                        if ((temp = labelSpace - labelHeight) > difference) {
                                            labelSpace -= difference;
                                            difference = 0;
                                        }
                                        else {
                                            difference -= temp;
                                            labelSpace = labelHeight;
                                            if (difference > 0) {
                                                difference -= titleHeightUsed + xAxisNamePadding;
                                                titleHeightUsed = 0;
                                                if (difference > 0) {
                                                    difference -= labelSpace;
                                                    labelSpace = 0;
                                                    if (difference > 0) {
                                                        labelPadding -= difference;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Place the elements
            //add extraspace if any
            labelPadding += marginBottomExtraSpace;

            labelX = conf.is3d ? - hcJSON.chart.xDepth : 0;
            trendTextY = labelSpace + labelPadding;
            xShipment = labelX;
            adjustedPx = labelHeight * 0.5;
            labelY = labelHeight + labelPadding;
            length = gridLinesArr.length;
            catCount = 0;

            if (!isXYPlot) {
                if (rotation) {
                    perLabelH = perCatWidth;
                    perLabelW = labelSpace - labelTextPadding;
                    textAlign = POSITION_RIGHT;
                    if (slantLabels) {
                        // in case of slant labels an extra charaters width has to be added to the yShipment
                        yShipment = labelPadding + 8;
                    } else {
                        yShipment = labelPadding + 4;//4px to looks poper like FC as there has a padding
                    }
                }
                else if (isStagger) {
                    // perLabelH = labelHeight;
                    perLabelW = perCatWidth - labelTextPadding;
                    textAlign = POSITION_CENTER;

                }
                else {
                    perLabelH = labelSpace;
                    perLabelW = perCatWidth - labelTextPadding;
                    //xShipment += 0;
                    textAlign = POSITION_CENTER;
                    yShipment = labelY;//4px to looks poper like FC as there has a padding
                }

                for(index = 0; index < length; index += stepValue) {
                    plotObj = gridLinesArr[index];
                    labelHeight = mathCeil(parseFloat(plotObj.label.style.lineHeight));
                    adjustedPx = labelHeight * 0.5;
                    labelY = labelHeight + labelPadding;
                    if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                        labelObj = plotObj.label;
                        //if the style not implemented then implement it
                        if (labelObj.style && labelObj.style !== lastUsedStyle) {
                            lastUsedStyle = labelObj.style;
                            SmartLabel.setStyle(lastUsedStyle);
                        }

                        if (!isNone) {
                            if (isStagger) {
                                perLabelH = labelHeight;
                            }
                            textObj = SmartLabel.getSmartText(labelObj.text, perLabelW, perLabelH, noWrap);
                            labelObj.text = textObj.text;
                            textObj.tooltext && (labelObj.originalText = textObj.tooltext);

                            if (isStagger) {
                                yShipment = labelY + ((catCount % staggerLines) * labelHeight);
                            }
                        }
                        if (rotation) {
                            //px adjustment to looks same as FC
                            xShipment = labelX + (labelHeight * 0.5);
                        } else if (!isStagger) {
                            // Need to recalculate the y position separately for each label
                            // in order to support individual font cosmetics
                            yShipment = labelHeight + labelPadding;
                        }
                        labelObj.y = yShipment;
                        labelObj.x = xShipment;
                        labelObj.rotation = rotation;
                        labelObj.textAlign = textAlign;
                        catCount += 1;
                    }
                }

                //if realtime store few conf for latter use
                axisConf._labelY = labelY;
                axisConf._labelX = labelX;
                axisConf._yShipment = yShipment;
                axisConf._isStagger = isStagger;
                axisConf._rotation = rotation;
                axisConf._textAlign = textAlign;
                axisConf._adjustedPx = adjustedPx;
                axisConf._staggerLines = staggerLines;
                axisConf._labelHeight = labelHeight;

            }
            else {
                // for scatter and bar charts
                if (rotation) {

                    textAlign = POSITION_RIGHT;
                    if (slantLabels) {
                        // in case of slant labels an extra charaters width has to be added to the yShipment
                        yShipment = labelPadding + 8;
                    } else {
                        yShipment = labelPadding + 4;//4px to looks poper like FC as there has a padding
                    }

                    length = gridLinesArr.length;
                    for(index = 0; index < length; index += 1) {
                        plotObj = gridLinesArr[index].plotObj;
                        if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                            labelObj = plotObj.label;
                            //if the style not implemented then implement it
                            if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                lastUsedStyle = labelObj.style;
                                SmartLabel.setStyle(lastUsedStyle);
                            }

                            i = 1;
                            textObj = SmartLabel.getSmartText(labelObj.text, labelSpace - 4, minWidth, noWrap);
                            labelObj.text = textObj.text;
                            textObj.tooltext && (labelObj.originalText = textObj.tooltext);

                            //px adjustment to looks same as FC
                            xShipment = labelX + (adjustedPx / 2);

                            labelObj.y = yShipment;
                            labelObj.x = xShipment;
                            labelObj.rotation = rotation;
                            labelObj.textAlign = textAlign;
                            catCount += 1;
                        }
                    }
                } else {
                    perLabelH = labelSpace;
                    textAlign = POSITION_CENTER;
                    yShipment = labelY;

                    for(index = 0; index < length; index += stepValue) {
                        plotObj = gridLinesArr[index].plotObj;
                        labelHeight = pInt(plotObj.label.style.lineHeight);
                        if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                            labelObj = plotObj.label;
                            //if the style not implemented then implement it
                            if (labelObj.style && labelObj.style !== lastUsedStyle) {
                                lastUsedStyle = labelObj.style;
                                SmartLabel.setStyle(lastUsedStyle);
                            }

                            if (!isNone) {
                                textObj = SmartLabel.getSmartText(labelObj.text, gridLinesArr[index].labelTextWidth - 4,
                                    perLabelH, noWrap);
                                labelObj.text = textObj.text;
                                textObj.tooltext && (labelObj.originalText = textObj.tooltext);

                                if (isStagger) {
                                    yShipment = labelY + ((catCount % staggerLines) * labelHeight);
                                }
                            }
                            labelObj.y = yShipment;
                            labelObj.x = xShipment;
                            labelObj.rotation = rotation;
                            labelObj.textAlign = textAlign;
                            catCount += 1;
                        }
                    }
                }
            }

            length = nonGridLinesArr.length;
            aoppTrendHeight = 0;
            atedendHeight = 0;
            for(index = 0; index < length; index += 1) {
                plotObj = nonGridLinesArr[index].plotObj ? nonGridLinesArr[index].plotObj : nonGridLinesArr[index];
                if (plotObj && plotObj.label && getValidValue(plotObj.label.text) !== undefined) {

                    labelObj = plotObj.label;
                    //if the style not implemented then implement it
                    if (labelObj.style && labelObj.style !== lastUsedStyle) {
                        lastUsedStyle = labelObj.style;
                        SmartLabel.setStyle(lastUsedStyle);
                    }
                    if (labelObj.verticalAlign === POSITION_BOTTOM) {
                        textObj = SmartLabel.getSmartText(labelObj.text, width, tedendHeight, true);
                        atedendHeight = mathMax(atedendHeight, textObj.height);
                        labelObj.text = textObj.text;
                        textObj.tooltext && (labelObj.originalText = textObj.tooltext);

                        labelObj.y = trendTextY + SmartLabel.getOriSize(labelObj.text).height;
                        labelObj.x = xShipment;
                    } else {
                        textObj = SmartLabel.getSmartText(labelObj.text, width, oppTrendHeight, true);
                        aoppTrendHeight = mathMax(aoppTrendHeight, textObj.height);
                        labelObj.text = textObj.text;
                        textObj.tooltext && (labelObj.originalText = textObj.tooltext);
                        /** @todo 2 has to be changed to borderthickness */
                        labelObj.y = - ((oppTrendHeight - SmartLabel.getOriSize(testStr).height) + labelPadding + 2);
                    }
                }
            }

            if (titleHeightUsed > 0) {
                SmartLabel.setStyle(axisObj.title.style);
                //now get the title space
                titleText = SmartLabel.getSmartText(axisObj.title.text, width, titleHeightUsed);
                axisObj.title.text = titleText.text;
                titleText.tooltext && (axisObj.title.originalText = titleText.tooltext);

                axisObj.title.margin = trendTextY + atedendHeight + xAxisNamePadding;
            }

            bottomSpace = atedendHeight;

            if (labelSpace > 0) {
                conf.horizontalAxisHeight = labelPadding + labelSpace - marginBottomExtraSpace;
                bottomSpace += conf.horizontalAxisHeight;
            }

            if (titleHeightUsed > 0) {
                bottomSpace += titleHeight = titleHeightUsed + xAxisNamePadding;
            }
            //In case of label less axis add axisLine/border thickness as bottomSpace
            bottomSpace = bottomSpace || (labelPadding - marginBottomExtraSpace);
            hcJSON.chart.marginBottom += bottomSpace;

            if (aoppTrendHeight > 0) {
                hcJSON.chart.marginTop += aoppTrendHeight;
                bottomSpace += aoppTrendHeight;
            }

            if (axisObj.opposite) {
                // Fix for xAxis name showing always at bottom
                axisObj.title.margin -= labelSpace -
                        (titleText && titleText.height || 0) + labelPadding;
                bottomSpace -= titleHeight;

                hcJSON.chart.marginTop += bottomSpace;
                hcJSON.chart.marginBottom -= bottomSpace;
                hcJSON.xAxis.opposite = 1;
                for (length = plotLinesArr.length, i = 0; i < length; i += 1) {
                    plotObj = plotLinesArr[i];
                    if (plotObj && plotObj.isGrid && (labelObj = plotObj.label) &&
                            labelObj.text !== undefined) {
                        labelObj.textAlign = POSITION_LEFT;
                        labelObj.y -= yShipment + labelPadding + 4;
                    }
                }
            }
            return bottomSpace;
        },

        configureLegendOptions = lib.configureLegendOptions = function (hcJSON, fcJSONChartObj, isONRight,
            isPointItem, availableWidth) {

            var legendObj = hcJSON.legend,
                hcJSONChart = hcJSON.chart,
                is3d = hcJSONChart.is3D,
                borderColor,
                palleteString = is3d ? chartPaletteStr.chart3D : chartPaletteStr.chart2D,
                interactiveLegend,
                borderAlpha,
                backgroundAlpha,
                roundEdges = hcJSONChart.useRoundEdges,
                padding = 4,
                legendHeight,
                padding2 = 2 * padding,
                legendScale = pluckNumber(fcJSONChartObj.legendiconscale, 1),
                frontHeight = parseInt(legendObj.itemStyle.fontSize, 10) || 10,
                symbolWidthSpace = frontHeight + 1,
                colorM = this.colorManager,
                symbolPadding = 3;

            if (legendScale <= 0 || legendScale > 5) {
                legendScale = 1;
            }

            legendObj.padding = padding;

            if (symbolWidthSpace <= 0) {
                symbolWidthSpace = 1;
            }
            availableWidth -= padding2;

            symbolWidthSpace *= legendScale;
            symbolPadding *= legendScale;
            symbolWidthSpace = mathMin(symbolWidthSpace, availableWidth);

            if (symbolWidthSpace <= 0) {
                symbolPadding = symbolWidthSpace = 0;
            }
            legendObj.symbolWidth = symbolWidthSpace;

            legendObj.symbolPadding = symbolPadding;
            legendObj.textPadding = 4;
            legendObj.legendHeight = legendHeight = symbolWidthSpace + (2 * symbolPadding);
            legendObj.rowHeight = mathMax(parseInt(legendObj.itemStyle.lineHeight, 10) || 12, legendHeight);

            if (isONRight) {//else pert is the default options
                //basic configuration for the legend box to show in right
                legendObj.align = POSITION_RIGHT;
                legendObj.verticalAlign = 'middle';
                legendObj.layout = 'vertical';
            }
            else {
                legendObj.x = (hcJSONChart.marginLeft - hcJSONChart.spacingLeft -
                    hcJSONChart.marginRight + hcJSONChart.spacingRight) / 2;
            }


            borderColor = pluck(fcJSONChartObj.legendbordercolor,
                colorM.getColor(palleteString.legendBorderColor));
            borderAlpha = pluckNumber(fcJSONChartObj.legendborderalpha, 100);
            backgroundAlpha = pluckNumber(fcJSONChartObj.legendbgalpha, 100);

            legendObj.backgroundColor  = convertColor(pluck(fcJSONChartObj.legendbgcolor,
                colorM.getColor(palleteString.legendBgColor)),
            backgroundAlpha);

            legendObj.borderColor = convertColor(borderColor, borderAlpha);
            legendObj.borderWidth = pluckNumber(fcJSONChartObj.legendborderthickness,
                !roundEdges || fcJSONChartObj.legendbordercolor ? 1 : 0);
            legendObj.shadow = Boolean(pluckNumber(fcJSONChartObj.legendshadow, 1));
            legendObj.symbol3DLighting = Boolean(pluckNumber(fcJSONChartObj.use3dlighting,
                fcJSONChartObj.useplotgradientcolor, 1));
            if (legendObj.shadow) {
                legendObj.shadow = {
                    enabled: legendObj.shadow,
                    opacity: mathMax(borderAlpha, backgroundAlpha) / 100
                };
            }
            legendObj.reversed = Boolean(pluckNumber(fcJSONChartObj.reverselegend, 0) -
                pluckNumber(this.reverseLegend, 0));
            legendObj.style = {
                padding : padding
            };

            interactiveLegend = Boolean(pluckNumber(fcJSONChartObj.interactivelegend, 1));
            if (!interactiveLegend) {
                hcJSON.legend.interactiveLegend = false;
                legendObj.itemStyle.cursor = 'default';
                legendObj.itemHoverStyle = {
                    cursor : 'inherit'
                };
            }
            else {
                legendObj.symbolStyle = {
                    '_cursor': 'hand',
                    'cursor': 'pointer'
                };
            }

            legendObj.borderRadius = pluckNumber(fcJSONChartObj.legendborderradius,
                roundEdges ? 3 : 0);

            //extra attr on hc JSON added for fc attr support
            legendObj.legendAllowDrag = Boolean(pluckNumber(fcJSONChartObj.legendallowdrag, 0));
            legendObj.title.text = parseUnsafeString(getFirstValue(fcJSONChartObj.legendcaption, BLANKSTRING));
            legendObj.legendScrollBgColor = getFirstColor(pluck(fcJSONChartObj.legendscrollbgcolor,
                fcJSONChartObj.scrollcolor, colorM.getColor('altHGridColor')));
            legendObj.legendScrollBarColor = pluck(fcJSONChartObj.legendscrollbarcolor, borderColor);
            legendObj.legendScrollBtnColor = pluck(fcJSONChartObj.legendscrollbtncolor, borderColor);


        },

        /**
         *  Used to compute the space required to place the legend block when the
         *  legend block display is turned on.
         *
         *  @param hcJSON {object}, is the JSON that is to be
         *
         */
        //Note: no text are allowed to be more in height then allowed (availableHeight) then there will be ellipses
        placeLegendBlockRight = lib.placeLegendBlockRight = function (hcJSON, fcJSON,
            availableWidth, availableHeight, isPointItem) {

            // configure LegendOptions
            this.configureLegendOptions(hcJSON, fcJSON.chart, true, isPointItem, availableWidth);

            var iapi = this,
                snapLiterals = iapi.snapLiterals || (iapi.snapLiterals = {}),
                i = 0, legendData = hcJSON.series, len, item,
                conf = hcJSON[FC_CONFIG_STRING],
                SmartLabel = iapi.smartLabel || conf.smartLabel,
                chartObj = hcJSON.chart,
                spacingRight = chartObj.spacingRight,
                legendObj =  hcJSON.legend,  smartText, textWidth,
                textPadding = legendObj.textPadding,
                captionPadding = legendObj.title.padding,
                captionWidth,
                symbolWidthSpace = legendObj.symbolWidth,
                symbolPadding = legendObj.symbolPadding,//6 px legend symbol fixed padding
                legendHeight = symbolWidthSpace + (2 * symbolPadding),
                allowedMaxHeight = availableHeight * 2,
                textWidthUsed = 0,
                legendPadding = pluckNumber(fcJSON.chart.legendpadding, 7),
                usedWidth = legendPadding + (legendObj.borderWidth / 2) +
                    pluckNumber(fcJSON.chart.canvasborderthickness, 1),
                padding = legendObj.padding,
                padding2 = 2 * padding,
                blockDimensions = {
                    width: padding2,
                    height: padding2
                },
                validLegendItem = false,
                itemArr = [],
                lItem;

            availableWidth -= padding2 + legendPadding;//5 pixel padding from canvas border

            if (isPointItem) {
                legendData = legendData && legendData[0] && legendData[0].data;
            }

            //return incase of no series
            if (typeof legendData === STRINGUNDEFINED || typeof legendData.length === STRINGUNDEFINED) {
                return 0;
            } else {
                len = legendData.length;
                for (i = 0; i < len; i += 1) {
                    lItem = legendData[i];
                    if (lItem && lItem.showInLegend !== false) {
                        //add temp index so that we can sort properly
                        lItem.__i = i;
                        itemArr.push(lItem);
                    }
                }
                itemArr.sort(function (a, b) {
                    return (a.legendIndex - b.legendIndex) || (a.__i - b.__i);
                });
                len = itemArr.length;
            }

            textWidth = availableWidth - legendHeight - legendPadding - textPadding;
            if (textWidth < 0) {
                textWidth = 0;
            }

            //blockDimensions.width = mathMax(legendHeight, blockDimensions.width);
            SmartLabel.setStyle(legendObj.itemStyle);
            if (legendObj.reversed) {
                itemArr.reverse();
            }
            for (i = 0; i < len; i += 1) {
                item = itemArr[i];
                validLegendItem = true;
                item._legendX = 0;
                item._legendY = blockDimensions.height;
                if (textWidth === 0) {
                    blockDimensions.height += (item._legendH = legendHeight);
                    item.name = BLANKSTRING;
                    item._totalWidth = symbolWidthSpace + symbolPadding;
                }
                else {
                    smartText = SmartLabel.getSmartText(item.name, textWidth, allowedMaxHeight);
                    item.name = smartText.text;
                    smartText.tooltext && (item.originalText = smartText.tooltext);
                    if (smartText.height < legendHeight) {
                        item._legendTestY = (legendHeight - smartText.height) / 2;
                    }
                    item._totalWidth = symbolWidthSpace + symbolPadding + textPadding + smartText.width + legendPadding;
                    blockDimensions.height += (item._legendH = mathMax(smartText.height, legendHeight));
                    textWidthUsed = mathMax(smartText.width, textWidthUsed);
                }
            }

            if (validLegendItem) {
                legendObj.itemWidth = textWidthUsed  + legendHeight + legendPadding + textPadding;
                legendObj.width = legendObj.itemWidth + padding2;
                if (legendObj.title.text !== BLANKSTRING) {
                    SmartLabel.setStyle(legendObj.title.style);
                    smartText = SmartLabel.getSmartText(legendObj.title.text, availableWidth, allowedMaxHeight);
                    legendObj.title.text = smartText.text;
                    smartText.tooltext && (legendObj.title.originalText = smartText.tooltext);

                    captionWidth = smartText.width + padding2;

                    //if the caption width has gretter width
                    if (legendObj.width < captionWidth) {
                        legendObj.initialItemX = (captionWidth - legendObj.width) / 2;
                        legendObj.width = captionWidth;
                    }
                    legendObj.initialItemY = smartText.height + captionPadding;
                    blockDimensions.height += legendObj.initialItemY ;
                }

                legendObj.height = legendObj.totalHeight = blockDimensions.height;

                if (legendObj.height > availableHeight) {
                    legendObj.height = availableHeight;
                    legendObj.scroll.enabled = true;
                    legendObj.scroll.flatScrollBars = conf.flatScrollBars;
                    legendObj.scroll.scrollBar3DLighting = conf.scrollBar3DLighting;
                    legendObj.width += (legendObj.scroll.scrollBarWidth = 10) + (legendObj.scroll.scrollBarPadding = 2);
                }

                //add anotation macro
                snapLiterals.legendstartx = conf.width - spacingRight - legendObj.width;
                snapLiterals.legendwidth = legendObj.width;
                snapLiterals.legendendx = snapLiterals.legendstartx + snapLiterals.legendwidth;
                snapLiterals.legendheight = legendObj.height;

                usedWidth = mathMin(legendObj.width + usedWidth, availableWidth);
                hcJSON.chart.marginRight += usedWidth + legendPadding;
                return usedWidth;
            }
            else {
                legendObj.enabled = false;
                return 0;
            }
        },

        //Note: no text are allowed to be more in height then 2 * allowed (availableHeight) then there will be ellipses
        placeLegendBlockBottom = lib.placeLegendBlockBottom = function (hcJSON, fcJSON,
            availableWidth, availableHeight, isPointItem) {

            //configure LegendOptions
            this.configureLegendOptions(hcJSON, fcJSON.chart, false, isPointItem, availableWidth);


            var iapi = this,
            snapLiterals = iapi.snapLiterals || (iapi.snapLiterals = {}),
            i = 0, legendData = hcJSON.series, len, item,
            conf = hcJSON[FC_CONFIG_STRING],
            SmartLabel = conf.smartLabel || iapi.smartLabel,
            chartObj = hcJSON.chart,
            spacingBottom = chartObj.spacingBottom,
            spacingLeft = chartObj.spacingLeft,
            spacingRight = chartObj.spacingRight,
            legendObj =  hcJSON.legend,  smartText, textWidth,
            textPadding = legendObj.textPadding,
            captionPadding = legendObj.title.padding,
            captionWidth,
            symbolWidthSpace = legendObj.symbolWidth,
            symbolPadding = legendObj.symbolPadding,//6 px legend symbol fixed padding
            legendHeight = legendObj.legendHeight,
            fcJSONChart = fcJSON.chart,
            legendCaptionHeight = 0,
            allowedMaxHeight = availableHeight * 2,
            rowHeight = legendObj.rowHeight,
            legendPadding = rowHeight * 0.05,
            tempTableStructure = [],
            minimiseWrappingInLegend = pluckNumber(fcJSONChart.minimisewrappinginlegend, 0),
            legendNumColumns = pluckNumber(parseInt(fcJSONChart.legendnumcolumns, 10), 0),
            maxWidth = 0, totalWidth = 0, totalNumber = 0, averageWidth = 0, perItemWidth = 0,
            padding = legendObj.padding,
            padding2 = 2 * padding,
            nonItemWidth = textPadding + symbolPadding + padding,
            usedHeight = pluckNumber(fcJSON.chart.legendpadding, 7) +
                    (legendObj.borderWidth / 2) + 1,
            blockDimensions = {
                width: padding2,
                height: padding2
            },
            validLegendItem = false,
            lItem,
            itemArr = [],
            rowIndex,
            singleRowLegend = false,
            current = 0,
            legendX = 0,
            colIndex,
            numRows, numberOfCell, j, tempCurrent, nonTextElemWidth,
            legendLineHeight;

            if (legendNumColumns < 0) {
                legendNumColumns = 0;
            }

            availableWidth -= padding2;//deduct the legend Box padding 2 * 6Px

            SmartLabel.setStyle(legendObj.itemStyle);
            legendLineHeight = SmartLabel.getOriSize(TESTSTR).height;
            // 8px padding for the legend text.
            usedHeight = mathMin(usedHeight, availableHeight - legendLineHeight - 8);
            availableHeight -= usedHeight;

            if (isPointItem) {
                legendData = legendData && legendData[0] && legendData[0].data;
            }

            //return incase of no series
            if (typeof legendData === STRINGUNDEFINED || typeof legendData.length === STRINGUNDEFINED) {
                return 0;
            } else {
                len = legendData.length;
                for (i = 0; i < len; i += 1) {
                    lItem = legendData[i];
                    if (lItem && lItem.showInLegend !== false) {
                        //add temp index so that we can sort properly
                        lItem.__i = i;
                        itemArr.push(lItem);
                    }
                }
                itemArr.sort(function (a, b) {
                    return (a.legendIndex - b.legendIndex) || (a.__i - b.__i);
                });
                len = itemArr.length;
            }


            //set the legend text style
            SmartLabel.setStyle(legendObj.itemStyle);
            //retrive average and total width
            for (i = 0;i < len; i += 1) {
                validLegendItem = true;
                smartText = SmartLabel.getOriSize(itemArr[i].name);
                maxWidth = mathMax(maxWidth, smartText.width);
                totalWidth += smartText.width;
                totalNumber += 1;
            }
            averageWidth = totalWidth / totalNumber;
            nonTextElemWidth = legendHeight + legendPadding + textPadding + symbolPadding + padding2;
            totalWidth += (nonTextElemWidth * totalNumber);

            if (validLegendItem) {
                averageWidth += nonTextElemWidth;
                maxWidth += nonTextElemWidth;

                if (legendNumColumns > 0 && totalNumber < legendNumColumns) {
                    legendNumColumns = totalNumber;
                }
                //if there has space to show all legends in one column
                if (totalWidth <= availableWidth && (legendNumColumns <=0 || legendNumColumns === totalNumber)) {
                    legendNumColumns = totalNumber;
                    perItemWidth = averageWidth = totalWidth / totalNumber;
                    singleRowLegend = true;
                }
                //if valid numcolumn[there has enough item for legendNumColumns, every item getting minimum space]
                else if (legendNumColumns > 0 && (perItemWidth = availableWidth / legendNumColumns) > averageWidth) {
                    if(perItemWidth > maxWidth){
                        perItemWidth = maxWidth;
                    }
                }
                //try to minimize wrapping
                else if (availableWidth > maxWidth && (minimiseWrappingInLegend || averageWidth * 1.5 > maxWidth)) {
                    legendNumColumns = mathFloor(availableWidth / maxWidth);
                    if (totalNumber < legendNumColumns) {
                        legendNumColumns = totalNumber;
                    }
                    perItemWidth = maxWidth;

                }
                //there has space for atlest 2 column
                else if(availableWidth >= 2 * averageWidth){
                    //The number of columns each of width as the averageWidth
                    legendNumColumns = mathFloor(availableWidth / averageWidth);

                    if (totalNumber < legendNumColumns) {
                        legendNumColumns = totalNumber;
                    }


                    //Provide best width space, which is greater than average width, generally (for numColumns is found
                    //above via mathFloor())
                    perItemWidth = mathFloor(availableWidth / legendNumColumns);

                    if (perItemWidth > maxWidth){
                        perItemWidth = maxWidth;
                    }
                }
                //else only 1 column per row
                else {
                    legendNumColumns = 1;
                    perItemWidth = availableWidth;
                }


                legendObj.itemWidth = perItemWidth;

                textWidth = perItemWidth - nonTextElemWidth;
                if (textWidth < 0) {
                    symbolPadding = textWidth = textPadding = 0;
                }
                legendObj.symbolPadding = symbolPadding;
                legendObj.textPadding = textPadding;


                legendObj.width = (perItemWidth * legendNumColumns) - legendPadding;

                if (legendObj.title.text !== BLANKSTRING) {
                    SmartLabel.setStyle(legendObj.title.style);
                    smartText = SmartLabel.getSmartText(legendObj.title.text, availableWidth, allowedMaxHeight);
                    legendObj.title.text = smartText.text;
                    smartText.tooltext && (legendObj.title.originalText = smartText.tooltext);

                    captionWidth = smartText.width + padding2;
                    //if the caption width has gretter width
                    if (legendObj.width < captionWidth) {
                        legendObj.initialItemX = (captionWidth - legendObj.width) / 2;
                        legendObj.width = captionWidth;
                    }
                    legendObj.initialItemY = legendCaptionHeight = smartText.height + captionPadding ;
                }

                SmartLabel.setStyle(legendObj.itemStyle);


                if (legendObj.reversed) {
                    itemArr.reverse();
                }

                //blockDimensions.width = mathMax(legendHeight, blockDimensions.width);
                for (i = 0 ;i < len; i += 1) {
                    item = itemArr[i];
                    if (textWidth === 0) {
                        tempTableStructure[current] = true;
                        item.name = BLANKSTRING;
                        j = 1;
                        rowIndex = parseInt(current / legendNumColumns, 10);
                        colIndex = current % legendNumColumns;
                        item._legendX = colIndex * perItemWidth;
                        item._legendY = (rowIndex * rowHeight) + padding2;
                        item._legendH = j * rowHeight;
                        item._totalWidth = symbolWidthSpace + symbolPadding;
                    }
                    if (singleRowLegend) {
                        smartText = SmartLabel.getOriSize(item.name);
                        if (smartText.height < rowHeight) {
                            item._legendTestY = (rowHeight - smartText.height) / 2;
                        }
                        item._legendX = legendX;
                        item._legendY = padding2;
                        item._legendH = rowHeight;
                        item._totalWidth = symbolWidthSpace + nonItemWidth + smartText.width;
                        legendX += smartText.width + nonTextElemWidth;
                    }
                    else {
                        smartText = SmartLabel.getSmartText(item.name, textWidth, allowedMaxHeight);
                        item.name = smartText.text;
                        smartText.tooltext && (item.originalText = smartText.tooltext);

                        while (tempTableStructure[current] === true) {
                            current += 1;
                        }
                        numberOfCell = smartText.height / rowHeight;
                        tempCurrent = current;
                        for (j = 0; j < numberOfCell; j += 1, tempCurrent += legendNumColumns) {
                            tempTableStructure[tempCurrent] = true;
                        }
                        if (smartText.height < rowHeight) {
                            item._legendTestY = (rowHeight - smartText.height) / 2;
                        }

                        rowIndex = parseInt(current / legendNumColumns, 10);
                        colIndex = current % legendNumColumns;
                        item._legendX = colIndex * perItemWidth;
                        item._legendY = (rowIndex * rowHeight) + padding2;
                        item._legendH = j * rowHeight;
                        item._totalWidth = symbolWidthSpace + nonItemWidth + smartText.width;
                    }
                    current += 1;
                }

                numRows = singleRowLegend ? 1 : mathCeil(tempTableStructure.length / legendNumColumns);
                blockDimensions.height += (numRows * rowHeight) + legendCaptionHeight;
                legendObj.height = legendObj.totalHeight = blockDimensions.height;
                legendObj.rowHeight = rowHeight;
                legendObj.legendNumColumns = legendNumColumns;

                if (legendObj.height > availableHeight) { // for padding
                    legendObj.height = availableHeight;
                    legendObj.scroll.enabled = true;
                    legendObj.scroll.flatScrollBars = conf.flatScrollBars;
                    legendObj.scroll.scrollBar3DLighting = conf.scrollBar3DLighting;
                    legendObj.width += (legendObj.scroll.scrollBarWidth = 10) + (legendObj.scroll.scrollBarPadding = 2);
                }
                //add anotation macro
                snapLiterals.legendstartx = spacingLeft + ((conf.width - spacingLeft - spacingRight -
                        legendObj.width) * 0.5) + (legendObj.x || 0);
                snapLiterals.legendwidth = legendObj.width;
                snapLiterals.legendendx = snapLiterals.legendstartx  + snapLiterals.legendwidth;
                snapLiterals.legendstarty = conf.height - spacingBottom - legendObj.height;
                snapLiterals.legendheight = legendObj.height;
                snapLiterals.legendendy = snapLiterals.legendstarty  + snapLiterals.legendheight;

                usedHeight += legendObj.height;
                hcJSON.chart.marginBottom += usedHeight;
                return usedHeight;
            }
            else {//in case of no visible item disable legend
                legendObj.enabled = false;
                return 0;
            }
        },

        /*
         *This Function set the x axis min max to prodice space for canvasPadding
         */
        plotLineSortFN = function(a, b) {
            return a.value - b.value;
        },

        realignVerticalAxisTitle = function (hcJSON, titleObj, maxHeight) {

            var titleText = titleObj._originalText,
                conf = hcJSON[FC_CONFIG_STRING],
                SmartLabel = conf.smartLabel;
            if (!titleObj.rotation) {
                titleObj.text = SmartLabel.getSmartText(titleText, titleObj._actualWidth, maxHeight).text;
            }
            else {
                titleObj.text = SmartLabel.getSmartText(titleText, maxHeight, titleObj._actualWidth).text;
            }

            titleObj.centerYAxisName = true;

        },

        /**
         * Method to calculate if any of the plot related objects will overflow out of the canvas
         * are and if they do, by how much (in px).
         * @param {object} hcJSON, The visualization logic corresponding to the chart
         * @param {boolean} edgeOnly, If true (and thus far is always true) will indicate that
         * the calculations need to be done only for the first and last items in the dataset(s).
         */
        calculateCanvasOverflow = function (hcJSON, edgeOnly) {

            var iapi = this,
                itemArr = iapi.canvasPaddingModifiers,
                chartOptions = hcJSON.chart,
                sl = iapi.smartLabel,
                left = 0,
                right = 0,
                leftxs = 0,
                rightxs = 0,
                padding = 2,
                seriesTrav = false, // whether to traverse the series in hcJSON
                manageAnchors = false,
                manageErrorBars = false, series,
                data,
                i = (itemArr && itemArr.length) || 0,
                j,
                seriesItem,
                item,
                dataTrav,
                manageValues,
                firstData,
                lastData;

            while (i--) {
                item = itemArr[i];

                // Checking for overflowing items as specified in the chartAPI.
                switch (item) {
                    case 'anchor':
                        seriesTrav = true;
                        dataTrav = true;
                        manageAnchors = true;
                        break;

                    case 'anchorlabel':
                        seriesTrav = true;
                        dataTrav = true;
                        manageValues = true;
                        break;

                    case 'errorbar':
                        seriesTrav = true;
                        manageErrorBars = true;
                        break;

                    default:
                        break;
                }

            }

            if (seriesTrav) {
                series = hcJSON.series;
                j = series && series.length || 0;
                if (edgeOnly) {
                    while (j--) {
                        seriesItem = series[j];
                        if (dataTrav) {
                            data = (seriesItem && seriesItem.data) || [];
                            if (data.length > 1) {
                                // Only the first and last items need to be considered
                                /** @todo  ignore null data in start and end */
                                firstData = data[0];
                                lastData = data[data.length - 1];

                                if (manageAnchors) {
                                    left = (firstData && firstData.marker && firstData.marker.enabled &&
                                        ((firstData.marker.radius  || 0) + (firstData.marker.lineWidth || 0))) || 0 ;
                                    right = (lastData && lastData.marker && lastData.marker.enabled &&
                                        ((lastData.marker.radius || 0) + (lastData.marker.lineWidth || 0))) || 0;

                                    leftxs = mathMax(left + padding, leftxs);
                                    rightxs = mathMax(right + padding, rightxs);
                                }

                                if (manageValues) {
                                    // Checking the data labels.
                                    sl.setStyle(hcJSON.plotOptions.series.dataLabels.style);
                                    if (chartOptions.rotateValues) {
                                        item = sl.getOriSize((firstData && firstData.displayValue) || BLANKSTRING);
                                        left = item.height / 2;
                                        item = sl.getOriSize((lastData && lastData.displayValue) || BLANKSTRING);
                                        right = item.height / 2;
                                    }
                                    else {
                                        item = sl.getOriSize((firstData && firstData.displayValue) || BLANKSTRING);
                                        left = item.width / 2;
                                        item = sl.getOriSize((lastData && lastData.displayValue) || BLANKSTRING);
                                        right = item.width / 2;
                                    }

                                    leftxs = mathMax(left + padding, leftxs);
                                    rightxs = mathMax(right + padding, rightxs);
                                }
                            }
                        }

                        if (manageErrorBars) {
                            right = left = (((seriesItem.errorBarWidth / 2)  + seriesItem.errorBarThickness) || 0);

                            leftxs = mathMax(left + padding, leftxs);
                            rightxs = mathMax(right + padding, rightxs);
                        }
                    }

                } /*
                else {
                    // We'll see later.
                } */
            }

            return {
                left: leftxs,
                right: rightxs
            };
        },

        /*
         * Function to manage the space for a single X and single Y type normal type charts
         */
        nonBarXYSpaceManager = function (hcJSON, fcJSON, width, height) {
            var iapi = this,
                conf = hcJSON[FC_CONFIG_STRING],
                axisConf, toAddV, isOnRight = true,
                titleHeight = 0, difference = 0, canvasWidth, fcJSONChart = fcJSON.chart,
                isDual = false, yAxisNamePadding, yAxisValuesPadding, rotateYAxisName,
                showPlotBorder, setBorderWidth, canvasBorderThickness, cpObj,
                hcChartObj = hcJSON.chart,
                totalOverflow,
                maxPaddingAllowed,
                leftFactor,
                rightFactor,
                marginLeftExtraSpace = conf.marginLeftExtraSpace,
                marginTopExtraSpace = conf.marginTopExtraSpace,
                marginBottomExtraSpace = conf.marginBottomExtraSpace,
                marginRightExtraSpace = conf.marginRightExtraSpace,
                workingWidth = width - (marginLeftExtraSpace + marginRightExtraSpace +
                    hcChartObj.marginRight + hcChartObj.marginLeft),
                workingHeight = height - (marginBottomExtraSpace + hcChartObj.marginBottom +
                    hcChartObj.marginTop),

                //calculate the min width, height for canvas
                /** @todo tis logic may change */
                minCanWidth = workingWidth * 0.3,
                minCanHeight = workingHeight * 0.3,

                // calculate the space remaining
                avaiableWidth = workingWidth - minCanWidth,
                avaiableHeight = workingHeight - minCanHeight,

                //if the legend is at the right then place it and deduct the width
                //if at bottom calculate the space for legend after the vertical axis placed
                drawFullAreaBorder = conf.drawFullAreaBorder = pluckNumber(fcJSONChart.drawfullareaborder, 1),
                legendPos = pluck(fcJSONChart.legendposition, POSITION_BOTTOM).toLowerCase(),
                xAxixLineThickNess = hcJSON.xAxis.showLine ? hcJSON.xAxis.lineThickness : 0,
                yAxixLineThickNess = hcJSON.yAxis[0].showLine ? hcJSON.yAxis[0].lineThickness : 0,
                sYAxixLineThickNess = conf.isDual && hcJSON.yAxis[1].showLine ? hcJSON.yAxis[1].lineThickness : 0,
                legendObj,
                extraWidth,
                maxHeight;

            /*
             * place the vertical axis
             */
            //add all axis margin pading
            yAxisNamePadding = pluckNumber(fcJSONChart.yaxisnamepadding, 5);
            yAxisValuesPadding = pluckNumber(fcJSONChart.yaxisvaluespadding, fcJSONChart.labelypadding, 4);

            showPlotBorder = (pluck(fcJSONChart.showplotborder,
                (conf.is3d ? ZEROSTRING : ONESTRING)) === ONESTRING);
                // 3D column chart doesn't show the plotborder by default
                // until we set showplotborder true

            setBorderWidth = conf.plotBorderThickness = (showPlotBorder ?
                (conf.is3d ? 1 : pluckNumber(fcJSONChart.plotborderthickness, 1)) : 0);

            canvasBorderThickness = mathMax(pluckNumber(hcChartObj.plotBorderWidth, 1), 0);

            toAddV = mathMax(canvasBorderThickness, setBorderWidth / 2);

            /** @todo for area charts we need to check for drawfullareaborder attribute */
            if (iapi.defaultSeriesType === 'area' && !drawFullAreaBorder) {
                toAddV = canvasBorderThickness;
            }

            if (yAxisValuesPadding < canvasBorderThickness) {
                yAxisValuesPadding = canvasBorderThickness;
            }

            if (!conf.isDual && hcChartObj.marginRight < canvasBorderThickness &&
                fcJSONChart.chartrightmargin === undefined) {
                difference = canvasBorderThickness - hcJSON.chart.marginRight;

                if (workingWidth > minCanWidth + difference) {
                    //commented to remode extra space at right when there has thick border
                    //hcChartObj.marginRight = canvasBorderThickness;
                    workingWidth -= difference;
                    minCanWidth = workingWidth * 0.3;
                    avaiableWidth = workingWidth - minCanWidth;
                }
            }

            if (hcJSON.legend.enabled && legendPos === POSITION_RIGHT) {
                avaiableWidth -= iapi.placeLegendBlockRight(hcJSON, fcJSON, avaiableWidth / 2, workingHeight);
            }

            if (conf.isDual) {
                isDual = true;
                axisConf = conf[1];

                /** @todo have to temporary calculate */
                isOnRight = hcJSON.yAxis[1].opposite;
                // Default rotation for secondary axis is clockwise
                rotateYAxisName = pluck(fcJSONChart.rotateyaxisname, isOnRight ? 'cw' : 'ccw');
                // Backward compatibility.
                rotateYAxisName = (rotateYAxisName === ZEROSTRING) ? 'none' : rotateYAxisName;

                axisConf.verticalAxisNamePadding = yAxisNamePadding;
                axisConf.verticalAxisValuesPadding = yAxisValuesPadding + sYAxixLineThickNess;
                axisConf.rotateVerticalAxisName = rotateYAxisName;
                axisConf.verticalAxisNameWidth = pluckNumber(fcJSONChart.syaxisnamewidth);
                //now configure the axis
                avaiableWidth -= placeVerticalAxis(hcJSON.yAxis[1], axisConf, hcJSON,
                    fcJSON, workingHeight, avaiableWidth / 2, isOnRight, isDual);
            }


            axisConf = conf[0];

            /** @todo have to temporary calculate */
            isOnRight = !isOnRight;
            // Default rotation for secondary axis is clockwise
            rotateYAxisName = pluck(fcJSONChart.rotateyaxisname, isOnRight ? 'cw' : 'ccw');
            // Backward compatibility.
            rotateYAxisName = (rotateYAxisName === ZEROSTRING) ? 'none' : rotateYAxisName;

            axisConf.verticalAxisNamePadding = yAxisNamePadding;
            axisConf.verticalAxisValuesPadding = yAxisValuesPadding + yAxixLineThickNess;
            axisConf.rotateVerticalAxisName = rotateYAxisName;
            axisConf.verticalAxisNameWidth = pluckNumber(isDual ? fcJSONChart.pyaxisnamewidth :
                fcJSONChart.yaxisnamewidth);
            //now configure the axis
            /*
             * To get the `maxWidthLabelPercent` attribute to work for HeatMap chart
             * we need to pass the workingWidth varaible to placeVerticalAxis function
             * RED - 1591.
             */
            avaiableWidth -= placeVerticalAxis(hcJSON.yAxis[0], axisConf, hcJSON, fcJSON,
                workingHeight, avaiableWidth, isOnRight, isDual, workingWidth);

            // adjust left and right canvas margins
            avaiableWidth -= adjustHorizontalCanvasMargin(hcJSON, fcJSON, avaiableWidth,
                hcJSON.yAxis[0], hcJSON.yAxis[1]);

            /** @todo realocate space for secondary axis if requared */

            //now thw canvas width is fixed(no element to reduce the width
            canvasWidth = avaiableWidth + minCanWidth;

            if (hcJSON.legend.enabled && legendPos !== POSITION_RIGHT) {
                avaiableHeight -= iapi.placeLegendBlockBottom(hcJSON, fcJSON, canvasWidth,
                    avaiableHeight/2);
            }

            /*
             * Now place the Title
             */
            //allowed height may

            avaiableHeight -= titleHeight = iapi.titleSpaceManager(hcJSON, fcJSON, canvasWidth,
                avaiableHeight/2);

            /*
             * Now place the horizontal axis
             */
            //add all axis margin pading
            axisConf = conf.x;
            axisConf.horizontalAxisNamePadding = pluckNumber(fcJSONChart.xaxisnamepadding, 5);
            axisConf.horizontalLabelPadding = pluckNumber(fcJSONChart.labelpadding, fcJSONChart.labelxpadding, 4) +
                xAxixLineThickNess;
            axisConf.labelDisplay = pluck(fcJSONChart.labeldisplay, 'auto').toLowerCase();
            axisConf.rotateLabels = pluckNumber(fcJSONChart.rotatelabels, fcJSONChart.rotatexaxislabels, 0);
            axisConf.staggerLines = pluckNumber(fcJSONChart.staggerlines, 2);
            axisConf.slantLabels = pluckNumber(fcJSONChart.slantlabels, fcJSONChart.slantlabel, 0);

            //extend x-Axis Line to adjust with yAxis line Width
            if (hcJSON.yAxis[0].opposite) {
                hcJSON.xAxis.lineEndExtension = yAxixLineThickNess;
                hcJSON.xAxis.lineStartExtension = sYAxixLineThickNess;
            }
            else {
                hcJSON.xAxis.lineEndExtension = sYAxixLineThickNess;
                hcJSON.xAxis.lineStartExtension = yAxixLineThickNess;
            }

            if (axisConf.horizontalLabelPadding < toAddV) {
                axisConf.horizontalLabelPadding = toAddV;
            }

            //set x axis min max
            cpObj = {left: 0, right: 0};

            cpObj = (hcChartObj.managePlotOverflow && iapi.canvasPaddingModifiers &&
                iapi.calculateCanvasOverflow(hcJSON, true)) || cpObj;

            totalOverflow = cpObj.left + cpObj.right;

            // The maximum amount of padding that can be added to improve visualization
            // while maintaining aesthetics.
            maxPaddingAllowed = canvasWidth * 0.6;

            if (totalOverflow > maxPaddingAllowed) {
                leftFactor = cpObj.left / (totalOverflow);
                rightFactor = 1 - leftFactor;
                cpObj.left -= (leftFactor * (totalOverflow - maxPaddingAllowed));
                cpObj.right -= (rightFactor * (totalOverflow - maxPaddingAllowed));
            }

            iapi.xAxisMinMaxSetter(hcJSON, fcJSON, canvasWidth, cpObj.left, cpObj.right);

            avaiableHeight -= iapi.placeHorizontalAxis(hcJSON.xAxis, axisConf, hcJSON, fcJSON,
                canvasWidth, avaiableHeight, minCanWidth);

            // adjust top and bottom the canvas margins here
            avaiableHeight -= adjustVerticalCanvasMargin(hcJSON, fcJSON, avaiableHeight, hcJSON.xAxis);

            if (!hcJSON.title.alignWithCanvas) {
                if (hcJSON.title.align === 'left') {
                    hcJSON.yAxis[0].title.text &&
                        realignVerticalAxisTitle(hcJSON, hcJSON.yAxis[0].title, (minCanHeight + avaiableHeight));
                }

                if (hcJSON.title.align === 'right' && isDual) {
                    hcJSON.yAxis[1].title.text &&
                        realignVerticalAxisTitle(hcJSON, hcJSON.yAxis[1].title, (minCanHeight + avaiableHeight));
                }
            }

            // checking after the finalizing of the canvas height whether, and to what extent should we
            // step them.
            if (isDual) {
                stepYAxisNames((minCanHeight + avaiableHeight), hcJSON, fcJSONChart, hcJSON.yAxis[1], conf[1].lYLblIdx);
                adjustVerticalAxisTitle(hcJSON, hcJSON.yAxis[1].title, (minCanHeight + avaiableHeight));
            }
            stepYAxisNames((minCanHeight + avaiableHeight), hcJSON, fcJSONChart, hcJSON.yAxis[0], conf[0].lYLblIdx);
            adjustVerticalAxisTitle(hcJSON, hcJSON.yAxis[0].title, (minCanHeight + avaiableHeight));

            if (hcJSON.legend.enabled && legendPos === POSITION_RIGHT) {
                legendObj = hcJSON.legend;
                maxHeight = minCanHeight + avaiableHeight;
                //no scroll for gradient legend
                if (legendObj.height > maxHeight) {
                    /**
                     * @todo Adjust the alignment. when it is gradient.
                     */
                    if (legendObj.type !== 'gradient') {
                        legendObj.height = maxHeight;
                        legendObj.scroll.enabled = true;
                        extraWidth = (legendObj.scroll.scrollBarWidth = 10) + (legendObj.scroll.scrollBarPadding = 2);
                        legendObj.width += extraWidth;
                        hcChartObj.marginRight += extraWidth;
                    }
                }
            }

            hcChartObj.marginLeft += marginLeftExtraSpace;
            hcChartObj.marginTop += marginTopExtraSpace;
            hcChartObj.marginBottom += marginBottomExtraSpace;
            hcChartObj.marginRight += marginRightExtraSpace;
        },

        /*
         * Bar chart spage management
         */
        barXYSpaceManager = function (hcJSON, fcJSON, width, height) {
            var iapi = this,
            conf = hcJSON[FC_CONFIG_STRING], avaiableWidth, avaiableHeight, axisConf, axisObj,
            titleHeight = 0, canvasWidth, fcJSONChart = fcJSON.chart, legendPos,
            showPlotBorder, setBorderWidth, canvasBorderThickness, toAddH, difference,
            isDual = false, verticalAxisNamePadding, verticalAxisValuesPadding, rotateVerticalAxisName,
            hcChartObj = hcJSON.chart,
            marginLeftExtraSpace = conf.marginLeftExtraSpace,
            marginTopExtraSpace = conf.marginTopExtraSpace,
            marginBottomExtraSpace = conf.marginBottomExtraSpace,
            marginRightExtraSpace = conf.marginRightExtraSpace,
            workingWidth = width - (marginLeftExtraSpace + marginRightExtraSpace +
                hcChartObj.marginRight + hcChartObj.marginLeft),
            workingHeight = height - (marginBottomExtraSpace + hcChartObj.marginBottom +
                hcChartObj.marginTop),

            //calculate the min width, height for canvas
            /** @todo this logic may change */
            minCanWidth = workingWidth * 0.3,
            minCanHeight = workingHeight * 0.3,
            xAxixLineThickNess = hcJSON.xAxis.showLine ? hcJSON.xAxis.lineThickness : 0,
            yAxixLineThickNess = hcJSON.yAxis[0].showLine ? hcJSON.yAxis[0].lineThickness : 0,
            plotLines,
            unitHeight,
            canvasTopSpace,
            canvasBottomSpace,
            legendObj,
            extraWidth,
            maxHeight;

            // calculate the space remaining
            avaiableWidth = workingWidth - minCanWidth;
            avaiableHeight = workingHeight - minCanHeight;

            /** @todo realocate space for secondary axis if requared */
            legendPos = pluck(fcJSONChart.legendposition, POSITION_BOTTOM).toLowerCase();

            //if the legend is at the right then place it and deduct the width
            //if at bottom calculate the space for legend after the vertical axis placed
            if (hcJSON.legend.enabled && legendPos === POSITION_RIGHT) {
                avaiableWidth -= iapi.placeLegendBlockRight(hcJSON, fcJSON, avaiableWidth / 2, workingHeight);
            }
            /*
             * place the vertical axis
             */
            //add all axis margin pading
            //yAxisNamePadding = pluckNumber(fcJSONChart.xaxisnamepadding, 5);
            verticalAxisNamePadding = pluckNumber(fcJSONChart.xaxisnamepadding, 5);
            //yAxisValuesPadding = pluckNumber(fcJSONChart.labelpadding, 4);
            verticalAxisValuesPadding = pluckNumber(fcJSONChart.labelpadding, 4);
            //rotateYAxisName = fcJSONChart.rotatexaxisname !== ZEROSTRING;
            rotateVerticalAxisName = pluck(fcJSONChart.rotatexaxisname, 'ccw');
            // Backward compatibility.
            rotateVerticalAxisName = (rotateVerticalAxisName === ZEROSTRING) ? 'none' : rotateVerticalAxisName;

            showPlotBorder = (pluck(fcJSONChart.showplotborder,
                (conf.is3d ? ZEROSTRING : ONESTRING)) === ONESTRING);
                // 3D column chart doesn't show the plotborder by default
                // until we set showplotborder true

            setBorderWidth = conf.plotBorderThickness = showPlotBorder ?
                (conf.is3d ? 1 : pluckNumber(fcJSONChart.plotborderthickness, 1)) : 0;

            canvasBorderThickness = mathMax(pluckNumber(hcChartObj.plotBorderWidth, 1), 0);



            if (!conf.isDual && hcChartObj.marginRight < canvasBorderThickness &&
                fcJSONChart.chartrightmargin === undefined) {
                difference = canvasBorderThickness - hcChartObj.marginRight;
                if (workingWidth > minCanWidth + difference) {
                    hcChartObj.marginRight = canvasBorderThickness;
                    workingWidth -= difference;
                    minCanWidth = workingWidth * 0.3;
                    avaiableWidth = workingWidth - minCanWidth;
                }
            }

            axisConf = conf.x;
            /** @todo Validate the use of plotborder thickness here */
            toAddH = mathMax(canvasBorderThickness, setBorderWidth / 2);

            if (verticalAxisValuesPadding < toAddH) {
                verticalAxisValuesPadding = toAddH;
            }
            axisConf.verticalAxisNamePadding = verticalAxisNamePadding;
            axisConf.verticalAxisValuesPadding = verticalAxisValuesPadding + xAxixLineThickNess;
            axisConf.rotateVerticalAxisName = rotateVerticalAxisName;
            axisConf.verticalAxisNameWidth = pluckNumber(isDual ? fcJSONChart.pxaxisnamewidth :
                fcJSONChart.xaxisnamewidth);

            //now configure the axis
            avaiableWidth -= placeVerticalAxis(hcJSON.xAxis, axisConf, hcJSON, fcJSON,
                workingHeight, avaiableWidth, false, false, workingWidth);

            //extend x-Axis Line to adjust with yAxis line Width
            hcJSON.xAxis.lineEndExtension = yAxixLineThickNess;

            // adjust left and right canvas margins
            avaiableWidth -= adjustHorizontalCanvasMargin(hcJSON, fcJSON, avaiableWidth, hcJSON.xAxis);

            //now thw canvas width is fixed(no element to reduce the width
            canvasWidth = avaiableWidth + minCanWidth;

            if (hcJSON.legend.enabled && legendPos !== POSITION_RIGHT) {
                avaiableHeight -= iapi.placeLegendBlockBottom(hcJSON, fcJSON, canvasWidth,
                    avaiableHeight/2);
            }

            /*
             * Now place the Title
             */
            //allowed height may

            avaiableHeight -= titleHeight = iapi.titleSpaceManager(hcJSON, fcJSON, canvasWidth,
                avaiableHeight/2);

            /*
             * Now place the horizontal axis
             */
            //add all axis margin pading
            axisConf = conf[0];
            axisConf.horizontalAxisNamePadding = pluckNumber(fcJSONChart.yaxisnamepadding, 5);
            axisConf.horizontalLabelPadding = mathMax(pluckNumber(fcJSONChart.yaxisvaluespadding, 4)) +
                yAxixLineThickNess;
            // Set the labelDisplay as auto for bar charts
            axisConf.labelDisplay = 'auto';
            axisConf.staggerLines = pluckNumber(fcJSONChart.staggerlines, 2);
            axisConf.slantLabels = pluckNumber(fcJSONChart.slantlabels, 0);

            axisConf.horizontalLabelPadding = (axisConf.horizontalLabelPadding < canvasBorderThickness ?
                canvasBorderThickness : axisConf.horizontalLabelPadding);

            iapi.xAxisMinMaxSetter(hcJSON, fcJSON, canvasWidth);

            axisObj = hcJSON.xAxis;

            plotLines = axisObj.plotLines;
            unitHeight = avaiableHeight / (axisObj.max - axisObj.min);

            if (plotLines && plotLines.length) {

                canvasTopSpace = ((plotLines[0].value - axisObj.min) * unitHeight),
                canvasBottomSpace = ((axisObj.max - plotLines[plotLines.length - 1].value) * unitHeight);

                if (conf.isBar) {
                    if (setBorderWidth > canvasTopSpace) {
                        axisObj.min -= ((setBorderWidth - canvasTopSpace) / (2 * unitHeight));
                    }

                    if (setBorderWidth > canvasBottomSpace) {
                        axisObj.max += ((setBorderWidth - canvasBottomSpace) /  (2 * unitHeight));
                    }
                }
            }

            // function (axisObj, axisConf, hcJSON, fcJSON, width, maxHeight)
            avaiableHeight -= iapi.placeHorizontalAxis(hcJSON.yAxis[0], axisConf, hcJSON,
                fcJSON, canvasWidth, avaiableHeight, minCanWidth);

            // adjust top and bottom the canvas margins here
            avaiableHeight -= adjustVerticalCanvasMargin(hcJSON, fcJSON, avaiableHeight, hcJSON.yAxis[0]);

            stepYAxisNames((minCanHeight + avaiableHeight), hcJSON, fcJSONChart, hcJSON.xAxis, conf.x.lYLblIdx, true);
            adjustVerticalAxisTitle(hcJSON, hcJSON.xAxis.title, avaiableHeight);

            if (hcJSON.legend.enabled && legendPos === POSITION_RIGHT) {
                legendObj = hcJSON.legend;
                maxHeight = minCanHeight + avaiableHeight;

                if (legendObj.height > maxHeight) {
                    legendObj.height = maxHeight;
                    legendObj.scroll.enabled = true;
                    extraWidth = (legendObj.scroll.scrollBarWidth = 10) + (legendObj.scroll.scrollBarPadding = 2);
                    legendObj.width += extraWidth;
                    hcChartObj.marginRight += extraWidth;
                }
                legendObj.y = 20;
            }

            /** @todo check is code is redundant after porting the entire suite to RedRaphael.
             *
            var xc = ((hcJSON.chart.marginLeft - pluckNumber(hcJSON.chart.spacingLeft, 0)) - (hcJSON.chart.marginRight -
                pluckNumber(hcJSON.chart.spacingRight, 0))) / 2,
            xl = hcJSON.chart.marginLeft - pluckNumber(hcJSON.chart.spacingLeft, 0),
            xr = - (hcJSON.chart.marginRight - pluckNumber(hcJSON.chart.spacingRight, 0));
            switch (hcJSON.title.align) {
                case 'left' :
                    hcJSON.title.x = xl;
                    break;
                case 'right':
                    hcJSON.title.x = xr;
                    break;
                default:
                    hcJSON.title.x = xc;
            }
            switch (hcJSON.subtitle.align) {
                case 'left' :
                    hcJSON.subtitle.x = xl;
                    break;
                case 'right':
                    hcJSON.subtitle.x = xr;
                    break;
                default:
                    hcJSON.subtitle.x = xc;
            }*/

            /*
             * if the titles requared space and there has avaleble space the re-alocatethe title space
             */
            /** @todo remove vertical axis labels that are overlaped and set the y for v lines */

            hcChartObj.marginLeft += marginLeftExtraSpace;
            hcChartObj.marginTop += marginTopExtraSpace;
            hcChartObj.marginBottom += marginBottomExtraSpace;
            hcChartObj.marginRight += marginRightExtraSpace;
        },

        adjustVerticalAxisTitle = lib.adjustVerticalAxisTitle = function (hcJSON, titleObj, availableHeight) {
            if (!titleObj || !titleObj.text) {
                return;
            }

            var titleText = titleObj.text, conf = hcJSON[FC_CONFIG_STRING], SmartLabel = conf.smartLabel, smartTitle,
            heightMax = 2 * mathMin(hcJSON.chart.marginTop, hcJSON.chart.marginBottom) + availableHeight,
            totalHeight = availableHeight + hcJSON.chart.marginTop + hcJSON.chart.marginBottom;

            if (titleObj.style) {
                SmartLabel.setStyle(titleObj.style);
            }

            smartTitle = SmartLabel.getOriSize(titleText);
            if (titleObj.centerYAxisName === undefined) {
                titleObj.centerYAxisName = true;
            }

            if (!titleObj.rotation) {
                if (smartTitle.height > heightMax) {
                    titleObj.y = ((totalHeight / 2) - ((availableHeight / 2) + hcJSON.chart.marginTop)) / 2;
                    titleObj.centerYAxisName = false;
                }
            } else if (smartTitle.width > heightMax) {
                titleObj.y = ((totalHeight / 2) - ((availableHeight / 2) + hcJSON.chart.marginTop));
                titleObj.centerYAxisName = false;
            }
        },

        adjustVerticalCanvasMargin = lib.adjustVerticalCanvasMargin = function (hcJSON, fcJSON, avaiableHeight, xAxis) {

            var fcJSONChart = fcJSON.chart, extraMargin = 0, topChange = 0, bottomChange = 0,
            canvasTopMargin = pluckNumber(fcJSONChart.canvastopmargin, 0),
            canvasBottomMargin = pluckNumber(fcJSONChart.canvasbottommargin, 0),
            totalVerticalMargin = canvasTopMargin + canvasBottomMargin,
            topMarginPercent = canvasTopMargin / totalVerticalMargin,
            bottomMarginPercent = 1 - topMarginPercent,
            actualTopMargin = hcJSON.chart.marginTop,
            actualBottomMargin = hcJSON.chart.marginBottom;

            if (canvasBottomMargin > actualBottomMargin) {
                extraMargin += (canvasBottomMargin - actualBottomMargin);
            }
            if (canvasTopMargin > actualTopMargin) {
                extraMargin += (canvasTopMargin - actualTopMargin);
            }
            if (extraMargin > avaiableHeight) {
                if (canvasTopMargin > actualTopMargin && canvasBottomMargin > actualBottomMargin) {
                    topChange = (avaiableHeight * topMarginPercent);
                    bottomChange = (avaiableHeight * bottomMarginPercent);
                } else {
                    if (canvasTopMargin > actualTopMargin) {
                        topChange = avaiableHeight;
                    } else {
                        bottomChange = avaiableHeight;
                    }
                }
            } else if (extraMargin > 0) {
                if (canvasBottomMargin > actualBottomMargin) {
                    bottomChange = (canvasBottomMargin - actualBottomMargin);
                }
                if (canvasTopMargin > actualTopMargin) {
                    topChange = (canvasTopMargin - actualTopMargin);
                }
            }

            if (topChange) {
                hcJSON.chart.marginTop += topChange;
            }

            if (bottomChange) {
                hcJSON.chart.marginBottom += bottomChange;
                if (xAxis && xAxis.title) {
                    xAxis.title.margin += bottomChange;
                }
            }

            return (topChange + bottomChange);
        },

        adjustHorizontalCanvasMargin = lib.adjustHorizontalCanvasMargin = function (hcJSON, fcJSON, avaiableWidth,
            leftYAxis, rightYAxis) {

            var fcJSONChart = fcJSON.chart,
            canvasLeftMargin = pluckNumber(fcJSONChart.canvasleftmargin, 0),
            canvasRightMargin = pluckNumber(fcJSONChart.canvasrightmargin, 0),
            totalHorizontalMargin = canvasLeftMargin + canvasRightMargin,
            leftMarginPercent = canvasLeftMargin / totalHorizontalMargin,
            rightMarginPercent = 1 - leftMarginPercent, extraMargin = 0,
            actualLeftMargin = hcJSON.chart.marginLeft, actualRightMargin = hcJSON.chart.marginRight,
            leftChange = 0, rightChange = 0;

            if (canvasLeftMargin > actualLeftMargin) {
                extraMargin += (canvasLeftMargin - actualLeftMargin);
            }
            if (canvasRightMargin > actualRightMargin) {
                extraMargin += (canvasRightMargin - actualRightMargin);
            }
            if (extraMargin > avaiableWidth) {
                if (canvasLeftMargin > actualLeftMargin && canvasRightMargin > actualRightMargin) {
                    leftChange = (avaiableWidth * leftMarginPercent);
                    rightChange = (avaiableWidth * rightMarginPercent);
                } else {
                    if (canvasRightMargin > actualRightMargin) {
                        rightChange = avaiableWidth;
                    } else {
                        leftChange = avaiableWidth;
                    }
                }
            } else if (extraMargin > 0) {
                if (canvasLeftMargin > actualLeftMargin) {
                    leftChange = (canvasLeftMargin - actualLeftMargin);
                }

                if (canvasRightMargin > actualRightMargin) {
                    rightChange = (canvasRightMargin - actualRightMargin);
                }
            }

            if (leftChange) {
                hcJSON.chart.marginLeft += leftChange;
                if (leftYAxis && leftYAxis.title) {
                    leftYAxis.title.margin += leftChange;
                }
            }

            if (rightChange) {
                hcJSON.chart.marginRight += rightChange;
                if (rightYAxis && rightYAxis.title) {
                    rightYAxis.title.margin += rightChange;
                }
            }

            return (rightChange + leftChange);
        },

        //post Series Adition Function
        postSeriesAddition = function (hcObj) {
            var conf = hcObj[FC_CONFIG_STRING],
                isBar = conf.isBar,
                is3d = conf.is3d,
                rotateValues = hcObj.chart.rotateValues && !isBar ? 270 : 0,
                //for the first y axis
                axisStack = conf[0],
                stacking100Percent = axisStack && axisStack.stacking100Percent,
                plotSpacePercent,
                defaultSeriesType,
                seriesType,
                totalStacks,
                axisConfStack,
                groupWidthPercent,
                perStackWidth,
                stackIndex,
                startStackIndex,
                position,
                length,
                catPosition,
                stackArr,
                stack,
                value,
                seriesArr,
                stackedDataArr,
                series,
                numberFormatter,
                percentDataValue,
                seri,
                i,
                ln,
                point,
                pointValue,
                labelPosition,
                style,
                labelFontSize,
                labeloffsetScale,
                labelInsidePlot;

            //show the stack total if requared
    //        if (this.isStacked && (conf.showStackTotal || stacking100Percent || showPercetValue)){
            if (this.isStacked){
                plotSpacePercent = conf.plotSpacePercent;
                defaultSeriesType = hcObj.chart.defaultSeriesType;
                groupWidthPercent = 1 - (2 * plotSpacePercent);
                series = hcObj.series;
                numberFormatter = this.numberFormatter;
                style = extend2({}, hcObj.plotOptions.series.dataLabels.style);
                labelFontSize = parseFloat(style.fontSize);
                labelInsidePlot = !axisStack.stacking100Percent;
                style.color = hcObj.plotOptions.series.dataLabels.color;
                axisConfStack = axisStack.stack;

                for (seriesType in axisConfStack) {
                    totalStacks = axisConfStack[seriesType].length;
                    perStackWidth = groupWidthPercent / totalStacks;
                    startStackIndex = - (groupWidthPercent - perStackWidth) / 2;
    //                if(stacking100Percent || showPercetValue){
                        //get all series tht has same series type and belongs to 0th y-axis
                    seriesArr = [];
                    for (i = 0, ln = series.length; i < ln; i += 1) {
                        seri = series[i];
                        if (!seri.yAxis && pluck(seri.type, defaultSeriesType)=== seriesType) {
                            seriesArr.push(seri);
                        }
                    }
    //                }

                    for (stackIndex = 0; stackIndex < totalStacks; stackIndex += 1,
                        startStackIndex += perStackWidth) {
                        stackArr = axisConfStack[seriesType][stackIndex];
    //                     if(stacking100Percent || showPercetValue){
                            //get all series tht has same startStackIndex from seriesArr
                        stackedDataArr = [];
                        for (i = 0, ln = seriesArr.length; i < ln; i += 1) {
                            seri = seriesArr[i];
                            if (pluckNumber(seri.columnPosition, 0)=== stackIndex) {
                                stackedDataArr.push(seri.data);
                            }
                        }
    //                    }
                        if (stackArr && stackArr.length) {
                            for (catPosition = 0, length = stackArr.length;
                                        catPosition < length; catPosition += 1) {
                                stack = stackArr[catPosition];
                                //if there has valid data por this stach index
                                if (stack) {
                                    value = (stack.n || 0) + (stack.p || 0);
                                    if (conf.showStackTotal) {
                                        position = catPosition;
                                        labelPosition = position + startStackIndex;
                                        labeloffsetScale = value < 0 ? stack.n : stack.p;

                                        //add the total value
                                        hcObj.xAxis.plotLines.push({
                                            value: labelPosition,
                                            width: 0,
                                            isVline: labelInsidePlot,
                                            isTrend: !labelInsidePlot,
                                            zIndex: 4,
                                            _isStackSum: 1,
                                            _catPosition: catPosition,
                                            _stackIndex: stackIndex,
                                            label: {
                                                align: POSITION_CENTER,
                                                textAlign: !is3d && rotateValues === 270 ?
                                                    (value < 0 ? POSITION_RIGHT : POSITION_LEFT) : (isBar ? value < 0 ?
                                                    POSITION_RIGHT : POSITION_LEFT : POSITION_CENTER),
                                                offsetScale: labelInsidePlot ? labeloffsetScale : undefined,
                                                offsetScaleIndex: 0,
                                                rotation: rotateValues,
                                                style: style,
                                                verticalAlign: POSITION_TOP,
                                                y: isBar ? 0 : (value < 0 ?
                                                        (rotateValues === 270 ? 4 : labelFontSize) : -4),
                                                x: 0,
                                                text: conf.numberFormatter.yAxis(value)
                                            }
                                        });
                                    }
                                    //manipulate values for 100percent stack
                                    for (i = 0, ln = stackedDataArr.length; i < ln; i += 1) {
                                        point = stackedDataArr[i][catPosition];
                                        if(point){
                                            pointValue = value && ((point.y || 0) / value * 100);
                                            percentDataValue = numberFormatter.percentValue(pointValue);
                                            point.toolText = parseTooltext(point.toolText, [14, 24, 25, 112], {
                                                percentValue: percentDataValue,
                                                sum: numberFormatter.dataLabels(value),
                                                unformattedSum: value
                                            });
                                            if (point.y || point.y === 0) {
                                                if (stacking100Percent) {
                                                    point.y = pointValue;
                                                    if (point.previousY || point.previousY === 0) {
                                                        point.previousY = point.previousY / value * 100;
                                                    }
                                                }
                                                //set display value
                                                if (point.showPercentValues) {
                                                    point.displayValue = percentDataValue;
                                                }
                                                //set tooltip
        //                                            if (point.showPercentInToolTip) {
        //                                                point.toolText = point.toolText +
        //                                                  (parseInt(pointValue * 100, 10) / 100) + '%';
        //                                            }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },

        sortFN = function (a, b) {
            return a - b;
        },

        /** @todo replace this code in a proper place */
        getDataParser = lib.getDataParser = {
            column: function (HCObj, seriesConf, chartAPI) {
                var conf = HCObj[FC_CONFIG_STRING],
                borderWidth = seriesConf.borderWidth;

                return function (dataObj, index, itemValue) {
                    var hoverEffects,
                        seriesGradientColor = seriesConf.plotgradientcolor,
                        is3d = seriesConf.is3d,
                        isRoundEdges= seriesConf.isRoundEdges,
                        // dataplot border color
                        setPlotBorderColor = seriesConf.plotBorderColor,
                        setBorderWidth = borderWidth,
                        // Color of the particular data
                        setColor = pluck(dataObj.color, seriesConf.color),
                        setRatio = pluck(dataObj.ratio, seriesConf.ratio),
                        // using getFirstAlpha to avoid comma separated alpha
                        setPlotBorderAlpha = getFirstAlpha(seriesConf.plotBorderAlpha),
                        setBorderDashed = pluckNumber(dataObj.dashed, seriesConf.dashed),
                        setDashLen = pluck(dataObj.dashlen, seriesConf.dashLen),
                        setDashGap = pluck(dataObj.dashgap, seriesConf.dashGap),
                        use3DLighting = seriesConf.use3DLighting,
                        // Alpha of the data point
                        // using getFirstAlpha to avoid comma separated alpha
                        setAlpha = getFirstAlpha(pluck(dataObj.alpha,
                            seriesConf.alpha)).toString(),
                        // Used to set alpha of the shadow
                        pointShadow = {
                            opacity: setAlpha / 100
                        },
                        isBar = seriesConf.isBar,
                        fillAangle = seriesConf.fillAangle,

                        angle = itemValue < 0 ? (isBar ? (180 - fillAangle) :
                                (360 - fillAangle)) : fillAangle,

                        // calculate the color object for the set
                        colorArr = getColumnColor (
                                setColor + COMMASTRING + seriesGradientColor,
                                setAlpha,
                                setRatio,
                                angle,
                                isRoundEdges,
                                setPlotBorderColor,
                                mathMin(setAlpha, setPlotBorderAlpha).toString(),
                                isBar,
                                is3d
                            ),

                        // get per-point dash-style
                        pointDashStyle = setBorderDashed ?
                            getDashStyle(setDashLen, setDashGap, setBorderWidth) :
                            'none',

                        point = chartAPI.getPointStub(dataObj,
                                itemValue, conf.oriCatTmp[index], HCObj,
                                seriesConf, seriesConf.showValues, seriesConf.yAxis);

                    // Point hover effects
                    hoverEffects = chartAPI.pointHoverOptions (dataObj, seriesConf, {
                            plotType: 'column',
                            is3d: is3d,
                            isBar: isBar,

                            use3DLighting: use3DLighting,
                            isRoundEdged: isRoundEdges,

                            color: setColor,
                            gradientColor: seriesGradientColor,
                            alpha: setAlpha,
                            ratio: setRatio,
                            angle: angle,

                            borderWidth: setBorderWidth,
                            borderColor: setPlotBorderColor,
                            borderAlpha: setPlotBorderAlpha,
                            borderDashed: setBorderDashed,
                            borderDashGap: setDashGap,
                            borderDashLen: setDashLen,

                            shadow: pointShadow
                        }
                    );
                    point.y = itemValue;
                    point.shadow= pointShadow;
                    point.color= colorArr[0];
                    point.borderColor= colorArr[1];
                    point.borderWidth= setBorderWidth;
                    point.use3DLighting = use3DLighting;
                    point.dashStyle= pointDashStyle;
                    point.tooltipConstraint = chartAPI.tooltipConstraint;
                    point.hoverEffects = hoverEffects.enabled && hoverEffects.options;
                    point.rolloverProperties = hoverEffects.enabled && hoverEffects.rolloverOptions;
                    return point;
                };
            },
            line: function (HCObj, seriesConf, chartAPI) {
                var conf = HCObj[FC_CONFIG_STRING];

                return function (dataObj, index, itemValue) {
                    // Alpha
                    var lineAlpha = pluckNumber(dataObj.alpha, seriesConf.lineAlpha),
                        // Used to set alpha of the shadow
                        pointShadow = {
                            opacity: lineAlpha / 100
                        },
                        // set attributes
                        setAnchorSides = pluckNumber(dataObj.anchorsides,
                            seriesConf.anchorSides, 0),
                        setAnchorBorderThickness = pluckNumber(dataObj.anchorborderthickness,
                            seriesConf.anchorBorderThickness, 1),
                        setAnchorBorderColor = getFirstColor(pluck(dataObj.anchorbordercolor,
                            seriesConf.anchorBorderColor)),
                        setAnchorBgColor = getFirstColor(pluck(dataObj.anchorbgcolor,
                            seriesConf.anchorBgColor)),
                        setAnchorAngle = pluckNumber(dataObj.anchorstartangle,
                            seriesConf.anchorStartAngle, 90),

                        setAnchorAlpha = pluck(dataObj.anchoralpha,
                                seriesConf.anchorAlpha),
                        setAnchorBgAlpha = pluck(dataObj.anchorbgalpha, setAnchorAlpha),
                        setAnchorRadius = pluckNumber(dataObj.anchorradius,
                                    seriesConf.anchorRadius),
                        setAnchorShadow = Boolean(pluckNumber(dataObj.anchorshadow,
                                        seriesConf.anchorShadow, 0)),

                        point = chartAPI.getPointStub(
                            dataObj, itemValue, conf.oriCatTmp[index], HCObj,
                            seriesConf, seriesConf.showValues, seriesConf.yAxis),
                        imageUrl = pluck(dataObj.anchorimageurl, seriesConf.imageUrl),
                        imageScale = pluck(dataObj.anchorimagescale, seriesConf.imageScale),
                        imageAlpha = pluck(dataObj.anchorimagealpha, seriesConf.imageAlpha),
                        hoverEffects;

                    point.y = itemValue;
                    point.shadow = pointShadow;
                    point.anchorShadow = seriesConf.anchorShadow;
                    point.dashStyle = pluckNumber(dataObj.dashed,
                        seriesConf.lineDashed) ?
                    getDashStyle(seriesConf.lineDashLen,
                        seriesConf.lineDashGap, seriesConf.lineThickness) : null;

                    point.color = {
                        FCcolor: {
                            color: getFirstColor(pluck(dataObj.color, seriesConf.lineColor)),
                            alpha: lineAlpha
                        }
                    };

                    point.valuePosition = pluck(dataObj.valueposition, seriesConf.valuePosition);

                    // Point hover effects
                    hoverEffects = chartAPI.pointHoverOptions (dataObj, seriesConf, {
                            plotType: 'anchor',

                            anchorBgColor: setAnchorBgColor,
                            anchorAlpha: setAnchorAlpha,
                            anchorBgAlpha: setAnchorBgAlpha,
                            anchorAngle: setAnchorAngle,

                            anchorBorderThickness: setAnchorBorderThickness,
                            anchorBorderColor: setAnchorBorderColor,
                            anchorBorderAlpha: setAnchorAlpha,
                            anchorSides: setAnchorSides,
                            anchorRadius: setAnchorRadius,
                            imageUrl: imageUrl,
                            imageScale: imageScale,
                            imageAlpha:imageAlpha,

                            shadow: pointShadow
                        }
                    );

                    point.marker = {
                        enabled: seriesConf.drawAnchors === undefined ? lineAlpha !== 0 : !!seriesConf.drawAnchors,
                        shadow: setAnchorShadow && {
                            opacity: setAnchorAlpha / 100
                        },
                        fillColor: {
                            FCcolor: {
                                color: getFirstColor(pluck(dataObj.anchorbgcolor,
                                    seriesConf.anchorBgColor)),
                                alpha: (pluck(dataObj.anchorbgalpha,
                                    seriesConf.anchorBgAlpha) *
                                            setAnchorAlpha / 100).toString()
                            }
                        },
                        lineColor: {
                            FCcolor: {
                                color: getFirstColor(pluck(dataObj.anchorbordercolor,
                                seriesConf.anchorBorderColor)),
                                alpha: setAnchorAlpha
                            }
                        },
                        imageUrl: imageUrl,
                        imageScale: imageScale,
                        imageAlpha:imageAlpha,

                        lineWidth: pluckNumber(dataObj.anchorborderthickness,
                                        seriesConf.anchorBorderThickness),
                        radius: pluckNumber(dataObj.anchorradius,
                                        seriesConf.anchorRadius),
                        symbol: mapSymbolName(pluckNumber(dataObj.anchorsides,
                                        seriesConf.anchorSides)),
                        startAngle: pluck(dataObj.anchorstartangle,
                                        seriesConf.anchorAngle)
                    };

                    point.hoverEffects = hoverEffects.enabled && hoverEffects.options;
                    point.rolloverProperties = hoverEffects.enabled && hoverEffects.rolloverOptions;

                    return point;
                };
            },
            area : function (HCObj, seriesConf, chartAPI) {
                var conf = HCObj[FC_CONFIG_STRING];

                return function (dataObj, index, itemValue) {
                    // Alpha
                    var setAlpha = pluck(dataObj.alpha, seriesConf.fillAlpha),
                        // Used to set alpha of the shadow
                        pointShadow = {
                            opacity: mathMax(setAlpha, seriesConf.lineAlpha) / 100,
                            inverted: true
                        },

                        // set attributes
                        setAnchorSides = pluckNumber(dataObj.anchorsides,
                            seriesConf.anchorSides, 0),
                        setAnchorBorderThickness = pluckNumber(dataObj.anchorborderthickness,
                            seriesConf.anchorBorderThickness, 1),
                        setAnchorBorderColor = getFirstColor(pluck(dataObj.anchorbordercolor,
                            seriesConf.anchorBorderColor)),
                        setAnchorBgColor = getFirstColor(pluck(dataObj.anchorbgcolor,
                            seriesConf.anchorBgColor)),
                        setAnchorAngle = pluckNumber(dataObj.anchorstartangle,
                            seriesConf.anchorStartAngle, 90),

                        setAnchorAlpha = pluck(dataObj.anchoralpha,
                                seriesConf.anchorAlpha),
                        setAnchorBgAlpha = pluck(dataObj.anchorbgalpha, setAnchorAlpha),
                        setAnchorRadius = pluckNumber(dataObj.anchorradius,
                                    seriesConf.anchorRadius),
                        setAnchorShadow = Boolean(pluckNumber(dataObj.anchorshadow,
                                        seriesConf.anchorShadow, 0)),

                        point = chartAPI.getPointStub(dataObj, itemValue,
                                conf.oriCatTmp[index], HCObj, seriesConf,
                                seriesConf.showValues, seriesConf.yAxis),
                        imageUrl = pluck(dataObj.anchorimageurl, seriesConf.imageUrl),
                        imageScale = pluck(dataObj.anchorimagescale, seriesConf.imageScale),
                        imageAlpha = pluck(dataObj.anchorimagealpha, seriesConf.imageAlpha),

                        hoverEffects;


                    point.y = itemValue;
                    point.shadow= pointShadow;
                    point.anchorShadow = seriesConf.anchorShadow;
                    point.color= {
                        FCcolor: {
                            color: getFirstColor(pluck(dataObj.color, seriesConf.fillColor)),
                            alpha: setAlpha
                        }
                    };
                    point.valuePosition = pluck(dataObj.valueposition, seriesConf.valuePosition);

                    // Point hover effects
                    hoverEffects = chartAPI.pointHoverOptions (dataObj, seriesConf, {
                        plotType: 'anchor',
                        anchorBgColor: setAnchorBgColor,
                        anchorAlpha: setAnchorAlpha,
                        anchorBgAlpha: setAnchorBgAlpha,
                        anchorAngle: setAnchorAngle,

                        anchorBorderThickness: setAnchorBorderThickness,
                        anchorBorderColor: setAnchorBorderColor,
                        anchorBorderAlpha: setAnchorAlpha,
                        anchorSides: setAnchorSides,
                        anchorRadius: setAnchorRadius,

                        imageUrl: imageUrl,
                        imageScale: imageScale,
                        imageAlpha:imageAlpha,

                        shadow: pointShadow
                    });

                    point.marker = {
                        enabled:  seriesConf.drawAnchors,
                        shadow: setAnchorShadow && {
                            opacity: setAnchorAlpha / 100
                        },
                        fillColor: {
                            FCcolor: {
                                color: getFirstColor(pluck(dataObj.anchorbgcolor, seriesConf.anchorBgColor)),
                                alpha: (pluck(dataObj.anchorbgalpha, seriesConf.anchorBgAlpha) *
                                    setAnchorAlpha / 100).toString()
                            }
                        },
                        lineColor: {
                            FCcolor: {
                                color: getFirstColor(pluck(dataObj.anchorbordercolor, seriesConf.anchorBorderColor)),
                                alpha: setAnchorAlpha
                            }
                        },
                        imageUrl: imageUrl,
                        imageScale: imageScale,
                        imageAlpha:imageAlpha,
                        lineWidth: pluckNumber(dataObj.anchorborderthickness, seriesConf.anchorBorderThickness),
                        radius: setAnchorRadius,
                        symbol: mapSymbolName(pluckNumber(dataObj.anchorsides, seriesConf.anchorSides)),
                        startAngle: pluck(dataObj.anchorstartangle, seriesConf.anchorAngle)
                    };

                    point.hoverEffects = hoverEffects.enabled && hoverEffects.options;
                    point.rolloverProperties = hoverEffects.enabled && hoverEffects.rolloverOptions;

                    point.events = {
                        click: seriesConf.getLink
                    };
                    return point;
                };
            }
        };



    // Add resize tracking default configs
    global.core.options.resizeTrackingInterval = 300;
    global.core.options.preventTrackResize = false;

    lib.createChart = function (chartObj, container, type, notify, hcJSON, animate, suppressDataEvents) {

        var vars = chartObj.jsVars,
            dataComp, dataObj,
            api = chartAPI[type || (type = chartObj.chartType())],
            instanceAPI,
            hasNativeMessage = vars.hasNativeMessage,
            chartOptions = chartObj.options,
            args = chartObj.args,
            callback;

        callback = function (obj) {

            var eventArgs = {
                    renderer: 'javascript'
                },
                fcObj = vars.fcObj,
                w = fcObj.width,
                h = fcObj.height,
                eiMethods = api && api.eiMethods,
                backEle = vars.overlayButton,
                method;

            container.jsVars = chartObj.jsVars;
            vars.container = container;
            vars.hcObj = obj;
            vars.type = type;
            vars.width = container.offsetWidth;
            vars.height = container.offsetHeight;
            vars.instanceAPI = instanceAPI;

            if (obj.hasRendered) {
                // Add private ExternalInterface API
                global.extend(container, privateAPIMethods);

                // Add Public externalInteface API
                if (eiMethods && typeof eiMethods !== 'string') {
                    for (method in eiMethods) {
                        container[method] = eiMethods[method];
                    }
                }

                // if overlaybutton was there, make it persistent.
                if (vars.overlayButtonActive && backEle) {
                    backEle.innerHTML = '';
                    backEle.appendChild(doc.createTextNode(vars.overlayButtonMessage)); // #FCXT-217
                    obj.container.appendChild(backEle);
                }
            }

            // In case of percentage dimension, perform interval based tracking
            if ((/\%/g.test(w) || /\%/g.test(h)) && container && container.parentNode &&
                    !global.core.options.preventTrackResize) {
                handleContainerResize(fcObj, container);
            }

            if (notify) {
                notify({
                    success: obj.hasRendered,
                    ref: container,
                    id: chartObj.id
                });

                if (obj.hasRendered) {
                    // Call render completion events.
                    /**
                     * The `loaded` event is raised when the chart has finished downloading itself in the client
                     * environment.
                     * This event indicates that the all the resources required to render the chart are ready and the
                     * chart can be drawn.
                     * You can use this event to hide any loader components that you might have on your page.
                     * @event FusionCharts#loaded
                     * @param {string} type This is the type of chart that is being rendered.
                     */
                    lib.raiseEvent('loaded', {
                        type: type,
                        renderer: 'javascript'
                    }, chartObj, [chartObj.id]);

                    if (!hasNativeMessage) {
                        fcObj.__state.firstRenderNotified = true;
                        setTimeout(function () {
                            /**
                             * This event is fired when the chart completes drawing after {@link FusionCharts#render} is
                             * called. If the data provided to the chart is appropriate, the chart would be rendered.
                             * Otherwise it will show a message from the list {@link FusionCharts~chartMessages}
                             * depending on the error.
                             *
                             * This call is made only once (even if new data is supplied to it). It can be used to
                             * invoke any further JavaScript methods on the chart or change the data of chart.
                             *
                             * > If chart animation is enabled, this event is fired before the animation process is
                             * triggered. In case you need to perform any action after animation has completed, you will
                             * need to add appropriate time delay in this event handler using `setTimeout`.
                             * > The default animation duration is `1000ms` (1 second). The animation duration can be
                             * customized using `animationDuration` chart attribute.
                             * @see FusionCharts#render
                             * @see FusionCharts#hasRendered
                             * @see FusionCharts#event:beforeRender
                             * @see FusionCharts#event:renderComplete
                             * @see FusionCharts#event:renderCancelled
                             * @event FusionCharts#rendered
                             */
                            lib.raiseEvent('rendered', {
                                renderer: 'javascript'
                            }, fcObj, [fcObj.id]);
                        }, 0);
                    }
                }
            }

            // Fire draw complete irrespective whether rendering was a chart or
            // a message. But do it after rendered event
            if (obj.hasRendered && vars.previousDrawCount < vars.drawCount) {
                eventArgs.width = vars.width;
                eventArgs.height = vars.height;
                eventArgs.drawCount = vars.drawCount;
                eventArgs.displayingMessage = hasNativeMessage;
                eventArgs.renderer = fcObj.options.renderer;
                /**
                 * This event is fired whenever an entire redraw of the chart is caused by data update, change of chart
                 * message, change of chart type or resize.
                 * @event FusionCharts#drawComplete
                 * @param {number} drawCount Number specifying the number of times the chart is (re)drawn.
                 * @param {number} drawLatency Number specifying the draw latency.
                 * @param {number} height Height of the chart object in pixels or percent.
                 * @param {number} width Width of the chart object in pixels or percent.
                 */
                lib.raiseEvent('drawcomplete', eventArgs, fcObj, [fcObj.id]);

                if (!hasNativeMessage && !suppressDataEvents) {
                    setTimeout(function () {
                        if (fcObj.__state && !fcObj.__state.firstRenderNotified) {
                            lib.raiseEvent('rendered', {
                                renderer: 'javascript'
                            }, fcObj, [fcObj.id]);
                        }
                        /**
                         * This event is fired every-time a chart is rendered either by {@link FusionCharts#render},
                         * {@link FusionCharts#chartType} or {@link FusionCharts#setChartData}. So, this event is fired
                         * any time `.render()` is called on the chart or the chart data is successfully updated,
                         * triggering a re-render internally.
                         *
                         * > This event is not fired when chart is resized.
                         *
                         * The difference between this event and {@link FusionCharts#event:rendered} event is that
                         * {@link FusionCharts#event:rendered} is fired only when `.render()` is called.
                         *
                         * `renderComplete` is not always preceded by {@link FusionCharts#event:beforeRender}. It is
                         * triggered even without firing {@link FusionCharts#event:beforeRender} during data update.
                         *
                         * > If chart animation is enabled, this event is fired before the animation process is
                         * triggered. In case you need to perform any action after  animation has completed, you will
                         * need to add appropriate time delay in  this event handler using `setTimeout`.
                         * > The default animation duration is `1000ms` (1 second). The animation duration can be
                         * customized using `animationDuration` chart attribute.
                         * @event FusionCharts#renderComplete
                         * @see FusionCharts#render
                         * @see FusionCharts#hasRendered
                         * @see FusionCharts#event:beforeRender
                         * @see FusionCharts#event:renderCancelled
                         * @see FusionCharts#event:rendered
                         */
                        global.raiseEvent('renderComplete', eventArgs, fcObj);
                    }, 0);
                }
            }
        };

        // dispose old instanceAPI
        if (vars.instanceAPI && vars.instanceAPI.dispose) {
            vars.instanceAPI.dispose();
        }
        instanceAPI = api ? new ChartAPI(type) : new ChartAPI('stub');
        instanceAPI.chartInstance = chartObj;

        // borrow initial render-time width and height from state
        instanceAPI.origRenderWidth = chartObj.__state.renderedWidth;
        instanceAPI.origRenderHeight = chartObj.__state.renderedHeight;

        // if a JSON is already provided
        if (hcJSON !== undefined) {
            if (typeof hcJSON === 'string') {
                hcJSON = new CreateDialog(container, hcJSON, chartObj);
                hasNativeMessage = vars.hasNativeMessage = true;
            }
        }
        //check verious condition where the chart shows an message
        //chart not supported
        else if (!(api && api.init) || (api && api.name === 'stub')) {
            chartObj._chartMessageStyle = {
                color: args.typeNotSupportedMessageColor || chartOptions.baseChartMessageColor,
                fontFamily: args.typeNotSupportedMessageFont || chartOptions.baseChartMessageFont,
                fontSize: args.typeNotSupportedMessageFontSize || chartOptions.baseChartMessageFontSize
            };
            hcJSON = new CreateDialog(container, chartOptions.typeNotSupportedMessage, chartObj);
            hasNativeMessage = vars.hasNativeMessage = true;
        }
        ////if chart has any msg to show
        else if (vars.message) {
            hcJSON = new CreateDialog(container, vars.message, chartObj);
            hasNativeMessage = vars.hasNativeMessage = true;
        }
        ////if chart has data loading error
        else if (vars.loadError) {
            chartObj._chartMessageStyle = {
                color: args.dataLoadErrorMessageColor || chartOptions.baseChartMessageColor,
                fontFamily: args.dataLoadErrorMessageFont || chartOptions.baseChartMessageFont,
                fontSize: args.dataLoadErrorMessageFontSize || chartOptions.baseChartMessageFontSize
            };
            hcJSON = new CreateDialog(container, chartOptions.dataLoadErrorMessage, chartObj);
            hasNativeMessage = vars.hasNativeMessage = true;
        }
        ////if chart is retriving data
        else if (vars.stallLoad) {
            chartObj._chartMessageStyle = {
                fontFamily: args.dataLoadStartMessageFont || chartOptions.baseChartMessageFont,
                fontSize: args.dataLoadStartMessageFontSize || chartOptions.baseChartMessageFontSize,
                color: args.dataLoadStartMessageColor || chartOptions.baseChartMessageColor
            };
            hcJSON = new CreateDialog(container, chartOptions.dataLoadStartMessage, chartObj);
            hasNativeMessage = vars.hasNativeMessage = true;
        }

        else {
            /**
             * @private
             * @event FusionCharts#internal.drawStart
             */
            global.raiseEvent('internal.drawStart', {
                chartType: type,
                logicName: instanceAPI.name,
                logicBase: instanceAPI.base && instanceAPI.base.name,
                defaultSeriesType: instanceAPI.defaultSeriesType
            }, chartObj);

            // Get the chart JSON from the theme instance if it is defined on the chart else
            // fetch it from the transcoder.
            dataComp = (chartObj.jsVars && chartObj.jsVars.themeObject &&
                chartObj.jsVars.themeObject.getThemedJSONData()) ||
                chartObj.getChartData(global.dataFormats.JSON, true);
            dataObj = dataComp.data;

            // if chart will show data parse error
            if (dataComp.error instanceof Error) {
                chartObj._chartMessageStyle = {
                    fontFamily: args.dataInvalidMessageFont || chartOptions.baseChartMessageFont,
                    fontSize: args.dataInvalidMessageFontSize || chartOptions.baseChartMessageFontSize,
                    color: args.dataInvalidMessageColor || chartOptions.baseChartMessageColor
                };
                hcJSON = new CreateDialog(container, chartOptions.dataInvalidMessage, chartObj);
                hasNativeMessage = vars.hasNativeMessage = true;
                // set the data-ready flag to false.
                chartObj.__state.dataReady = false;
                if (!suppressDataEvents) {
                    /**
                     * When a chart attempts to render, it fetches data that has been set on it. In case no data was
                     * provided prior to rendering, or in case the data provided had errors in parsing or fetching
                     * from server, this event is raised.
                     *
                     * Maps, realtime charts and some gauges do not require initial data to begin with. Those charts
                     * will not raise this event if no data was set.
                     * @event FusionCharts#dataInvalid
                     *
                     * @param {Error} error - The error that caused the rendering to stop.
                     * @since 3.4.0
                     */
                    global.raiseEvent('dataInvalid', {
                        error: dataComp.error
                    }, vars.fcObj, undefined, function () {
                        /**
                         * DataXMLInvalid is fired if the data passed either by url or string to the chart object is
                         * not in an usable format.
                         * @event FusionCharts#dataXMLInvalid
                         * @deprecated Since 3.4. Use alternative 'dataInvalid' event.
                         */
                        lib.raiseEvent('dataxmlinvalid', {}, chartObj, [chartObj.id]);
                    });

                }
            }
            //convert the chart's JSON into HC compatable data
            else {
                if (!suppressDataEvents) {
                    /**
                     * Before a chart is rendered, the data needs to be loaded to plot the data on the chart.
                     * `DataLoaded` event is fired after the data passed either by url or string is loaded to the
                     * chart object. This event assures that the data passed is valid and the chart can now be rendered.
                     * It can be used to further process data in any other components in your page.
                     * @event FusionCharts#dataLoaded
                     */
                    lib.raiseEvent('dataloaded', {}, chartObj, [chartObj.id]);
                }

                // convert it into HC data
                hcJSON = instanceAPI.init(container, dataObj, chartObj, callback);
                instanceAPI.inited = true;
                vars.previousDrawCount = vars.drawCount; // store old drawcount
                vars.drawCount += 1;

                //if no data to display
                /** @todo have to check all condition where chart will show the nodata msg
                we may use flag during convertation to made it eseare */
                if (hcJSON.series.length === 0) {
                    chartObj._chartMessageStyle = {
                        fontFamily: args.dataEmptyMessageFont || chartOptions.baseChartMessageFont,
                        fontSize: args.dataEmptyMessageFontSize || chartOptions.baseChartMessageFontSize,
                        color: args.dataEmptyMessageColor || chartOptions.baseChartMessageColor
                    };
                    hcJSON = new CreateDialog(container, chartOptions.dataEmptyMessage, chartObj);
                    hasNativeMessage = vars.hasNativeMessage = true;
                    // set the data-ready flag to false.
                    chartObj.__state.dataReady = false;
                    if (!suppressDataEvents) {
                        /**
                         * Before rendering a chart into a container, the data has to be loaded. In case the
                         * `dataSource` of the chart is empty or has no data, then the `noDataToDisplay` event is fired.
                         * It can be used to show an error message to user, or to take a corrective measure.
                         * @event FusionCharts#noDataToDisplay
                         */
                        lib.raiseEvent('nodatatodisplay', {}, chartObj, [chartObj.id]);
                    }
                }
                else {
                    chartObj.__state.dataReady = true;
                    hasNativeMessage = vars.hasNativeMessage = false;
                    delete vars.message;
                }
            }
        }

        if (!hcJSON) {
            chartObj._chartMessageStyle = {
                fontFamily: chartOptions.baseChartMessageFont,
                fontSize: chartOptions.baseChartMessageFontSize,
                color: chartOptions.baseChartMessageColor
            };
            hcJSON = new CreateDialog(container, 'Error rendering chart {0x01}', chartObj);
            hasNativeMessage = vars.hasNativeMessage = true;
        }

        // Special init for stub
        if (hasNativeMessage && !instanceAPI.inited) {
            instanceAPI.init(container, dataObj, chartObj, callback);
        }

        // configure container
        hcJSON.chart = hcJSON.chart || {};
        //hcJSON.chart.renderTo = container;

        /** @todo remove storing of iapi inside hcJSON */
        // store chart api
        // hcJSON.instanceAPI = instanceAPI;

        // configure the credit label
        hcJSON.credits = hcJSON.credits || {};
        hcJSON.credits.enabled = api && api.creditLabel === true ? true : false;

        // predisable animation (when sent as create-chart param during resize)
        if (animate === false) {
            hcJSON.chart.animation = false;

            (hcJSON.plotOptions || (hcJSON.plotOptions = {})) &&
                (hcJSON.plotOptions.series || (hcJSON.plotOptions.series = {}));
            hcJSON.plotOptions.series.animation = false;
        }

        // Check / set bgColor
        if (container.style) {
            hcJSON.chart.containerBackgroundColor = lib.getContainerBackgroundColor(chartObj);
        }

        return instanceAPI.draw(hcJSON, callback);
    };


    //// add the base
    chartAPI('base', {
        useScaleRecursively: true,
        tooltipConstraint : 'chart',
        rendererId: 'root',
        canvasPaddingModifiers: ['anchor', 'anchorlabel'],
        drawAnnotations: true,

        draw: function (options, callback) {
            var logic = this,
                renderer = logic.renderer;

            if (!renderer) {
                renderer = logic.renderer = new ChartAPI('renderer.' + logic.rendererId);
            }

            logic.updateDefaultAnnotations();
            return renderer.init(logic, options, callback);
        },

        init: function (container, dataObj) {

            var iapi = this,
                chartObj = iapi.chartInstance || arguments[2], // legacy
                vars = chartObj.jsVars,
                reflowData = vars._reflowData || (vars._reflowData = {}),
                reflowClean = vars._reflowClean,
                chartOptions = chartObj.options,
                args = chartOptions.args,
                reflowJSON,
                chartAttrs,
                hcJSON;

            //clone FC data so that any modiffication on it will not effect the original
            iapi.dataObj = dataObj = extend2({}, dataObj);

            // Clone the chart obj from graph or blank object
            chartAttrs = dataObj.chart = (dataObj.chart || dataObj.graph ||
                    dataObj.map || {});
            delete dataObj.graph;
            delete dataObj.map;

            // restore state data
            if (reflowData && !iapi.stateless) {
                reflowJSON = reflowData.hcJSON;
                delete reflowData.hcJSON;
                extend2(iapi, reflowData, true);
                iapi.preReflowAdjustments &&
                    iapi.preReflowAdjustments.call(this);
                reflowData.hcJSON = reflowJSON;
                reflowJSON = null;
            }


            iapi.containerElement = container;
            iapi.config = {};

            iapi.smartLabel = vars.smartLabel;
            iapi.smartLabel.useEllipsesOnOverflow(pluckNumber(chartAttrs.useellipseswhenoverflow,
                    chartAttrs.useellipsewhenoverflow, 1));

            iapi.colorManager = new lib.colorManager(dataObj, iapi);

            iapi.linkClickFN = getLinkAction(dataObj, chartObj);

            iapi.numberFormatter = new NumberFormatter(dataObj.chart, iapi);

            if (!iapi.standaloneInit) {
                chartObj._chartMessageStyle = {
                    fontFamily: args.typeNotSupportedMessageFont || chartOptions.baseChartMessageFont,
                    fontSize: args.typeNotSupportedMessageFontSize || chartOptions.baseChartMessageFontSize,
                    color: args.typeNotSupportedMessageColor || chartOptions.baseChartMessageColor
                };
                return new lib.createDialog(container, chartOptions.typeNotSupportedMessage, chartObj);
            }

            //call the chart conf function
            hcJSON = iapi.chart(container.offsetWidth || parseFloat(container.style.width),
                container.offsetHeight || parseFloat(container.style.height), chartObj);

            if (reflowData && !iapi.stateless) {
                if (reflowData.hcJSON) {
                    extend2(hcJSON, reflowData.hcJSON, true);
                }
                iapi.postReflowAdjustments &&
                        iapi.postReflowAdjustments.call(this);
                // delete cleaned data
                if (reflowClean && iapi.cleanedData) {
                    iapi.cleanedData(iapi, reflowClean);
                    iapi.cleanedData(reflowData, reflowClean);//delete all updates also
                }
            }

            return hcJSON;
        },

        postSpaceManager: function () {
            var logic = this,
                hcJSON = logic.hcJSON,
                conf = hcJSON._FCconf,
                optionsChart = hcJSON.chart,
                marginLeft = optionsChart.marginLeft,
                marginRight = optionsChart.marginRight,
                mLeft = optionsChart.spacingLeft,
                mRight = optionsChart.spacingRight,
                canvasWidth = conf.width - marginLeft - marginRight,
                optionsCap = hcJSON.title,
                optionsSubCap = hcJSON.subtitle,
                width = conf.width,
                capAlign = optionsCap.align,
                captionX = optionsCap.x,
                hPadding = optionsCap.horizontalPadding,
                alignWtCanvas = optionsCap.alignWithCanvas,
                canvasCentre = (mathRound(marginLeft) || 0) + (pluckNumber(canvasWidth, width) / 2),
                snapLiterals = logic.snapLiterals || (logic.snapLiterals = {}),
                canvasCaptionGap,
                canvasSubCaptionGap,
                captionWidth = optionsCap._captionWidth,
                subCaptionWidth = optionsSubCap._subCaptionWidth,
                captionLineHeight = optionsCap._lineHeight,
                subCaptionLineHeight = optionsSubCap._lineHeight,
                interCaptionGap = 2,
                hasCaption = optionsCap.text;

            // calculate caption x position after space management if it is
            // not calculated yet, most of the widgets caption x is already calculated
            // in their space managers
            // captions are center aligned with respect to canvas and we
            // position them (cap and subcap) vertically one after another
            // and keep their v-align as top.
            // Calculate caption alignment and x value, this calculation
            // will also work for sub-caption

            if (captionX === undefined) {
                switch (capAlign) {
                case POSITION_RIGHT :
                    captionX = alignWtCanvas ? width - optionsChart.marginRight - hPadding :
                        width - hPadding;
                    break;
                case POSITION_LEFT :
                    captionX = alignWtCanvas ? optionsChart.marginLeft + hPadding : hPadding;
                    break;
                default :
                    captionX = alignWtCanvas ? canvasCentre : (mLeft + ((width - mLeft - mRight) * 0.5) ||
                        (width / 2));
                }
                if (optionsCap.align === POSITION_LEFT) {
                    canvasCaptionGap = 0;
                    canvasSubCaptionGap = 0;
                    optionsCap.align = POSITION_START;
                }
                else if (optionsCap.align === POSITION_RIGHT) {
                    canvasCaptionGap = captionWidth;
                    canvasSubCaptionGap = subCaptionWidth;
                    optionsCap.align = POSITION_END;
                }
                else {
                    canvasCaptionGap = captionWidth/ 2;
                    canvasSubCaptionGap = subCaptionWidth/ 2;
                    optionsCap.align = POSITION_MIDDLE;
                }
                optionsCap.x = captionX;
                optionsCap.y = optionsCap.y || optionsChart.spacingTop || 0;
                optionsSubCap.y = hasCaption ?
                            (optionsCap.y + captionLineHeight + interCaptionGap) :
                            (optionsCap.y || optionsChart.spacingTop || 0);

                snapLiterals.captionstartx = captionX - canvasCaptionGap - 2;
                snapLiterals.captionwidth = captionWidth + 4;
                snapLiterals.captionendx = snapLiterals.captionstartx + snapLiterals.captionwidth;
                snapLiterals.captionstarty = (optionsCap.y || 0 );
                snapLiterals.captionheight = captionLineHeight + 2;
                snapLiterals.captionendy = snapLiterals.captionstarty + snapLiterals.captionheight;
                snapLiterals.subcaptionstartx = captionX - canvasSubCaptionGap - 2;
                snapLiterals.subcaptionwidth = subCaptionWidth + 4;
                snapLiterals.subcaptionendx = snapLiterals.subcaptionstartx + snapLiterals.subcaptionwidth;
                snapLiterals.subcaptionstarty = (optionsSubCap.y || 0);
                snapLiterals.subcaptionheight = subCaptionLineHeight + 2;
                snapLiterals.subcaptionendy = snapLiterals.subcaptionstarty + snapLiterals.subcaptionheight;
            }
        },

        chart: function (width, height) {
            var iapi = this,
                chartName = iapi.name,
                obj = iapi.dataObj,
                FCChartObj = obj.chart,
                colorM = this.colorManager,
                hc,
                is3d,
                zeroPlaneColor,
                zeroPlaneAlpha,
                stack100percent,
                smartLabel,
                isPie,
                defaultSeries = iapi.defaultSeriesType,
                conf,
                isBar,
                plotOptions,
                showBorder,
                showCanvasBorder,
                palleteString,
                isRoundEdges,
                xAxis,
                HCChartObj,
                fontBdrColor,
                snapLiterals,
                marginTop,
                marginBottom,
                marginLeft,
                marginRight,
                paletteIndex,
                inCanfontFamily,
                inCanfontSize,
                inCancolor,
                outCanfontFamily,
                fontSize,
                outCanfontSize,
                outCancolor,
                outCanLineHeight,
                inCanLineHeight,
                axisTitleLineHeight,
                baseFontSize,
                legendCaptionFontSize,
                legendItemFont,
                legendFontSize,
                legendFontColor,
                legendItenFontWeight,
                bgImageDisplayMode,
                bgImageVAlign,
                bgImageHAlign,
                TILE,
                FILL,
                FIT,
                toolbar,
                button,
                bSymbolPadding,
                bPosition,
                bHAlign,
                bVAlign,
                vDirection,
                hDirection,
                divLineColor,
                divLineAlpha,
                divLineThickness,
                divLineIsDashed,
                divLineDashLen,
                divLineDashGap,
                showPercentValues,
                canBGColor,
                showPercentInToolTip,
                canBGAlpha,
                showCanvasBG,
                tooltipStyle,
                plotSpacePercent,
                drawQuadrant,
                xMin,
                xMax,
                yMin,
                yMax,
                quadrantXVal,
                quadrantYVal,
                vDivLineThickness,
                vDivLineIsDashed,
                vDivLineDashLen,
                vDivLineDashGap,
                quadrantLineColor,
                quadrantLineThickness,
                quadrantLineIsDashed,
                quadrantLineDashLen,
                quadrantLineDashGap,
                quadrantLabelTL,
                quadrantLabelTR,
                quadrantLabelBL,
                quadrantLabelBR,
                quadrantLabelPadding,
                dashStyle,
                canvasWidth,
                canvasHeight,
                labelWidthPart1,
                labelWidthPart2,
                labelHeightPart1,
                labelHeightPart2,
                smartText,
                inCanvasStyle,
                top1,
                top2,
                left1,
                left2,
                showVerticalDivLines,
                numVDivLines,
                vDivLineColor,
                vDivLineAlpha,
                min,
                catLength,
                max,
                value,
                gridInterval,
                drawAltGrid,
                lastValue,
                alternateVGridColor,
                showAlternateVGridColor;

            //set the default tooltip charecter seperator if not defined
            // We don't need to set 'tooltipsepchar' here
            //obj.chart.tooltipsepchar = pluck(FCChartObj.tooltipsepchar, COMMASTRING);

            //creade defaule stub
            hc = hcStub(obj, width, height, this);
            // HighChart Chart object
            HCChartObj = hc.chart;
            //HighChart xAxis
            xAxis = hc.xAxis;
            //HighChart conf obj
            conf = hc[FC_CONFIG_STRING];

            //create store for anotation macro.
            if (!iapi.snapLiterals){
                iapi.snapLiterals = {};
            }
            snapLiterals = iapi.snapLiterals;
            //add macros
            snapLiterals.chartstartx  = 0;
            snapLiterals.chartstarty = 0;
            snapLiterals.chartwidth = width;
            snapLiterals.chartheight = height;
            snapLiterals.chartendx = width;
            snapLiterals.chartendy = height;
            snapLiterals.chartcenterx = width / 2;
            snapLiterals.chartcentery = height / 2;
            snapLiterals.chartbottommargin = HCChartObj.spacingBottom;
            snapLiterals.chartleftmargin = HCChartObj.spacingLeft;
            snapLiterals.chartrightmargin = HCChartObj.spacingRight;
            snapLiterals.charttopmargin = HCChartObj.spacingTop;

            iapi.updateSnapPoints && iapi.updateSnapPoints();

            if (iapi.postHCJSONCreation) {
                iapi.postHCJSONCreation.call(iapi, hc);
            }
            global.raiseEvent('internal.postlogic', iapi, iapi.chartInstance);

            //create the smartLabel instance
            hc.labels.smartLabel = smartLabel = conf.smartLabel = this.smartLabel;
            //save the width and height
            conf.width = width;
            conf.height = height;
            plotOptions = hc.plotOptions;


            conf.isDual = this.isDual;
            //create the numberformatter instance
            conf.numberFormatter = this.numberFormatter;
            //create the numberformatter instance
            conf.axisGridManager = new AxisLabelAdder (defaultSeries, FCChartObj);
            //store all tooltext related attributes in conf
            conf.tooltext = FCChartObj.plottooltext;
            conf.trendLineToolText = FCChartObj.trendlinetooltext;

            //is the chart 3d
            HCChartObj.is3D = is3d = conf.is3d = /3d$/.test(defaultSeries);
            HCChartObj.isBar = isBar = conf.isBar = this.isBar;
            isPie = /^pie/.test(defaultSeries);

            // If roundedges is enabled
            isRoundEdges = FCChartObj.useroundedges == 1,
            // Whether the cosmetics is to use 3D
            palleteString = is3d ? chartPaletteStr.chart3D : chartPaletteStr.chart2D;
            //save the FC Linkclick function
            HCChartObj.events.click = hc.plotOptions.series.point.events.click = this.linkClickFN;

            //fiend defaultseries type depemding upon chart's name
            HCChartObj.defaultSeriesType = defaultSeries;
            ////palette////
            paletteIndex = FCChartObj.palette > 0 && FCChartObj.palette < 6 ?
                FCChartObj.palette : pluckNumber(this.paletteIndex, 1);
            ////reduce by 1 for array positining
            paletteIndex -= 1;
            //save the palette index for further reference
            HCChartObj.paletteIndex = paletteIndex;

            // Flag to use per-point datalabel color
            HCChartObj.usePerPointLabelColor = FCChartObj.colorlabelsfromplot == ONESTRING;

            // To sync anchorHoverRadius and data label in line and area type of chart
            HCChartObj.syncLabelWithAnchor = pluckNumber(FCChartObj.synclabelwithanchoronhover, 1);

            // If we're plotting round edges, we necessarily apply shadow
            // To give the contrasting effect.
            HCChartObj.useRoundEdges = (isRoundEdges && !is3d && !this.distributedColumns &&
                this.defaultSeriesType !== 'pie');

            // Full Chart as a hotspot
            if (pluck(FCChartObj.clickurl) !== undefined) {
                HCChartObj.link = FCChartObj.clickurl;
                HCChartObj.style.cursor = 'pointer';
                //change the point Click event ot make similar as FC
                hc.plotOptions.series.point.events.click = function () {
                    HCChartObj.events.click.call({
                        link : FCChartObj.clickurl
                    });
                };
            }

            //////////Chart font style////////////////////
            inCanfontFamily = pluck(FCChartObj.basefont, 'Verdana,sans');
            inCanfontSize =  pluckFontSize(FCChartObj.basefontsize, 10);
            inCancolor = pluck(FCChartObj.basefontcolor, colorM.getColor(palleteString.baseFontColor));
            outCanfontFamily = pluck(FCChartObj.outcnvbasefont, inCanfontFamily);
            fontSize = pluckFontSize(FCChartObj.outcnvbasefontsize, inCanfontSize);
            outCanfontSize = fontSize + PXSTRING;
            outCancolor = pluck(FCChartObj.outcnvbasefontcolor, inCancolor).replace(/^#?([a-f0-9]+)/ig, '#$1');
            baseFontSize = inCanfontSize;
            inCanfontSize =  inCanfontSize + PXSTRING;
            inCancolor = inCancolor.replace(/^#?([a-f0-9]+)/ig, '#$1');

            //create style for tredn tendtext
            //save it in the hc JSON for ferther refrence
            /** @todo replace trendStyle as outcanvasStyle */
            conf.trendStyle = conf.outCanvasStyle = {
                fontFamily: outCanfontFamily,
                color: outCancolor,
                fontSize:  outCanfontSize
            };
            outCanLineHeight = setLineHeight(conf.trendStyle);

            conf.inCanvasStyle = {
                fontFamily: inCanfontFamily,
                fontSize:  inCanfontSize,
                color: inCancolor
            };

            inCanLineHeight = setLineHeight(conf.inCanvasStyle);
            conf.divlineStyle = {
                fontFamily: inCanfontFamily,
                fontSize:  inCanfontSize,
                color: inCancolor,
                lineHeight : inCanLineHeight
            };

            xAxis.labels.style = {//style for x axis
                fontFamily: pluck(FCChartObj.labelfont, outCanfontFamily),
                fontSize:  pluckNumber(FCChartObj.labelfontsize, fontSize) + PXSTRING,
                color: pluck(FCChartObj.labelfontcolor, outCancolor)
            };
            xAxis.labels.style.lineHeight = setLineHeight(xAxis.labels.style);

            xAxis.steppedLabels.style = {//style for x axis
                fontFamily: outCanfontFamily,
                fontSize:  outCanfontSize,
                lineHeight : outCanLineHeight,
                color: outCancolor,
                visibility: 'hidden'
            };
            //style for pyasis
            hc.yAxis[0].labels.style = {
                fontFamily: outCanfontFamily,
                fontSize:  outCanfontSize,
                lineHeight : outCanLineHeight,
                color: outCancolor
            };
            //style for syaxis
            hc.yAxis[1].labels.style = {
                fontFamily: outCanfontFamily,
                fontSize:  outCanfontSize,
                lineHeight : outCanLineHeight,
                color: outCancolor
            };

            legendItemFont = pluck(FCChartObj.legenditemfont, outCanfontFamily);
            legendFontSize = pluckFontSize(FCChartObj.legenditemfontsize, fontSize);
            legendFontColor = pluck(FCChartObj.legenditemfontcolor, outCancolor).replace(/^#?([a-f0-9]+)/ig, '#$1');
            legendItenFontWeight = styleValueMap.fontWeight[pluckNumber(FCChartObj.legenditemfontbold, 0)] || '';
            legendCaptionFontSize = pluckFontSize(FCChartObj.legendcaptionfontsize, fontSize) + PXSTRING;
            legendFontSize = legendFontSize + PXSTRING;
            //legend
            hc.legend.itemStyle = {
                fontFamily: legendItemFont,
                fontSize:  legendFontSize,
                color: legendFontColor,
                fontWeight: legendItenFontWeight
            };
            setLineHeight(hc.legend.itemStyle);
            hc.legend.itemHiddenStyle = {
                fontFamily: legendItemFont,
                fontSize:  legendFontSize,
                color: pluck(FCChartObj.legenditemhiddencolor, 'cccccc').replace(/^#?([a-f0-9]+)/ig, '#$1'),
                fontWeight: legendItenFontWeight
            };
            setLineHeight(hc.legend.itemHiddenStyle);
            /** @note: to avoid spacemanagement issues on hover we allow to set hover-color only */
            hc.legend.itemHoverStyle = {
                color: pluck(FCChartObj.legenditemhoverfontcolor, legendFontColor).replace(/^#?([a-f0-9]+)/ig, '#$1')
            };
            hc.legend.title.style = {
                fontFamily: pluck(FCChartObj.legendcaptionfont, legendItemFont),
                fontSize:  legendCaptionFontSize,
                color: pluck(FCChartObj.legendcaptionfontcolor, outCancolor).replace(/^#?([a-f0-9]+)/ig, '#$1'),
                fontWeight: styleValueMap.fontWeight[pluckNumber(FCChartObj.legendcaptionfontbold, 1)] || ''
            };
            setLineHeight(hc.legend.title.style);

            hc.legend.title.align = TEXT_ANCHOR_MAP[FCChartObj.legendcaptionalignment &&
                        FCChartObj.legendcaptionalignment.toLowerCase() || POSITION_CENTER] || TEXT_ANCHOR_MAP.center;

            ///datalabels
            fontBdrColor = getFirstValue(FCChartObj.valuebordercolor,
                BLANKSTRING);
            fontBdrColor = fontBdrColor ? convertColor(
                fontBdrColor, pluckNumber(FCChartObj.valueborderalpha,
                FCChartObj.valuealpha, 100)) : BLANKSTRING;

            hc.plotOptions.series.dataLabels.style = {
                fontFamily: pluck(FCChartObj.valuefont, inCanfontFamily),
                fontSize: pluck(FCChartObj.valuefontsize, pInt(inCanfontSize, 10)) + PXSTRING,
                lineHeight: inCanLineHeight,
                color: convertColor(pluck(FCChartObj.valuefontcolor, inCancolor),
                    pluckNumber(FCChartObj.valuefontalpha,
                    FCChartObj.valuealpha, 100)),
                fontWeight: pluckNumber(FCChartObj.valuefontbold) ? 'bold' :
                    'normal',
                fontStyle: pluckNumber(FCChartObj.valuefontitalic) ? 'italic' :
                    'normal',
                // Set border as empty string when not required,
                // since IE will stop js execution if it is undefined or null.
                border: fontBdrColor || FCChartObj.valuebgcolor ?
                    (pluckNumber(FCChartObj.valueborderthickness, 1) + 'px solid') : '',
                borderColor: fontBdrColor,
                borderThickness: pluckNumber(FCChartObj.valueborderthickness, 1),
                borderPadding: pluckNumber(FCChartObj.valueborderpadding, 2),
                borderRadius: pluckNumber(FCChartObj.valueborderradius, 0),
                backgroundColor: FCChartObj.valuebgcolor ?
                    convertColor(FCChartObj.valuebgcolor,
                    pluckNumber(FCChartObj.valuebgalpha, FCChartObj.valuealpha,
                    100)) : BLANKSTRING,
                borderDash: pluckNumber(FCChartObj.valueborderdashed, 0) ?
                    getDashStyle(pluckNumber(FCChartObj.valueborderdashlen, 4),
                    pluckNumber(FCChartObj.valueborderdashgap, 2),
                    pluckNumber(FCChartObj.valueborderthickness, 1)) : UNDEFINED
            };
            setLineHeight(hc.plotOptions.series.dataLabels.style);
            //special attr for datalabels color
            /** @todo Do this after the style tag parsing. */
            hc.plotOptions.series.dataLabels.color = hc.plotOptions.series.dataLabels.style.color;
            ///tooltip
            hc.tooltip.style = {
                fontFamily: inCanfontFamily,
                fontSize:  inCanfontSize,
                lineHeight : inCanLineHeight,
                color: inCancolor
            };

            //set the caption font style
            hc.title.style = {
                fontFamily: pluck(FCChartObj.captionfont, outCanfontFamily),
                color: pluck(FCChartObj.captionfontcolor, outCancolor).
                    replace(/^#?([a-f0-9]+)/ig, '#$1'),
                fontSize: pluckNumber(FCChartObj.captionfontsize, (fontSize + 3)) + PXSTRING,
                fontWeight: pluckNumber(FCChartObj.captionfontbold) === 0 ? 'normal' : 'bold'
            };
            hc.title.align = pluck(FCChartObj.captionalignment, POSITION_CENTER);
            hc.title.isOnTop = pluckNumber(FCChartObj.captionontop, 1);
            hc.title.alignWithCanvas = pluckNumber(FCChartObj.aligncaptionwithcanvas, iapi.alignCaptionWithCanvas, 1);
            hc.title.horizontalPadding = pluckNumber(FCChartObj.captionhorizontalpadding,
                (hc.title.alignWithCanvas ? 0 : 15));
            setLineHeight(hc.title.style);

            hc.subtitle.style = {
                fontFamily: pluck(FCChartObj.subcaptionfont, FCChartObj.captionfont, outCanfontFamily),
                color: pluck(FCChartObj.subcaptionfontcolor, FCChartObj.captionfontcolor, outCancolor).
                    replace(/^#?([a-f0-9]+)/ig, '#$1'),
                fontSize: (pluckNumber(
                    FCChartObj.subcaptionfontsize,
                        (pluckNumber(mathMax(pluckNumber(FCChartObj.captionfontsize) - 3, -1), fontSize) +
                        pluckNumber(this.subTitleFontSizeExtender, 1))
                    ) + PXSTRING),
                fontWeight: pluckNumber(FCChartObj.subcaptionfontbold, this.subTitleFontWeight,
                    FCChartObj.captionfontbold) === 0 ? 'normal' : 'bold'
            };

            // Maintaining redundancy for now so that the drawing depends on these attributes, that can be overriden in
            // the future.
            hc.subtitle.align = hc.title.align;
            hc.subtitle.isOnTop = hc.title.isOnTop;
            hc.subtitle.alignWithCanvas = hc.title.alignWithCanvas;
            hc.subtitle.horizontalPadding = hc.title.horizontalPadding;
            setLineHeight(hc.subtitle.style);

            //set the style for the xAxis name
            ///datalabels
            fontBdrColor = getFirstValue(FCChartObj.xaxisnamebordercolor,
                BLANKSTRING);
            fontBdrColor = fontBdrColor ? convertColor(
                fontBdrColor, pluckNumber(FCChartObj.xaxisnameborderalpha,
                FCChartObj.xaxisnamealpha, 100)) : BLANKSTRING;
            xAxis.title.style = {
                fontFamily: pluck(FCChartObj.xaxisnamefont, outCanfontFamily),
                fontSize: pluck(FCChartObj.xaxisnamefontsize, pInt(outCanfontSize)) + PXSTRING,
                color: convertColor(pluck(FCChartObj.xaxisnamefontcolor, outCancolor),
                    pluckNumber(FCChartObj.xaxisnamefontalpha,
                    FCChartObj.xaxisnamealpha, 100)),
                fontWeight: pluckNumber(FCChartObj.xaxisnamefontbold, 1) ? 'bold' :
                    'normal',
                fontStyle: pluckNumber(FCChartObj.xaxisnamefontitalic) ? 'italic' :
                    'normal',
                border: fontBdrColor || FCChartObj.xaxisnamebgcolor ?
                    (pluckNumber(FCChartObj.xaxisnameborderthickness, 1) + 'px solid') :
                    undefined,
                borderColor: fontBdrColor,
                borderThickness: pluckNumber(FCChartObj.xaxisnameborderthickness, 1),
                borderPadding: pluckNumber(FCChartObj.xaxisnameborderpadding, 2),
                borderRadius: pluckNumber(FCChartObj.xaxisnameborderradius, 0),
                backgroundColor: FCChartObj.xaxisnamebgcolor ?
                    convertColor(FCChartObj.xaxisnamebgcolor,
                    pluckNumber(FCChartObj.xaxisnamebgalpha, FCChartObj.xaxisnamealpha,
                    100)) : BLANKSTRING,
                borderDash: pluckNumber(FCChartObj.xaxisnameborderdashed, 0) ?
                    getDashStyle(pluckNumber(FCChartObj.xaxisnameborderdashlen, 4),
                    pluckNumber(FCChartObj.xaxisnameborderdashgap, 2),
                    pluckNumber(FCChartObj.xaxisnameborderthickness, 1)) : UNDEFINED
            };
            setLineHeight(xAxis.title.style);

            //set the style for the primary yAxis name
            fontBdrColor = pluck(FCChartObj.pyaxisnamebordercolor,
                FCChartObj.yaxisnamebordercolor, BLANKSTRING);
            fontBdrColor = fontBdrColor ? convertColor(
                fontBdrColor, pluckNumber(FCChartObj.pyaxisnameborderalpha,
                FCChartObj.yaxisnameborderalpha, FCChartObj.pyaxisnamealpha,
                    FCChartObj.yaxisnamealpha, 100)) : BLANKSTRING;
            hc.yAxis[0].title.style = {
                fontFamily: pluck(FCChartObj.pyaxisnamefont,
                    FCChartObj.yaxisnamefont, outCanfontFamily),
                fontSize: pluck(FCChartObj.pyaxisnamefontsize,
                    FCChartObj.yaxisnamefontsize, pInt(outCanfontSize, 10)) + PXSTRING,
                color: convertColor(pluck(FCChartObj.pyaxisnamefontcolor,
                    FCChartObj.yaxisnamefontcolor, outCancolor),
                    pluckNumber(FCChartObj.pyaxisnamefontalpha,
                    FCChartObj.yaxisnamefontalpha, FCChartObj.pyaxisnamealpha,
                    FCChartObj.yaxisnamealpha, 100)),
                fontWeight: pluckNumber(FCChartObj.pyaxisnamefontbold,
                    FCChartObj.yaxisnamefontbold, 1) ? 'bold' :
                    'normal',
                fontStyle: pluckNumber(FCChartObj.pyaxisnamefontitalic,
                    FCChartObj.yaxisnamefontitalic) ? 'italic' :
                    'normal',
                border: fontBdrColor || FCChartObj.pyaxisnamebgcolor ||
                    FCChartObj.yaxisnamebgcolor ?
                    (pluckNumber(FCChartObj.pyaxisnameborderthickness,
                    FCChartObj.yaxisnameborderthickness, 1) + 'px solid') :
                    undefined,
                borderColor: fontBdrColor,
                borderThickness: pluckNumber(FCChartObj.pyaxisnameborderthickness,
                    FCChartObj.yaxisnameborderthickness, 1),
                borderPadding: pluckNumber(FCChartObj.pyaxisnameborderpadding,
                    FCChartObj.yaxisnameborderpadding, 2),
                borderRadius: pluckNumber(FCChartObj.pyaxisnameborderradius,
                    FCChartObj.yaxisnameborderradius, 0),
                backgroundColor: FCChartObj.pyaxisnamebgcolor || FCChartObj.yaxisnamebgcolor ?
                    convertColor(pluck(FCChartObj.pyaxisnamebgcolor, FCChartObj.yaxisnamebgcolor),
                    pluckNumber(FCChartObj.pyaxisnamebgalpha, FCChartObj.yaxisnamebgalpha,
                    FCChartObj.pyaxisnamealpha, FCChartObj.yaxisnamealpha,
                    100)) : BLANKSTRING,
                borderDash: pluckNumber(FCChartObj.pyaxisnameborderdashed, FCChartObj.yaxisnameborderdashed, 0) ?
                    getDashStyle(pluckNumber(FCChartObj.pyaxisnameborderdashlen, FCChartObj.yaxisnameborderdashlen, 4),
                    pluckNumber(FCChartObj.pyaxisnameborderdashgap,
                        FCChartObj.yaxisnameborderdashgap, 2),
                    pluckNumber(FCChartObj.pyaxisnameborderthickness, FCChartObj.yaxisnameborderthickness, 1)) :
                        UNDEFINED
            };
            setLineHeight(hc.yAxis[0].title.style);

            //set the style for the secinadry yAxis name
            hc.yAxis[1].title.style = {
                fontFamily: outCanfontFamily,
                color: outCancolor,
                fontSize:  outCanfontSize,
                lineHeight : axisTitleLineHeight,
                fontWeight: 'bold'
            };
            fontBdrColor = pluck(FCChartObj.syaxisnamebordercolor,
                FCChartObj.yaxisnamebordercolor, BLANKSTRING);
            fontBdrColor = fontBdrColor ? convertColor(
                fontBdrColor, pluckNumber(FCChartObj.syaxisnameborderalpha,
                FCChartObj.yaxisnameborderalpha, FCChartObj.syaxisnamealpha,
                    FCChartObj.yaxisnamealpha, 100)) : BLANKSTRING;

            hc.yAxis[1].title.style = {
                fontFamily: pluck(FCChartObj.syaxisnamefont,
                    FCChartObj.yaxisnamefont, outCanfontFamily),
                fontSize: pluck(FCChartObj.syaxisnamefontsize,
                    FCChartObj.yaxisnamefontsize, pInt(outCanfontSize, 10)) + PXSTRING,
                color: convertColor(pluck(FCChartObj.syaxisnamefontcolor,
                    FCChartObj.yaxisnamefontcolor, outCancolor),
                    pluckNumber(FCChartObj.syaxisnamefontalpha,
                    FCChartObj.yaxisnamefontalpha, FCChartObj.syaxisnamealpha,
                    FCChartObj.yaxisnamealpha, 100)),
                fontWeight: pluckNumber(FCChartObj.syaxisnamefontbold,
                    FCChartObj.yaxisnamefontbold, 1) ? 'bold' :
                    'normal',
                fontStyle: pluckNumber(FCChartObj.syaxisnamefontitalic,
                    FCChartObj.yaxisnamefontitalic) ? 'italic' :
                    'normal',
                border: fontBdrColor || FCChartObj.syaxisnamebgcolor ||
                    FCChartObj.yaxisnamebgcolor ?
                    (pluckNumber(FCChartObj.syaxisnameborderthickness,
                    FCChartObj.yaxisnameborderthickness, 1) + 'px solid') :
                    undefined,
                borderColor: fontBdrColor,
                borderThickness: pluckNumber(FCChartObj.syaxisnameborderthickness,
                    FCChartObj.yaxisnameborderthickness, 1),
                borderPadding: pluckNumber(FCChartObj.syaxisnameborderpadding,
                    FCChartObj.yaxisnameborderpadding, 2),
                borderRadius: pluckNumber(FCChartObj.syaxisnameborderradius,
                    FCChartObj.yaxisnameborderradius, 0),
                backgroundColor: FCChartObj.syaxisnamebgcolor || FCChartObj.yaxisnamebgcolor ?
                    convertColor(pluck(FCChartObj.syaxisnamebgcolor, FCChartObj.yaxisnamebgcolor),
                    pluckNumber(FCChartObj.syaxisnamebgalpha, FCChartObj.yaxisnamebgalpha,
                    FCChartObj.syaxisnamealpha, FCChartObj.yaxisnamealpha,
                    100)) : BLANKSTRING,
                borderDash: pluckNumber(FCChartObj.syaxisnameborderdashed,
                    FCChartObj.yaxisnameborderdashed, 0) ?
                    getDashStyle(pluckNumber(FCChartObj.syaxisnameborderdashlen, FCChartObj.yaxisnameborderdashlen, 4),
                    pluckNumber(FCChartObj.syaxisnameborderdashgap,
                        FCChartObj.yaxisnameborderdashgap, 2),
                    pluckNumber(FCChartObj.syaxisnameborderthickness, FCChartObj.yaxisnameborderthickness, 1)) :
                        UNDEFINED
            };
            setLineHeight(hc.yAxis[1].title.style);

            HCChartObj.overlapColumns = pluckNumber(FCChartObj[isBar && 'overlapbars' || 'overlapcolumns'],
                is3d ? 0 : 1);

            //Annotations default style
            hc.orphanStyles = {
                defaultStyle: {
                    style: extend2({}, conf.inCanvasStyle)
                },
                connectorlabels: {
                    style: extend2({}, hc.plotOptions.series.dataLabels)
                },
                vyaxisname: {//for candle stick chart's volume axis
                    style: extend2({}, hc.yAxis[0].title.style)
                }
            };

            ///Heat-Map extra label's style
            hc.plotOptions.series.dataLabels.tlLabelStyle = {
                fontFamily:    getValidValue(FCChartObj.tlfont, inCanfontFamily),
                color: getFirstColor(getValidValue(FCChartObj.tlfontcolor, inCancolor)),
                fontSize: pluckFontSize(FCChartObj.tlfontsize, baseFontSize) + PX
            };
            // calculate line height
            setLineHeight(hc.plotOptions.series.dataLabels.tlLabelStyle);

            hc.plotOptions.series.dataLabels.trLabelStyle = {
                fontFamily:    getValidValue(FCChartObj.trfont, inCanfontFamily),
                color: getFirstColor(getValidValue(FCChartObj.trfontcolor, inCancolor)),
                fontSize: pluckFontSize(FCChartObj.trfontsize, baseFontSize) + PX
            };
            // calculate line height
            setLineHeight(hc.plotOptions.series.dataLabels.trLabelStyle);

            hc.plotOptions.series.dataLabels.blLabelStyle = {
                fontFamily: getValidValue(FCChartObj.blfont, inCanfontFamily),
                color: getFirstColor(getValidValue(FCChartObj.blfontcolor, inCancolor)),
                fontSize: pluckFontSize(FCChartObj.blfontsize, baseFontSize) + PX
            };
            // calculate line height
            setLineHeight(hc.plotOptions.series.dataLabels.blLabelStyle);

            hc.plotOptions.series.dataLabels.brLabelStyle = {
                fontFamily:    getValidValue(FCChartObj.brfont, inCanfontFamily),
                color: getFirstColor(getValidValue(FCChartObj.brfontcolor, inCancolor)),
                fontSize: pluckFontSize(FCChartObj.brfontsize, baseFontSize) + PX
            };
            // calculate line height
            setLineHeight(hc.plotOptions.series.dataLabels.brLabelStyle);

            //////set styles//////////
            this.parseStyles(hc);

            //after applying the style do the


            // Deleting background style for not to effect the background cosmetics
            // for 3.2.2 relelease.
            delete hc.xAxis.labels.style.backgroundColor;
            delete hc.xAxis.labels.style.borderColor;

            delete hc.yAxis[0].labels.style.backgroundColor;
            delete hc.yAxis[0].labels.style.borderColor;

            delete hc.yAxis[1].labels.style.backgroundColor;
            delete hc.yAxis[1].labels.style.borderColor;


            // Point configuration to show label tooltext and data values
            conf.showTooltip = pluckNumber(FCChartObj.showtooltip, this.showtooltip, 1);
            conf.tooltipSepChar = pluck(FCChartObj.tooltipsepchar, this.tooltipsepchar, COMMASPACE);
            conf.showValues = pluckNumber(FCChartObj.showvalues, this.showValues, 1);
            conf.seriesNameInToolTip = pluckNumber(FCChartObj.seriesnameintooltip, 1);

            conf.showVLines = pluckNumber(FCChartObj.showvlines, 1);
            conf.showVLinesOnTop = pluckNumber(FCChartObj.showvlinesontop, 0);
            conf.showVLineLabels = pluckNumber(FCChartObj.showvlinelabels, this.showVLineLabels, 1);
            conf.showVLineLabelBorder = pluckNumber(FCChartObj.showvlinelabelborder, 1);
            conf.rotateVLineLabels = pluckNumber(FCChartObj.rotatevlinelabels, 0);
            conf.vLineColor = pluck(FCChartObj.vlinecolor, '333333');
            conf.vLineLabelColor = pluck(FCChartObj.vlinelabelcolor);
            conf.vLineThickness = pluck(FCChartObj.vlinethickness, 1);
            conf.vLineAlpha = pluckNumber(FCChartObj.vlinealpha, 80);
            conf.vLineLabelBgColor = pluck(FCChartObj.vlinelabelbgcolor, 'ffffff');
            conf.vLineLabelBgAlpha = pluckNumber(FCChartObj.vlinelabelbgalpha, is3d ? 50 : 100);

            conf.trendlineColor = pluck(FCChartObj.trendlinecolor, '333333');
            conf.trendlineThickness = pluck(FCChartObj.trendlinethickness, 1);
            conf.trendlineAlpha = pluckNumber(FCChartObj.trendlinealpha);
            conf.showTrendlinesOnTop = pluck(FCChartObj.showtrendlinesontop, 0);
            conf.trendlineValuesOnOpp = pluck(FCChartObj.trendlinevaluesonopp, FCChartObj.trendlinevaluesonright, 0);
            conf.trendlinesAreDashed = pluckNumber(FCChartObj.trendlinesaredashed, 0);
            conf.trendlinesDashLen = pluckNumber(FCChartObj.trendlinedashlen, 5);
            conf.trendlinesDashGap = pluckNumber(FCChartObj.trendlinedashgap, 2);
            conf.showTrendlines = pluckNumber(FCChartObj.showtrendlines, 1);
            conf.showTrendlineLabels = pluckNumber(FCChartObj.showtrendlinelabels, this.showTrendlineLabels, 1);

            conf.flatScrollBars = pluckNumber(FCChartObj.flatscrollbars, 0);
            conf.scrollBar3DLighting = pluckNumber(FCChartObj.scrollbar3dlighting, 1);

            // hot/tracker threshold in pixels
            HCChartObj.anchorTrackingRadius = pluckNumber(FCChartObj.anchortrackingradius,
                hasTouch ? TOUCH_THRESHOLD_PIXELS : CLICK_THRESHOLD_PIXELS);

            /** @todo Apply Style Object */

            hc.plotOptions.series.connectNullData = pluckNumber(FCChartObj.connectnulldata, 0);
            // create the back-ground color
            ////Finaly Set the Plot and Background color[must be modifyed al last as margins may be changed any where]
            HCChartObj.backgroundColor = {
                FCcolor : {
                    color : pluck(FCChartObj.bgcolor, colorM.getColor(palleteString.bgColor)),
                    alpha : pluck(FCChartObj.bgalpha, colorM.getColor(palleteString.bgAlpha)),
                    angle : pluck(FCChartObj.bgangle, colorM.getColor(palleteString.bgAngle)),
                    ratio : pluck(FCChartObj.bgratio, colorM.getColor(palleteString.bgRatio))
                }
            };

            // Whether to rotate the values
            HCChartObj.rotateValues = pluckNumber(FCChartObj.rotatevalues, 0);

            // placevaluesinside
            HCChartObj.placeValuesInside = pluckNumber(FCChartObj.placevaluesinside, 0);

            // valuePosition for line and area
            HCChartObj.valuePosition = pluck(FCChartObj.valueposition, 'auto');

            // valuePosition for line and area
            HCChartObj.valuePadding = pluckNumber(FCChartObj.valuepadding, 2);

            // attribute to check whether canvas overflow should be managed or not
            HCChartObj.managePlotOverflow = pluckNumber(FCChartObj.manageplotoverflow , 1);

            HCChartObj.borderColor = convertColor(pluck(FCChartObj.bordercolor, is3d ? '#666666' :
                colorM.getColor('borderColor')),
            pluck(FCChartObj.borderalpha, is3d ? '100' : colorM.getColor('borderAlpha')));

            showBorder = pluckNumber(FCChartObj.showborder, is3d ? 0 : 1);
            HCChartObj.borderWidth = showBorder ? pluckNumber(FCChartObj.borderthickness, 1) : 0;
            HCChartObj.borderRadius = pluckNumber(FCChartObj.borderradius, 0);
            HCChartObj.borderDashStyle = pluckNumber(FCChartObj.borderdashed, 0) ?
                getDashStyle(pluckNumber(FCChartObj.borderdashlen, 4),
                pluckNumber(FCChartObj.borderdashgap, 2), HCChartObj.borderWidth) : undefined;

            HCChartObj.plotBorderColor = convertColor(pluck(FCChartObj.canvasbordercolor,
                colorM.getColor('canvasBorderColor')),
            pluck(FCChartObj.canvasborderalpha, colorM.getColor('canvasBorderAlpha')));
            if (FCChartObj.showcanvasborder !== '0') {
                showCanvasBorder = Boolean(pluck(FCChartObj.canvasborderthickness, isRoundEdges ? 0 : 1));
                //if any axis has its own line drawing we force canvas without border
                if(FCChartObj.showaxislines === '1' || FCChartObj.showxaxisline === '1' ||
                    FCChartObj.showyaxisline === '1' || FCChartObj.showsyaxisline === '1'){
                    //but we only force if user explicitly has not set border
                    (FCChartObj.showcanvasborder !== '1') &&  (showCanvasBorder = 0);
                }
            }

            HCChartObj.plotBorderWidth = is3d || !showCanvasBorder ? 0 : pluckNumber(FCChartObj.canvasborderthickness,
                                                                                     this.canvasborderthickness,
                                                                                     HCChartObj.useRoundEdges ? 1 : 2);
            // Chart background image
            /* Attributes for customize bg image
                bgImage (String)
                bgImageAlpha    (0-100)
                bgImageDisplayMode    (none, stretch, center, fill, fit, tile )
                bgImageVAlign    (top, middle, bottom)
                bgImageHAlign    (left, middle, right)
                bgImageScale    (0-300)
             */

            TILE = 'tile';
            FILL = 'fill';
            FIT = 'fit';

            HCChartObj.bgSWF = pluck(FCChartObj.bgimage, FCChartObj.bgswf);
            HCChartObj.bgSWFAlpha = pluckNumber(FCChartObj.bgimagealpha, FCChartObj.bgswfalpha, 100);
            // Set background swf param
            bgImageDisplayMode = pluck(FCChartObj.bgimagedisplaymode, 'none').toLowerCase();
            bgImageVAlign = getValidValue(FCChartObj.bgimagevalign, BLANKSTRING).toLowerCase();
            bgImageHAlign = getValidValue(FCChartObj.bgimagehalign, BLANKSTRING).toLowerCase();
            //when background mode is tile, fill and fit then default value of vertical alignment and horizontal
            //alignment will be middle and middle
            if (bgImageDisplayMode == TILE || bgImageDisplayMode == FILL || bgImageDisplayMode == FIT) {
                if (bgImageVAlign != POSITION_TOP && bgImageVAlign != POSITION_MIDDLE &&
                        bgImageVAlign != POSITION_BOTTOM) {
                    bgImageVAlign = POSITION_MIDDLE;
                }
                if (bgImageHAlign != POSITION_LEFT && bgImageHAlign != POSITION_MIDDLE &&
                        bgImageHAlign != POSITION_RIGHT) {
                    bgImageHAlign = POSITION_MIDDLE;
                }
            }
            else {
                if (bgImageVAlign != POSITION_TOP && bgImageVAlign != POSITION_MIDDLE &&
                        bgImageVAlign != POSITION_BOTTOM) {
                    bgImageVAlign = POSITION_TOP;
                }
                if (bgImageHAlign != POSITION_LEFT && bgImageHAlign != POSITION_MIDDLE &&
                        bgImageHAlign != POSITION_RIGHT) {
                    bgImageHAlign = POSITION_LEFT;
                }
            }
            HCChartObj.bgImageDisplayMode = bgImageDisplayMode;
            HCChartObj.bgImageVAlign = bgImageVAlign;
            HCChartObj.bgImageHAlign = bgImageHAlign;
            HCChartObj.bgImageScale = pluckNumber(FCChartObj.bgimagescale, 100);


            // LOGO URL (foreground) logo parameters
            HCChartObj.logoURL = getValidValue(FCChartObj.logourl);
            HCChartObj.logoPosition = pluck(FCChartObj.logoposition, 'tl').toLowerCase();
            HCChartObj.logoAlpha = pluckNumber(FCChartObj.logoalpha, 100);
            HCChartObj.logoLink = getValidValue(FCChartObj.logolink);
            HCChartObj.logoScale = pluckNumber(FCChartObj.logoscale, 100);
            HCChartObj.logoLeftMargin = pluckNumber(FCChartObj.logoleftmargin, 0);
            HCChartObj.logoTopMargin = pluckNumber(FCChartObj.logotopmargin, 0);

            //toolbar button parameters
            toolbar = HCChartObj.toolbar = {button: {}};
            button = toolbar.button;

            button.scale = pluckNumber(FCChartObj.toolbarbuttonscale, 1.15);
            button.width = pluckNumber(FCChartObj.toolbarbuttonwidth, 15);
            button.height = pluckNumber(FCChartObj.toolbarbuttonheight, 15);
            button.radius = pluckNumber(FCChartObj.toolbarbuttonradius, 2);
            button.spacing = pluckNumber(FCChartObj.toolbarbuttonspacing, 5);

            button.fill = convertColor(pluck(FCChartObj.toolbarbuttoncolor, 'ffffff'));
            button.labelFill = convertColor(pluck(FCChartObj.toolbarlabelcolor, 'cccccc'));
            button.symbolFill = convertColor(pluck(FCChartObj.toolbarsymbolcolor, 'ffffff'));
            button.hoverFill = convertColor(pluck(FCChartObj.toolbarbuttonhovercolor, 'ffffff'));
            button.stroke = convertColor(pluck(FCChartObj.toolbarbuttonbordercolor, 'bbbbbb'));
            button.symbolStroke = convertColor(pluck(FCChartObj.toolbarsymbolbordercolor, '9a9a9a'));

            button.strokeWidth = pluckNumber(FCChartObj.toolbarbuttonborderthickness, 1);
            button.symbolStrokeWidth = pluckNumber(FCChartObj.toolbarsymbolborderthickness, 1);
            bSymbolPadding = button.symbolPadding = pluckNumber(FCChartObj.toolbarsymbolpadding, 5);
            button.symbolHPadding = pluckNumber(FCChartObj.toolbarsymbolhpadding, bSymbolPadding);
            button.symbolVPadding = pluckNumber(FCChartObj.toolbarsymbolvpadding, bSymbolPadding);

            bPosition = toolbar.position = pluck(FCChartObj.toolbarposition, 'tr').toLowerCase();
            switch(bPosition) {
                case 'tr':
                case 'rt':
                case 'top right':
                case 'right top':
                    bPosition = 'tr';
                    break;

                case 'br':
                case 'rb':
                case 'bottom right':
                case 'right bottom':
                    bPosition = 'br';
                    break;

                case 'tl':
                case 'lt':
                case 'top left':
                case 'left top':
                    bPosition = 'tl';
                    break;

                case 'bl':
                case 'lb':
                case 'bottom left':
                case 'left bottom':
                    bPosition = 'bl';
                    break;

                default:
                    bPosition = 'tr';
            }
            bHAlign = toolbar.hAlign = (BLANKSTRING + FCChartObj.toolbarhalign).toLowerCase() === 'left' ?
                'l': bPosition.charAt(1);
            bVAlign = toolbar.vAlign = (BLANKSTRING + FCChartObj.toolbarvalign).toLowerCase() === 'bottom' ?
                'b' : bPosition.charAt(0);
            hDirection = toolbar.hDirection = pluckNumber(FCChartObj.toolbarhdirection, (bHAlign === 'r' ? -1 : 1));
            vDirection = toolbar.vDirection = pluckNumber(FCChartObj.toolbarvdirection, (bVAlign === 'b' ? -1 : 1));
            toolbar.vMargin = pluckNumber(FCChartObj.toolbarvmargin, 6);
            toolbar.hMargin = pluckNumber(FCChartObj.toolbarhmargin, 10);
            toolbar.x = pluckNumber(FCChartObj.toolbarx, bHAlign === 'l' ? 0: width);
            toolbar.y = pluckNumber(FCChartObj.toolbary, bVAlign === 't' ? 0: height);

            // Div lines and grid
            divLineColor = pluck(FCChartObj.divlinecolor, colorM.getColor(palleteString.divLineColor));
            divLineAlpha = pluck(FCChartObj.divlinealpha, is3d ?
                colorM.getColor('divLineAlpha3D') : colorM.getColor('divLineAlpha'));
            divLineThickness = pluckNumber(FCChartObj.divlinethickness, 1);
            divLineIsDashed = Boolean(pluckNumber(FCChartObj.divlinedashed, FCChartObj.divlineisdashed,
                this.divLineIsDashed, 0));
            divLineDashLen = pluckNumber(FCChartObj.divlinedashlen, 4);
            divLineDashGap = pluckNumber(FCChartObj.divlinedashgap, 2);

            hc.yAxis[0].gridLineColor = convertColor(divLineColor, divLineAlpha);
            hc.yAxis[0].gridLineWidth = divLineThickness;
            hc.yAxis[0].gridLineDashStyle = divLineIsDashed ? getDashStyle(divLineDashLen,
                divLineDashGap, divLineThickness) : 'none';
            if (isBar) {
                hc.yAxis[0].alternateGridColor = convertColor(pluck(FCChartObj.alternatevgridcolor,
                    colorM.getColor('altVGridColor')),
                pluckNumber(FCChartObj.showalternatevgridcolor, 1) === 1 ?
                    pluck(FCChartObj.alternatevgridalpha, colorM.getColor('altVGridAlpha')) : ZEROSTRING);
            } else {
                hc.yAxis[0].alternateGridColor = convertColor(pluck(FCChartObj.alternatehgridcolor,
                    colorM.getColor('altHGridColor')),
                (FCChartObj.showalternatehgridcolor === '0') ? 0 : (pluck(FCChartObj.alternatehgridalpha,
                    colorM.getColor('altHGridAlpha'))));
            }

            //create the x axis options scatter
            vDivLineThickness = pluckNumber(FCChartObj.vdivlinethickness, 1);
            vDivLineIsDashed = Boolean(pluckNumber(FCChartObj.vdivlinedashed, FCChartObj.vdivlineisdashed, 0));
            vDivLineDashLen = pluckNumber(FCChartObj.vdivlinedashlen, 4);
            vDivLineDashGap = pluckNumber(FCChartObj.vdivlinedashgap, 2);

            xAxis.gridLineColor = convertColor(pluck(FCChartObj.vdivlinecolor,
                colorM.getColor(palleteString.divLineColor)),
            pluck(FCChartObj.vdivlinealpha, colorM.getColor('divLineAlpha')));
            xAxis.gridLineWidth = vDivLineThickness;
            xAxis.gridLineDashStyle = vDivLineIsDashed ? getDashStyle(vDivLineDashLen,
                vDivLineDashGap, vDivLineThickness) : 'none';
            xAxis.alternateGridColor = convertColor(pluck(FCChartObj.alternatevgridcolor,
                colorM.getColor('altVGridColor')),
            (FCChartObj.showalternatehgridcolor === '1') ? (pluck(FCChartObj.alternatevgridalpha,
                colorM.getColor('altVGridAlpha'))) : 0);

            canBGColor = pluck(FCChartObj.canvasbgcolor, colorM.getColor(palleteString.canvasBgColor));
            canBGAlpha = pluck(FCChartObj.canvasbgalpha, colorM.getColor('canvasBgAlpha'));
            showCanvasBG = pluck(FCChartObj.showcanvasbg, ONESTRING);

            if (showCanvasBG == ZEROSTRING) {
                canBGAlpha = '0';
            }

            // Plot shadow effect. Note that this is overridden in the if-block
            // below.
            hc.plotOptions.series.shadow = pluckNumber(FCChartObj.showshadow,
                FCChartObj.showcolumnshadow,
                this.defaultPlotShadow,
                colorM.getColor('showShadow'));

            //if inversed chart then set the reverse attr for axis
            if (this.inversed) {
                hc.yAxis[0].reversed = true;
                hc.yAxis[1].reversed = true;
            }

            //if stacked chart
            if (this.isStacked) {
                if (this.distributedColumns) {
                    conf.showStackTotal = Boolean(pluckNumber(FCChartObj.showsum,  1));
                    stack100percent = pluckNumber(FCChartObj.usepercentdistribution, 1);
                    /** @todo flsh has showPercentValues = 0 and showPercentInToolTip = 1 */
                    showPercentValues = pluckNumber(FCChartObj.showpercentvalues, 0);
                    showPercentInToolTip = pluckNumber(FCChartObj.showpercentintooltip, stack100percent, 0);
                    conf.showXAxisPercentValues = pluckNumber(FCChartObj.showxaxispercentvalues, 1);
                }
                else {
                    conf.showStackTotal = Boolean(pluckNumber(this.showSum, FCChartObj.showsum,  0));
                    //combicharts dose not support stack100percent
                    stack100percent = pluckNumber(this.stack100percent, FCChartObj.stack100percent, 0);
                    showPercentValues = pluckNumber(FCChartObj.showpercentvalues, stack100percent, 0);
                    showPercentInToolTip = pluckNumber(FCChartObj.showpercentintooltip, showPercentValues);
                }
                //add the showPercentValues in conf
                conf.showPercentValues = showPercentValues;
                conf.showPercentInToolTip = showPercentInToolTip;

                //only default series get the stack property
                if (stack100percent) {
                    conf.isValueAbs = true;
                    plotOptions[defaultSeries].stacking = 'percent';
                    //first axis will be percent stacking
                    conf[0].stacking100Percent = true;
                }
                else {
                    plotOptions[defaultSeries].stacking = 'normal';
                }
            }

            //Issue #680 solved
            if(this.isDual) {
                if (FCChartObj.primaryaxisonleft === '0') {
                    hc.yAxis[0].opposite = true;
                    hc.yAxis[1].opposite = false;
                }
                hc.yAxis[0].showAlways = true;
                hc.yAxis[1].showAlways = true;
            }



            if (HCChartObj.useRoundEdges) {
                hc.plotOptions.series.shadow = pluckNumber(FCChartObj.showshadow,
                    FCChartObj.showcolumnshadow, 1);
                hc.plotOptions.series.borderRadius = 1;
                hc.tooltip.style.borderRadius = 2 + 'px';
                // Manage canvas cosmetics
                HCChartObj.plotBorderRadius = 3;
                if (!showCanvasBorder) {
                    HCChartObj.plotBorderWidth = 0;
                }
                HCChartObj.plotShadow = hc.plotOptions.series.shadow ? {
                    enabled: true,
                    opacity: canBGAlpha / 100
                } : 0;

            }

            if (pluckNumber(FCChartObj.use3dlighting, 1) === 1) {
                hc.legend.lighting3d = true;
            }

            ///add the support for maxColWidth/maxBarHeight
            hc.plotOptions.series.userMaxColWidth = isBar ?
                        FCChartObj.maxbarheight :
                        pluckNumber(FCChartObj.maxcolwidth, this.maxColWidth);
            hc.plotOptions.series.maxColWidth = mathAbs(pluckNumber(
                    hc.plotOptions.series.userMaxColWidth, 50)) || 1;

            //Title
            hc.title.text = parseUnsafeString(FCChartObj.caption);

            //SubTitle
            hc.subtitle.text = parseUnsafeString(FCChartObj.subcaption);


            ///////// tooltip Options//////////////
            if (pluckNumber(FCChartObj.showtooltip, this.showtooltip) === 0) { //area/line anchor conflict
                hc.tooltip.enabled =  false;
            }

            tooltipStyle = hc.tooltip.style;

            tooltipStyle.backgroundColor = convertColor(pluck(tooltipStyle.backgroundColor, FCChartObj.tooltipbgcolor,
                colorM.getColor('toolTipBgColor')), pluck(FCChartObj.tooltipbgalpha, 100));
            tooltipStyle.borderColor = convertColor(pluck(tooltipStyle.borderColor, FCChartObj.tooltipbordercolor,
                colorM.getColor('toolTipBorderColor')), pluck(FCChartObj.tooltipborderalpha, 100));

            hc.tooltip.shadow = pluckNumber(FCChartObj.showtooltipshadow, FCChartObj.showshadow, 1) ? {
                enabled: true,
                opacity: mathMax(pluckNumber(FCChartObj.tooltipbgalpha, 100),
                    pluckNumber(FCChartObj.tooltipborderalpha,100)) / 100
            } : false;
            hc.tooltip.constrain = pluckNumber(FCChartObj.constraintooltip, 1);
            tooltipStyle.borderWidth = pluckNumber(FCChartObj.tooltipborderthickness, 1) + 'px';
            if (FCChartObj.tooltipborderradius) {
                tooltipStyle.borderRadius = pluckNumber(FCChartObj.tooltipborderradius, 1) + 'px';
            }
            tooltipStyle.padding =
            pluckNumber(FCChartObj.tooltippadding, this.tooltippadding, 3) + 'px';
            if (FCChartObj.tooltipcolor) {
                tooltipStyle.color = getFirstColor(FCChartObj.tooltipcolor);
            }


            //set the plotspace ppercent has effecton column only
            conf.userPlotSpacePercent = hc.plotOptions.series.userPlotSpacePercent = FCChartObj.plotspacepercent;
            plotSpacePercent = pluckNumber(FCChartObj.plotspacepercent, 20) % 100;

//            if (plotSpacePercent > 80 || plotSpacePercent < 0) {
//                plotSpacePercent = 20;
//            }
            //set the plot space percent
            conf.plotSpacePercent = hc.plotOptions.series.groupPadding = plotSpacePercent / 200;

            //if 3d chart then add 15 * 15 pixel space
            /** @todo during space management take care of base canvas bg, xDepth, yDepth etc if it shows */
            if (is3d && !isPie) {
                //combi chart add shift for 2d series
                //**set the speciffic 3dShift conf in chartApi(2d area in 3d chart issue)
                HCChartObj.series2D3Dshift = chartName === 'mscombi3d' ? true : Boolean(pluckNumber(
                    FCChartObj.use3dlineshift, 0));
                HCChartObj.canvasBaseColor3D = pluck(FCChartObj.canvasbasecolor,
                    colorM.getColor('canvasBaseColor3D'));
                HCChartObj.canvasBaseDepth = pluckNumber(FCChartObj.canvasbasedepth, 10);
                HCChartObj.canvasBgDepth = pluckNumber(FCChartObj.canvasbgdepth, 3);
                HCChartObj.showCanvasBg = Boolean(pluckNumber(FCChartObj.showcanvasbg, 1));
                HCChartObj.showCanvasBase = Boolean(pluckNumber(FCChartObj.showcanvasbase, 1));
                if (isBar) {
                    HCChartObj.xDepth = 5;
                    HCChartObj.yDepth = 5;

                    // adjust the space for canvasBgDepth
                    //Store it as marginRightExtraSpace
                    if (HCChartObj.showCanvasBg) {
                        conf.marginTopExtraSpace +=  HCChartObj.canvasBgDepth;
                    }
                    //adjust the space for canvasBaseDepth and yDepth
                    conf.marginLeftExtraSpace += HCChartObj.yDepth + (HCChartObj.showCanvasBase ?
                        HCChartObj.canvasBaseDepth : 0);
                    conf.marginBottomExtraSpace += 5;
                }
                else {
                    HCChartObj.xDepth = 10;
                    HCChartObj.yDepth = 10;

                    // adjust the space for canvasBgDepth
                    //Store it as marginRightExtraSpace
                    if (HCChartObj.showCanvasBg) {
                        conf.marginRightExtraSpace +=  HCChartObj.canvasBgDepth;
                    }
                    //adjust the space for canvasBaseDepth and yDepth
                    conf.marginBottomExtraSpace += HCChartObj.yDepth + (HCChartObj.showCanvasBase ?
                        HCChartObj.canvasBaseDepth : 0);
                }
                //build the 3d effect of the plotBackgroundColor
                canBGColor = canBGColor.split(COMMASTRING)[0];
                canBGAlpha = canBGAlpha.split(COMMASTRING)[0];
                HCChartObj.use3DLighting = Boolean(pluckNumber(FCChartObj.use3dlighting, 1));
                if (HCChartObj.use3DLighting) {
                    HCChartObj.plotBackgroundColor = {
                        FCcolor : {
                            color : getDarkColor (canBGColor, 85) + COMMASTRING + getLightColor (canBGColor, 55),
                            alpha : canBGAlpha + COMMASTRING + canBGAlpha,
                            ratio : BGRATIOSTRING,
                            angle : getAngle (width - (HCChartObj.marginLeft + HCChartObj.marginRight),
                                height - (HCChartObj.marginTop + HCChartObj.marginBottom), 1)
                        }
                    };
                }
                else {
                    HCChartObj.plotBackgroundColor =  convertColor(canBGColor, canBGAlpha);
                }


                //for bg depth
                HCChartObj.canvasBgColor = convertColor(getDarkColor(canBGColor, 80), canBGAlpha);
                zeroPlaneColor = pluck(FCChartObj.zeroplanecolor, FCChartObj.divlinecolor,
                    colorM.getColor(palleteString.divLineColor));
                zeroPlaneAlpha = pluck(FCChartObj.zeroplanealpha, FCChartObj.divlinealpha,
                    colorM.getColor('divLineAlpha'));
                HCChartObj.zeroPlaneColor = convertColor(zeroPlaneColor, zeroPlaneAlpha);
                HCChartObj.zeroPlaneBorderColor = convertColor(pluck(FCChartObj.zeroplanebordercolor,
                    zeroPlaneColor), pluckNumber(FCChartObj.zeroplaneshowborder, 1) ? zeroPlaneAlpha : 0);
                HCChartObj.zeroPlaneShowBorder = pluckNumber(FCChartObj.zeroplaneshowborder, 1);
            }
            else {
                HCChartObj.is3D = false;//for pie 3d
                // Manage canvas cosmetics
                HCChartObj.plotBackgroundColor = {
                    FCcolor : {
                        color : canBGColor,
                        alpha : canBGAlpha,
                        angle : pluck(FCChartObj.canvasbgangle, colorM.getColor('canvasBgAngle')),
                        ratio : pluck(FCChartObj.canvasbgratio, colorM.getColor('canvasBgRatio'))
                    }
                };
            }


            //
            //////Export Module/////
            this.parseExportOptions(hc);

            // Parse Hover effect options
            this.parseHoverEffectOptions(HCChartObj);

            // preSeriesAddition function is to configure the charts (Modify Data)
            // before series function executes
            if (this.preSeriesAddition) {
                this.preSeriesAddition(hc, obj, width, height);
            }

            //create the Data serias first
            this.series && this.series(obj, hc, chartName, width, height);

            //this function do the after series addition works like:
            // showsum for stacking
            //marimekko conf
            this.postSeriesAddition(hc, obj, width, height);

            /*
             *Manage the space
             */
            this.spaceManager(hc, obj, width, height);

            // postSpaceManager function is to configure the charts (Modify Data)
            // after space manager function executes
            this.postSpaceManager && this.postSpaceManager(hc, obj, width, height);

            // Drawing Quadrant for XY plot Charts
            drawQuadrant = pluckNumber(FCChartObj.drawquadrant, 0);
            if (conf.isXYPlot && drawQuadrant) {

                //Quadrant related properties
                xMin = xAxis.min;
                xMax = xAxis.max;
                yMin = hc.yAxis[0].min;
                yMax = hc.yAxis[0].max;
                quadrantXVal = pluckNumber(FCChartObj.quadrantxval, (xMin + xMax)/2);
                quadrantYVal = pluckNumber(FCChartObj.quadrantyval, (yMin + yMax)/2);

                if (quadrantYVal >= yMin && quadrantYVal <= yMax && quadrantXVal >= xMin && quadrantXVal <= xMax) {
                    quadrantLineColor = convertColor(pluck(FCChartObj.quadrantlinecolor, HCChartObj.plotBorderColor),
                        pluck(FCChartObj.quadrantlinealpha, HUNDREDSTRING));
                    quadrantLineThickness = pluckNumber(FCChartObj.quadrantlinethickness, HCChartObj.plotBorderWidth);
                    quadrantLineIsDashed = pluckNumber(FCChartObj.quadrantlinedashed,
                        FCChartObj.quadrantlineisdashed, 0);
                    quadrantLineDashLen = pluckNumber(FCChartObj.quadrantlinedashLen, 4);
                    quadrantLineDashGap = pluckNumber(FCChartObj.quadrantlinedashgap, 2);
                    quadrantLabelTL = getValidValue(FCChartObj.quadrantlabeltl, BLANKSTRING);
                    quadrantLabelTR = getValidValue(FCChartObj.quadrantlabeltr, BLANKSTRING);
                    quadrantLabelBL = getValidValue(FCChartObj.quadrantlabelbl, BLANKSTRING);
                    quadrantLabelBR  = getValidValue(FCChartObj.quadrantlabelbr, BLANKSTRING);
                    //Padding of label from any side of canvase
                    quadrantLabelPadding = pluckNumber(FCChartObj.quadrantlabelpadding, 3);
                    dashStyle = quadrantLineIsDashed ? getDashStyle(quadrantLineDashLen, quadrantLineDashGap,
                        quadrantLineThickness) : 'none';


                    //Now check whether they're in range.
                    xAxis.plotLines.push({
                        color: quadrantLineColor,
                        value: quadrantXVal,
                        width: quadrantLineThickness,
                        dashStyle: dashStyle,
                        zIndex: 3
                    });

                    hc.yAxis[0].plotLines.push({
                        color: quadrantLineColor,
                        value: quadrantYVal,
                        width: quadrantLineThickness,
                        dashStyle: dashStyle,
                        zIndex: 3
                    });

                    canvasWidth = width - HCChartObj.marginRight - HCChartObj.marginLeft;
                    canvasHeight = height - HCChartObj.marginTop - HCChartObj.marginBottom;
                    inCanvasStyle = conf.inCanvasStyle;

                    labelWidthPart1 = (canvasWidth / (xMax - xMin)) * (quadrantXVal - xMin);
                    labelWidthPart2 = canvasWidth - labelWidthPart1;

                    labelHeightPart2 = (canvasHeight / (yMax - yMin)) * (quadrantYVal - yMin);
                    labelHeightPart1 = canvasHeight - labelHeightPart2;

                    //remove the padding amount
                    labelWidthPart1 -= quadrantLabelPadding;
                    labelWidthPart2 -= quadrantLabelPadding;
                    labelHeightPart1 -= quadrantLabelPadding;
                    labelHeightPart2 -= quadrantLabelPadding;
                    /* Fix for raphael's bottom alignment.
                     * removed inCanvasFontSize from the calculation
                     * applied vAlign to top quadrant. - P.B
                     */
                    top1 = quadrantLabelPadding + PXSTRING;// + inCanvasFontSize + PXSTRING,
                    top2 = (canvasHeight - quadrantLabelPadding) + PXSTRING;
                    left1 = quadrantLabelPadding + PXSTRING;
                    left2 = (canvasWidth - quadrantLabelPadding) + PXSTRING;

                    // Draw the quadrant labels.
                    smartLabel.setStyle(inCanvasStyle);

                    if (labelHeightPart1 > 0) {
                        if (quadrantLabelTL !== BLANKSTRING && labelWidthPart1 > 0) {
                            smartText = smartLabel.getSmartText(quadrantLabelTL, labelWidthPart1, labelHeightPart1);
                            hc.labels.items.push({
                                html: smartText.text,
                                zIndex : 3,
                                vAlign: POSITION_TOP,
                                style: {
                                    left: left1,
                                    top: top1,
                                    fontSize: inCanvasStyle.fontSize,
                                    lineHeight: inCanvasStyle.lineHeight,
                                    fontFamily: inCanvasStyle.fontFamily,
                                    color: inCanvasStyle.color
                                }
                            });
                        }

                        if (quadrantLabelTR !== BLANKSTRING && labelWidthPart2 > 0) {
                            smartText = smartLabel.getSmartText(quadrantLabelTR, labelWidthPart2, labelHeightPart1);
                            hc.labels.items.push({
                                html: smartText.text,
                                textAlign: POSITION_RIGHT,
                                vAlign: POSITION_TOP,
                                zIndex : 3,
                                style: {
                                    left: left2,
                                    top: top1,
                                    //textAlign: POSITION_RIGHT,
                                    fontSize: inCanvasStyle.fontSize,
                                    lineHeight: inCanvasStyle.lineHeight,
                                    fontFamily: inCanvasStyle.fontFamily,
                                    color: inCanvasStyle.color
                                }
                            });
                        }
                    }
                    if (labelHeightPart2 > 0) {
                        if (quadrantLabelBL !== BLANKSTRING && labelWidthPart1 > 0) {
                            smartText = smartLabel.getSmartText(quadrantLabelBL, labelWidthPart1, labelHeightPart2);
                            hc.labels.items.push({
                                html: smartText.text,
                                vAlign : POSITION_BOTTOM,
                                zIndex : 3,
                                style: {
                                    left: left1,
                                    top: top2,
                                    //vAlign : POSITION_BOTTOM,
                                    fontSize: inCanvasStyle.fontSize,
                                    lineHeight: inCanvasStyle.lineHeight,
                                    fontFamily: inCanvasStyle.fontFamily,
                                    color: inCanvasStyle.color
                                }
                            });
                        }

                        if (quadrantLabelBR !== BLANKSTRING && labelWidthPart2 > 0) {
                            smartText = smartLabel.getSmartText(quadrantLabelBR, labelWidthPart2, labelHeightPart2);
                            hc.labels.items.push({
                                html: smartText.text,
                                textAlign: POSITION_RIGHT,
                                vAlign : POSITION_BOTTOM,
                                zIndex : 3,
                                style: {
                                    left: left2,
                                    top: top2,
                                   // textAlign: POSITION_RIGHT,
                                    //vAlign : POSITION_BOTTOM,
                                    fontSize: inCanvasStyle.fontSize,
                                    lineHeight: inCanvasStyle.lineHeight,
                                    fontFamily: inCanvasStyle.fontFamily,
                                    color: inCanvasStyle.color
                                }
                            });
                        }
                    }
                }
            }


            //add the code for x axis num v div line for line area
            if (this.hasVDivLine) {
                showVerticalDivLines = pluckNumber(FCChartObj.showvdivlines, 0);

                numVDivLines = pluckNumber(FCChartObj.numvdivlines, 0) + 1;
                /** @todo: Code saved while jshinting
                 * if (showVerticalDivLines && !numVDivLines <= 1) {
                 * (!numVDivLines <= 1) turns out be always true,
                 * so removing the part from the condition
                 */
                if (showVerticalDivLines) {
                    numVDivLines = conf.x.catCount - 1;
                }
                if (numVDivLines > 1) {
                    min = xAxis.min;
                    catLength = conf.x.catCount - 1;
                    max = xAxis.max;
                    gridInterval = catLength / numVDivLines;
                    drawAltGrid = true;
                    lastValue = min;

                    //for scroll charts this should be the scoll viewPort max not the
                    //intial axis end
                    xAxis.scroll && !isNaN(xAxis.scroll.viewPortMax) &&
                            (max = xAxis.scroll.viewPortMax);

                    vDivLineColor = pluck(FCChartObj.vdivlinecolor, divLineColor);
                    vDivLineAlpha = pluckNumber(FCChartObj.vdivlinealpha, divLineAlpha);
                    vDivLineThickness = pluckNumber(FCChartObj.vdivlinethickness, divLineThickness);
                    vDivLineIsDashed = pluckNumber(FCChartObj.vdivlinedashed,
                        FCChartObj.vdivlineisdashed, divLineIsDashed);
                    vDivLineDashLen = pluckNumber(FCChartObj.vdivlinedashlen, divLineDashLen);
                    vDivLineDashGap = pluckNumber(FCChartObj.vdivlinedashgap, divLineDashGap);
                    showAlternateVGridColor = pluckNumber(FCChartObj.showalternatevgridcolor, 0);

                    if (showAlternateVGridColor) {
                        alternateVGridColor = convertColor(pluck(FCChartObj.alternatevgridcolor,
                            colorM.getColor('altVGridColor')),
                        pluck(FCChartObj.alternatevgridalpha,
                            colorM.getColor('altVGridAlpha')
                            ));
                    }

                    for (value = gridInterval; value < catLength; value += gridInterval,
                        drawAltGrid = !drawAltGrid) {
                        // Draw the alternate grid
                        if (drawAltGrid && showAlternateVGridColor) {
                            xAxis.plotBands.push({
                                isNumVDIV : true,//will not move during realtime update
                                color: alternateVGridColor,
                                from: lastValue,
                                to: value,
                                zIndex: 1
                            });
                        }
                        // Draw the Grid lines
                        xAxis.plotLines.push({
                            isNumVDIV : true,//will not move during realtime update
                            width: vDivLineThickness,
                            color: convertColor(vDivLineColor, vDivLineAlpha),
                            dashStyle : vDivLineIsDashed ? getDashStyle(vDivLineDashLen,
                                vDivLineDashGap, vDivLineThickness) : 'none',
                            value: value,
                            zIndex: 1
                        });
                        lastValue = value;
                    }
                    // Draw the alternate grid for last one
                    if (drawAltGrid && showAlternateVGridColor) {
                        xAxis.plotBands.push({
                            isNumVDIV : true,//will not move during realtime update
                            color: alternateVGridColor,
                            from: lastValue,
                            to: max,
                            zIndex: 1
                        });
                    }

                }
            }

            /*
             * Add snapLiterals
             */
            marginTop = HCChartObj.marginTop;
            marginBottom = HCChartObj.marginBottom;
            marginLeft = HCChartObj.marginLeft;
            marginRight = HCChartObj.marginRight;

            // SnapLiterals for canvas positions
            snapLiterals.canvasstartx = marginLeft;
            snapLiterals.canvasstarty = marginTop;
            snapLiterals.canvasendx = width - marginRight;
            snapLiterals.canvasendy = height - marginBottom;
            snapLiterals.canvaswidth = snapLiterals.canvasendx - snapLiterals.canvasstartx;
            snapLiterals.canvasheight = snapLiterals.canvasendy - snapLiterals.canvasstarty;

            // SnapLiterals for legend ypos when it is positioned vertically
            if (hc.legend && hc.legend.enabled && hc.legend.layout === 'vertical') {
                snapLiterals.legendstarty = marginTop + ((conf.height - marginBottom - marginTop -
                        snapLiterals.legendheight) * 0.5) + (hc.legend.y || 0);
                snapLiterals.legendendy = snapLiterals.legendstarty  + snapLiterals.legendheight;
            }



            /** @todo restructure the code
            // manageSpace (hc, obj, StoreChartObj.axisType, width, height);
            //place elements as per space calculated
            //placeElements (hc, StoreChartObj.axisType);
            */
            //special checking for axis Depth. if there dont have sufficiant space for x depth
            //then add it
            if (is3d && HCChartObj.xDepth > HCChartObj.marginLeft) {
                HCChartObj.marginLeft = HCChartObj.xDepth;
            }

            //if the axis has no negative value then set the thresold as max
            /** @todo will be added in the inverse configuration
            if (StoreChartObj.seriesType === INVERSESERIES && hc.yAxis[0].min >= 0) {
                hc.plotOptions.series.threshold = hc.yAxis[0].max;
            }*/

            /*jslint devel:true */
            if (win.console && win.console.log && win.FC_DEV_ENVIRONMENT) {
                console.log(hc);
            }
            /*jslint devel:false */

            //return the converted object
            return hc;
        },

        parseHoverEffectOptions: function (HCChartObj) {
            var chart = this,
                FCChartObj = chart.dataObj.chart,
                plotHoverEffects;

            // Plot hover effects
            /** @todo set default showhovereffct to 0 */
            HCChartObj.showHoverEffect = FCChartObj.showhovereffect;
            HCChartObj.plotHoverEffect = pluckNumber(FCChartObj.plothovereffect,
                                FCChartObj.anchorhovereffect, HCChartObj.showHoverEffect);
            plotHoverEffects = HCChartObj.plotHoverEffects = {
                enabled: HCChartObj.plotHoverEffect
            };

            plotHoverEffects.highlight = pluckNumber(FCChartObj.highlightonhover,
                            FCChartObj.highlightplotonhover, HCChartObj.plotHoverEffect);

            plotHoverEffects.columnHighlight = pluckNumber(plotHoverEffects.highlight,
                    FCChartObj.highlightcolumnonhover,
                    FCChartObj.highlightbaronhover
                );
            plotHoverEffects.anchorHighlight = pluckNumber(plotHoverEffects.highlight,
                    FCChartObj.highlightanchoronhover
                );
            plotHoverEffects.imageHighlight = pluckNumber(plotHoverEffects.highlight,
                    FCChartObj.highlightanchorimageonhover
                );
            plotHoverEffects.anchorImageHoverAlpha = pluck(FCChartObj.anchorimagehoveralpha);

            plotHoverEffects.anchorImageHoverScale = pluck(FCChartObj.anchorimagehoverscale);

            plotHoverEffects.bubbleHighlight = pluckNumber(plotHoverEffects.highlight,
                    FCChartObj.highlightbubbleonhover
                );

            plotHoverEffects.color = pluck(FCChartObj.plotfillhovercolor,
                FCChartObj.columnhovercolor,
                FCChartObj.barhovercolor,
                //FCChartObj.anchorhovercolor, FCChartObj.anchorbghovercolor,
                FCChartObj.bubblehovercolor);

            plotHoverEffects.alpha = pluck(FCChartObj.plotfillhoveralpha,
                FCChartObj.columnhoveralpha,
                FCChartObj.barhoveralpha,
                //FCChartObj.anchorhoveralpha,
                FCChartObj.bubblehoveralpha);

            plotHoverEffects.scale = pluck(FCChartObj.plothoverscale,
                FCChartObj.columnhoverscale,
                FCChartObj.barhoverscale,
                //FCChartObj.anchorhoverscale,
                FCChartObj.bubblehoverscale);


            plotHoverEffects.gradientColor = FCChartObj.plothovergradientcolor;
            plotHoverEffects.ratio = FCChartObj.plothoverratio;
            plotHoverEffects.angle = FCChartObj.plothoverangle;

            plotHoverEffects.borderColor = FCChartObj.plotborderhovercolor;
            plotHoverEffects.borderAlpha = FCChartObj.plotborderhoveralpha;
            plotHoverEffects.borderThickness = FCChartObj.plotborderhoverthickness;
            plotHoverEffects.borderDashed = FCChartObj.plotborderhoverdashed;
            plotHoverEffects.borderDashGap = FCChartObj.plotborderhoverdashgap;
            plotHoverEffects.borderDashLen = FCChartObj.plotborderhoverdashlen;

            plotHoverEffects.shadow = FCChartObj.plothovershadow;

            plotHoverEffects.anchorScale = FCChartObj.anchorhoverscale;
            plotHoverEffects.anchorSides = FCChartObj.anchorhoversides;
            plotHoverEffects.anchorRadius = FCChartObj.anchorhoverradius;
            plotHoverEffects.anchorAlpha = FCChartObj.anchorhoveralpha;
            plotHoverEffects.anchorBgColor = pluck (FCChartObj.anchorbghovercolor,
            FCChartObj.anchorhovercolor);
            plotHoverEffects.anchorBgAlpha = FCChartObj.anchorbghoveralpha;
            plotHoverEffects.anchorBorderColor = FCChartObj.anchorborderhovercolor;
            plotHoverEffects.anchorBorderAlpha = FCChartObj.anchorborderhoveralpha;
            plotHoverEffects.anchorBorderThickness = FCChartObj.anchorborderhoverthickness;
            plotHoverEffects.anchorStartAngle = FCChartObj.anchorhoverstartangle;
            plotHoverEffects.anchorDip = pluckNumber(FCChartObj.anchorhoverdip);
            plotHoverEffects.anchorAnimation = pluckNumber(FCChartObj.anchorhoveranimation, 1);

            plotHoverEffects.negativeColor = pluck(FCChartObj.negativehovercolor,
                    FCChartObj.negativecolor);
            plotHoverEffects.is3DBubble = pluckNumber(FCChartObj.is3donhover);
        },

        parseExportOptions: function (hc) {
            var chart = this,
                fusioncharts = chart.chartInstance,
                chartAttrs = chart.dataObj.chart;

            extend2(hc.exporting, {
                enabled: pluckNumber(chartAttrs.exportenabled, 0),
                bgcolor: (fusioncharts.jsVars.transparent ||
                    (pluckNumber(fusioncharts.options.containerBackgroundOpacity, 1) === 0)) ? BLANKSTRING :
                    (fusioncharts.options.containerBackgroundColor || '#ffffff'),
                bgalpha: (fusioncharts.jsVars.transparent ? 0 :
                    pluckNumber(fusioncharts.options.containerBackgroundOpacity, 1)) + BLANKSTRING,

                exporttargetwindow: pluck(chartAttrs.exporttargetwindow, (isIOS ? '_blank' : '_self')),
                exportaction: (chartAttrs.exportaction &&
                    (chartAttrs.exportaction.toString().toLowerCase() === 'save') && 'save' || 'download'),
                exportfilename: pluck(chartAttrs.exportfilename, 'FusionCharts'),
                exporthandler: pluck(chartAttrs.html5exporthandler, chartAttrs.exporthandler, DEFAULT_EXPORT_URL),
                exportparameters: pluck(chartAttrs.exportparameters, BLANKSTRING),
                exportformat: pluck(chartAttrs.exportformat, 'PNG'),

                buttons: {
                    printButton: {
                        enabled: !!pluckNumber(chartAttrs.printshowbutton, chartAttrs.showprintmenuitem, 0)
                    },
                    exportButton: {
                        enabled: !!(pluckNumber(chartAttrs.exportenabled, 0) &&
                            pluckNumber(chartAttrs.exportshowbutton, chartAttrs.exportshowmenuitem, 1))
                    }
                }
            });

            hc.exporting.exportformats = (function(strFormats, action) {
                var exportFormats = {
                        'JPG': action + ' as JPEG image',
                        'PNG': action + ' as PNG image',
                        'PDF': action + ' as PDF document',
                        'SVG': action + ' as SVG vector image'
                    },
                    finalFormats,
                    arrFormats,
                    item,
                    format,
                    label,
                    i;

                if (!strFormats) {
                    return exportFormats;
                }

                arrFormats = strFormats.split(/\s*?\|\s*?/);

                for (i = 0; i < arrFormats.length; i++) {
                    item = arrFormats[i].split(/\s*?=\s*?/);
                    format = item && item[0].toUpperCase() || BLANKSTRING;
                    label = item && item[1] || BLANKSTRING;

                    exportFormats[format] && (finalFormats || (finalFormats = {})) &&
                        (finalFormats[format] = (label || exportFormats[format]));
                }

                return finalFormats || exportFormats;
            }(chartAttrs.exportformats, getSentenceCase(hc.exporting.exportaction)));
        },

        defaultSeriesType: BLANKSTRING,
        paletteIndex: 1,
        creditLabel: creditLabel,

        // Space Management Routines
        titleSpaceManager: titleSpaceManager,
        placeLegendBlockBottom: placeLegendBlockBottom,
        configureLegendOptions: configureLegendOptions,
        placeLegendBlockRight: placeLegendBlockRight,
        placeHorizontalAxis: placeHorizontalAxis,
        placeVerticalAxis: placeVerticalAxis,
        placeHorizontalCanvasMarginAdjustment: adjustHorizontalCanvasMargin,
        placeVerticalCanvasMarginAdjustment: adjustVerticalCanvasMargin,
        placeHorizontalXYSpaceManager: barXYSpaceManager,
        placeVerticalXYSpaceManager: nonBarXYSpaceManager,
        placeVerticalAxisTitle: adjustVerticalAxisTitle,
        calculateCanvasOverflow: calculateCanvasOverflow,

        spaceManager : function () {
            return this.placeVerticalXYSpaceManager.apply(this, arguments);
        },

        /*
         * this function will set the min max and the tickinterval for a y axis
         */
        axisMinMaxSetter: function (aXisObj, axisConf, yAxisMaxValue,
            yAxisMinValue, stopMaxAtZero, setMinAsZero, numDivLines,
            adjustDiv) {

            var axisLimits;
            if (axisConf.stacking100Percent) {
                axisLimits = getAxisLimits(99, 1, 100, 0, stopMaxAtZero,
                    setMinAsZero, numDivLines, adjustDiv);
            }
            else {
                axisLimits = getAxisLimits(pluckNumber(axisConf.max,
                    yAxisMaxValue), pluckNumber(axisConf.min, yAxisMinValue),
                    yAxisMaxValue, yAxisMinValue, stopMaxAtZero, setMinAsZero,
                    numDivLines, adjustDiv);
            }
            aXisObj.min = Number(toPrecision(axisLimits.Min,10));
            aXisObj.max = Number(toPrecision(axisLimits.Max, 10));
            aXisObj.tickInterval = Number(toPrecision(axisLimits.divGap, 10));

             //for realtime chart add the calculated numdivlines
            axisConf.numdivlines = math.round((aXisObj.max - aXisObj.min) / aXisObj.tickInterval) - 1;

            //fix issue #698
            if (axisLimits.Range / axisLimits.divGap <= 2) {
                aXisObj.alternateGridColor = COLOR_TRANSPARENT;
            }

            // Store the High and Low value of data in chartAPI before deleting
            // it form conf this will be use by FusionWidgets Spark Charts.
            this.highValue = axisConf.max;
            this.lowValue = axisConf.min;

            // Delete the min max.
            delete axisConf.max;
            delete axisConf.min;
        },
        configurePlotLines: configureAxis,

        xAxisMinMaxSetter: function (hcJSON, fcJSON, canvasWidth, cpLeft, cpRight) {
            var conf = hcJSON[FC_CONFIG_STRING],
                xAxisConf = conf.x,
                /** @todo always set the min and max for the xAsis. */
                // no catCount is requierd.
                FCChartObj = fcJSON.chart,
                min = xAxisConf.min = pluckNumber(xAxisConf.min, 0),
                max = xAxisConf.max = pluckNumber(xAxisConf.max, xAxisConf.catCount - 1),
                leftValuePad = 0,
                rightValuePad = 0,
                valuePixelRatio,
                defaultSeries = hcJSON.chart.defaultSeriesType,
                isColumnType = /^(column|column3d|bar|bar3d|floatedcolumn|sparkwinloss|boxandwhisker2d|dragcolumn)$/
                    .test(defaultSeries),
                isLineType = /^(line|area|spline|areaspline)$/.test(defaultSeries),
                isXYPlot = /^(scatter|bubble|candlestick|dragnode)$/.test(defaultSeries),
                xAxis = hcJSON.xAxis,
                scrollOptions = xAxis.scroll,
                isScrollEnabled = scrollOptions && scrollOptions.enabled,
                canvasPadding = pluckNumber(FCChartObj.canvaspadding),
                cpDefined = defined(canvasPadding),
                leftPixelPad = mathCeil(mathMin(pluckNumber(canvasPadding, cpLeft, 0),
                    (canvasWidth / 2) - 10)),
                rightPixelPad = mathCeil(mathMin(pluckNumber(canvasPadding, cpRight, 0),
                    (canvasWidth / 2) - 10)),//plot area will not be less then 10 px
                setadaptiveXmin, stopMaxAtZero, setMinAsZero, numVDivLines,
                adjustVDiv, showXAxisValues, showVLimits, showVDivLineValues,
                xaxisvaluesstep,
                vxLength,
                perColWidth,
                scrollableLength,
                maxVisiblePlots;

            //if scatter or bubble the calculate the min max
            //NOTE: this flag is added in cat adder of scatter
            if (xAxisConf.adjustMinMax) {
                setadaptiveXmin = pluckNumber(FCChartObj.setadaptivexmin, 1);
                setMinAsZero = stopMaxAtZero = !setadaptiveXmin;
                numVDivLines = pluckNumber(this.numVDivLines, FCChartObj.numvdivlines, 4);
                adjustVDiv = FCChartObj.adjustvdiv !== ZEROSTRING;
                showXAxisValues = pluckNumber(FCChartObj.showxaxisvalues, FCChartObj.showxaxisvalue, 1);
                showVLimits = pluckNumber(FCChartObj.showvlimits, showXAxisValues);
                showVDivLineValues = pluckNumber(FCChartObj.showvdivlinevalue, FCChartObj.showvdivlinevalues,
                    showXAxisValues);

                //////////////////////calculate the axis min max and the div interval for x axis ///////////////////
                this.axisMinMaxSetter(xAxis, xAxisConf, FCChartObj.xaxismaxvalue, FCChartObj.xaxisminvalue,
                    stopMaxAtZero, setMinAsZero, numVDivLines, adjustVDiv);
                //add this new min max in the local variable for proper code flow
                min = xAxis.min;
                max = xAxis.max;
                //if auto numeric calculation requared
                if (xAxisConf.requiredAutoNumericLabels) {
                    xaxisvaluesstep = pluckNumber(parseInt(FCChartObj.xaxisvaluesstep, 10), 1);
                    xaxisvaluesstep = xaxisvaluesstep < 1 ? 1 : xaxisvaluesstep;
                    this.configurePlotLines (FCChartObj, hcJSON, xAxis, xAxisConf, showVLimits,
                        showVDivLineValues, xaxisvaluesstep, conf.numberFormatter, false, true);
                }
                //now sort the grid lines so that we can determine the space during space management
                xAxis.plotLines.sort(plotLineSortFN);
            }
            //remove all grid related conf
            xAxis.labels.enabled = false;
            xAxis.gridLineWidth = INT_ZERO;
            xAxis.alternateGridColor = COLOR_TRANSPARENT;


            // We add some spacing to start and end of column/bar plot.
            if ((isColumnType || conf.isScroll) && !conf.hasNoColumn) {
                // If canvas padding is not defined, check whether the first label is smaller than the column width
                // and set left padding at zero, do the same for the last column and set the right padding.
                if (!cpDefined && defined(cpLeft) && defined(cpRight)) {
                    // Find the max that a column can have.
                    perColWidth = canvasWidth / (max - min + 1) * 0.5;
                    // If first label width is less than the first column width, set the left padding at zero
                    leftPixelPad = perColWidth - cpLeft > 0 ? 0 : leftPixelPad;
                    // If last label width is less than the last column width, set the right padding at zero
                    rightPixelPad = perColWidth - cpRight > 0 ? 0 : rightPixelPad;

                    leftValuePad = (perColWidth - cpLeft) > 0 ? 0.5 : 0;
                    rightValuePad = (perColWidth - cpRight) > 0 ? 0.5 : 0;
                }
            }

            if(isColumnType && !conf.hasNoColumn){
                leftValuePad = 0.5;
                rightValuePad = 0.5;
            }

            if (conf.is3d) {
                leftPixelPad += pluckNumber(hcJSON.chart.xDepth, 0);
            }

            //For scroll charts the valuePixelRation should depend on the number of
            //visible plots
            maxVisiblePlots = isScrollEnabled ? scrollOptions.vxLength : max;
            valuePixelRatio = (canvasWidth - (leftPixelPad + rightPixelPad)) / ((maxVisiblePlots - min) +
                (leftValuePad + rightValuePad));

            xAxis.min = min - (leftValuePad + (leftPixelPad / valuePixelRatio));
            xAxis.max = max + (rightValuePad + (rightPixelPad / valuePixelRatio));

            // Special checking for scroll charts
            if (isScrollEnabled) {
                vxLength = scrollOptions.vxLength;
                //scrollStartPercent = scrollOptions.startPercent,
                scrollableLength = xAxis.max - xAxis.min;

                scrollOptions.viewPortMin = xAxis.min;
                scrollOptions.viewPortMax = xAxis.max;
                scrollOptions.scrollRatio = vxLength / scrollableLength;
                scrollOptions.flatScrollBars = conf.flatScrollBars;
                scrollOptions.scrollBar3DLighting = conf.scrollBar3DLighting;
                //set the new min max
                // xAxis.min += (scrollableLength - vxLength) * scrollStartPercent;
                xAxis.max = xAxis.min + vxLength;
            }

            //fix for single point line series
            if (isLineType && xAxis.min === xAxis.max) {
                xAxis.min -= 0.65;
                xAxis.max += 0.65;
            }


            ///////////Trend-lines /////////////////
            if (isXYPlot && fcJSON.vtrendlines) {
                createTrendLine(fcJSON.vtrendlines, xAxis, conf, false, true, true);
            }

        },
        postSeriesAddition: postSeriesAddition,

        // supported style type that are supported in js chart
        styleMapForFont: fontStyleMap,

        styleApplicationDefinition_font: function (HC, toObj, style) { // jshint ignore:line
            var styleobject, x, y, isDataValues = false, i, len, styleobjectI,
            fontStyleMap = this.styleMapForFont;

            switch (toObj) {//fiend the toobject of HC depending upon toobject string of FC
                case 'caption':
                    styleobject = HC.title;
                    break;

                case 'datalabels':
                    styleobject = HC.xAxis.labels;
                    break;

                case 'datavalues':
                    styleobject = HC.plotOptions.series.dataLabels;
                    isDataValues = true;
                    break;

                case 'tldatavalues':
                    styleobject = {
                        style : HC.plotOptions.series.dataLabels.tlLabelStyle
                    };
                    break;

                case 'trdatavalues':
                    styleobject = {
                        style : HC.plotOptions.series.dataLabels.trLabelStyle
                    };
                    break;

                case 'bldatavalues':
                    styleobject = {
                        style : HC.plotOptions.series.dataLabels.blLabelStyle
                    };
                    break;

                case 'brdatavalues':
                    styleobject = {
                        style : HC.plotOptions.series.dataLabels.brLabelStyle
                    };
                    break;

                case 'subcaption':
                    styleobject = HC.subtitle;
                    break;

                case 'tooltip':
                    styleobject = HC.tooltip;
                    break;

                case 'trendvalues':
                    styleobject = {
                        style : HC[FC_CONFIG_STRING].trendStyle
                    };
                    break;

                case 'xaxisname':
                    styleobject = HC.xAxis.title;
                    break;

                case 'yaxisname':
                case 'pyaxisname'://for candlestick mainly
                case 'axistitle'://for mlline only
                    styleobject = [];
                    for (i = 0, len = HC.yAxis.length; i < len; i += 1) {
                        styleobject.push(HC.yAxis[i].title);
                    }
                    break;
                case 'yaxisvalues':
                    styleobject = [];
                    for (i = 0, len = HC.yAxis.length; i < len; i += 1) {
                        styleobject.push(HC.yAxis[i].labels);
                    }
                    break;
                case 'vlinelabels':
                    styleobject = {
                        style : HC[FC_CONFIG_STRING].divlineStyle
                    };
                    break;

                case 'legend':
                    styleobject = {
                        style : HC.legend.itemStyle
                    };
                    break;

                default:
                    //to prevent error send a dummy styleObj
                    styleobject = HC.orphanStyles[toObj];
                    if (!styleobject) {
                        HC.orphanStyles[toObj] = styleobject = {
                            text: '',
                            style : {}
                        };
                    }
                    break;
            }

            if (typeof styleobject === 'object') {
                if (styleobject instanceof Array) {
                    for (i = 0, len = styleobject.length; i < len; i += 1) {
                        styleobjectI = styleobject[i];
                        for (x in style) {//add all style attr into the hc object
                            y = x.toLowerCase();
                            if (typeof fontStyleMap[y] === 'function') {
                                fontStyleMap[y](style[x], styleobjectI, isDataValues);
                            }
                        }
                        setLineHeight(styleobjectI.style);
                    }
                }
                else {
                    for (x in style) {//add all style attr into the hc object
                        y = x.toLowerCase();
                        if (typeof fontStyleMap[y] === 'function') {
                            fontStyleMap[y](style[x], styleobject, isDataValues);
                        }
                    }
                    setLineHeight(styleobject.style);
                }
            }
        },

        parseStyles: function (hcObj) {
            var j, styleArr, styleName, tempstyle = {}, l, definitionObj,
            fcObj = this.dataObj;

            if (fcObj.styles && fcObj.styles.definition instanceof Array && fcObj.styles.application instanceof Array) {
                // retrieving all style definition and storing them in a temporary store
                for (j = 0; j < fcObj.styles.definition.length; j += 1) {
                    definitionObj = fcObj.styles.definition[j];
                    if (definitionObj.type && definitionObj.name &&
                        this['styleApplicationDefinition_' + definitionObj.type.toLowerCase()]) {
                        tempstyle[definitionObj.name.toLowerCase()] = definitionObj;
                    }
                }

                // find all apply object
                for (j = 0; j < fcObj.styles.application.length; j += 1) {
                    styleArr = fcObj.styles.application[j].styles &&
                    fcObj.styles.application[j].styles.split(COMMASTRING) || [];
                    for (l = 0; l < styleArr.length; l += 1) {
                        styleName = styleArr[l].toLowerCase();
                        if (tempstyle[styleName] && fcObj.styles.application[j].toobject) {
                            this['styleApplicationDefinition_' + tempstyle[styleName].type.toLowerCase()]
                            (hcObj, fcObj.styles.application[j].toobject.toLowerCase(), tempstyle[styleName]);
                        }
                    }
                }
            }
        },

        updateDefaultAnnotations: function () {
            var logic = this,
                chart = logic.renderer,
                data = logic.dataObj,
                chartObj = logic.chartInstance,
                definition = data && data.annotations || {},
                sharedOptions = {},
                scaleOnResize;
            // We have nothing to do if chartApi does not say annotation is
            // required and if no annotation object has been found.
            if (logic.drawAnnotations && chartObj.dataReady() && data &&
                    data.chart && pluckNumber(data.chart.showannotations, 1)) {

                // Compute scaleOnResize attribute
                scaleOnResize = pluckNumber(definition.scaleonresize, data.chart.scaleonresize, 1);

                // Prepare the set of common attributes / configuration that is
                // required by all annotation groups. These are mainly in the root
                // annotation tag.
                sharedOptions = extend({
                    interactionevents: pluck(logic.annotationInteractionEvents, true),
                    showbelow: pluck(definition.showbelow, definition.showbelowchart),
                    autoscale: definition.autoscale,
                    scaletext: definition.scaletext,
                    scaleimages: definition.scaleimages,
                    constrainedscale: definition.constrainedscale,
                    scaleonresize: scaleOnResize,
                    origw: pluck(definition.origw, data.chart.origw, scaleOnResize ?
                        logic.origRenderWidth : chart.chartWidth),
                    origh: pluck(definition.origh, data.chart.origh, scaleOnResize ?
                        logic.origRenderHeight : chart.chartHeight),
                    xshift: definition.xshift,
                    yshift: definition.yshift,
                    grpxshift: definition.grpxshift,
                    grpyshift: definition.grpyshift,
                    xscale: definition.xscale,
                    yscale: definition.yscale,
                    // special scaling at annotations tag
                    rootxscale: pluckNumber(definition.xscale, 100) / 100,
                    rootyscale: pluckNumber(definition.yscale, 100) / 100
                }, sharedOptions);

                chartObj.annotations.reset(definition, sharedOptions, logic.snapLiterals);
            }
            else {
                chartObj.annotations.clear();
            }
        },

        dispose: function () {
            var logic = this,
                prop;

            logic.disposing = true;
            // execute specific objects that has dispose functions
            logic.renderer && logic.renderer.dispose();
            logic.numberFormatter && logic.numberFormatter.dispose();

            logic.hcJSON && logic.hcJSON.chart && logic.hcJSON.chart.renderTo && (delete logic.hcJSON.chart.renderTo);

            // remove all variables
            for (prop in logic) {
                delete logic[prop];
            }
            delete logic.disposing;
            logic.disposed = true;
        }

    });

    chartAPI('stub', {
        init: function (container, dataObj, chartObj) {
            this.containerElement = container;
            this.smartLabel = chartObj.jsVars.smartLabel;
        },

        standaloneInit: true
    }, chartAPI.base);

    chartAPI('barbase', {
        spaceManager: function () {
            return this.placeHorizontalXYSpaceManager.apply(this, arguments);
        }
    }, chartAPI.base);

    //// add the singleseries
    chartAPI('singleseries', {
        series : function (FCObj, HCObj, chartName) {
            var data = FCObj.data || (FCObj.dataset && FCObj.dataset[0] && FCObj.dataset[0].data),
                series,
                seriesArr;
            //if (FCObj.data && FCObj.data.length > 0) {
            if (data && data.length > 0 && data instanceof Array) {
                series = {
                    data : [],
                    hoverEffects: this.parseSeriesHoverOptions(FCObj, HCObj, {}, chartName),
                    // for single series the color will be added point by point from palette
                    colorByPoint: true
                };

                /////////if any SPECIAL settings needed for single series chart

                //disable the legend (special case for pie)
                HCObj.legend.enabled = false;

                //add data using chart speciffic function
                seriesArr = this.point(chartName, series, data, FCObj.chart, HCObj);
                //if the returned series is an array of series (case: pareto)
                if (seriesArr instanceof Array) {
                    HCObj.series = HCObj.series.concat(seriesArr);
                }
                //all other case there will be only1 series
                else {
                    HCObj.series.push(seriesArr);
                }

                ///configure the axis
                this.configureAxis(HCObj, FCObj);
                ///////////Trend-lines /////////////////
                if (FCObj.trendlines) {
                    createTrendLine (FCObj.trendlines, HCObj.yAxis, HCObj[FC_CONFIG_STRING],
                        false, this.isBar);
                }

            }
        },
        defaultSeriesType : BLANKSTRING,
        configureAxis : yxAxisConfigurer,
        pointValueWatcher : pointValueWatcher,

        // Function to parse hover effect options
        parseSeriesHoverOptions: function (FCObj, HCObj, dataset) {
            var globalHoverEffects = HCObj.chart.plotHoverEffects,
                // Parse hover effects
                hoverEffect = pluck(dataset.showhovereffect, dataset.hovereffect,
                     globalHoverEffects.enabled),
                hoverEffects;

            hoverEffects = { enabled: hoverEffect };
            hoverEffects.highlight = pluckNumber(dataset.highlightonhover,
                            dataset.highlightplotonhover, globalHoverEffects.highlight);

            hoverEffects.columnHighlight = pluckNumber(hoverEffects.highlight,
                    dataset.highlightcolumnonhover,
                    dataset.highlightbaronhover,
                    globalHoverEffects.columnHighlight
                );
            hoverEffects.anchorHighlight = pluckNumber(hoverEffects.highlight,
                    dataset.highlightanchoronhover,
                    globalHoverEffects.anchorHighlight
                );
            hoverEffects.anchorHighlight = pluckNumber(hoverEffects.highlight,
                    dataset.highlightimageonhover,
                    globalHoverEffects.imageHighlight
                );
            hoverEffects.bubbleHighlight = pluckNumber(hoverEffects.highlight,
                    dataset.highlightbubbleonhover,
                    dataset.highlightbaronhover,
                    globalHoverEffects.bubbleHighlight
                );

            hoverEffects.imageHoverAlpha = pluck(dataset.anchorimagehoveralpha,
                            globalHoverEffects.anchorImageHoverAlpha);
            hoverEffects.imageHoverScale = pluck(dataset.anchorimagehoverscale,
                            globalHoverEffects.anchorImageHoverScale);

            hoverEffects.color = pluck(dataset.hovercolor,
                            dataset.bubblehovercolor,
                            //dataset.anchorhovercolor,
                           // dataset.anchorbghovercolor,
                            globalHoverEffects.color);

            hoverEffects.alpha = pluck(dataset.hoveralpha,
                            //dataset.anchorhoveralpha,
                            globalHoverEffects.alpha);

            hoverEffects.scale = pluck(dataset.hoverscale, dataset.bubblehoverscale,
                            globalHoverEffects.scale);

            hoverEffects.gradientColor = (dataset.hovergradientcolor !== UNDEFINED ?
                            dataset.hovergradientcolor :
                            globalHoverEffects.gradientColor);

            hoverEffects.ratio = pluck(dataset.hoverratio,
                            globalHoverEffects.ratio);

            hoverEffects.angle = pluck(dataset.hoverangle,
                            globalHoverEffects.angle);

            hoverEffects.borderColor = pluck(dataset.borderhovercolor,
                            globalHoverEffects.borderColor);

            hoverEffects.borderAlpha = pluck(dataset.borderhoveralpha,
                            globalHoverEffects.borderAlpha);

            hoverEffects.borderThickness = pluckNumber(dataset.borderhoverthickness,
                            globalHoverEffects.borderThickness);

            hoverEffects.borderDashed =  pluckNumber(dataset.borderhoverdashed,
                            globalHoverEffects.borderDashed);

            hoverEffects.borderDashGap = pluckNumber(dataset.borderhoverdashgap,
                            globalHoverEffects.borderDashGap);

            hoverEffects.borderDashLen = pluckNumber(dataset.borderhoverdashlen,
                            globalHoverEffects.borderDashLen);

            hoverEffects.shadow = pluck(dataset.hovershadow,
                            globalHoverEffects.shadow);

            hoverEffects.anchorSides = pluck(dataset.anchorhoversides,
                            globalHoverEffects.anchorSides);

            hoverEffects.anchorRadius = pluck(dataset.anchorhoverradius,
                            globalHoverEffects.anchorRadius);

            hoverEffects.anchorScale = pluck(dataset.anchorhoverscale,
                            globalHoverEffects.anchorScale);

            hoverEffects.anchorAlpha = pluck(dataset.anchorhoveralpha,
                dataset.hoveralpha, globalHoverEffects.anchorAlpha);

            hoverEffects.anchorBgColor = pluck(dataset.anchorbghovercolor,
                    dataset.anchorhovercolor, globalHoverEffects.anchorBgColor);

            hoverEffects.anchorBgAlpha = pluck(dataset.anchorbghoveralpha,
                            globalHoverEffects.anchorBgAlpha);

            hoverEffects.anchorBorderColor = pluck(dataset.anchorborderhovercolor,
                            globalHoverEffects.anchorBorderColor);

            hoverEffects.anchorBorderAlpha = pluck(dataset.anchorborderhoveralpha,
                            globalHoverEffects.anchorBorderAlpha);

            hoverEffects.anchorBorderThickness = pluckNumber(dataset.anchorborderhoverthickness,
                            globalHoverEffects.anchorBorderThickness);

            hoverEffects.anchorStartAngle = pluck(dataset.anchorhoverstartangle,
                            globalHoverEffects.anchorStartAngle);

            hoverEffects.anchorDip = pluck(dataset.anchorhoverdip,
                            globalHoverEffects.anchorDip);

            hoverEffects.anchorAnimation = pluckNumber(dataset.anchorhoveranimation,
                            globalHoverEffects.anchorAnimation, 1);

            hoverEffects.negativeColor = pluck(dataset.negativehovercolor,
                    globalHoverEffects.negativeColor);

            hoverEffects.is3DBubble = pluckNumber(dataset.is3donhover,
                    globalHoverEffects.is3DBubble);


            return hoverEffects;
        },

        // Function to set point hover effect
        pointHoverOptions: function (dataObj, series, pointCosmetics) {
            var highlightColors,
                hColorsLen,
                hColorsLoop,
                isHoverColorString,
                rolloverProperties = {},
                seriesHoverEffects = series.hoverEffects,
                hoverEffect = pluckNumber(dataObj.hovereffect,
                                seriesHoverEffects && seriesHoverEffects.enabled),
                quickEnabled = false,
                hoverEffects = { enabled: hoverEffect },
                plot = pointCosmetics && (BLANKSTRING + (
                    pointCosmetics.plotType).toLowerCase());


            // Detect whether any of the hover effect attributes are explicitly set or not
            // Enable hover effect when any of the hover attributes are explicitly set
            if (hoverEffect === UNDEFINED) {
                if (this.forceHoverEnable) {
                    quickEnabled = hoverEffect = hoverEffects.enabled = true;
                } else {
                    if (plot == 'anchor') {
                        if (pointCosmetics.imageUrl) {
                            quickEnabled = hoverEffect = hoverEffects.enabled =
                                pluck(dataObj.anchorimagehoveralpha,
                                seriesHoverEffects.imageHoverAlpha,
                                dataObj.anchorimagehoverscale,
                                seriesHoverEffects.imageHoverScale, UNDEFINED
                            ) !== UNDEFINED;
                        } else {
                            quickEnabled = hoverEffect = hoverEffects.enabled = pluck (
                                dataObj.hovercolor, dataObj.anchorhovercolor,dataObj.anchorbghovercolor,
                                seriesHoverEffects.anchorBgColor,seriesHoverEffects.color,
                                dataObj.hoveralpha, dataObj.anchorhoveralpha,seriesHoverEffects.anchorAlpha,
                                dataObj.bghoveralpha, dataObj.anchorbghoveralpha, seriesHoverEffects.anchorBgAlpha,
                                dataObj.anchorborderhovercolor, dataObj.borderhovercolor,
                                seriesHoverEffects.anchorBorderColor, dataObj.anchorborderhoverthickness,
                                dataObj.borderhoverthickness, seriesHoverEffects.anchorBorderThickness,
                                dataObj.anchorborderhoveralpha, dataObj.borderhoveralpha,
                                seriesHoverEffects.anchorBorderAlpha, dataObj.hoverdip, dataObj.anchorhoverdip,
                                seriesHoverEffects.anchorDip, dataObj.anchorhoverstartangle,
                                seriesHoverEffects.anchorStartAngle, dataObj.hoversides, dataObj.anchorhoversides,
                                seriesHoverEffects.anchorSides, dataObj.hoverradius, dataObj.anchorhoverradius,
                                seriesHoverEffects.anchorRadius, UNDEFINED
                            ) !== UNDEFINED;
                        }
                    }

                    if (plot == 'column' || plot == 'bubble') {
                        quickEnabled = hoverEffect = hoverEffects.enabled = pluck (
                            dataObj.hoveralpha, seriesHoverEffects.alpha,
                            dataObj.hovergradientcolor, seriesHoverEffects.gradientColor,
                            dataObj.borderhovercolor, seriesHoverEffects.borderColor,
                            dataObj.borderhoverthickness, seriesHoverEffects.borderThickness,
                            dataObj.hoverratio, seriesHoverEffects.ratio,
                            dataObj.hoverangle, seriesHoverEffects.angle,
                            dataObj.borderhoveralpha, seriesHoverEffects.borderAlpha,
                            dataObj.borderhoverdashed, seriesHoverEffects.borderDashed,
                            dataObj.borderhoverdashgap, seriesHoverEffects.borderDashGap,
                            dataObj.borderhoverdashlen, seriesHoverEffects.borderDashLen,
                            dataObj.hovercolor, seriesHoverEffects.color,
                            UNDEFINED
                        ) !== UNDEFINED;
                    }

                    if (!quickEnabled && plot == 'bubble') {
                        quickEnabled = hoverEffect = hoverEffects.enabled = pluck (
                          dataObj.negativehovercolor, seriesHoverEffects.negativeColor,
                          dataObj.is3donhover, seriesHoverEffects.is3DBubble,
                          dataObj.hoverscale, seriesHoverEffects.scale,
                          UNDEFINED
                        ) !== UNDEFINED;
                    }

                    if (plot == 'pie') {
                        quickEnabled = hoverEffect = hoverEffects.enabled = pluck (
                            dataObj.hovercolor, seriesHoverEffects.color,
                            dataObj.hoveralpha, seriesHoverEffects.alpha,
                            dataObj.borderhovercolor, seriesHoverEffects.borderColor,
                            dataObj.borderhoverthickness, seriesHoverEffects.borderThickness,
                            dataObj.borderhoveralpha, seriesHoverEffects.borderAlpha,
                            UNDEFINED
                        ) !== UNDEFINED;
                    }
                }
            }

            if (hoverEffect) {
                hoverEffects.highlight = pluckNumber(dataObj.highlightonhover,
                                seriesHoverEffects.highlight);

                hoverEffects.columnHighlight = pluckNumber(hoverEffects.highlight,
                        dataObj.highlightcolumnonhover,
                        dataObj.highlightbaronhover
                    );
                hoverEffects.anchorHighlight = pluckNumber(hoverEffects.highlight,
                        dataObj.highlightanchoronhover
                    );
                hoverEffects.bubbleHighlight = pluckNumber(hoverEffects.highlight,
                        dataObj.highlightbubbleonhover
                    );

                // Hover effects related to column and bubble
                hoverEffects.alpha = pluck(dataObj.hoveralpha,
                                seriesHoverEffects.alpha, pointCosmetics.alpha);

                hoverEffects.scale = pluck(dataObj.hoverscale,
                                seriesHoverEffects.scale, 1);

                hoverEffects.gradientColor = dataObj.hovergradientcolor === UNDEFINED ?
                    seriesHoverEffects.gradientColor: dataObj.hovergradientcolor;

                hoverEffects.borderColor = pluck(dataObj.borderhovercolor,
                                seriesHoverEffects.borderColor, pointCosmetics.borderColor);

                hoverEffects.borderThickness = pluckNumber(dataObj.borderhoverthickness,
                                seriesHoverEffects.borderThickness, pointCosmetics.borderWidth);

                hoverEffects.ratio = pluck(dataObj.hoverratio,
                                seriesHoverEffects.ratio, pointCosmetics.ratio);

                hoverEffects.angle = pluck(dataObj.hoverangle,
                                seriesHoverEffects.angle, pointCosmetics.angle);

                hoverEffects.borderAlpha = pluck(dataObj.borderhoveralpha,
                                seriesHoverEffects.borderAlpha, pointCosmetics.borderAlpha);

                hoverEffects.borderDashed =  pluckNumber(dataObj.borderhoverdashed,
                                seriesHoverEffects.borderDashed, pointCosmetics.borderDashed, 0);

                hoverEffects.borderDashGap = pluckNumber(dataObj.borderhoverdashgap,
                                seriesHoverEffects.borderDashGap, pointCosmetics.borderDashGap);

                hoverEffects.borderDashLen = pluckNumber(dataObj.borderhoverdashlen,
                                seriesHoverEffects.borderDashLen, pointCosmetics.borderDashLen);

                hoverEffects.shadow = pluck(dataObj.hovershadow,
                                seriesHoverEffects.shadow, 0);

                hoverEffects.color = pluck(dataObj.hovercolor,
                                seriesHoverEffects.color);

                // Anchor attributes
                if (plot == 'anchor') {
                    if (pointCosmetics.imageUrl) {
                        hoverEffects.imageHoverAlpha = pluckNumber(dataObj.anchorimagehoveralpha,
                            seriesHoverEffects.imageHoverAlpha, 100);
                        hoverEffects.imageHoverScale = pointCosmetics.imageScale *
                            mathAbs(pluckNumber(dataObj.anchorimagehoverscale,
                            seriesHoverEffects.imageHoverScale, 110)) * 0.01;
                        hoverEffects.anchorAnimation = pluckNumber(dataObj.anchorhoveranimation,
                                        seriesHoverEffects.anchorAnimation, 1);
                    } else {
                        hoverEffects.anchorColor = getFirstColor(pluck(dataObj.hovercolor,
                                        dataObj.anchorhovercolor,
                                        dataObj.anchorbghovercolor,
                                        seriesHoverEffects.anchorBgColor,
                                        seriesHoverEffects.color,
                                        pointCosmetics.anchorBgColor));

                        hoverEffects.anchorAlpha = pluck(dataObj.hoveralpha,
                                        dataObj.anchorhoveralpha,
                                        seriesHoverEffects.anchorAlpha,
                                        pointCosmetics.anchorAlpha);

                        hoverEffects.anchorBgAlpha = pluck(dataObj.bghoveralpha,
                                        dataObj.anchorbghoveralpha,
                                        seriesHoverEffects.anchorBgAlpha,
                                        hoverEffects.anchorAlpha,
                                        pointCosmetics.anchorBgAlpha);

                        hoverEffects.anchorBorderColor = pluck(dataObj.anchorborderhovercolor,
                                        dataObj.borderhovercolor,
                                        seriesHoverEffects.anchorBorderColor,
                                        pointCosmetics.anchorBorderColor);

                        hoverEffects.anchorBorderThickness = pluck(
                                        dataObj.anchorborderhoverthickness,
                                        dataObj.borderhoverthickness,
                                        seriesHoverEffects.anchorBorderThickness,
                                        pointCosmetics.anchorBorderThickness);

                        hoverEffects.anchorBorderAlpha = pluckNumber(
                                        dataObj.anchorborderhoveralpha,
                                        dataObj.borderhoveralpha,
                                        seriesHoverEffects.anchorBorderAlpha,
                                        hoverEffects.anchorAlpha,
                                        pointCosmetics.anchorBorderAlpha);

                        hoverEffects.anchorDip = pluckNumber(dataObj.hoverdip,
                                        dataObj.anchorhoverdip,
                                        seriesHoverEffects.anchorDip);

                        hoverEffects.startAngle = pluck(
                                dataObj.anchorhoverstartangle,
                                seriesHoverEffects.anchorStartAngle,
                                pointCosmetics.anchorAngle);

                        hoverEffects.anchorSides = pluckNumber(dataObj.hoversides,
                                        dataObj.anchorhoversides,
                                        seriesHoverEffects.anchorSides,
                                        pointCosmetics.anchorSides);

                        // deafult plot radius will be set later
                        hoverEffects.anchorRadius = pluckNumber(dataObj.hoverradius,
                                        dataObj.anchorhoverradius,
                                        seriesHoverEffects.anchorRadius);

                        hoverEffects.anchorScale = pluckNumber(dataObj.hoverscale,
                                        dataObj.anchorhoverscale,
                                        seriesHoverEffects.anchorScale);

                        hoverEffects.anchorAnimation = pluckNumber(dataObj.anchorhoveranimation,
                                        seriesHoverEffects.anchorAnimation, 1);

                        if (hoverEffects.anchorRadius === UNDEFINED) {
                            hoverEffects.anchorRadius = !quickEnabled || hoverEffects.anchorHighlight ?
                                (pointCosmetics.anchorRadius &&
                                        pointCosmetics.anchorRadius + 1) : pointCosmetics.anchorRadius;
                        }
                    }
                }

                if (quickEnabled || ((hoverEffects.columnHighlight || hoverEffects.bubbleHighlight) &&
                        hoverEffects.color && hoverEffects.highlight == 1)) {
                    hoverEffects.highlight = 0;
                }

                // Re-define color for column
                if (plot == 'column') {
                    hoverEffects.color = (pluck(hoverEffects.color,
                            pointCosmetics.color) +
                            COMMASTRING +
                            (hoverEffects.gradientColor === UNDEFINED ?
                                    pointCosmetics.gradientColor:
                                            hoverEffects.gradientColor))
                            .replace(/,+?$/,'');
                }

                if (plot === 'pie') {
                    hoverEffects.color = pluck(hoverEffects.color,
                        pointCosmetics.color).replace(/,+?$/,'');
                }

                if (plot == 'bubble') {

                    hoverEffects.negativeColor = pluck(dataObj.negativehovercolor,
                                    seriesHoverEffects.negativeColor,
                                    pointCosmetics.negativeColor);

                    hoverEffects.is3d = pluckNumber(dataObj.is3donhover,
                                    seriesHoverEffects.is3DBubble, pointCosmetics.is3d);

                    hoverEffects.color = hoverEffects.negativeColor && dataObj.z < 0 ?
                                hoverEffects.negativeColor :
                                        (hoverEffects.color || pointCosmetics.color);

                    isHoverColorString = typeof hoverEffects.color == 'string';

                    hoverEffects.color = getFirstColor(isHoverColorString?
                        hoverEffects.color : hoverEffects.color.FCcolor.color
                    );

                    hoverEffects.color = hoverEffects.is3d ? chartAPI.bubble.getPointColor(hoverEffects.color,
                        hoverEffects.alpha) : {
                            FCcolor: {
                                color: hoverEffects.color,
                                alpha: hoverEffects.alpha
                            }
                        };
                }

                if (hoverEffects.highlight == 1 && plot !== 'anchor') {
                    isHoverColorString = typeof hoverEffects.color == 'string';

                    highlightColors = isHoverColorString ?
                        hoverEffects.color.split(/\s{0,},\s{0,}/) :
                        hoverEffects.color.FCcolor.color.split(/\s{0,},\s{0,}/);

                    hColorsLen = highlightColors.length;
                    for (hColorsLoop = 0; hColorsLoop < hColorsLen; hColorsLoop++) {
                        highlightColors[hColorsLoop] = getLightColor(highlightColors[hColorsLoop], 70);
                    }

                    if (isHoverColorString) {
                        hoverEffects.color = highlightColors.join(',');
                    }
                    else {
                        hoverEffects.color.FCcolor.color = highlightColors.join(',');
                    }
                }

                if (plot === 'pie') {
                    rolloverProperties = {
                        color: this.getPointColor(hoverEffects.color, hoverEffects.alpha,
                            pointCosmetics.radius3D),
                        alpha: hoverEffects.alpha,
                        borderColor: convertColor(hoverEffects.borderColor,
                            hoverEffects.borderAlpha),
                        borderWidth: hoverEffects.borderThickness
                    };
                }

                if (plot == 'column') {
                    hoverEffects.colorArr = getColumnColor (
                    hoverEffects.color,
                    hoverEffects.alpha,
                    hoverEffects.ratio,
                    hoverEffects.angle,
                    pointCosmetics.isRoundEdged,
                    hoverEffects.borderColor,
                    mathMin(hoverEffects.alpha, hoverEffects.borderAlpha).toString(),
                    pointCosmetics.isBar,
                    pointCosmetics.is3d);

                    hoverEffects.dashStyle = hoverEffects.borderDashed ?
                        getDashStyle(hoverEffects.borderDashLen,
                            hoverEffects.borderDashGap, hoverEffects.borderThickness) :
                                'none';

                    rolloverProperties = {
                        shadow: hoverEffects.shadow,
                        color: hoverEffects.colorArr[0],
                        borderColor: hoverEffects.colorArr[1],
                        borderWidth: hoverEffects.borderThickness,
                        use3DLighting: pointCosmetics.use3DLighting,
                        dashStyle: hoverEffects.dashStyle
                    };

                }

                if (plot == 'anchor') {
                    if (!pointCosmetics.imageUrl) {
                        rolloverProperties = {
                            animation: hoverEffects.anchorAnimation,
                            shadow: hoverEffects.shadow,
                            fillColor: {
                                FCcolor: {
                                    color: hoverEffects.anchorColor,
                                    alpha: ((hoverEffects.anchorBgAlpha *
                                        hoverEffects.anchorAlpha) / 100) +
                                        BLANKSTRING
                                }
                            },
                            lineColor: {
                                FCcolor: {
                                    color: hoverEffects.anchorBorderColor,
                                    alpha: hoverEffects.anchorBorderAlpha
                                }
                            },
                            lineWidth: hoverEffects.anchorBorderThickness,
                            radius: hoverEffects.anchorRadius,
                            symbol: mapSymbolName(hoverEffects.anchorSides),
                            startAngle: hoverEffects.startAngle,
                            sides: hoverEffects.anchorSides,
                            scale: hoverEffects.anchorScale,
                            dip: hoverEffects.anchorDip
                        };
                    } else {
                        rolloverProperties = {
                            animation: hoverEffects.anchorAnimation,
                            imageHoverAlpha: hoverEffects.imageHoverAlpha,
                            imageHoverScale: hoverEffects.imageHoverScale
                        };
                    }
                }

                if (plot == 'bubble') {
                    rolloverProperties = {
                        symbol: hoverEffects.seriesAnchorSymbol,
                        shadow: hoverEffects.shadow,
                        scale: hoverEffects.scale,
                        fillColor: hoverEffects.color,
                        lineColor: {
                            FCcolor: {
                                color: hoverEffects.borderColor,
                                alpha: hoverEffects.alpha
                            }
                        },
                        lineWidth: hoverEffects.borderThickness
                    };
                }
            }

            return {
                enabled: hoverEffect,
                options: hoverEffects,
                rolloverOptions: rolloverProperties
            };
        },

        // Function to create tooltext for individual data points
        getPointStub: function (setObj, value, label, HCObj) {
            var iapi = this,
                    dataObj = iapi.dataObj,
                    FCCHartObj = dataObj.chart,
            toolText, displayValue, dataLink, HCConfig = HCObj[FC_CONFIG_STRING],
            formatedVal = value === null ? value : HCConfig.numberFormatter.dataLabels(value),
            setTooltext = getValidValue(parseUnsafeString(pluck(setObj.tooltext, HCConfig.tooltext))),
            setDisplayValue = getValidValue(parseUnsafeString(setObj.displayvalue));

            //create the tooltext
            if (!HCConfig.showTooltip) {
                toolText = BLANKSTRING;
            }
            else if (setTooltext !== undefined) {
                toolText = parseTooltext(setTooltext, [1,2,3,5,6,7], {
                    formattedValue: formatedVal,
                    label: label,
                    yaxisName: parseUnsafeString(FCCHartObj.yaxisname),
                    xaxisName: parseUnsafeString(FCCHartObj.xaxisname)
                }, setObj, FCCHartObj);
            }
            else {//determine the dispalay value then
                toolText = formatedVal === null ? false :
                (label !== BLANKSTRING) ? label + HCConfig.tooltipSepChar + formatedVal : formatedVal;
            }
            //create the displayvalue
            if (!pluckNumber(setObj.showvalue, HCConfig.showValues)) {
                displayValue = BLANKSTRING;
            }
            else if (setDisplayValue !== undefined) {
                displayValue = setDisplayValue;
            }
            else {//determine the dispalay value then
                displayValue = formatedVal;
            }

            ////create the link
            dataLink = pluck(setObj.link);
            return {
                displayValue: displayValue,
                categoryLabel: label,
                toolText: toolText,
                link: dataLink
            };
        },

        //
        updateSnapPoints: function () {
            var iapi = this,
                snaps = iapi.snapLiterals,
                xyCalculator = function (what, bbox) {
                    var ret = 0;

                    switch (what) {
                        case 'startx':
                            ret = bbox.x;
                            break;

                        case 'starty':
                            ret = bbox.y;
                            break;

                        case 'x':
                        case 'middlex':
                        case 'centerx':
                            ret = bbox.x + (bbox.width / 2);
                            break;

                        case 'y':
                        case 'middley':
                        case 'centery':
                            ret = bbox.y + (bbox.height / 2);
                            break;

                        case 'endx':
                            ret = (bbox.x + bbox.width);
                            break;

                        case 'endy':
                            ret = (bbox.y + bbox.height);
                            break;

                        default:
                            ret = 0;
                    }

                    return ret;
                };

            /**
             * Evaluates a macro that corresponds to elements in a dataset.
             *
             * @param {array} subtokens The array containing the subtokens that follow the $dataset directive.
             * @param {boolean} isBelow. A boolean value indicating whether the shape in which the subtokens
             * is used is drawn above or below the chart.
             *
             * @return {number} ret The numerical value that corresponds to the given macro.
             *
             */
            snaps.dataset = function (subtokens, isBelow) {
                var plots = (iapi.renderer && iapi.renderer.plots),
                    datasetIndex,
                    what,
                    item,
                    bbox,
                    ret,
                    plotIndex,
                    graphic,
                    is3DPlot = iapi.is3D;

                if (!plots || !plots.length) {
                    return 0;
                }

                if (!isNaN(subtokens[0])) {
                    datasetIndex = Number(subtokens[0]);
                    subtokens = subtokens.slice(1);
                }
                else {
                    datasetIndex = 0;
                }

                what = subtokens[0];

                if (what === 'set') {

                    if (!isNaN(subtokens[1])) {
                        plotIndex = Number(subtokens[1]);
                        subtokens = subtokens.slice(2);
                    }
                    else {
                        plotIndex = 0;
                        subtokens = subtokens.slice(1);
                    }

                    what = subtokens[0];
                    item = plots[datasetIndex] && plots[datasetIndex].items[plotIndex];
                    graphic = item && item.graphic;

                    if (!graphic) {
                        return 0;
                    }

                    if (isBelow && is3DPlot) {
                        bbox = graphic._getBBox2();
                    }
                    else {
                        bbox = graphic.getBBox();
                    }

                    ret = xyCalculator(what, bbox);

                    return ret;
                }

                return ret;
            };

            /**
             * Evaluates a macro that corresponds to elements of the xaxis.
             *
             * @param {array} subtokens The array containing the subtokens that follow the $dataset directive.
             *
             * @return {number} ret The numerical value that corresponds to the given macro.
             *
             */
            snaps.xaxis = function (subtokens) {

                var xlabels = (iapi.renderer && iapi.renderer.xAxis && iapi.renderer.xAxis[0] &&
                        iapi.renderer.xAxis[0].labels),
                    labelIndex,
                    what,
                    bbox,
                    ret,
                    graphic;

                if (!xlabels || !xlabels.length) {
                    return 0;
                }

                what = subtokens[0];

                if (what === 'label') {

                    if (!isNaN(subtokens[1])) {
                        labelIndex = Number(subtokens[1]);
                        subtokens = subtokens.slice(2);
                    }
                    else {
                        labelIndex = 0;
                        subtokens = subtokens.slice(1);
                    }

                    what = subtokens[0];
                    graphic = xlabels[labelIndex];

                    if (!graphic) {
                        return 0;
                    }

                    bbox = graphic.getBBox();
                    ret = xyCalculator(what, bbox);

                    return ret;
                }

                return ret;
            };

            /**
             * Evaluates a macro that corresponds to elements of the yaxis.
             *
             * @param {array} subtokens The array containing the subtokens that follow the $dataset directive.
             *
             * @return {number} ret The numerical value that corresponds to the given macro.
             *
             */
            snaps.yaxis = function (subtokens) {

                var yaxis = (iapi.renderer && iapi.renderer.yAxis),
                    axisIndex,
                    axis,
                    yaxislabels,
                    labelIndex,
                    what,
                    bbox,
                    ret,
                    graphic;

                if (!yaxis || !yaxis.length) {
                    return 0;
                }

                if (!isNaN(subtokens[0])) {
                    axisIndex = Number(subtokens[0]);
                    subtokens = subtokens.slice(1);
                }
                else {
                    axisIndex = 0;
                }

                axis = yaxis[axisIndex];

                if (!axis) {
                    return 0;
                }

                what = subtokens[0];

                if (what === 'label') {

                    yaxislabels = axis.labels;

                    if (!isNaN(subtokens[1])) {
                        labelIndex = Number(subtokens[1]);
                        subtokens = subtokens.slice(2);
                    }
                    else {
                        labelIndex = 0;
                        subtokens = subtokens.slice(1);
                    }

                    what = subtokens[0];
                    graphic = yaxislabels[labelIndex];

                    if (!graphic) {
                        return 0;
                    }

                    bbox = graphic.getBBox();
                    ret = xyCalculator(what, bbox);

                    return ret;
                }

                return ret;
            };
        }

    }, chartAPI.base);

    //// add the multyseries
    chartAPI('multiseries', {
        series : function (FCObj, HCObj, chartName) {
            var index,
                length,
                conf = HCObj[FC_CONFIG_STRING],
                dataset,
                series,
                seriesArr;

            /*
            // Use single series data for ms charts
            if (!FCObj.dataset && FCObj.data && !FCObj.categories) {
                FCObj.dataset = [{data: FCObj.data}];
                FCObj.categories = [{category: []}];
                for (index = 0; index < FCObj.data.length; index += 1) {
                    FCObj.categories[0].category.push({
                        label: pluck(FCObj.data[index].label, FCObj.data[index].name, '')
                    })
                }
            }
            */

            //enable the legend
            HCObj.legend.enabled = Boolean(pluckNumber(FCObj.chart.showlegend, 1));

            if (FCObj.dataset && FCObj.dataset.length > 0) {
                // add category
                this.categoryAdder(FCObj, HCObj);
                //add data series
                for (index = 0, length = FCObj.dataset.length; index < length; index += 1) {

                    dataset = FCObj.dataset[index];

                    // Create stub series
                    series = {
                        hoverEffects: this.parseSeriesHoverOptions(FCObj, HCObj, dataset, chartName),
                        visible: !pluckNumber(dataset.initiallyhidden, 0),
                        data : []
                    };
                    //add numColumns for all non-stacked charts
                    if (!this.isStacked){
                        series.numColumns = length;
                    }
                    //add data to the series
                    seriesArr = this.point(chartName, series,
                        dataset, FCObj.chart, HCObj, conf.oriCatTmp.length,
                        index);


                    //if the returned series is an array of series (case: pareto)
                    if (seriesArr instanceof Array) {
                        HCObj.series = HCObj.series.concat(seriesArr);
                    }
                    //all other case there will be only1 series
                    else {
                        HCObj.series.push(seriesArr);
                    }
                }
                ///configure the axis
                this.configureAxis(HCObj, FCObj);
                ///////////Trend-lines /////////////////
                //for log it will be done in configureAxis
                if (FCObj.trendlines && !this.isLog) {
                    createTrendLine (FCObj.trendlines, HCObj.yAxis, conf,
                        false, this.isBar, undefined, this.inversed);
                }

            }
        },
        categoryAdder : function(FCObj, HCObj) {
            var index,
                countCat = 0,
                fontSize,
                conf = HCObj[FC_CONFIG_STRING],
                axisGridManager = conf.axisGridManager,
                FCChartObj = FCObj.chart,
                xAxisObj = HCObj.xAxis,
                dataLabel,
                axisConf = conf.x,
                showLabels,
                oriCatTmp,
                categories,
                catObj;

            if (FCObj.categories && FCObj.categories[0] && FCObj.categories[0].category) {
                //update the font relate attr in HC cat
                if (FCObj.categories[0].font) {
                    HCObj.xAxis.labels.style.fontFamily  = FCObj.categories[0].font;
                }
                if ((fontSize = pluckNumber(FCObj.categories[0].fontsize)) !== undefined) {
                    if (fontSize < 1) {
                        fontSize = 1;
                    }
                    HCObj.xAxis.labels.style.fontSize  = fontSize + PXSTRING;
                    setLineHeight(HCObj.xAxis.labels.style);
                }
                if (FCObj.categories[0].fontcolor) {
                    HCObj.xAxis.labels.style.color  = FCObj.categories[0].fontcolor.
                    split(COMMASTRING)[0].replace(/^\#?/, '#');
                }
                //temp object for cat text in data tooltext
                oriCatTmp = HCObj[FC_CONFIG_STRING].oriCatTmp;
                categories = FCObj.categories[0].category;
                for (index = 0; index < categories.length; index += 1) {
                    if (!categories[index].vline) {
                        showLabels = pluckNumber(categories[index].showlabel, FCChartObj.showlabels, 1);
                        catObj = FCObj.categories[0].category[index];
                        dataLabel = parseUnsafeString(getFirstValue(catObj.label,
                            catObj.name));
                        axisGridManager.addXaxisCat(xAxisObj, countCat, countCat, showLabels ? dataLabel : BLANKSTRING,
                            {}, catObj, FCChartObj);
                        oriCatTmp[countCat] = getFirstValue(parseUnsafeString(
                            catObj.tooltext), dataLabel);
                        countCat += 1;
                    }
                    else {
                        axisGridManager.addVline(xAxisObj, categories[index], countCat, HCObj);
                    }
                }
            }
            axisConf.catCount = countCat;
        },

        /*
         * Function to create tooltext, displayValu etc for individual data points
         * ~param {object} setObj set tag JSON corresponding to the point
         * ~param {number} value Value of the point
         * ~param {string} label Corresponding xAxis label
         * ~param {object} HCObj Corresponding HCObj
         * ~param {object} dataset Corresponding dataset tag JSON
         * ~param {Bolean} datasetShowValues Flag whether we have to show Value(dataset level)
         * ~param {number} yAxisIndex corresponding yAxis index
         * ~param {number} errorValue errorValue forErrorcharts only
         * ~param {number} hErrorValue HorozontalErrorValue for errorScatter only
         * ~param {number} xValue xposition of the Point(applicable for ErrorScatter only
         */
        getPointStub: function (setObj, value, label, HCObj, dataset, datasetShowValues, yAxisIndex, errorValue,
                hErrorValue, xValue) {
            var iapi = this,
                dataObj = iapi.dataObj,
                FCCHartObj = dataObj.chart,
                isDual = iapi.isDual,
                isXY = iapi.isXY,
                isMLAxis = iapi.isMLAxis,
                isStacked = iapi.isStacked,
                isErrorChart = iapi.isErrorChart,
                toolText, displayValue, HCConfig = HCObj[FC_CONFIG_STRING],
                showPercentValuesRequared, showPercentInToolTipRequared,
                formatedVal = value === null ? value : iapi.numberFormatter.dataLabels(value, yAxisIndex),
                seriesname, setTooltext = getValidValue(parseUnsafeString(pluck(setObj.tooltext, dataset.plottooltext,
                    HCConfig.tooltext))),
                tooltipSepChar = HCConfig.tooltipSepChar,
                parserConfig,
                errorParserConfig,
                macroIndices,
                errorMacroIndices,
                returnObj = {},
                errorTooltext,
                hErrorTooltext,
                formattedErrorValue,
                formattedHErrorValue,
                yAxisName,
                xAxisName,
                errorPercentValue,
                hErrorPercentValue,
                unformattedErrorValue,
                unformattedHErrorValue;
            /*
             * If Error chart then parseErrorRelated configurations
             * Also create tooltext for error plots
             */
            if (isErrorChart) {
                formattedErrorValue = errorValue === null ?
                    errorValue : iapi.numberFormatter.dataLabels(errorValue, yAxisIndex);
                errorPercentValue = value === null ?
                    BLANKSTRING : iapi.numberFormatter.percentValue((errorValue / value) * 100);
                errorMacroIndices = [1,2,3,4,5,6,7,99,100,101,102];
                errorParserConfig = {
                        yaxisName: yAxisName = parseUnsafeString(isDual? (yAxisIndex ? FCCHartObj.syaxisname :
                                FCCHartObj.pyaxisname) : FCCHartObj.yaxisname),
                        xaxisName: xAxisName = parseUnsafeString(FCCHartObj.xaxisname),
                        formattedValue: formatedVal,
                        label: label,
                        errorDataValue:  formattedErrorValue,
                        errorPercentValue: errorPercentValue
                    };
                /*
                 * If this is a errorScatter then we have to parse 2 type error value
                 * For errorScatter default errorParsing procedure/attrbutes will represent verticalError plot
                 * we have to manipulate default error related varibles correspondingly.
                 */

                if (isXY) {
                    formattedHErrorValue = hErrorValue === null ? hErrorValue : iapi.numberFormatter.xAxis(hErrorValue);
                    hErrorPercentValue = xValue === null ?
                        BLANKSTRING : iapi.numberFormatter.percentValue((hErrorValue / xValue) * 100);
                    errorMacroIndices.push(103,104,105,106,107,108,109,110);
                    unformattedHErrorValue = pluck(setObj.horizontalerrorvalue, setObj.errorvalue);
                    errorParserConfig.errorValue = unformattedErrorValue =
                        pluck(setObj.verticalerrorvalue, setObj.errorvalue);
                    errorTooltext = getValidValue(parseUnsafeString(pluck(setObj.verticalerrorplottooltext,
                        setObj.errorplottooltext, dataset.verticalerrorplottooltext, dataset.errorplottooltext,
                        FCCHartObj.verticalerrorplottooltext, FCCHartObj.errorplottooltext)));
                    if (errorValue !== null){
                        errorParserConfig.verticalErrorDataValue =  formattedErrorValue;
                        errorParserConfig.verticalErrorPercentValue = errorPercentValue;
                        errorParserConfig.verticalErrorValue = unformattedErrorValue;
                    }
                    if (hErrorValue !== null){
                        errorParserConfig.horizontalErrorDataValue =  formattedHErrorValue;
                        errorParserConfig.horizontalErrorPercentValue = hErrorPercentValue;
                        errorParserConfig.horizontalErrorValue = unformattedHErrorValue;
                    }
                    //Parse horizontal error plot tooltext
                    hErrorTooltext = getValidValue(parseUnsafeString(pluck(setObj.horizontalerrorplottooltext,
                        setObj.errorplottooltext, dataset.horizontalerrorplottooltext, dataset.errorplottooltext,
                        FCCHartObj.horizontalerrorplottooltext, FCCHartObj.errorplottooltext)));
                    //create the tooltext
                    if (!HCConfig.showTooltip) {
                        returnObj._hErrortoolText = false;
                    }
                    // if tooltext is given in data object
                    else if (hErrorTooltext !== undefined) {
                        returnObj._hErrortoolText = parseTooltext(hErrorTooltext, errorMacroIndices, {
                            yaxisName: yAxisName = parseUnsafeString(isDual? (yAxisIndex ? FCCHartObj.syaxisname :
                                    FCCHartObj.pyaxisname) : FCCHartObj.yaxisname),
                            xaxisName: xAxisName = parseUnsafeString(FCCHartObj.xaxisname),
                            formattedValue: formatedVal,
                            label: label,
                            errorDataValue:  formattedHErrorValue,
                            errorPercentValue: hErrorPercentValue,
                            errorValue: unformattedHErrorValue,
                            verticalErrorDataValue:  formattedErrorValue,
                            verticalErrorPercentValue: errorPercentValue,
                            verticalErrorValue: unformattedErrorValue,
                            horizontalErrorDataValue:  formattedHErrorValue,
                            horizontalErrorPercentValue: hErrorPercentValue,
                            horizontalErrorValue: unformattedHErrorValue

                        }, setObj, FCCHartObj, dataset);
                    }
                    else {//determine the tooltext then
                        if (errorValue === null) {
                            returnObj._hErrortoolText = false;
                        } else {
                            returnObj._hErrortoolText = formattedHErrorValue;
                        }
                    }

                }
                else {
                    errorTooltext = getValidValue(parseUnsafeString(pluck(setObj.errorplottooltext,
                        dataset.errorplottooltext, FCCHartObj.errorplottooltext)));
                    errorParserConfig.errorValue = unformattedErrorValue = pluck(setObj.errorvalue);
                }
                //create the tooltext
                if (!HCConfig.showTooltip) {
                    returnObj._errortoolText = false;
                }
                // if tooltext is given in data object
                else if (errorTooltext !== undefined) {
                    returnObj._errortoolText = parseTooltext(errorTooltext, errorMacroIndices, errorParserConfig,
                        setObj, FCCHartObj, dataset);
                }
                else {//determine the tooltext then
                    if (errorValue === null) {
                        returnObj._errortoolText = false;
                    } else {
                        returnObj._errortoolText = formattedErrorValue;
                    }
                }
            }

            //create the tooltext
            if (!HCConfig.showTooltip) {
                toolText = false;
            }
            // if tooltext is given in data object
            else if (setTooltext !== undefined) {
                macroIndices = [4,5,6,7];
                parserConfig = {
                    yaxisName: yAxisName || parseUnsafeString(isDual? (yAxisIndex ? FCCHartObj.syaxisname :
                            FCCHartObj.pyaxisname) : (isMLAxis ? dataset._yAxisName : FCCHartObj.yaxisname)),
                    xaxisName: xAxisName || parseUnsafeString(FCCHartObj.xaxisname)
                };
                //If xy(numeric x axis) plot charts
                if (isXY){
                    macroIndices.push(8,9,10,11);
                    parserConfig.yDataValue = formatedVal;
                    parserConfig.xDataValue = label;
                    //If this is a error chart then add error related macros
                    if (isErrorChart){
                        macroIndices.push(103,104,105,106,107,108,109,110);
                        if (errorValue !== null){
                            parserConfig.verticalErrorDataValue =  formattedErrorValue;
                            parserConfig.verticalErrorPercentValue = errorPercentValue;
                            parserConfig.verticalErrorValue = unformattedErrorValue;
                        }
                        if (hErrorValue !== null){
                            parserConfig.horizontalErrorDataValue =  formattedHErrorValue;
                            parserConfig.horizontalErrorPercentValue = hErrorPercentValue;
                            parserConfig.horizontalErrorValue = unformattedHErrorValue;
                        }
                    }
                }
                //Non-XY charts
                else {
                    macroIndices.push(1,2,3);
                    parserConfig.formattedValue = formatedVal;
                    parserConfig.label = label;
                    //If this is a error chart then add error related macros
                    if (isErrorChart){
                        macroIndices.push(99,100,101,102);
                        parserConfig.errorValue = unformattedErrorValue;
                        if (errorValue !== null){
                            parserConfig.errorDataValue =  formattedErrorValue;
                            parserConfig.errorPercentValue = errorPercentValue;
                        }
                    }
                }
                toolText = parseTooltext(setTooltext, macroIndices, parserConfig, setObj, FCCHartObj, dataset);
            }
            else {//determine the tooltext then
                if (formatedVal === null) {
                    toolText = false;
                } else {
                    if (HCConfig.seriesNameInToolTip) {
                        seriesname = getFirstValue(dataset && dataset.seriesname);
                    }
                    toolText = seriesname ? seriesname + tooltipSepChar : BLANKSTRING;
                    toolText += label ? label + tooltipSepChar : BLANKSTRING;
                    if (HCConfig.showPercentInToolTip && isStacked){
                        showPercentInToolTipRequared = true;
                        toolText += percentMacro;
                    }
                    else {
                        toolText += formatedVal;
                    }
                }
            }

            //create the displayvalue
            if (!pluckNumber(setObj.showvalue, datasetShowValues)) {
                displayValue = BLANKSTRING;
            }
            else if (getValidValue(setObj.displayvalue) !== undefined) {
                displayValue = parseUnsafeString(setObj.displayvalue);
            }
            else if (HCConfig.showPercentValues){
                showPercentValuesRequared = true;
            }
            else {//determine the dispalay value then
                displayValue = formatedVal;
            }

            ////create the link
            returnObj.link = pluck(setObj.link);
            returnObj.displayValue = displayValue;
            returnObj.categoryLabel = label;
            returnObj.toolText = toolText;
            returnObj.showPercentValues = showPercentValuesRequared;
            returnObj.showPercentInToolTip = showPercentInToolTipRequared;

            return returnObj;
        }
    }, chartAPI.singleseries);

    chartAPI('xybase', {
        hideRLine : function () {
            var index = this.index,
            regrationLineSeries = this.chart.series[index + 1];
            if (regrationLineSeries && regrationLineSeries.hide) {
                regrationLineSeries.hide();
            }
        },
        showRLine : function () {
            var index = this.index,
            regrationLineSeries = this.chart.series[index + 1];
            if (regrationLineSeries && regrationLineSeries.show) {
                regrationLineSeries.show();
            }
        },
        getRegressionLineSeries : function (regrationObj, showYOnX, dataLength) {
            var data, xMin, xMax, yMin, yMax, slopeB, firstY, secondY, firstX, secondX,
            sumXY = regrationObj.sumXY,
            sumX = regrationObj.sumX,
            sumY = regrationObj.sumY,
            xValues = regrationObj.xValues,
            sumXsqure = regrationObj.sumXsqure,
            yValues = regrationObj.yValues,
            sumYsqure = regrationObj.sumYsqure;
            if(showYOnX){
                //Short the array
                xValues.sort(sortFN);
                //Store X minimum and maximum no
                xMin = xValues[0];
                xMax = xValues[xValues.length - 1];

                slopeB = (dataLength*sumXY - sumX*sumY) / (dataLength*sumXsqure - mathPow(sumX, 2));
                firstY = (!isNaN(slopeB))? (slopeB * (xMin - sumX/dataLength)) + sumY/dataLength : sumY/dataLength;
                secondY = (!isNaN(slopeB))? (slopeB * (xMax - sumX/dataLength)) + sumY/dataLength : sumY/dataLength;

                data = [{
                    x : xMin,
                    y : firstY
                }, {
                    x : xMax,
                    y : secondY
                }];
            } else {
                //Short the array
                yValues.sort(sortFN);
                //Store Y minimum and maximum no
                yMin = yValues[0];
                yMax = yValues[yValues.length - 1];

                slopeB = (dataLength*sumXY - sumX*sumY) / (dataLength*sumYsqure - mathPow(sumY, 2));
                firstX = (!isNaN(slopeB))? (slopeB * (yMin - sumY/dataLength)) + sumX/dataLength : sumX/dataLength;
                secondX = (!isNaN(slopeB))? (slopeB * (yMax - sumY/dataLength)) + sumX/dataLength : sumX/dataLength;

                data = [{
                    x : firstX,
                    y : yMin
                }, {
                    x : secondX,
                    y : yMax
                }];
            }
            return data;
        },
        pointValueWatcher: function (HCObj, valueY, valueX, regressionObj) {
            var obj,
                FCconf = HCObj[FC_CONFIG_STRING],
                objX,
                itemValueX,
                itemValueY;

            if (valueY !== null) {
                obj = FCconf[0];
                obj.max = obj.max > valueY ? obj.max : valueY;
                obj.min = obj.min < valueY ? obj.min : valueY;
            }
            if (valueX !== null) {
                objX = FCconf.x;
                objX.max = objX.max > valueX ? objX.max : valueX;
                objX.min = objX.min < valueX ? objX.min : valueX;
            }
            //code for regration line
            if (regressionObj) {
                itemValueX = valueX || 0;
                itemValueY = valueY || 0;
                //Calculating the summation of X.
                regressionObj.sumX += itemValueX;
                //Calculating the summation of Y.
                regressionObj.sumY += itemValueY;
                //Calculating the summation of XY.
                regressionObj.sumXY += itemValueX * itemValueY;
                //Calculating the summation of X짼
                regressionObj.sumXsqure += mathPow(itemValueX, 2);
                //Push all the x values
                regressionObj.xValues.push(itemValueX);
                //Calculating the summation of Y짼
                regressionObj.sumYsqure += mathPow(itemValueY, 2);
                //Push all the y values
                regressionObj.yValues.push(itemValueY);

            }
        }

    }, chartAPI.multiseries);

    chartAPI('scrollbase', {
        /** @todo Add all the scroll related properties. */
        postSeriesAddition: function () {

            var iapi = this,
                hc = iapi.hcJSON,
                xAxis = hc.xAxis,
                scollOptions = xAxis.scroll,
                config = hc[FC_CONFIG_STRING],
                width = config.width,
                catCount = config.x.catCount,
                chartAttrs = iapi.dataObj.chart,
                colorM = iapi.colorManager,
                totalNumPoint, numVisiblePlot, numberOfColumnSeries, i, length, seriesArr, type, columnStr,
                defaultseries;

            //add the scroll flag at chart so ttat the cliprect works properly
            config.isScroll = true;
            hc.chart.hasScroll = true;

            if (this.isStacked) {
                numberOfColumnSeries = 1;
            }
            else {
                numberOfColumnSeries = 0;
                i = 0;
                seriesArr = hc.series;
                columnStr = 'column';
                defaultseries = hc.chart.defaultSeriesType;

                for (length = seriesArr.length; i < length; i ++) {
                    type = pluck(seriesArr[i].type, defaultseries);
                    if (type === columnStr) {
                        numberOfColumnSeries += 1;
                    }
                }
                if (numberOfColumnSeries < 1) {
                    numberOfColumnSeries = 1;
                }

            }

            totalNumPoint = catCount * numberOfColumnSeries;
            numVisiblePlot = pluckNumber(chartAttrs.numvisibleplot,
                mathFloor(width / iapi.avgScrollPointWidth));

            // Validate numVisiblePlot and then enable the scroll.
            if (scollOptions && numVisiblePlot >= 2 && numVisiblePlot < totalNumPoint) {
                scollOptions.enabled = true;
                scollOptions.vxLength = numVisiblePlot / numberOfColumnSeries;
                scollOptions.startPercent = mathMin(1, mathMax(0,
                                    parseFloat(chartAttrs.scrolltoend) || 0));

                scollOptions.padding = pluckNumber(chartAttrs.scrollpadding, 0);
                scollOptions.height = pluckNumber(chartAttrs.scrollheight, 16);
                scollOptions.showButtons = !!pluckNumber(chartAttrs.scrollshowbuttons, 1);
                scollOptions.buttonPadding = pluckNumber(chartAttrs.scrollbtnpadding, 0);
                scollOptions.color = getFirstColor(pluck(chartAttrs.scrollcolor,
                    colorM.getColor('altHGridColor')));

                //add the space for scroller
                config.marginBottomExtraSpace +=
                scollOptions.padding + scollOptions.height;
            }

            if (hasTouch || pluckNumber(chartAttrs.enabletouchscroll, 0)) { // when on touch devices
                hc.chart.zoomType = 'x';
                hc.chart.nativeZoom = false;
                hc.chart.selectionMarkerFill = 'rgba(255,255,255,0)';
                (hc.callbacks || (hc.callbacks = [])).push(function (chart) {
                    addEvent(chart, 'selectionstart selectiondrag', chartAPI.scrollbase.performTouchScroll, {});
                });
            }

        },
        performTouchScroll: function (e) {
            var chart = this,
                xAxis = chart.xAxis[0],
                scroller = xAxis.scroller,
                config = scroller.config,
                scrollBarW = config.trackLength,
                groupWidth = config.width / config.scrollRatio,
                pageX =  (scrollBarW / groupWidth) * (e.chartX || 1);

            if(e.isOutsidePlot === true) {
                return;
            }

            fireEvent(scroller.elements.anchor.element, (e.type === 'selectionstart' ? 'dragstart' : 'drag'), {
                pageX: -pageX,
                pageY: -e.chartY
            });
        }
    }, chartAPI.multiseries);

    chartAPI('logbase', {
        isLog: true,
        // Log charts cannot have negative values.
        isValueAbs: true,
        // Log charts have their own configureAxis function that linearizes log
        // data to make it plottable on ex-renderer
        configureAxis: function (HCObj, FCObj) {
            var conf = HCObj[FC_CONFIG_STRING],
            iapi = this,
            axisGridManager = conf.axisGridManager,
            numberFormatter = iapi.numberFormatter,
            series = HCObj.series,
            xAxisObj = HCObj.xAxis,
            yAxisObj = HCObj.yAxis[0],
            yAxisConf = conf[0],
            chartAttr = FCObj.chart,
            hideLimits = !pluckNumber(chartAttr.showyaxislimits, chartAttr.showlimits, chartAttr.showyaxisvalues, 1),
            hideValues = !pluckNumber(chartAttr.showdivlinevalues, chartAttr.showyaxisvalues, 1),
            base = pluckNumber(chartAttr.base, chartAttr.logbase, 10),
            userYMax = pluckNumber(chartAttr.yaxismaxvalue),
            userYMin = pluckNumber(chartAttr.yaxisminvalue),
            colorM = iapi.colorManager,

            // Minor grid line color and alpha processing is done here since
            // minor gridlines are specific to log charts.
            showMinorValues = pluckNumber(chartAttr.showminordivlinevalues) === 1,
            minorGlColor = pluck(chartAttr.minordivlinecolor, yAxisObj.gridLineColor,
                colorM.getColor('divLineColor')),
            minorGlAlpha = pluckNumber(chartAttr.minordivlinealpha, chartAttr.divlinealpha,
                colorM.getColor('divLineAlpha')),

            // Grid line configs (gl stands for grid-line)
            majorGridParams = [
                yAxisObj,
                undefined, // variable: value
                undefined, // variable: text
                pluckNumber(chartAttr.divlinethickness, 2), // thickness
                yAxisObj.gridLineDashStyle, // dashed
                yAxisObj.gridLineColor, // color
                2
            ],
            seri,
            minorGridParams = [
                yAxisObj,
                undefined, // variable: value
                undefined, // variable: text
                pluckNumber(chartAttr.minordivlinethickness , 1), // thickness
                yAxisObj.gridLineDashStyle, // dashed
                convertColor(pluck(chartAttr.minordivlinecolor,
                minorGlColor), pluckNumber(chartAttr.minordivlinealpha,
                minorGlAlpha / 2)), // color
                2
            ],

            doCalculateMinors = showMinorValues || (minorGlAlpha &&
                minorGridParams[3]),
            // If showCanvasBorder is disabled, force enables the limit grid lines
            forceLimitGridLinesEnabled = pluckNumber(chartAttr.showaxislimitgridlines,
                iapi.showAxisLimitGridLines),
            showLimitGridLines = pluckNumber(forceLimitGridLinesEnabled,
                iapi.is3D || HCObj.chart.plotBorderWidth ? 0 : 1),

            logLimits,
            data,
            item,
            i,
            j;


            // Perform zero validation for log charts. This is very important so
            // as to avoid infinite loop related crashes
            if (base <= 0) {
                base = 10;
            }
            if (userYMax <= 0) {
                userYMax = undefined;
            }
            if (userYMin <= 0) {
                userYMin = undefined;
            }



            // Recalculate log limits post data modification.
            logLimits = this.getLogAxisLimits(yAxisConf.max || base,
                yAxisConf.min || 1, userYMax, userYMin, base,
                doCalculateMinors ? chartAttr.numminordivlines : 0);

            xAxisObj.title.text = parseUnsafeString(chartAttr.xaxisname);
            xAxisObj.showLine = pluckNumber(chartAttr.showxaxisline, chartAttr.showaxislines, 0);
            xAxisObj.lineThickness = pluckNumber(chartAttr.xaxislinethickness, chartAttr.axislinethickness, 1);
            xAxisObj.lineAlpha = pluckNumber(chartAttr.xaxislinealpha, chartAttr.axislinealpha, 100);
            xAxisObj.lineColor = convertColor(pluck(chartAttr.xaxislinecolor, chartAttr.axislinecolor, '000'));

            // Configure the axis that is to be processed by ex-renderer
            extend2(yAxisObj, {
                title: { // set axis name
                    text: parseUnsafeString(chartAttr.yaxisname)
                },
                labels: { // disable labels and other ex-renderer own processes.
                    enabled: false
                },
                gridLineWidth: INT_ZERO,
                alternateGridColor: COLOR_TRANSPARENT,
                reversed: (chartAttr.invertyaxis === '1'),
                max: logOf(logLimits.Max, base),
                min: logOf(logLimits.Min, base),
                showLine: pluckNumber(chartAttr.showyaxisline, chartAttr.showaxislines, 0),
                lineThickness: pluckNumber(chartAttr.yaxislinethickness, chartAttr.axislinethickness, 1),
                lineAlpha: pluckNumber(chartAttr.yaxislinealpha, chartAttr.axislinealpha, 100),
                lineColor: convertColor(pluck(chartAttr.yaxislinecolor, chartAttr.axislinecolor, '000'))
            });

            // Modify all series value
            i = series.length;
            while (i--) {
                seri = series[i];
                if (seri) {
                    //fix #PCXT-427
                   //threshold always should be axis min
                    seri.threshold = yAxisObj.min;
                    data = seri.data;
                    j = data && data.length || 0;
                    while (j--) {
                        item = data[j];
                        item.y = logOf(item.y, base);
                    }
                }
            }

            // delete the min max from conf and mark the conf axis as 'log'
            delete yAxisConf.max;
            delete yAxisConf.min;
            yAxisConf.isLog = true;

            if (yAxisObj.reversed && yAxisObj.min >= 0) {
                HCObj.plotOptions.series.threshold = yAxisObj.max;
            }

            // now put the trends in it
            if (FCObj.trendlines) {
                createTrendLine (FCObj.trendlines, [{
                    max : logLimits.Max,
                    min : logLimits.Min,
                    plotLines : yAxisObj.plotLines,
                    plotBands : yAxisObj.plotBands,
                    title: yAxisObj.title
                }], conf);
            }

            // Modify all plotLines and plotBands lines
            i = yAxisObj.plotLines.length;
            while (i--) {
                item = yAxisObj.plotLines[i];
                item.value && (item.value = logOf(item.value, base));
                item.from && (item.from = logOf(item.from, base));
                item.to && (item.to = logOf(item.to, base));
            }

            i = yAxisObj.plotBands.length;
            while (i--) {
                item = yAxisObj.plotBands[i];
                item.from && (item.from = logOf(item.from, base));
                item.to && (item.to = logOf(item.to, base));
            }

            // Add the major and minor divlines
            i = logLimits.divArr.length;
            while (i--) {
                item = logLimits.divArr[i];

                if (item.ismajor) {
                    majorGridParams[1] = logOf(item.value, base);
                    majorGridParams[2] = numberFormatter.yAxis(item.value);
                    axisGridManager.addAxisGridLine
                    .apply(axisGridManager, majorGridParams);
                }
                // While calculating minor divlines, we need to draw it (even
                // if it is not needed) when it is in extreme.
                else if (doCalculateMinors || item.isextreme) {
                    minorGridParams[1] = logOf(item.value, base);
                    minorGridParams[2] = (showMinorValues || item.isextreme) ?
                    numberFormatter.yAxis(item.value) : BLANKSTRING;
                    axisGridManager.addAxisGridLine
                    .apply(axisGridManager, minorGridParams);
                }

                // re-using 'data' variable to store reference to last plotline.
                data = yAxisObj.plotLines[yAxisObj.plotLines.length - 1];

                // extreme items does not show the lines.
                // the label texts are made blank instead of setting hidden style.
                if (item.isextreme) {
                    data.width = (forceLimitGridLinesEnabled ||
                        (showLimitGridLines && !(item.isMin && xAxisObj.showLine))) ? data.width : 0.1;
                    if (hideLimits) {
                        data.label.text = BLANKSTRING;
                    }
                }
                else if (hideValues && data.label) {
                    data.label.text = BLANKSTRING;
                }
            }
            // When space management will be done, yAxis.plotLines needs to be
            // sorted. Refer to base function.
        },

        //log axis helper Function
        /*
         * getAxisLimits is the method to calculate the axis limits
         * of the chart w.r.t. the mantissa of the yMax and yMin.
         * ~@param    maxValue    the maximum value of the data set to
         *                        be plotted.
         * ~param    minValue    the minimum value of the data set to
         *                        be plotted.
         */
        getLogAxisLimits : function (maxValue , minValue, yAxisMaxValue, yAxisMinValue, base, numMinorDivLines) {
            //Local function to check whether the given parameter is specified or not.
            var validate = function (param) {
                if (param === null || param === undefined || param === '' || isNaN(param)) {
                    //Variable is not specified - so return false.
                    return false;
                }
                else {
                    //Variable is specified - so return true.
                    return true;
                }
            },
            //Initialize counter to 0
            counter = 0,
            divLines = [],
            power,
            minLogY,
            maxLogY,
            yMin,
            yMax,
            numDivLines,
            divLineValue,
            //Initial and check value
            iniValue,
            checkValue,
            //Get log of base w.r.t. base=10
            r,
            i,
            j,
            isYMinDivLine,
            isYMaxDivLine,
            d,
            u,
            e,
            //Numeric interval between two succesive major divLines (variable)
            slabInterval,
            //Numeric interval between two succesive minor divLines (variable) in between 2 successive major divLines
            subInterval;

            // if yAxisMaxValue is valid and greater than yMax
            if (validate(yAxisMaxValue) && Number(yAxisMaxValue) >= maxValue) {
                yMax = Number(yAxisMaxValue);
            } else {
                // for base greater than one
                if (base > 1) {
                    power = mathCeil (mathLog (maxValue) / mathLog (base));
                // for 0 < base < 1

                }
                else {
                    power = mathFloor (mathLog (maxValue) / mathLog (base));
                }
                yMax = mathPow (base, power);
                maxLogY = power;
            }
            // if maxLogY is not yet defined
            if (!maxLogY) {
                // for base greater than one
                if (base > 1) {
                    maxLogY = mathCeil (mathLog (yMax) / mathLog (base));
                } else {
                    maxLogY = mathFloor (mathLog (yMax) / mathLog (base));
                }
            }
            // if yAxisMinValue is valid and less than yMin
            if (validate(yAxisMinValue) && Number(yAxisMinValue) <= minValue) {
                yMin = Number(yAxisMinValue);
            } else {
                // for base greater than one
                if (base > 1) {
                    power = mathFloor(mathLog(minValue) / mathLog(base));
                } else {
                    power = mathCeil(mathLog(minValue) / mathLog(base));
                }
                yMin = mathPow(base, power);
                minLogY = power;
            }
            // if minLogY is not yet defined
            if (!minLogY) {
                // for base greater than one
                if (base > 1) {
                    minLogY = mathFloor(mathLog(yMin) / mathLog(base));
                // for 0 < base < 1
                } else {
                    minLogY = mathCeil (mathLog(yMin) / mathLog(base));
                }
            }
            //}




            //Get log of base w.r.t. base=10
            r = Number (String(mathLog(base) / mathLog(10)));
            //R is integer if base is an integer power of 10. So, set
            //num div lines accordingly.
            numDivLines = Number(numMinorDivLines) || ((mathFloor(r) == r) ? 8 : 4);
            //Initialize iniValue and checkValue w.r.t base value
            if (base > 1) {
                //If base > 1
                iniValue = maxLogY;
                checkValue = minLogY;
            } else if (base > 0 && base < 1) {
                //If base between 0 and 1.
                iniValue = minLogY;
                checkValue = maxLogY;
            }
            //Initialize r to maxLogY. It will be incremented/decremented within loop as required
            r = maxLogY;

            //Loop to calculate major div lines
            for (i = iniValue; i >= checkValue; --i) {

                //Select the major divLines
                // Conditions for major div lines:
                // 1. If y-axis is inverted and div value is not the very first one
                //    (the lowest one coinciding with x-axis)
                // OR
                // 2. If y-axis is not inverted and div value is not the very last one
                //    (the lowest one coinciding with x-axis)
                //if ((invertYAxis && r != maxLogY) || !(invertYAxis || i == checkValue)) {
                //Get the numerical value of div line by getting power of base.
                divLineValue = mathPow(base, r);
                //Create the div line object
                // conditional to avoid plot of major divLines and their axis labels beyond plot area

                if (yMin <= divLineValue && yMax >= divLineValue) {
                    divLines [counter++] = {
                        value: divLineValue,
                        ismajor: true
                    };
                }
                //Increment counter to be used in calculation for minor divLines

                //If it's upper limit (mantissa), no need of the minor divLines, as only major can be plotted
                if (i == checkValue) {
                    continue;
                }
                //Multiplication factor
                //For base <1, powers go in negative -0.1 is 10^-1, 0.001 is 10 ^ -3 and so on.
                d = (base > 1) ? - 1 : 1;
                //Numeric interval between two succesive major divLines (variable)
                slabInterval = mathPow(base, r) - mathPow(base, r + d);
                //Numeric interval between two succesive minor divLines (variable) in between 2 successive major
                //divLines
                subInterval = slabInterval / (numDivLines + 1);
                //Iterate through minor div lines
                for (j = 1; j <= numDivLines; ++j) {
                    //Get the numeric value for minor div line
                    //By adding the sub-interval to power of base (of major div line)
                    divLineValue = mathPow(base, r + d) + subInterval * j;
                    //Create the object
                    // conditional to avoid plot of minor divLines and their axis labels beyond plot area
                    //if (divLineValue>=yMin && divLineValue<=yMax) {
                    if (yMin <= divLineValue && yMax >= divLineValue) {
                        divLines [counter++] = {
                            value: divLineValue,
                            ismajor: false
                        };
                    }
                //Increment
                }
                //Update counter corresponding to next major divLine w.r.t. base value
                if (base > 1) {
                    r--;
                } else {
                    r++;
                }
            }
            // iterating to check if the limits are divLines and flagged
            for (u in divLines) {
                for (e in divLines [u]) {
                    if (e == 'value') {
                        //if its found that yMin is a divLine, then don't work on it anymore
                        if (!isYMinDivLine) {
                            isYMinDivLine = (divLines [u][e] == yMin) &&
                            (divLines[u].isextreme = divLines[u].isMin = true);
                        }
                        //if its found that yMax is a divLine, then don't work on it anymore
                        if (!isYMaxDivLine) {
                            isYMaxDivLine = (divLines [u][e] == yMax) &&
                            (divLines [u].isextreme = divLines[u].isMax = true);
                        }
                    }
                }
            }

            // if yMin is not a divLine
            if (!isYMinDivLine) {
                // include yMin as a divLine
                divLines [counter++] = {
                    value: yMin,
                    ismajor: true,
                    isMin: true,
                    isextreme: true
                };
            }
            // if yMax is not a divLine
            if (!isYMaxDivLine) {
                // include yMax as a divLine
                divLines [counter] = {
                    value: yMax,
                    ismajor: true,
                    isMax: true,
                    isextreme: true
                };
            }

            ///return
            return {
                Max: yMax,
                Min: yMin,
                divArr: divLines
            };
        },

        // PVWathcer of log chart needs to avoid/drop negative values.
        pointValueWatcher: function (HCObj, value, yAxisIndex) {
            var axis,
            conf = HCObj[FC_CONFIG_STRING];

            yAxisIndex = pluckNumber(yAxisIndex, 0);

            if (value > 0) {
                if (!conf[yAxisIndex]) {
                    conf[yAxisIndex] = {};
                }

                axis = conf[yAxisIndex];
                axis.max = axis.max > value ? axis.max : value;
                axis.min = axis.min < value ? axis.min : value;
            }
        }
    }, chartAPI.mslinebase);

    //////// COMMOM Charts to be use as charts as well as PowerCharts   //////////////
    /////////////////  column2d //////////////
    singleSeriesAPI = chartAPI.singleseries,
    multiSeriesAPI = chartAPI.multiseries;

    //add the charts
    //only the point and default series will differ from singleSeriesAPI
    chartAPI('column2dbase', {
        point : function (chartName, series, data, FCChartObj, HCObj) {

            // length of the data
            var length = data.length,
                iapi = this,
                // ex-renderer configuration
                conf = HCObj[FC_CONFIG_STRING],
                // axisGridManager to manage the axis
                // it contains addVline, addXaxisCat, addAxisAltGrid and
                // addAxisGridLine function
                axisGridManager = conf.axisGridManager,
                // ex-renderer xAxis obj
                xAxisObj = HCObj.xAxis,
                // xAxis configuration it contains configuration of xAxis like
                // catCount, horizontalAxisNamePadding, horizontalLabelPadding,
                // labelDisplay, slantLabels, staggerLines
                xAxisConf = conf.x,

                // default color for Spark
                colorM = iapi.colorManager,
                // is3d and isBar helps to get the column color by
                // getColumnColor function
                // whether the chart is a 3D or Bar
                is3d = /3d$/.test(HCObj.chart.defaultSeriesType),
                isBar = iapi.isBar,
                isSpark = /^spark/i.test(chartName),
                // dataplot border width
                // Managing for 3D too
                showPlotBorder = pluck(FCChartObj.showplotborder,
                    (isSpark || is3d ? ZEROSTRING : ONESTRING) ) === ONESTRING,
                // 3D column chart doesn't show the plotborder by default
                // until we set showplotborder true
                setBorderWidth = showPlotBorder ?
                (is3d ? 1 : pluckNumber(FCChartObj.plotborderthickness, 1)) : 0,
                // whether to use round edges or not in the column
                isRoundEdges = HCObj.chart.useRoundEdges,
                // dataplot border alpha
                seriesPlotBorderAlpha = pluckNumber(FCChartObj.plotborderalpha,
                    FCChartObj.plotfillalpha, 100),
                // dataplot border color
                setPlotBorderColor = pluck(FCChartObj.plotbordercolor,
                    colorM.getColor('plotBorderColor'))
                    .split(COMMASTRING)[0],
                // GradientColor of the plot fill
                seriesGradientColor = isSpark ? '' : (pluckNumber(FCChartObj.useplotgradientcolor, 1) ?
                    getDefinedColor(FCChartObj.plotgradientcolor,
                        colorM.getColor('plotGradientColor')) :
                    BLANKSTRING),
                // Original index of the data inside the loop
                catIndex = 0,
                // use3DLighting to show gredient color effect in 3D Column charts
                use3DLighting = Boolean(pluckNumber(FCChartObj.use3dlighting,
                1)),
                NumberFormatter = HCObj[FC_CONFIG_STRING].numberFormatter,
                // Calculate the dashStyle per point
                pointDashStyle,
                seriesDashStyle = pluckNumber(FCChartObj.plotborderdashed, 0),
                // length of the dash
                seriesDashLen = pluckNumber(FCChartObj.plotborderdashlen, 5),
                // distance between dash
                seriesDashGap = pluckNumber(FCChartObj.plotborderdashgap, 4),
                hoverEffects,
                itemValue,
                index,
                countPoint,
                dataLabel,
                setColor,
                setAlpha,
                setRatio,
                setAngle,
                setBorderAlpha,
                setBorderDashed,
                setBorderDashGap,
                setBorderDashLen,
                colorArr,
                dataObj,
                showLabel,
                pointShadow;

            // Iterate through all level data
            // We are managing the data value labels and other cosmetics
            // inside this loop
            for (index = 0, countPoint = 0; index < length; index += 1) {

                // individual data obj
                dataObj = data[index];

                // Managing vLines in between <set> elements
                // If its vline
                // we call the grid manager addVline function,
                // that creates vline and we stop execution here and
                // continue the loop to next data
                if (dataObj.vline) {
                    axisGridManager.addVline(xAxisObj, dataObj, catIndex,
                        HCObj);
                    continue;
                }

                // get the valid value
                // parsePointValue check the its a value value of not and
                // return the valid value
                itemValue = NumberFormatter.getCleanValue(dataObj.value);
                // we check showLabel in individual data
                // if its set to 0 than we do not show the particular label
                showLabel = pluckNumber(dataObj.showlabel,
                    FCChartObj.showlabels, 1);

                // Label of the data
                // getFirstValue returns the first defined value in arguments
                // we check if showLabel is not set to 0 in data
                // then we take the label given in data, it can be given using
                // label as well as name too
                // we give priority to label if label is not there,
                // we check the name attribute
                dataLabel = parseUnsafeString(getFirstValue(dataObj.label, dataObj.name));

                // <set> cosmetics
                // Color of the particular data
                setColor = pluck(dataObj.color, colorM.getPlotColor());
                // Alpha of the data
                setAlpha = pluck(dataObj.alpha, FCChartObj.plotfillalpha,
                    HUNDREDSTRING);
                // Fill ratio of the data
                setRatio = pluck(dataObj.ratio, FCChartObj.plotfillratio);
                // defaultAngle depend upon item value
                setAngle = pluck(360 - FCChartObj.plotfillangle, isBar ? 180 : 90);

                setBorderAlpha = pluck(dataObj.alpha, seriesPlotBorderAlpha);

                setBorderDashed = pluckNumber(dataObj.dashed, seriesDashStyle);
                setBorderDashGap =pluck(dataObj.dashgap, seriesDashGap);
                setBorderDashLen = pluck(dataObj.dashlen, seriesDashLen);

                // adding label in HighChart xAxis categories
                // increase category counter by one
                axisGridManager.addXaxisCat(xAxisObj, catIndex, catIndex,
                    showLabel ? dataLabel : BLANKSTRING, dataObj, {}, FCChartObj, setColor);
                catIndex += 1;

                if (itemValue < 0) {
                    if (isBar){
                        setAngle = 180 - setAngle;
                    }
                    else {
                        setAngle = 360 - setAngle;
                    }
                }

                // Used to set alpha of the shadow
                pointShadow = {
                    opacity: setAlpha / 100
                };

                // calculate the color object for the column
                colorArr = getColumnColor (setColor  + COMMASTRING +
                    seriesGradientColor.replace(/,+?$/,''), setAlpha, setRatio,
                    setAngle, isRoundEdges, setPlotBorderColor,
                     setBorderAlpha + BLANKSTRING,
                        isBar, is3d);

                // get per-point dash-style
                pointDashStyle = setBorderDashed ?
                    getDashStyle(setBorderDashLen, setBorderDashGap, setBorderWidth) :
                         'none';

                hoverEffects = iapi.pointHoverOptions (dataObj, series, {
                        plotType: 'column',
                        is3d: is3d,
                        isBar: isBar,

                        use3DLighting: use3DLighting,
                        isRoundEdged: isRoundEdges,

                        color: setColor,
                        gradientColor: seriesGradientColor,
                        alpha: setAlpha,
                        ratio: setRatio,
                        angle: setAngle,

                        borderWidth: setBorderWidth,
                        borderColor: setPlotBorderColor,
                        borderAlpha: setBorderAlpha,
                        borderDashed: setBorderDashed,
                        borderDashGap: setBorderDashGap,
                        borderDashLen: setBorderDashLen,

                        shadow: pointShadow
                    }
                );
                // Finally add the data
                // we call getPointStub function that manage displayValue,
                // toolText and link
                series.data.push( extend2(
                    iapi.getPointStub(dataObj, itemValue, dataLabel, HCObj), {
                        y: itemValue,
                        shadow: pointShadow,
                        color: colorArr[0],
                        borderColor: colorArr[1],
                        borderWidth: setBorderWidth,
                        use3DLighting: use3DLighting,
                        dashStyle: pointDashStyle,
                        tooltipConstraint : iapi.tooltipConstraint,
                        hoverEffects: hoverEffects.enabled && hoverEffects.options,
                        rolloverProperties: hoverEffects.enabled && hoverEffects.rolloverOptions
                    })
                );
                // Set the maximum and minimum found in data
                // pointValueWatcher use to calculate the maximum and minimum
                // value of the Axis
                iapi.pointValueWatcher(HCObj, itemValue);
                countPoint += 1;
            }
            // set the xAxisConf catCount for further use
            xAxisConf.catCount = catIndex;

            return series;
        },
        defaultSeriesType : 'column'
    }, singleSeriesAPI);

    /////////////// Line ///////////
    chartAPI('linebase', {
        defaultSeriesType: 'line',
        hasVDivLine: true,
        defaultPlotShadow: 1,

        point : function (chartName, series, data, FCChartObj, HCObj) {
            var itemValue, index, dataLabel, dataObj,
            countPoint, showLabel, dashStyle, pointShadow,
            lineDashLen, lineDashGap, lineColor, lineAlpha, lineThickness,
            lineDashed, drawAnchors, lineColorDef, lineAlphaDef,
            pointAnchorEnabled,
            // set attributes
            setAnchorSides, setAnchorBorderThickness, setAnchorBorderColor,
            setAnchorRadius, setAnchorBgColor, setAnchorAlpha, setAnchorBgAlpha,
            setAnchorAngle, anchorShadow, setAnchorShadow,
            HCChartObj = HCObj.chart,
            // length of the data
            length = data.length,
            // ex-renderer xAxis obj
            xAxisObj = HCObj.xAxis,
            // ex-renderer configuration
            conf = HCObj[FC_CONFIG_STRING],
            colorM = this.colorManager,

            hoverEffects,

            // axisGridManager to manage the axis
            // it contains addVline, addXaxisCat, addAxisAltGrid and
            // addAxisGridLine function
            axisGridManager = conf.axisGridManager,
            catIndex = 0,
            xAxisConf = conf.x,
            NumberFormatter = HCObj[FC_CONFIG_STRING].numberFormatter,
            imageUrl,
            imageScale,
            imageAlpha;


            // Managing line series cosmetics
            // Color of the line
            lineColorDef = getFirstColor(pluck(FCChartObj.linecolor,
                FCChartObj.palettecolors,
                colorM.getColor('plotFillColor')));
            // alpha
            lineAlphaDef = pluck(FCChartObj.linealpha, HUNDREDSTRING);
            // thickness
            lineThickness = pluckNumber(FCChartObj.linethickness, this.lineThickness, 4);
            // to use dash line
            lineDashed = Boolean(pluckNumber(FCChartObj.linedashed, 0));
            // length of the dash
            lineDashLen = pluckNumber(FCChartObj.linedashlen, 5);
            // distance between dash
            lineDashGap = pluckNumber(FCChartObj.linedashgap, 4);
            // anchor shadow
            anchorShadow = pluckNumber(FCChartObj.anchorshadow, 0);

            // set the line color and alpha to
            // HC seris obj with FusionCharts color format using FCcolor obj
            series.color = {
                FCcolor: {
                    color: lineColorDef,
                    alpha: lineAlphaDef
                }
            };

            // set the line thickness (line width)
            series.lineWidth = lineThickness;

            // set the series anchor shadow
            series.anchorShadow = anchorShadow;

            // IF its a step line chart
            series.step = pluck(this.stepLine, series.step);
            // Special attribute for StepLine (drawVerticalJoins)
            series.drawVerticalJoins = Boolean(pluckNumber(series.drawVerticalJoins, FCChartObj.drawverticaljoins, 1));
            series.useForwardSteps = Boolean(pluckNumber(series.useForwardSteps, FCChartObj.useforwardsteps, 1));

            // Managing line series markers
            // Whether to drow the Anchor or not
            drawAnchors = pluckNumber(FCChartObj.drawanchors ,
                FCChartObj.showanchors);

            // Iterate through all level data
            for (index = 0, countPoint = 0; index < length; index += 1) {
                // individual data obj
                // for further manipulation
                dataObj = data[index];

                // Managing vLines in between <set> elements
                // If its vline
                // we call the grid manager addVline function, that creates vline
                // and we stop execution here and continue the loop to next data
                if (dataObj.vline) {
                    axisGridManager.addVline(xAxisObj, dataObj, catIndex, HCObj);
                    continue;
                }

                // get the valid value
                // parsePointValue check the its a value value of not and return
                // the valid value
                itemValue = NumberFormatter.getCleanValue(dataObj.value);

                // we check showLabel in individual data
                // if its set to 0 than we do not show the particular label
                showLabel = pluckNumber(dataObj.showlabel, FCChartObj.showlabels, 1);

                // Label of the data
                // getFirstValue returns the first defined value in arguments
                // we check if showLabel is not set to 0 in data
                // then we take the label given in data, it can be given using label as well as name too
                // we give priority to label if label is not there, we check the name attribute
                dataLabel = parseUnsafeString(getFirstValue(dataObj.label, dataObj.name));

                // adding label in HighChart xAxis categories
                // increase category counter by one
                axisGridManager.addXaxisCat(xAxisObj, catIndex, catIndex, showLabel ? dataLabel : BLANKSTRING,
                    dataObj, {}, FCChartObj);
                catIndex += 1;

                // Managing line series cosmetics
                // Color of the line
                lineColor = getFirstColor(pluck( dataObj.color, lineColorDef));
                // alpha
                lineAlpha = pluckNumber(dataObj.alpha, lineAlphaDef);

                // create line dash
                // using dashStyle of HC
                dashStyle = pluckNumber(dataObj.dashed, lineDashed) ? getDashStyle(lineDashLen,
                    lineDashGap, lineThickness) : 'none';

                pointShadow = {
                    opacity: lineAlpha / 100
                };

                // Anchor cosmetics in data points
                // Getting anchor cosmetics for the data points or its default values
                // The default value is different from flash in order to render a
                // perfect circle when no anchorside is provided.
                setAnchorSides = pluckNumber(dataObj.anchorsides,
                    FCChartObj.anchorsides, 0);
                setAnchorAngle = pluckNumber(dataObj.anchorstartangle,
                    FCChartObj.anchorstartangle, 90);
                setAnchorRadius = pluckNumber(dataObj.anchorradius,
                    FCChartObj.anchorradius, this.anchorRadius, 3);
                setAnchorBorderColor = getFirstColor(pluck(dataObj.anchorbordercolor,
                    FCChartObj.anchorbordercolor, lineColorDef));
                setAnchorBorderThickness = pluckNumber(dataObj.anchorborderthickness,
                    FCChartObj.anchorborderthickness, this.anchorBorderThickness, 1);
                setAnchorBgColor = getFirstColor(pluck(dataObj.anchorbgcolor,
                    FCChartObj.anchorbgcolor, colorM.getColor('anchorBgColor')));
                setAnchorAlpha = pluck(dataObj.anchoralpha, FCChartObj.anchoralpha,
                    HUNDREDSTRING);
                setAnchorBgAlpha = pluck(dataObj.anchorbgalpha,
                    FCChartObj.anchorbgalpha, setAnchorAlpha);
                imageUrl = pluck(dataObj.anchorimageurl, FCChartObj.anchorimageurl);
                imageScale = pluck(dataObj.anchorimagescale, FCChartObj.anchorimagescale, 100);
                imageAlpha = pluck(dataObj.anchorimagealpha, FCChartObj.anchorimagealpha, 100);

                pointAnchorEnabled = drawAnchors === undefined ? lineAlpha !== 0 : !!drawAnchors;

                setAnchorShadow = Boolean(pluckNumber(dataObj.anchorshadow,
                                    anchorShadow, 0));

                // Point hover effects
                hoverEffects = this.pointHoverOptions (dataObj, series, {
                    plotType: 'anchor',
                    anchorBgColor: setAnchorBgColor,
                    anchorAlpha: setAnchorAlpha,
                    anchorBgAlpha: setAnchorBgAlpha,
                    anchorAngle: setAnchorAngle,

                    anchorBorderThickness: setAnchorBorderThickness,
                    anchorBorderColor: setAnchorBorderColor,
                    anchorBorderAlpha: setAnchorAlpha,
                    anchorSides: setAnchorSides,
                    anchorRadius: setAnchorRadius,

                    imageUrl: imageUrl,
                    imageScale: imageScale,
                    imageAlpha:imageAlpha,

                    shadow: pointShadow
                });

                // Finally add the data
                // we call getPointStub function that manage displayValue, toolText and link
                series.data.push(extend2(
                    this.getPointStub(dataObj, itemValue, dataLabel, HCObj),
                    {
                        y : itemValue,
                        color: {
                            FCcolor: {
                                color: lineColor,
                                alpha: lineAlpha
                            }
                        },
                        shadow: pointShadow,
                        dashStyle: dashStyle,
                        valuePosition: pluck(dataObj.valueposition, HCChartObj.valuePosition),
                        marker: {
                            enabled: !!pointAnchorEnabled,
                            shadow: setAnchorShadow && {
                                opacity: setAnchorAlpha / 100
                            },
                            fillColor: {
                                FCcolor: {
                                    color: setAnchorBgColor,
                                    alpha: ((setAnchorBgAlpha * setAnchorAlpha) / 100) + BLANKSTRING
                                }
                            },
                            lineColor: {
                                FCcolor: {
                                    color: setAnchorBorderColor,
                                    alpha: setAnchorAlpha
                                }
                            },
                            lineWidth: setAnchorBorderThickness,
                            radius: setAnchorRadius,
                            startAngle: setAnchorAngle,
                            symbol: mapSymbolName(setAnchorSides),
                            imageUrl: imageUrl,
                            imageScale: imageScale,
                            imageAlpha: imageAlpha

                        },
                        tooltipConstraint : this.tooltipConstraint,

                        hoverEffects: hoverEffects.enabled && hoverEffects.options,
                        rolloverProperties: hoverEffects.enabled && hoverEffects.rolloverOptions
                    }));

                // Set the maximum and minimum found in data
                // pointValueWatcher use to calculate the maximum and minimum value of the Axis
                this.pointValueWatcher(HCObj, itemValue);
                countPoint += 1;
            }
            xAxisConf.catCount = catIndex;
            //return series
            return series;
        },
        defaultZeroPlaneHighlighted: false
    }, singleSeriesAPI);

    /////////////// Area ///////////
    chartAPI('area2dbase', {
        defaultSeriesType : 'area',
        hasVDivLine : true,

        point: function (chartName, series, data, FCChartObj, HCObj) {
            // HighChart chart obj
            var HCChartObj = HCObj.chart,
                // Data array in dataset object
                length = data.length,
                // ex-renderer xAxis obj
                xAxisObj = HCObj.xAxis,
                // HighChart configuration object
                conf = HCObj[FC_CONFIG_STRING],
                // axisGridManager to manage the axis
                // it contains addVline, addXaxisCat, addAxisAltGrid and
                // addAxisGridLine function
                axisGridManager = conf.axisGridManager,
                xAxisConf = conf.x,
                NumberFormatter = HCObj[FC_CONFIG_STRING].numberFormatter,
                colorM = this.colorManager,
                catIndex = 0,

                itemValue,
                index,
                dataLabel,
                showLabel,
                seriesFillColor,
                seriesFillAlpha,
                seriesFillAngle,
                seriesLineColor,
                seriesLineAlpha,
                seriesLineAngle,
                seriesLineRatio,
                setAnchorSides,
                setAnchorRadius,
                setAnchorBorderColor,
                setAnchorAngle,
                dataObj,
                setAnchorBgColor,
                setAnchorAlpha,
                setAnchorBgAlpha,
                drawAnchors,
                seriesDashed,
                seriesDashLen,
                seriesDashGap,
                seriesLineThickness,
                setAnchorBorderThickness,
                countPoint,
                setColor,
                setAlpha,
                seriesGradientColor,
                pointShadow,
                seriesFill,
                pointFillColor,
                anchorShadow,
                setAnchorShadow,

                imageUrl,
                imageScale,
                imageAlpha,
                hoverEffects;

            // Managing Area cosmetics
            // Color of the area
            seriesFillColor =
                pluck(FCChartObj.plotfillcolor, FCChartObj.areabgcolor, (getValidValue(FCChartObj.palettecolors) ?
                colorM.getPlotColor(0) : colorM.getColor('plotFillColor'))).split(/\s*\,\s*/)[0];
            // GradientColor of the area fill
            seriesGradientColor = COMMASTRING + (pluckNumber(FCChartObj.useplotgradientcolor, 1) ?
                getDefinedColor(FCChartObj.plotgradientcolor, colorM.getColor('plotGradientColor')) : BLANKSTRING);
            seriesFillAlpha = pluck(FCChartObj.plotfillalpha, FCChartObj.areaalpha, this.isStacked ?
                HUNDREDSTRING : '90');
            seriesFillAngle = pluckNumber(FCChartObj.plotfillangle , 270);

            // Managing line series cosmetics
            // Color of the line
            seriesLineColor =
                pluck(FCChartObj.plotbordercolor, FCChartObj.areabordercolor, (getValidValue(FCChartObj.palettecolors) ?
                colorM.getPlotColor(0) : colorM.getColor('plotBorderColor'))).split(/\s*\,\s*/)[0];

            // Plot border alpha
            seriesLineAlpha = FCChartObj.showplotborder == ZEROSTRING ?
                ZEROSTRING :
                pluck(FCChartObj.plotborderalpha, FCChartObj.plotfillalpha, FCChartObj.areaalpha, HUNDREDSTRING);
            seriesLineAngle = pluckNumber(FCChartObj.plotborderangle , 270);
            seriesLineRatio = HUNDREDSTRING;
            seriesDashed = Boolean(pluckNumber(FCChartObj.plotborderdashed, 0));
            seriesDashLen = pluckNumber(FCChartObj.plotborderdashlen, 5);
            seriesDashGap = pluckNumber(FCChartObj.plotborderdashgap, 4);
            // Plot border thickness
            seriesLineThickness = pluckNumber(FCChartObj.plotborderthickness, FCChartObj.areaborderthickness, 1);
            // Set the area fill color and alpha to
            // HC seris obj with FusionCharts color format using FCcolor obj
            seriesFill = series.fillColor = {
                FCcolor: {
                    color: seriesFillColor + seriesGradientColor.replace(/,+?$/,''),
                    alpha: seriesFillAlpha,
                    ratio: BGRATIOSTRING,
                    angle: seriesFillAngle
                }
            };

            series.lineWidth = seriesLineThickness;
            series.dashStyle  = seriesDashed ? getDashStyle(seriesDashLen,
                seriesDashGap, seriesLineThickness) : 'none';
            // set the line color and alpha to
            // HC seris obj with FusionCharts color format using FCcolor obj
            series.lineColor = {
                FCcolor: {
                    color: seriesLineColor,
                    alpha: seriesLineAlpha,
                    ratio: seriesLineRatio,
                    angle: seriesLineAngle
                }
            };

           // IF its a step area chart
            series.step = pluck(this.stepLine, series.step);
            // Special attribute for StepLine (drawVerticalJoins)
            series.drawVerticalJoins = Boolean(pluckNumber(series.drawVerticalJoins, FCChartObj.drawverticaljoins, 1));
            series.useForwardSteps = Boolean(pluckNumber(series.useForwardSteps, FCChartObj.useforwardsteps, 1));


            // Managing line series markers
            // Whether to drow the Anchor or not
            drawAnchors = Boolean(pluckNumber(FCChartObj.drawanchors ,
                FCChartObj.showanchors , 1));

            // anchor shadow
            // set the series anchor shadow
            series.anchorShadow = anchorShadow = pluckNumber(FCChartObj.anchorshadow, 0);

            // Iterate through all level data
            for (index = 0, countPoint = 0; index < length; index += 1) {

                dataObj = data[index];

                // vLine
                if (dataObj.vline) {
                    axisGridManager.addVline(xAxisObj, dataObj, catIndex,
                    HCObj);
                    continue;
                }

                itemValue = NumberFormatter.getCleanValue(dataObj.value);

                showLabel = pluckNumber(dataObj.showlabel,
                    FCChartObj.showlabels, 1);
                // Label of the data
                // getFirstValue returns the first defined value in arguments
                // we check if showLabel is not set to 0 in data
                // then we take the label given in data, it can be given
                // using label as well as name too
                // we give priority to label if label is not there,
                // we check the name attribute
                dataLabel = parseUnsafeString(getFirstValue(dataObj.label, dataObj.name));
                // Put label in ex-renderer xAxis categories
                axisGridManager.addXaxisCat(xAxisObj, catIndex, catIndex,
                    showLabel ? dataLabel : BLANKSTRING, dataObj, {}, FCChartObj);
                catIndex += 1;

                // Taking default anchor cosmetics form dataset obj or
                // Chart obj or default
                setAnchorSides = pluckNumber(dataObj.anchorsides,
                    FCChartObj.anchorsides, 0);
                setAnchorAngle = pluckNumber(dataObj.anchorstartangle,
                    FCChartObj.anchorstartangle, 90);
                setAnchorRadius = pluckNumber(dataObj.anchorradius,
                    FCChartObj.anchorradius, 3);
                setAnchorBorderColor = getFirstColor(pluck(
                    dataObj.anchorbordercolor, FCChartObj.anchorbordercolor,
                    seriesLineColor));
                setAnchorBorderThickness = pluckNumber(
                    dataObj.anchorborderthickness,
                    FCChartObj.anchorborderthickness, 1);
                setAnchorBgColor = getFirstColor(pluck(dataObj.anchorbgcolor,
                    FCChartObj.anchorbgcolor,
                        colorM.getColor('anchorBgColor')));
                setAnchorAlpha = pluck(dataObj.anchoralpha,
                FCChartObj.anchoralpha, this.anchorAlpha, ZEROSTRING);
                setAnchorBgAlpha = pluck(dataObj.anchorbgalpha,
                    FCChartObj.anchorbgalpha, setAnchorAlpha);

                setAnchorShadow = Boolean(pluckNumber(dataObj.anchorshadow,
                                    anchorShadow, 0));
                // Managing line series cosmetics
                // Color of the line
                /** @todo Gradient calculation take from top */
                setColor = getValidValue(dataObj.color);
                // alpha
                setAlpha = pluckNumber(dataObj.alpha);

                if (setColor !== undefined || setAlpha !== undefined) {
                    pointFillColor = {
                        FCcolor: {
                            color: setColor ? getFirstColor(setColor) +
                                seriesGradientColor : seriesFillColor,
                            alpha: undefined === setAlpha ?
                                getFirstAlpha(setAlpha) + BLANKSTRING :
                                seriesFillAlpha,
                            ratio: BGRATIOSTRING,
                            angle: seriesFillAngle
                        }
                    };
                }
                else {
                    pointFillColor = seriesFill;
                }

                imageUrl = pluck(dataObj.anchorimageurl, FCChartObj.anchorimageurl);
                imageScale = pluck(dataObj.anchorimagescale, FCChartObj.anchorimagescale, 100);
                imageAlpha = pluck(dataObj.anchorimagealpha, FCChartObj.anchorimagealpha, 100);

                // Used to set alpha of the shadow
                pointShadow = {
                    opacity: mathMax(setAlpha, seriesLineAlpha) / 100,
                    inverted: true
                };

                // Point hover effects
                hoverEffects = this.pointHoverOptions(dataObj, series, {
                        plotType: 'anchor',
                        anchorBgColor: setAnchorBgColor,
                        anchorAlpha: setAnchorAlpha,
                        anchorBgAlpha: setAnchorBgAlpha,
                        anchorAngle: setAnchorAngle,

                        anchorBorderThickness: setAnchorBorderThickness,
                        anchorBorderColor: setAnchorBorderColor,
                        anchorBorderAlpha: setAnchorAlpha,
                        anchorSides: setAnchorSides,
                        anchorRadius: setAnchorRadius,

                        imageUrl: imageUrl,
                        imageScale: imageScale,
                        imageAlpha:imageAlpha,

                        shadow: pointShadow
                    }
                );

                // Finally add the data
                // we call getPointStub function that manage displayValue,
                // toolText and link
                series.data.push(extend2(
                    this.getPointStub(dataObj, itemValue, dataLabel, HCObj),
                    {
                        y : itemValue,
                        shadow: pointShadow,
                        color: pointFillColor,
                        valuePosition: pluck(dataObj.valueposition,
                            HCChartObj.valuePosition),
                        marker : {
                            enabled: drawAnchors,
                            shadow: setAnchorShadow && {
                                opacity: setAnchorAlpha / 100
                            },
                            fillColor: {
                                FCcolor: {
                                    color: setAnchorBgColor,
                                    alpha: ((setAnchorBgAlpha * setAnchorAlpha) /
                                         100) + BLANKSTRING
                                }
                            },
                            lineColor: {
                                FCcolor: {
                                    color: setAnchorBorderColor,
                                    alpha: setAnchorAlpha
                                }
                            },
                            lineWidth: setAnchorBorderThickness,
                            radius: setAnchorRadius,
                            symbol: mapSymbolName(setAnchorSides),
                            startAngle: setAnchorAngle,
                            imageUrl: imageUrl,
                            imageScale: imageScale,
                            imageAlpha: imageAlpha
                        },
                        tooltipConstraint : this.tooltipConstraint,
                        // Set the maximum and minimum found in data
                        // pointValueWatcher use to calculate the maximum and minimum
                        // value of the Axis
                        previousY: this.pointValueWatcher(HCObj, itemValue),

                        hoverEffects: hoverEffects.enabled && hoverEffects.options,
                        rolloverProperties: hoverEffects.enabled && hoverEffects.rolloverOptions
                    }));


                countPoint += 1;
            }
            xAxisConf.catCount = catIndex;

            //return series
            return series;
        }
    }, singleSeriesAPI);

    /////////////// mscolumn2d ///////////
    chartAPI('mscolumn2dbase', {
        /*
         *  Function for MSColumn2D chart
         *  ~param {string} chartName name of the chart eg: column2d
         *  ~param {object} series HighChart series object where the point will be added
         *  ~param {object} dataset corresponding FusionCharts dataset object
         *  ~param {object} FCChartObj FusionCharts JSON of chart tag
         *  ~param {object} HCObj HighChart JSON object
         *  ~param {number} catLength total number of categories
         *  ~param {number} seriesIndex index position of that series
         *  ~param {number} MSStackIndex stack index of that series (only for MSStacked)
         *  ~param {number} position of the column for MSColumn or MSStacked charts
         */
        point : function (chartName, series, dataset, FCChartObj, HCObj,
                    catLength, seriesIndex, MSStackIndex, columnPosition) {

            var ignoreEmptyDatasets = pluckNumber(FCChartObj.ignoreemptydatasets, 0),
            hasValidPoint = false,
                data = dataset.data || [],
                dataParser,
                // HighChart configuration object
                conf = HCObj[FC_CONFIG_STRING],
                // take the series type
                seriesType = pluck(series.type, this.defaultSeriesType),
                // Check the chart is a stacked chart or not
                isStacked = pluck(series.isStacked, (HCObj.plotOptions[seriesType] &&
                    HCObj.plotOptions[seriesType].stacking)),
                // 100% stacked chart takes absolute values only
                isValueAbs = pluck(this.isValueAbs, conf.isValueAbs, false),
                // showValues attribute in individual dataset
                seriesYAxis = pluckNumber(series.yAxis, 0),
                NumberFormatter = HCObj[FC_CONFIG_STRING].numberFormatter,
                colorM = this.colorManager,
                plotColor = colorM.getPlotColor(),
                itemValue,
                index,
                dataObj,
                fillAangle,
                isBar = HCObj._FCconf.isBar,
                is3d,
                pointObj,

                // Hover effect
                seriesHoverEffects = series.hoverEffects;

            //add column position
            if (!isStacked) {
                series.columnPosition = pluckNumber(columnPosition, MSStackIndex, seriesIndex);
            }

            // Dataset seriesname
            series.name = getValidValue(dataset.seriesname);

            // If includeInLegend set to false
            // We set series.name blank
            if (pluckNumber(dataset.includeinlegend) === 0 ||
                    series.name === undefined) {
                series.showInLegend = false;
            }

            // Color of the individual series
            series.color = pluck(dataset.color, plotColor)
                .split(COMMASTRING)[0]
                .replace(/^#?/g, '#');
            // is3d and isBar helps to get the column color by
            // getColumnColor function
            // whether the chart is a 3D
            is3d = /3d$/.test(HCObj.chart.defaultSeriesType);

            fillAangle = pluck(360 - FCChartObj.plotfillangle, isBar ? 180 : 90);
            if (itemValue < 0) {
                fillAangle = 360 - fillAangle;
            }
            dataParser = series._dataParser = getDataParser.column(HCObj, {
                seriesname : series.name,
                plottooltext : dataset.plottooltext,
                color : pluck(dataset.color, plotColor),
                alpha : pluck(dataset.alpha, FCChartObj.plotfillalpha,
                    HUNDREDSTRING),
                plotgradientcolor : (pluckNumber(FCChartObj.useplotgradientcolor, 1) ?
                    getDefinedColor(FCChartObj.plotgradientcolor,
                        colorM.getColor('plotGradientColor')) :
                    BLANKSTRING),
                ratio : pluck(dataset.ratio, FCChartObj.plotfillratio),
                fillAangle : fillAangle,
                isRoundEdges : HCObj.chart.useRoundEdges,
                plotBorderColor : pluck(FCChartObj.plotbordercolor, is3d ?
                    COLOR_WHITE : colorM.getColor('plotBorderColor'))
                        .split(COMMASTRING)[0],
                plotBorderAlpha : (FCChartObj.showplotborder == ZEROSTRING  ||
                    (is3d && FCChartObj.showplotborder != ONESTRING)) ?
                    ZEROSTRING : pluck(FCChartObj.plotborderalpha,
                    HUNDREDSTRING),
                isBar : this.isBar,
                is3d : is3d,
                dashed : pluckNumber(dataset.dashed,
                    FCChartObj.plotborderdashed, 0),
                dashLen : pluckNumber(dataset.dashlen,
                    FCChartObj.plotborderdashlen, 5),
                dashGap : pluckNumber(dataset.dashgap,
                    FCChartObj.plotborderdashgap, 4),
                borderWidth : pluckNumber(FCChartObj.plotborderthickness , ONESTRING),
                showValues : pluckNumber(dataset.showvalues, conf.showValues),
                yAxis : seriesYAxis,
                use3DLighting : pluckNumber(FCChartObj.use3dlighting, 1),
                // also sending FusionCharts dataset to pick new attributes if
                // needed in any new chart type.
                _sourceDataset: dataset,
                hoverEffects: seriesHoverEffects

            }, this);

            // Iterate through all level data
            // We are managing the data value labels and other
            // cosmetics inside this loop
            for (index = 0; index < catLength; index += 1) {
                // Individual data object
                dataObj = data[index];
                if (dataObj) {
                    // get the valid value
                    itemValue = NumberFormatter.getCleanValue(
                        dataObj.value, isValueAbs);
                    if (itemValue === null) {
                        // add the data
                        series.data.push({
                            y : null
                        });
                        continue;
                    }
                    //set this flag as true
                    hasValidPoint = true;

                    pointObj = dataParser(dataObj, index, itemValue);
                    //push the point object
                    series.data.push(pointObj);

                    // Set the maximum and minimum found in data
                    // pointValueWatcher use to calculate the maximum and
                    // minimum value of the Axis
                    pointObj.previousY = this.pointValueWatcher(HCObj, itemValue, seriesYAxis,
                        isStacked, index, MSStackIndex, seriesType);

                }
                else {
                    // add the data
                    series.data.push({
                        y : null
                    });
                }
            }
            /** @todo: in case of empty series remove interactivity. */
            if (ignoreEmptyDatasets && !hasValidPoint && !this.realtimeEnabled) {
                series.showInLegend = false;
            }

            return series;
        },
        defaultSeriesType : 'column'
    }, multiSeriesAPI);

    /////////////// msline ///////////
    chartAPI('mslinebase', {
        hasVDivLine : true,
        point: function (chartName, series, dataset, FCChartObj, HCObj, catLength) {
            var ignoreEmptyDatasets = pluckNumber(FCChartObj.ignoreemptydatasets, 0),
                hasValidPoint = false,
                colorM = this.colorManager,
                itemValue,
                index,
                dataParser,
                dataObj,
                pointObj,
                HCChartObj = HCObj.chart,
                // Data array in dataset object
                data = dataset.data || [],
                // HighChart configuration object
                conf = HCObj[FC_CONFIG_STRING],
                // take the series type
                seriesType = pluck(series.type, this.defaultSeriesType),
                // Check the chart is a stacked chart or not
                isStacked = pluck(series.isStacked, (HCObj.plotOptions[seriesType] &&
                    HCObj.plotOptions[seriesType].stacking)),
                // 100% stacked chart takes absolute values only
                isValueAbs = pluck(this.isValueAbs, conf.isValueAbs, false),
                seriesYAxis = pluckNumber(series.yAxis, 0),
                NumberFormatter = this.numberFormatter,

                // Line cosmetics attributes
                // Color of the line series
                lineColorDef = getFirstColor(pluck(dataset.color, FCChartObj.linecolor,
                    colorM.getPlotColor())),
                // Alpha of the line
                lineAlphaDef = pluckNumber(dataset.alpha, FCChartObj.linealpha, HUNDREDSTRING),
                showShadow = pluckNumber(FCChartObj.showshadow, this.defaultPlotShadow, 1),
                // Managing line series markers
                // Whether to drow the Anchor or not
                drawAnchors = pluckNumber(dataset.drawanchors, dataset.showanchors , FCChartObj.drawanchors,
                    FCChartObj.showanchors),
                // Anchor cosmetics
                // We first look into dataset then chart obj and then default value.
                setAnchorSidesDef = pluckNumber(dataset.anchorsides,
                    FCChartObj.anchorsides, 0),
                setAnchorAngleDef = pluckNumber(dataset.anchorstartangle,
                    FCChartObj.anchorstartangle, 90),
                setAnchorRadiusDef = pluckNumber(dataset.anchorradius,
                    FCChartObj.anchorradius, 3),
                setAnchorBorderColorDef = getFirstColor(pluck(dataset.anchorbordercolor,
                    FCChartObj.anchorbordercolor, lineColorDef)),
                setAnchorBorderThicknessDef = pluckNumber(dataset.anchorborderthickness,
                    FCChartObj.anchorborderthickness, 1),
                setAnchorBgColorDef = getFirstColor(pluck(dataset.anchorbgcolor,
                    FCChartObj.anchorbgcolor, colorM.getColor('anchorBgColor'))),
                setAnchorAlphaDef = pluck(dataset.anchoralpha, FCChartObj.anchoralpha,
                    HUNDREDSTRING),
                setAnchorBgAlphaDef = pluck(dataset.anchorbgalpha, FCChartObj.anchorbgalpha,
                    setAnchorAlphaDef),
                anchorShadow = setAnchorAlphaDef &&
                        pluck(dataset.anchorshadow, FCChartObj.anchorshadow, 0),

                // Hover effect
                seriesHoverEffects = series.hoverEffects;

            // Dataset seriesname
            series.name = getValidValue(dataset.seriesname);
            // If includeInLegend set to false
            // We set series.name blank
            if (pluckNumber(dataset.includeinlegend) === 0 ||
                series.name === undefined || (lineAlphaDef === 0 &&
                    drawAnchors !== 1)) {
                series.showInLegend = false;
            }

            //set the marker attr at series
            series.marker = {
                fillColor: {
                    FCcolor: {
                        color: setAnchorBgColorDef,
                        alpha: ((setAnchorBgAlphaDef * setAnchorAlphaDef) / 100) + BLANKSTRING
                    }
                },
                lineColor: {
                    FCcolor: {
                        color: setAnchorBorderColorDef,
                        alpha: setAnchorAlphaDef + BLANKSTRING
                    }
                },
                lineWidth: setAnchorBorderThicknessDef,
                radius: setAnchorRadiusDef,
                symbol: mapSymbolName(setAnchorSidesDef),
                startAngle: setAnchorAngleDef
            };

            // Set the line color and alpha to
            // HC seris obj with FusionCharts color format using FCcolor obj
            series.color = {
                FCcolor: {
                    color: lineColorDef,
                    alpha: lineAlphaDef
                }
            };
            // For Spline Chart shadow do not works at point label.
            series.shadow = showShadow ? {
                opacity: showShadow ? lineAlphaDef / 100 : 0
            } : false;

            series.anchorShadow = anchorShadow;

            // IF its a step line chart
            series.step = pluck(this.stepLine, series.step);
            // Special attribute for StepLine (drawVerticalJoins)
            series.drawVerticalJoins = Boolean(pluckNumber(series.drawVerticalJoins, FCChartObj.drawverticaljoins, 1));
            series.useForwardSteps = Boolean(pluckNumber(series.useForwardSteps, FCChartObj.useforwardsteps, 1));

            // Set the line thickness (line width)
            series.lineWidth = pluckNumber(dataset.linethickness, FCChartObj.linethickness, 2);


            dataParser = series._dataParser = getDataParser.line(HCObj, {
                seriesname : series.name,
                plottooltext : dataset.plottooltext,
                lineAlpha : lineAlphaDef,
                anchorAlpha : setAnchorAlphaDef,
                showValues : pluckNumber(dataset.showvalues, conf.showValues),
                yAxis : seriesYAxis,
                lineDashed : Boolean(pluckNumber(dataset.dashed, FCChartObj.linedashed, 0)),
                lineDashLen : pluckNumber(dataset.linedashlen, FCChartObj.linedashlen, 5),
                lineDashGap : pluckNumber(dataset.linedashgap, FCChartObj.linedashgap, 4),
                lineThickness : series.lineWidth,
                lineColor : lineColorDef,
                valuePosition : pluck(dataset.valueposition, HCChartObj.valuePosition),
                drawAnchors : drawAnchors,
                anchorBgColor : setAnchorBgColorDef,
                anchorBgAlpha : setAnchorBgAlphaDef,
                anchorBorderColor : setAnchorBorderColorDef,
                anchorBorderThickness : setAnchorBorderThicknessDef,
                anchorRadius : setAnchorRadiusDef,
                anchorSides : setAnchorSidesDef,
                anchorAngle : setAnchorAngleDef,
                anchorShadow: series.anchorShadow,
                anchorStartAngle: pluckNumber(dataset.anchorstartangle, FCChartObj.anchorstartangle),
                // also sending FusionCharts dataset to pick new attributes if
                // needed in any new chart type.
                _sourceDataset: dataset,
                hoverEffects: seriesHoverEffects,
                imageUrl: pluck(dataset.anchorimageurl, FCChartObj.anchorimageurl),
                imageScale: pluck(dataset.anchorimagescale, FCChartObj.anchorimagescale, 100),
                imageAlpha: pluck(dataset.anchorimagealpha, FCChartObj.anchorimagealpha, 100)
            }, this);



            // Iterate through all level data
            for (index = 0; index < catLength; index += 1) {
                // Individual data obj
                // for further manipulation
                dataObj = data[index];
                if (dataObj) {
                    itemValue = NumberFormatter.getCleanValue(dataObj.value, isValueAbs);
                    if (itemValue === null) {
                        // add the data
                        series.data.push({
                            y : null
                        });
                        continue;
                    }
                    //set the flag
                    hasValidPoint = true;

                    pointObj = dataParser(dataObj, index, itemValue);
                    //push the point object
                    series.data.push(pointObj);

                    // Set the maximum and minimum found in data
                    // pointValueWatcher use to calculate the maximum and
                    // minimum value of the Axis
                    pointObj.previousY = this.pointValueWatcher(HCObj, itemValue, seriesYAxis,
                        isStacked, index, 0, seriesType);

                }
                else {
                    // add the data
                    series.data.push({
                        y : null
                    });
                }
            }
            /** @todo: in case of empty series remove interactivity. */
            if (ignoreEmptyDatasets && !hasValidPoint && !this.realtimeEnabled) {
                series.showInLegend = false;
            }

            //return series
            return series;
        },
        defaultSeriesType : 'line',
        defaultPlotShadow: 1,
        defaultZeroPlaneHighlighted: false
    }, multiSeriesAPI);

    ////// msarea ////////
    chartAPI('msareabase', {
        hasVDivLine : true,
        point: function (chartName, series, dataset, FCChartObj, HCObj,
                   catLength) {
            var ignoreEmptyDatasets = pluckNumber(FCChartObj.ignoreemptydatasets, 0),
                hasValidPoint = false,
                HCChartObj = HCObj.chart,
                iapi = this,
                // Data array in dataset object
                data = dataset.data || [],
                // HighChart configuration object
                conf = HCObj[FC_CONFIG_STRING],
                // take the series type
                seriesType = pluck(series.type, iapi.defaultSeriesType),
                // Check the chart is a stacked chart or not
                isStacked = pluck(series.isStacked, (HCObj.plotOptions[seriesType] &&
                    HCObj.plotOptions[seriesType].stacking)),
                // 100% stacked chart takes absolute values only
                isValueAbs = pluck(iapi.isValueAbs, conf.isValueAbs, false),
                // Whether to use yAxis or not
                seriesYAxis = pluckNumber(series.yAxis, 0),
                NumberFormatter = HCObj[FC_CONFIG_STRING].numberFormatter,
                colorM = this.colorManager,
                plotColor = colorM.getPlotColor(),
                // Area fill color
                seriesFillColor = pluck(dataset.color,
                    FCChartObj.plotfillcolor,
                    plotColor)
                    .split(COMMASTRING)[0].replace(/^#?/g, '#')
                    .split(COMMASTRING)[0],
                // Alpha of the area fill
                seriesFillAlpha = pluck(dataset.alpha, FCChartObj.plotfillalpha,
                    FCChartObj.areaalpha, iapi.areaAlpha, 70),
                // Angle of the area fill
                seriesFillAngle = pluckNumber(FCChartObj.plotfillangle, 270),
                // Angle of the fill ratio
                seriesFillRatio = BGRATIOSTRING,
                // Area line cosmetics
                seriesLineColor = pluck(dataset.plotbordercolor,
                    FCChartObj.plotbordercolor, FCChartObj.areabordercolor,
                    iapi.isRadar ? plotColor : '666666')
                        .split(COMMASTRING)[0],
                // Area border cosmetics
                // alpha
                seriesLineAlpha = pluck(dataset.showplotborder,
                    FCChartObj.showplotborder) == ZEROSTRING  ? ZEROSTRING :
                    pluck(dataset.plotborderalpha, FCChartObj.plotborderalpha,
                    dataset.alpha, FCChartObj.plotfillalpha,
                    FCChartObj.areaalpha, '95'),
                seriesLineAngle = pluckNumber(FCChartObj.plotborderangle , 270),
                seriesLineRatio = HUNDREDSTRING,
                // Taking default anchor cosmetics form dataset obj or
                // Chart obj or default
                setAnchorSidesDef = pluckNumber(dataset.anchorsides,
                    FCChartObj.anchorsides, 0),
                setAnchorAngleDef = pluckNumber(dataset.anchorstartangle,
                    FCChartObj.anchorstartangle, 90),
                setAnchorRadiusDef = pluckNumber(dataset.anchorradius,
                    FCChartObj.anchorradius, 3),
                setAnchorBorderColorDef = getFirstColor(pluck(
                    dataset.anchorbordercolor,
                    FCChartObj.anchorbordercolor, seriesFillColor)),
                setAnchorBorderThicknessDef = pluckNumber(
                    dataset.anchorborderthickness,
                    FCChartObj.anchorborderthickness, 1),
                setAnchorBgColorDef = getFirstColor(pluck(dataset.anchorbgcolor,
                    FCChartObj.anchorbgcolor,
                    colorM.getColor('anchorBgColor'))),
                setAnchorAlphaDef = pluckNumber(dataset.anchoralpha,
                    FCChartObj.anchoralpha, iapi.anchorAlpha, 0),
                setAnchorBgAlphaDef = pluckNumber(dataset.anchorbgalpha,
                    FCChartObj.anchorbgalpha, setAnchorAlphaDef),
                anchorShadow = setAnchorAlphaDef &&
                        pluck(dataset.anchorshadow, FCChartObj.anchorshadow, 0),
                dataParser,
                itemValue,
                index,
                dataObj,
                pointObj,

                // Hover effect
                seriesHoverEffects = series.hoverEffects;

            if (!iapi.isRadar) {
                seriesFillColor += COMMASTRING + (pluckNumber(
                    FCChartObj.useplotgradientcolor, 1) ?
                    getDefinedColor(FCChartObj.plotgradientcolor,
                        colorM.getColor('plotGradientColor')) :
                    BLANKSTRING);
                seriesFillColor = seriesFillColor.replace(/,+?$/,'');
            }

            // IF its a step area chart
            series.step = pluck(iapi.stepLine, series.step);
            // Special attribute for StepLine (drawVerticalJoins)
            series.drawVerticalJoins = Boolean(pluckNumber(series.drawVerticalJoins, FCChartObj.drawverticaljoins, 1));
            series.useForwardSteps = Boolean(pluckNumber(series.useForwardSteps, FCChartObj.useforwardsteps, 1));


            // Dataset seriesname
            series.name = pluck(dataset.seriesname);
            // If includeInLegend set to false
            // We set series.name blank
            if (pluckNumber(dataset.includeinlegend) === 0 ||
                    series.name === undefined) {
                series.showInLegend = false;
            }
            // Set the area fill color and alpha to
            // HC seris obj with FusionCharts color format using FCcolor obj
            series.fillColor = {
                FCcolor: {
                    color: seriesFillColor,
                    alpha: seriesFillAlpha,
                    ratio: seriesFillRatio,
                    angle: seriesFillAngle
                }
            };
            // To set the color of the legend icon, we need to set the
            // series color
            series.color = seriesFillColor;
            // For Spline Chart shadow do not works at point label.
            series.shadow = {
                opacity: pluckNumber(FCChartObj.showshadow, 1) ?
                    (seriesLineAlpha / 100) : 0
            };
            series.anchorShadow = anchorShadow;

            // set the line color and alpha to
            // HC seris obj with FusionCharts color format using FCcolor obj
            series.lineColor = {
                FCcolor: {
                    color: seriesLineColor,
                    alpha: seriesLineAlpha,
                    ratio: seriesLineRatio,
                    angle: seriesLineAngle
                }
            };
            // set the line thickness (line width)
            series.lineWidth = pluck(dataset.plotborderthickness,
                FCChartObj.plotborderthickness, 1);
            // create line dash
            // using dashStyle of HC
            series.dashStyle  = Boolean(pluckNumber(dataset.dashed,
                FCChartObj.plotborderdashed, 0)) ? getDashStyle(
                pluckNumber(dataset.dashlen, FCChartObj.plotborderdashlen, 5),
                pluckNumber(dataset.dashgap, FCChartObj.plotborderdashgap, 4),
                series.lineWidth) : undefined;
            //set the marker attr at series
            series.marker = {
                fillColor: {
                    FCcolor: {
                        color: setAnchorBgColorDef,
                        alpha: ((setAnchorBgAlphaDef * setAnchorAlphaDef) /
                            100) + BLANKSTRING
                    }
                },
                lineColor: {
                    FCcolor: {
                        color: setAnchorBorderColorDef,
                        alpha: setAnchorAlphaDef + BLANKSTRING
                    }
                },
                lineWidth: setAnchorBorderThicknessDef,
                radius: setAnchorRadiusDef,
                symbol: mapSymbolName(setAnchorSidesDef),
                startAngle: setAnchorAngleDef
            };
            dataParser = series._dataParser = getDataParser.area(HCObj, {
                seriesname : series.name,
                plottooltext : dataset.plottooltext,
                lineAlpha : seriesLineAlpha,
                anchorAlpha : setAnchorAlphaDef,
                showValues : pluckNumber(dataset.showvalues, conf.showValues),
                yAxis : seriesYAxis,
                fillColor : seriesFillColor,
                fillAlpha : seriesFillAlpha,
                valuePosition : pluck(dataset.valueposition,
                    HCChartObj.valuePosition),
                drawAnchors : Boolean(pluckNumber(dataset.drawanchors, FCChartObj.drawanchors,
                    FCChartObj.showanchors , 1)),
                anchorBgColor : setAnchorBgColorDef,
                anchorBgAlpha : setAnchorBgAlphaDef,
                anchorBorderColor : setAnchorBorderColorDef,
                anchorBorderThickness : setAnchorBorderThicknessDef,
                anchorRadius : setAnchorRadiusDef,
                anchorSides : setAnchorSidesDef,
                anchorAngle : setAnchorAngleDef,
                anchorShadow: series.anchorShadow,
                getLink : iapi.linkClickFN,
                anchorStartAngle: pluckNumber(dataset.anchorstartangle, FCChartObj.anchorstartangle),
                // also sending FusionCharts dataset to pick new attributes if
                // needed in any new chart type.
                _sourceDataset: dataset,
                hoverEffects: seriesHoverEffects,
                imageUrl: pluck(dataset.anchorimageurl, FCChartObj.anchorimageurl),
                imageScale: pluck(dataset.anchorimagescale, FCChartObj.anchorimagescale, 100),
                imageAlpha: pluck(dataset.anchorimagealpha, FCChartObj.anchorimagealpha, 100)
            }, this);

            // Iterate through all level data
            for (index = 0; index < catLength; index += 1) {
                // individual data obj
                // for further manipulation
                dataObj = data[index];
                if (dataObj) {
                    // get the valid value
                    // parsePointValue check the its a value value of not
                    // and return the valid value
                    itemValue = dataObj ? NumberFormatter.getCleanValue(
                        dataObj.value, isValueAbs) : null;
                    if (itemValue === null) {
                        // add the data
                        series.data.push({
                            y : null
                        });
                        continue;
                    }

                    hasValidPoint = true;

                    pointObj = dataParser(dataObj, index, itemValue);
                    //push the point object
                    series.data.push(pointObj);


                    // Set the maximum and minimum found in data
                    // pointValueWatcher use to calculate the maximum and
                    // minimum value of the Axis
                    pointObj.previousY = iapi.pointValueWatcher(HCObj, itemValue, seriesYAxis,
                        isStacked, index, 0, seriesType);
                }
                else {
                    // add the data
                    series.data.push({
                        y : null
                    });
                }
            }
            /** @todo: in case of empty series remove interactivity. */
            if (ignoreEmptyDatasets && !hasValidPoint && !iapi.realtimeEnabled) {
                series.showInLegend = false;
            }
            return series;
        },
        defaultSeriesType : 'area',
        defaultPlotShadow: 0
    }, multiSeriesAPI);

    //////scatter base ////////
    chartAPI('scatterbase', {
        showValues : 0,
        defaultPlotShadow: 0,
        rendererId: 'cartesian',
        defaultSeriesType: 'scatter',
        canvasPaddingModifiers: ['anchorlabel'],
        point: function (chartName, series, dataset, FCChartObj, HCObj, catLength, seriesIndex) {
                var ignoreEmptyDatasets = pluckNumber(FCChartObj.ignoreemptydatasets, 0),
                    colorM = this.colorManager,
                    plotColor = colorM.getPlotColor(),
                    itemValueY,
                    index,
                    scatterBorderColor,
                    scatterAlpha,
                    lineThickness,
                    lineDashed,
                    lineDashLen,
                    lineDashGap,
                    drawAnchors,
                    dataObj,
                    pointShadow,
                    anchorShadow,
                    setAnchorShadow,
                    seriesAnchorSides,
                    seriesAnchorRadius,
                    seriesAnchorBorderColor,
                    seriesAnchorBorderThickness,
                    seriesAnchorBgColor,
                    seriesAnchorAlpha,
                    seriesAnchorBgAlpha,
                    setAnchorSides,
                    setAnchorRadius,
                    setAnchorBorderColor,
                    setAnchorBorderThickness,
                    setAnchorBgColor,
                    setAnchorAlpha,
                    setAnchorBgAlpha,
                    itemValueX,
                    hasValidPoint = false,
                    seriesAnchorAngle,
                    pointStub,
                    chartNameAPI = this,
                    // Whether to draw scatter line
                    drawLine = pluckNumber(dataset.drawline, FCChartObj.drawlines, 0),
                    drawProgressionCurve = pluckNumber(dataset.drawprogressioncurve, 0),
                    conf = HCObj[FC_CONFIG_STRING],
                    // Data array in dataset object
                    data = dataset.data || [],
                    regressionData,
                    regressionObj, regressionLineColor, regressionLineThickness, regressionLineAlpha, regLineColor,
                    showYOnX, regSeries,
                    dataLength,
                    // showValues attribute in individual dataset
                    datasetShowValues = pluckNumber(dataset.showvalues, conf.showValues),
                    NumberFormatter = this.numberFormatter,

                    // Hover effect
                    hoverEffects,

                    //Regratation line
                    showRegressionLine = series._showRegression = pluckNumber(dataset.showregressionline,
                        FCChartObj.showregressionline, 0);

                //add z index so that the regration line set at the back of the series
                series.zIndex = 1;

                // Dataset seriesname
                series.name = getValidValue(dataset.seriesname);
                // If showInLegend set to false
                // We set series.name blank
                if (pluckNumber(dataset.includeinlegend) === 0 || series.name === undefined) {
                    series.showInLegend = false;
                }

                if (drawLine || drawProgressionCurve) {
                    /** @todo  Apply spline codebase to to render spline
                    if (drawProgressionCurve) {
                        //series.type = 'spline';
                    }
                    */
                    // Line cosmetics attributes
                    // Color of the line series
                    scatterBorderColor = getFirstColor(pluck(dataset.color,
                        plotColor));
                    // Alpha of the line
                    scatterAlpha = pluck(dataset.alpha, HUNDREDSTRING);
                    // Line Thickness
                    lineThickness = pluckNumber(dataset.linethickness,
                        FCChartObj.linethickness, 2);
                    // Whether to use dashline
                    lineDashed = Boolean(pluckNumber(dataset.linedashed,
                        dataset.dashed, FCChartObj.linedashed, 0));

                    // line dash attrs
                    lineDashLen = pluckNumber(dataset.linedashlen,
                        FCChartObj.linedashlen, 5);
                    lineDashGap = pluckNumber(dataset.linedashgap,
                        FCChartObj.linedashgap, 4);

                    // Set the line color and alpha to
                    // HC seris obj with FusionCharts color format using FCcolor obj
                    series.color = convertColor(pluck(dataset.linecolor,
                        FCChartObj.linecolor, scatterBorderColor),
                        pluckNumber(dataset.linealpha, FCChartObj.linealpha,
                        scatterAlpha));

                    // Set the line thickness (line width)
                    series.lineWidth = lineThickness;
                    // Create line dash
                    // Using dashStyle of HC
                    series.dashStyle = lineDashed ? getDashStyle(lineDashLen,
                        lineDashGap, lineThickness) : 'none';
                }

                // Managing line series markers
                // Whether to drow the Anchor or not
                drawAnchors = Boolean(pluckNumber(dataset.drawanchors, dataset.showanchors,
                    FCChartObj.drawanchors, FCChartObj.showanchors, 1));

                // Anchor cosmetics
                // We first look into dataset then chart obj and then default value.
                seriesAnchorSides = pluckNumber(dataset.anchorsides,
                    FCChartObj.anchorsides, seriesIndex + 3);
                seriesAnchorRadius = pluckNumber(dataset.anchorradius,
                    FCChartObj.anchorradius, 3);
                seriesAnchorBorderColor = getFirstColor(pluck(dataset.anchorbordercolor, dataset.color,
                    FCChartObj.anchorbordercolor, scatterBorderColor, plotColor));
                seriesAnchorBorderThickness = pluckNumber(dataset.anchorborderthickness,
                    FCChartObj.anchorborderthickness, 1);
                seriesAnchorBgColor = getFirstColor(pluck(dataset.anchorbgcolor,
                    FCChartObj.anchorbgcolor, colorM.getColor('anchorBgColor')));
                seriesAnchorAlpha = pluck(dataset.anchoralpha, dataset.alpha, FCChartObj.anchoralpha,
                    HUNDREDSTRING);
                seriesAnchorBgAlpha = pluck(dataset.anchorbgalpha, dataset.alpha, FCChartObj.anchorbgalpha,
                    seriesAnchorAlpha);
                seriesAnchorAngle = pluck(dataset.anchorstartangle, FCChartObj.anchorstartangle, 90);

                series.anchorShadow = anchorShadow = pluckNumber(FCChartObj.anchorshadow, 0);

                //set the marker attr at series
                series.marker = {
                    fillColor: this.getPointColor(seriesAnchorBgColor, HUNDREDSTRING),
                    lineColor: {
                        FCcolor: {
                            color: seriesAnchorBorderColor,
                            alpha: seriesAnchorAlpha + BLANKSTRING
                        }
                    },
                    lineWidth: seriesAnchorBorderThickness,
                    radius: seriesAnchorRadius,
                    symbol: mapSymbolName(seriesAnchorSides)
                };


                if (data = (dataset.data || [])) {
                    dataLength = data.length;
                    if (showRegressionLine) {
                        series.events = {
                            hide : this.hideRLine,
                            show : this.showRLine
                        };
                        //regration object used in XY chart
                        //create here to avoid checking always
                        regressionObj = {
                            sumX : 0,
                            sumY : 0,
                            sumXY : 0,
                            sumXsqure : 0,
                            sumYsqure : 0,
                            xValues : [],
                            yValues : []
                        };
                        showYOnX = pluckNumber(dataset.showyonx, FCChartObj.showyonx, 1);
                        regressionLineColor = getFirstColor(pluck(dataset.regressionlinecolor,
                            FCChartObj.regressionlinecolor, seriesAnchorBorderColor));
                        regressionLineThickness = pluckNumber(dataset.regressionlinethickness,
                            FCChartObj.regressionlinethickness, seriesAnchorBorderThickness),
                        regressionLineAlpha = getFirstAlpha(pluckNumber(dataset.regressionlinealpha,
                            FCChartObj.regressionlinealpha, seriesAnchorAlpha));
                        regLineColor = convertColor(regressionLineColor, regressionLineAlpha);
                    }

                    // Iterate through all level data
                    for (index = 0; index < dataLength; index += 1) {
                        // Individual data obj
                        // for further manipulation
                        dataObj = data[index];
                        if (dataObj) {
                            itemValueY = NumberFormatter.getCleanValue(dataObj.y);
                            itemValueX = NumberFormatter.getCleanValue(dataObj.x);

                            if (itemValueY === null) {
                                series.data.push({
                                    y: null,
                                    x: itemValueX
                                });
                                continue;
                            }

                            hasValidPoint = true;

                            pointStub = chartNameAPI.getPointStub(dataObj, itemValueY,
                                NumberFormatter.xAxis(itemValueX), HCObj, dataset, datasetShowValues);


                            // Anchor cosmetics
                            // We first look into dataset then chart obj and then default value.
                            setAnchorSides = pluckNumber(dataObj.anchorsides, seriesAnchorSides);
                            setAnchorRadius = pluckNumber(dataObj.anchorradius, seriesAnchorRadius);
                            setAnchorBorderColor = getFirstColor(pluck(dataObj.anchorbordercolor,
                                seriesAnchorBorderColor));
                            setAnchorBorderThickness = pluckNumber(dataObj.anchorborderthickness,
                                seriesAnchorBorderThickness);
                            setAnchorBgColor = getFirstColor(pluck(dataObj.anchorbgcolor, seriesAnchorBgColor));
                            setAnchorAlpha = pluck(dataObj.anchoralpha, dataObj.alpha, seriesAnchorAlpha);
                            setAnchorBgAlpha = pluck(dataObj.anchorbgalpha, seriesAnchorBgAlpha);
                            setAnchorShadow = Boolean(pluckNumber(dataObj.anchorshadow,
                                        anchorShadow, 0));

                            // Point hover effects
                            hoverEffects = this.pointHoverOptions (dataObj, series, {
                                plotType: 'anchor',

                                anchorBgColor: setAnchorBgColor,
                                anchorAlpha: setAnchorAlpha,
                                anchorBgAlpha: setAnchorBgAlpha,
                                anchorAngle: seriesAnchorAngle,

                                anchorBorderThickness: setAnchorBorderThickness,
                                anchorBorderColor: setAnchorBorderColor,
                                anchorBorderAlpha: setAnchorAlpha,
                                anchorSides: setAnchorSides,
                                anchorRadius: setAnchorRadius,

                                shadow: pointShadow
                            });

                            // Finally add the data
                            // we call getPointStub function that manage displayValue,
                            // toolText and link
                            series.data.push({
                                y: itemValueY,
                                x: itemValueX,
                                displayValue : pointStub.displayValue,
                                toolText : pointStub.toolText,
                                link: pointStub.link,
                                marker: {
                                    enabled: drawAnchors,
                                    shadow: setAnchorShadow && {
                                        opacity: setAnchorAlpha / 100
                                    },
                                    fillColor: {
                                        FCcolor: {
                                            color: setAnchorBgColor,
                                            alpha: ((setAnchorBgAlpha *
                                                setAnchorAlpha) / 100) + BLANKSTRING
                                        }
                                    },
                                    lineColor: {
                                        FCcolor: {
                                            color: setAnchorBorderColor,
                                            alpha: setAnchorAlpha
                                        }
                                    },
                                    lineWidth: setAnchorBorderThickness,
                                    radius: setAnchorRadius,
                                    symbol: mapSymbolName(setAnchorSides),
                                    startAngle: pluck(dataObj.anchorstartangle,
                                        dataset.anchorstartangle, FCChartObj.anchorstartangle, 90)
                                },
                                hoverEffects: hoverEffects.enabled &&
                                        hoverEffects.options,
                                rolloverProperties: hoverEffects.enabled &&
                                        hoverEffects.rolloverOptions

                            });

                            // Set the maximum and minimum found in data
                            // pointValueWatcher use to calculate the maximum and minimum value of the Axis
                            this.pointValueWatcher(HCObj, itemValueY, itemValueX, showRegressionLine && regressionObj);
                        }
                        else {
                            // add the data
                            series.data.push({
                                y : null
                            });
                        }
                    }

                    if (showRegressionLine) {
                        regressionData = this.getRegressionLineSeries(regressionObj,
                            showYOnX, dataLength);

                        this.pointValueWatcher(HCObj, regressionData[0].y,
                            regressionData[0].x);
                        this.pointValueWatcher(HCObj, regressionData[1].y,
                            regressionData[1].x);

                        regSeries = {
                            type : 'line',
                            color : regLineColor,
                            showInLegend: false,
                            lineWidth : regressionLineThickness,
                            enableMouseTracking : false,
                            marker : {
                                enabled : false
                            },
                            data: regressionData,
                            zIndex : 0
                        };
                        series = [series, regSeries];
                    }
                }
                // If all the values in current dataset is null
                // we will not show its legend
                /** @todo: in case of empty series remove interactivity. */
                if (ignoreEmptyDatasets && !hasValidPoint) {
                    series.showInLegend = false;
                }
                return series;
            },

        postSeriesAddition: function(HCObj, FCObj) {
            var HCChartObj = HCObj.chart,
                FCChartObj = FCObj.chart,
                series = HCObj.series,
                i = 0,
                len = series.length;
            // Add related series to hide/show regression line from legend
            for (;i < len; i += 1) {
                if (series[i]._showRegression) {
                    series[i].relatedSeries = [i + 1];
                }
            }
            HCChartObj.clipBubbles = pluckNumber(FCChartObj.clipbubbles, 1);
        },

        categoryAdder : function(FCObj, HCObj) {
            var index, countCat = 0, fontSize, conf = HCObj[FC_CONFIG_STRING],
                xAxisConf = conf.x, catXValue,
                xAxisObj = HCObj.xAxis, dataLabel, categories,
                FCchartObj = FCObj.chart,
                labelStep = parseInt(FCchartObj.labelstep, 10),
                showLabels = pluckNumber(FCchartObj.showlabels, 1),
                xAxisLabelMode = pluck(FCchartObj.xaxislabelmode, 'categories').toLowerCase(),
                colorM = this.colorManager,
                NumberFormatter = HCObj[FC_CONFIG_STRING].numberFormatter,
                verticalLineColor,
                verticalLineThickness,
                verticalLineAlpha,
                verticalLineDashed,
                verticalLineDashLen,
                verticalLineDashGap,
                verticalLineColorRGB,
                category,
                catShowVerticalLine,
                catLineDashed,
                catShowLabel;

            // NOTE: adding isXYPlot as the placeHorizontalAxis function needs this info.
            HCObj._FCconf.isXYPlot = true;

            labelStep = labelStep > 1 ? labelStep : 1;
            //track category occupied values
            //so that auto values will not work for that value
            xAxisConf.catOccupied = {};

            if (xAxisLabelMode !== 'auto' && FCObj.categories && FCObj.categories[0] && FCObj.categories[0].category) {
                categories = FCObj.categories[0];
                //update the font relate attr in HC cat
                if (categories.font) {
                    HCObj.xAxis.labels.style.fontFamily  = categories.font;
                }
                if ((fontSize = pluckNumber(categories.fontsize)) !== undefined) {
                    if (fontSize < 1) {
                        fontSize = 1;
                    }
                    HCObj.xAxis.labels.style.fontSize  = fontSize + PXSTRING;
                    setLineHeight(HCObj.xAxis.labels.style);
                }

                if (categories.fontcolor) {
                    HCObj.xAxis.labels.style.color  = categories.fontcolor.
                    split(COMMASTRING)[0].replace(/^\#?/, '#');
                }

                verticalLineColor = pluck(categories.verticallinecolor , colorM.getColor('divLineColor'));
                verticalLineThickness = pluckNumber(categories.verticallinethickness, 1);
                verticalLineAlpha = pluckNumber(categories.verticallinealpha, colorM.getColor('divLineAlpha'));
                verticalLineDashed = pluckNumber(categories.verticallinedashed, 0);
                verticalLineDashLen = pluckNumber(categories.verticallinedashlen, 4);
                verticalLineDashGap = pluckNumber(categories.verticallinedashgap, 2);
                verticalLineColorRGB = convertColor(verticalLineColor, verticalLineAlpha);

                for (index = 0; index < categories.category.length; index += 1) {
                    category = categories.category[index];
                    catXValue = NumberFormatter.getCleanValue(category.x);
                    if (catXValue !== null && !category.vline) {
                        //store the cat occupied values
                        xAxisConf.catOccupied[catXValue] = true;

                        catShowLabel = pluckNumber(category.showlabel, category.showname,
                            showLabels);
                        catShowVerticalLine = pluckNumber(category.showverticalline, category.showline, category.sl, 0);
                        catLineDashed = pluckNumber(category.linedashed, verticalLineDashed);
                        dataLabel = (catShowLabel === 0 || countCat % labelStep !== 0) ?
                            BLANKSTRING : parseUnsafeString(getFirstValue(category.label, category.name));
                        xAxisObj.plotLines.push({
                            isGrid : true,
                            isCat : true,
                            isDataLabel: true,
                            width: catShowVerticalLine ? verticalLineThickness : 0,
                            color  : verticalLineColorRGB,
                            dashStyle  : getDashStyle(verticalLineDashLen, verticalLineDashGap, verticalLineThickness,
                                catLineDashed),
                            value: catXValue,
                            label : {
                                text : dataLabel,
                                link: pluck(category.link, FCchartObj.labellink),
                                style: parsexAxisStyles({}, category, FCchartObj, xAxisObj.labels.style),
                                align: POSITION_CENTER,
                                verticalAlign: POSITION_BOTTOM,
                                textAlign: POSITION_CENTER,
                                rotation : 0,
                                x : 0,
                                y : 0
                            }
                        });

                        //watch the value for min max of x
                        this.pointValueWatcher(HCObj, null, catXValue);
                        countCat += 1;
                    }
                }
                //if it is in mix mode then set the flag for requiredAutoNumericLabels
                if (xAxisLabelMode === 'mixed') {
                    // Fix for hide the min and max for the xAxis of the CandleStick Chart
                    xAxisConf.requiredAutoNumericLabels = pluckNumber(this.requiredAutoNumericLabels, 1);
                }
            }
            else {
                // Fix for hide the min and max for the xAxis of the CandleStick Chart
                xAxisConf.requiredAutoNumericLabels = pluckNumber(this.requiredAutoNumericLabels, 1);
            }
            xAxisConf.adjustMinMax = true;
        },

        // Function that produce the point color
        getPointColor : function (color, alpha) {
            var colorObj, innerColor, outerColor;
            color = getFirstColor(color);
            alpha = getFirstAlpha(alpha);
            innerColor = getLightColor(color, 70);
            outerColor = getDarkColor(color, 50);
            colorObj = {
                FCcolor : {
                    gradientUnits : 'objectBoundingBox',
                    cx: 0.4,
                    cy: 0.4,
                    r: '100%',
                    color :  innerColor + COMMASTRING + outerColor,
                    alpha : alpha + COMMASTRING + alpha,
                    ratio : BGRATIOSTRING,
                    radialGradient : true
                }
            };

            return colorObj;
        }
    }, chartAPI.xybase);

    /////// mscombi2d ///////
    chartAPI('mscombibase', {
        canvasPaddingModifiers: ['anchor', 'anchorlabel'],
        series : function (FCObj, HCObj, chartName) {
            var seriesIndex, length, dataset, catLength, FCChartObj = FCObj.chart,
            series, lineArr = [], columnArr = [], areaArr = [],
            isSY, renderAs,
            conf = HCObj[FC_CONFIG_STRING],
            isDual = this.isDual,
            columnPosition = 0,
            i,
            ln,
            seriesFilterStatus;

            //enable the legend
            HCObj.legend.enabled = Boolean(pluckNumber(FCObj.chart.showlegend, 1));

            if (FCObj.dataset && FCObj.dataset.length > 0) {
                // add category
                this.categoryAdder(FCObj, HCObj);
                catLength = conf.oriCatTmp.length;
                //add data series
                for (seriesIndex = 0, length = FCObj.dataset.length;
                seriesIndex < length; seriesIndex += 1) {
                    dataset = FCObj.dataset[seriesIndex];
                    isSY = isDual && pluck(dataset.parentyaxis, 'p')
                        .toLowerCase() === 's' ? true : false;
                    series = {
                        hoverEffects: this.parseSeriesHoverOptions(FCObj, HCObj, dataset, chartName),
                        visible: !pluckNumber(dataset.initiallyhidden, 0),
                        legendIndex: seriesIndex,
                        data : []
                    };
                    if (isSY) {
                        series.yAxis = 1;
                        renderAs = getFirstValue(dataset.renderas,
                            this.secondarySeriesType);
                        if (this.secondarySeriesFilter) {
                            seriesFilterStatus = this.secondarySeriesFilter[renderAs];
                        }
                    }
                    else {
                        renderAs = getFirstValue(dataset.renderas,
                            this.defaultSeriesType);
                        if (this.defaultSeriesFilter) {
                            seriesFilterStatus = this.defaultSeriesFilter[renderAs];
                        }
                    }
                    renderAs = renderAs.toLowerCase();

                    switch(renderAs){
                        case 'line':
                        case 'spline':
                            series.type = (seriesFilterStatus === true) ?
                                renderAs : 'line';
                            lineArr.push(chartAPI.mslinebase.point.call(this,
                                chartName, series, dataset,
                                FCChartObj, HCObj, catLength, seriesIndex));
                            break;
                        case 'area':
                        case 'splinearea':
                            series.type = (seriesFilterStatus === true) ?
                                renderAs : 'area';
                            //if there has any area chart then set series2D3Dshift as true
                            HCObj.chart.series2D3Dshift = true;
                            areaArr.push(chartAPI.msareabase.point.call(this,
                                chartName, series, dataset,
                                FCChartObj, HCObj, catLength, seriesIndex));
                            break;
                        case 'column':
                        case 'column3d':
                            columnArr.push(chartAPI.mscolumn2dbase.point.call(this,
                                chartName, series, FCObj.dataset[seriesIndex],
                                FCChartObj, HCObj, catLength, seriesIndex,
                                undefined, columnPosition));
                            columnPosition += 1;
                            break;
                        default:
                            if (isSY) {
                                series.type = 'line';
                                lineArr.push(chartAPI.mslinebase.point.call(this,
                                    chartName, series, dataset,
                                    FCChartObj, HCObj, catLength, seriesIndex));
                            }
                            else {
                                columnArr.push(chartAPI.mscolumn2dbase.point.call(this,
                                    chartName, series, FCObj.dataset[seriesIndex],
                                    FCChartObj, HCObj, catLength, seriesIndex,
                                    undefined, columnPosition));
                                columnPosition += 1;
                            }
                    }
                }

                //push the data at the series array
                /** @todo find the index of render as */
                if (FCChartObj.areaovercolumns !== '0') {
                    HCObj.chart.areaOverColumns = true;
                    HCObj.series = HCObj.series.concat(columnArr, areaArr, lineArr);
                }
                else {
                    HCObj.chart.areaOverColumns = false;
                    HCObj.series = HCObj.series.concat(areaArr, columnArr, lineArr);
                }
                if (columnArr.length === 0 && catLength !== 1) {
                    conf.hasNoColumn = true;
                }
                else if(!this.isStacked){
                    //add column count
                    for (i = 0, ln = columnArr.length;i < ln; i += 1 ) {
                        columnArr[i].numColumns = ln;
                    }
                }
                ///configure the axis
                this.configureAxis(HCObj, FCObj);
                ///////////Trend-lines /////////////////
                if (FCObj.trendlines) {
                    createTrendLine (FCObj.trendlines, HCObj.yAxis, HCObj[FC_CONFIG_STRING], isDual, this.isBar);
                }
            }
        }
    }, chartAPI.mscolumn2dbase);
}]);
/**
 * Red Raphael JavaScript Library
 * ------------------------------
 * Base common renderer that consumes Raphael for rendering the
 * visualization logic.
 * @private
 *
 * @module fusioncharts.renderer.javascript.visualizer
 * @requires fusioncharts.redraphael
 * @requires fusioncharts.redraphael.css
 * @requires fusioncharts.redraphael.export
 * @requires fusioncharts.redraphael.shadow
 * @requires fusioncharts.redraphael.shapes
 * @requires fusioncharts.redraphael.html
 * @requires fusioncharts.redraphael.tooltip
 * @requires fusioncharts.renderer.javascript.logic
 */
FusionCharts.register('module', ['private', 'modules.renderer.js-renderer',
    function () {

        var global = this,
            win = global.window,
            lib = global.hcLib,
            R = lib.Raphael,
            renderer = lib.chartAPI,
            rendererRoot,
            userAgent = win.navigator.userAgent,
            isIE = /msie/i.test(userAgent) && !win.opera,
            doc = win.document,
            Image = win.Image,
            isVML = (R.type === 'VML'),
            BLANK = lib.BLANKSTRING,
            COMMA = ',',
            PNG = 'png',
            SVG = 'svg',
            INPUT = 'input',
            FORM = 'form',
            DOWNLOAD = 'download',
            HIDDEN = 'hidden',
            POST = 'POST',
            CRISP = 'crisp',
            BEFOREPRINT = 'BeforePrint',
            PRINTCANCELLED = 'PrintCancelled',
            PRINTCOMPLETE = 'PrintComplete',
            LOGOROLLOUT = 'LogoRollout',
            LOGOROLLOVER = 'LogoRollover',
            LOGOCLICK = 'LogoClick',
            LOGOLOADED = 'LogoLoaded',
            LOGOLOADERROR = 'LogoLoadError',
            BACKGROUNDLOADED = 'BackgroundLoaded',
            BACKGROUNDLOADERROR = 'BackgroundLoadError',
            LEGENDITEMROLLOVER = 'LegendItemRollover',
            LEGENDITEMROLLOUT = 'LegendItemRollout',
            LEGENDITEMCLICKED = 'LegendItemClicked',
            TRACKER_FILL = 'rgba(192,192,192,' + (isIE ? 0.002 : 0.000001) + ')', // invisible but clickable,
            TOUCH_THRESHOLD_PIXELS = lib.TOUCH_THRESHOLD_PIXELS,
            CLICK_THRESHOLD_PIXELS = lib.CLICK_THRESHOLD_PIXELS,
            NONE = 'none',
            TL = 'tl',
            stubFN = lib.stubFN,
            stubEvent = {
                pageX: 0,
                pageY: 0
            },
            toFloat = parseFloat,
            toInt = parseInt,
            extend2 = lib.extend2,
            addEvent = lib.addEvent,
            getMouseCoordinate = lib.getMouseCoordinate,
            removeEvent = lib.removeEvent,
            pluck = lib.pluck,
            pluckNumber = lib.pluckNumber,
            toRaphaelColor = lib.toRaphaelColor,
            setImageDisplayMode = lib.setImageDisplayMode,
            CONFIGKEY = lib.FC_CONFIG_STRING,
            plotEventHandler = lib.plotEventHandler,
            ROLLOVER = 'DataPlotRollOver',
            ROLLOUT = 'DataPlotRollOut',
            rolloverAnimationDuration = 50,
            isArray = lib.isArray,

            each = lib.each = function (obj, fn, scope, data) {
                var i;

                if (!scope) {
                    scope = obj;
                }

                if (!data) {
                    data = {};
                }

                if (isArray(obj)) {
                    for (i = 0; i < obj.length; i += 1) {
                        if (fn.call(scope, obj[i], i, obj, data) === false) {
                            return i;
                        }
                    }
                } else if (!(obj === null || obj === undefined)) {
                    for (i in obj) {
                        if (fn.call(scope, obj[i], i, obj, data) === false) {
                            return i;
                        }
                    }
                }
            },

            createElement = lib.createElement,
            createContextMenu = lib.createContextMenu,
            hasTouch = lib.hasTouch,
            // hot/tracker threshold in pixels
            HTP = hasTouch ? TOUCH_THRESHOLD_PIXELS : CLICK_THRESHOLD_PIXELS,
            getSentenceCase = lib.getSentenceCase,
            getCrispValues = lib.getCrispValues,
            //add the tools thats are requared
            getValidValue = lib.getValidValue,
            getFirstValue = lib.getFirstValue,
            dropHash = lib.regex.dropHash,
            HASHSTRING = lib.HASHSTRING,
            defined = function (obj) {
                return obj !== UNDEFINED && obj !== null;
            },
            pInt = function (s, mag) {
                return parseInt(s, mag || 10);
            },
            isObject = function (obj) {
                return typeof obj === 'object';
            },
            isString = function (s) {
                return typeof s === 'string';
            },
            getCrispPath = function (path, width) {
                if (path[1] === path[4]) {
                    path[1] = path[4] = mathRound(path[1]) + (width % 2 / 2);
                }
                if (path[2] === path[5]) {
                    path[2] = path[5] = mathRound(path[2]) + (width % 2 / 2);
                }
                return path;
            },
            docMode8 = doc.documentMode === 8,
            UNDEFINED,
            VISIBLE = docMode8 ? 'visible' : '',
            M = 'M',
            L = 'L',
            V = 'V',
            H = 'H',
            Z = 'Z',
            math = win.Math,
            mathSin = math.sin,
            mathCos = math.cos,
            mathATan2 = math.atan2,
            mathRound = math.round,
            mathMin = math.min,
            mathMax = math.max,
            mathAbs = math.abs,
            mathPI = math.PI,
            mathCeil = math.ceil,
            mathFloor = math.floor,
            rad2deg = 180 / mathPI,
            pi = math.PI,
            piBy2 = pi / 2,
            pi2 = 2 * pi,
            pi3By2 = pi + piBy2,
            getFirstColor = lib.getFirstColor,
            getLightColor = lib.graphics.getLightColor,
            POSITION_TOP = lib.POSITION_TOP,
            POSITION_BOTTOM = lib.POSITION_BOTTOM,
            POSITION_RIGHT = lib.POSITION_RIGHT,
            POSITION_LEFT = lib.POSITION_LEFT,
            POSITION_MIDDLE = 'middle',
            POSITION_START = 'start',
            POSITION_END = 'end',
            MAX_MITER_LINEJOIN = 2,
            GUTTER_4 = 4,
            GUTTER_2 = 2;

        // Custom attribute to mark an element as tracker equivalent.
        R.ca.ishot = function (val) {
            if (this.removed) {
                return false;
            }
            var o = this,
                node = o.node,
                child;
            val = val || '';
            node.ishot = val;
            switch (o.type) {
            case 'group':
                child = o.bottom;
                while (child) {
                    child.attr('ishot', val);
                    child = child.next;
                }
                break;
            case 'text':
                if (R.svg) {
                    child = node.getElementsByTagName('tspan')[0];
                    while (child) {
                        child.ishot = val;
                        child = child.nextSibling;
                    }
                }
            }
            return false;
        };

        // Add custom symbol to Raphael
        R.addSymbol({
            printIcon: function (x, y, radius) {
                var r1 = radius * 0.75,
                    r2 = radius * 0.5,
                    r3 = radius * 0.33,
                    x1 = mathRound(x - radius) + 0.5,
                    y1 = mathRound(y - radius) + 0.5,
                    x2 = mathRound(x + radius) + 0.5,
                    y2 = mathRound(y + radius) + 0.5,
                    x3 = mathRound(x - r1) + 0.5,
                    y3 = mathRound(y - r1) + 0.5,
                    x4 = mathRound(x + r1) + 0.5,
                    y4 = mathRound(y + r2) + 0.5,
                    x5 = mathRound(x + r2) + 0.5,
                    y5 = mathRound(y + r3) + 0.5,
                    x6 = mathRound(x - r2) + 0.5,
                    y6 = mathRound(y + r3 + r3) + 0.5;
                return [
                    M, // the upper sheet
                    x3, y1,
                    L,
                    x4, y1,
                    x4, y3,
                    x3, y3,
                    'Z',
                    M, // the printer
                    x1, y3,
                    L,
                    x1, y4,
                    x3, y4,
                    x3, y,
                    x4, y,
                    x4, y4,
                    x2, y4,
                    x2, y3,
                    'Z',
                    M, // the lower sheet
                    x3, y,
                    L,
                    x3, y2,
                    x4, y2,
                    x4, y,
                    'Z',
                    M, //lower lines
                    x5, y5,
                    L,
                    x6, y5,
                    M,
                    x5, y6,
                    L,
                    x6, y6
                ];
            },
            exportIcon: function (x, y, radius) {
                var r1 = radius * 0.66,
                    r2 = r1 * 0.5,
                    x1 = mathRound(x - radius) + 0.5,
                    y1 = mathRound(y - radius) + 0.5,
                    x2 = mathRound(x + radius) + 0.5,
                    y2 = mathRound(y + radius) - 0.5,
                    x3 = mathRound(x - r2) + 0.5,
                    y3 = y < y2 - 3 ? y2 - 3 : mathRound(y) + 0.5,
                    x4 = mathRound(x + r2) - 0.5,
                    x5 = mathRound(x + r1) - 0.5,
                    x6 = mathRound(x - r1) + 0.5;
                return [
                    M, // the disk
                    x1, y3,
                    L,
                    x1, y2,
                    x2, y2,
                    x2, y3,
                    x2, y2,
                    x1, y2,
                    'Z',
                    M, // the arrow
                    x, y2 - 1,
                    L,
                    x6, y,
                    x3, y,
                    x3, y1,
                    x4, y1,
                    x4, y,
                    x5, y,
                    'Z'
                ];
            }
        });


        rendererRoot = lib.rendererRoot = renderer('renderer.root', {
            standaloneInit: false, // prevent being used as visualization logic
            isRenderer: true, // flag as compatible to be used as renderer

            inited: false,

            callbacks: [],

            init: function (logic, options, callback) {
                var chart = this,
                    container = chart.container = (logic && logic.containerElement) || options.chart.renderTo,
                    tooltip = options.tooltip,
                    paper,
                    layers = chart.layer,
                    desc,
                    chartOptions,
                    animationDuration;

                chart.options = options;
                chart.logic = logic;
                chart.definition = logic.dataObj;
                chart.smartLabel = logic.smartLabel;
                chart.numberFormatter = logic.numberFormatter;
                chart.fusionCharts = logic.chartInstance;
                chart.linkClickFN = logic.linkClickFN;

                animationDuration = (chartOptions = options.chart) && chartOptions.animation &&
                                    chartOptions.animation.duration;

                // Clear the previous animation complete queues of the chart to clear the animation
                // callbacks which might not have been executed
                chart.animationCompleteQueue = [];

                // Clear the container so that it only contains the SVG element
                container.innerHTML = BLANK;
                paper = chart.paper = chart.fusionCharts.jsVars.paper = new R(container,
                    container.offsetWidth || logic.width,
                    container.offsetHeight || logic.height);

                if (global.core.options._useSVGDescTag !== false && paper._desc) {
                    desc = (logic.friendlyName || 'Vector image');

                    if (chart.definition && chart.definition.chart) {
                        chart.definition.chart.caption && (desc += ' with caption \"' +
                            chart.definition.chart.caption + '\"');
                    }
                    paper._desc(desc);
                }

                chart.chartWidth = paper.width;
                chart.chartHeight = paper.height;

                if (!chart.elements) {
                    chart.elements = {};
                }
                if (!layers) {
                    layers = chart.layers = {};
                    layers.background = layers.background || paper.group('background');
                    layers.dataset = layers.dataset || paper.group('dataset')
                        .insertAfter(layers.background);
                    layers.tracker = layers.tracker || paper.group('hot')
                        .insertAfter(layers.dataset);
                }

                // set tooltip configurations
                if (tooltip && (tooltip.enabled !== false)) {
                    paper.tooltip(tooltip.style, tooltip.shadow, tooltip.constrain);
                    layers.tracker.trackTooltip(true);
                    layers.dataset.trackTooltip(true);
                }

                chart.disposeChartStyleSheet();

                chart.setMargins();
                chart.drawBackground();

                // add Buttons
                chart.drawButtons();

                chart.drawGraph();

                //draw the Legend
                if (options.legend && options.legend.enabled) {
                    chart.drawLegend();
                }

                chart.drawCaption();
                chart.drawLogo();

                // set clickURL and other events that happen globally.
                chart.setChartEvents();

                chart.drawLabels && chart.drawLabels();

                each(options.callbacks, function (fn) {
                    fn.apply(chart, this);
                }, [logic]);

                each(chart.callbacks, function (fn) {
                    fn.apply(chart, this);
                }, [logic]);

                if (chart.fusionCharts.annotations) {
                    chart.fusionCharts.annotations.draw(chart);
                }

                chart.createChartStyleSheet();


                // If there is no animation duration raise animation complete after render so that
                // annotations get applied.
                /**
                 * @todo fire internal.animationcomplete for all non catersian charts after animating
                 */
                if (!chart.options.nativeMessage && !animationDuration) {
                    global.raiseEvent('internal.animationComplete', {}, chart.fusionCharts);
                }

                chart.hasRendered = true;
                callback && callback(chart);
            },

            /** EXTERNAL STYLE SHEETS **/
            disposeChartStyleSheet: function () {
                var chart = this,
                    paper = chart.paper;

                paper.cssClear();
            },

            createChartStyleSheet: function () {
                var chart = this,
                    paper = chart.paper;

                paper.cssRender();
            },

            addCSSDefinition: function (rule, styleObj) {
                var chart = this,
                    paper = chart.paper;

                /**
                 * Handling cross browser quirks here.
                 */
                if (styleObj.color) {
                    styleObj.fill = styleObj.color;
                }

                paper.cssAddRule(rule, styleObj);
            },
            /**
             * A queue to maintain what all logic needs to be executed after the internal.animationComplete
             * event is fired.
             * Typically plot draw functions queue have logic to change the attributes of some elements
             * after the animation is complete.Each plot draw function queues a function to be executed
             * after the chart's animation complete event is fired.
             *
             * @example
             * chart.animationCompleteQueue.push({
             *   fn: function() {
             *     //Trnaform the attributes of the elements
             *   },
             *  scope: chart
             * });
             */
            /**
             * @todo: ideally the functions in the animationComplete queue should be closure free
             *  and all the variables should be evaluated from scope and arguments, currently the function
             *  variables are evaluated through closures
             */
            animationCompleteQueue: [],

            // This function gets executed after animation complete of an element.
            // Also increases the count of animated elements count and raises an internal event
            // animationcomplete if every element in the chart finished animating
            animationComplete: function () {
                var chart = this,
                    i,
                    ii,
                    queue,
                    animationCallback;
                chart.animatedElements = chart.animatedElements ? ++chart.animatedElements : 1;

                if (chart.animatedElements === chart.animatingElementsCount) {
                    queue = chart.animationCompleteQueue;

                    for (i = 0, ii = queue.length; i < ii; i++) {
                        animationCallback = queue[i];
                        animationCallback.fn && animationCallback.fn.call(animationCallback.scope);

                        // clear the animationCallback
                        animationCallback = undefined;
                    }

                    // Clear the animationCompleteQueue
                    chart.animationCompleteQueue = [];

                    global.raiseEvent('internal.animationComplete', {}, chart.fusionCharts);
                }
            },
            /*
                This function returns a callback function which needs to be executed after each
                animating element in a chart finishes animating.

                It increments the count of animating elements in the chart, which will be used to
                finally decide if all the elements in the chart finished animating

            */
            getAnimationCompleteFn: function () {
                var chart = this;

                chart.animatingElementsCount = chart.animatingElementsCount ? ++chart.animatingElementsCount : 1;

                return function () {
                    chart.animationComplete();
                };
            },
            /** EXTERNAL STYLE SHEETS **/

            reinit: function (logic, options, callback) {
                var chart = this;

                if (!chart.hasRendered) {
                    chart.init(options, callback);
                }
            },

            dispose: function () {
                var chart = this,
                    listeners = chart.eventListeners,
                    ii = listeners && listeners.length,
                    item;

                chart.disposing = true;

                // remove all the listeners that have been stored for removal during dispose.
                if (ii) {
                    while (ii--) {
                        listeners[ii].unlisten();
                    }
                    // clear the array storing the listener objects
                    listeners = [];
                }

                // remove all items from the toolbar array to avoid memory leak
                if (chart.toolbar && chart.toolbar.length) {
                    while (chart.toolbar.length) {
                        item = chart.toolbar.pop();
                        item.remove();
                    }
                    chart.toolbar.add = null;
                }

                // remove all menu items to clean up memory
                if (chart.menus && chart.menus.length) {
                    while (chart.menus.length) {
                        item = chart.menus.pop();
                        item.destroy();
                    }
                }

                if (chart.paper) {
                    chart.paper.clear();
                    chart.paper.remove();
                    delete chart.paper;
                }
                if (chart.exportIframe) {
                    chart.exportIframe.parentNode.removeChild(chart.exportIframe);
                    delete chart.exportIframe;
                }

                delete chart.disposing;
                chart.container = null;
                chart.disposed = true;
            },

            onContainerClick: function (e) {
                var tgt = e.target || e.originalTarget || e.srcElement ||
                    e.relatedTarget || e.fromElement,
                    chart = e.data,
                    fusionCharts = chart.fusionCharts,
                    oriEvent = e.originalEvent,
                    coordinate = lib.getMouseCoordinate(chart.container, oriEvent),
                    args;

                if (!fusionCharts.ref) {
                    return;
                }

                args = extend2({
                    height: fusionCharts.args.height,
                    width: fusionCharts.args.width,
                    pixelHeight: fusionCharts.ref.offsetHeight,
                    pixelWidth: fusionCharts.ref.offsetWidth,
                    id: fusionCharts.args.id,
                    renderer: fusionCharts.args.renderer,
                    container: fusionCharts.options.containerElement
                }, coordinate);

                /**
                 * This event is fired when the chart is clicked. For touch devices, this event is fired when user
                 * taps on the chart.
                 *
                 * This event provides useful information on the position of mouse relative to the chart and the page.
                 * This can be used to position things like annotations based on where the chart is clicked.
                 *
                 * @see FusionCharts#event:chartRollOver
                 * @see FusionCharts#event:chartRollOut
                 * @see FusionCharts#event:chartMouseMove
                 *
                 * @event FusionCharts#chartClick
                 * @since 3.4.0
                 * @group chart
                 *
                 * @param {string} container - The DOM element within which the chart has been rendered.
                 * @param {string} id - The `id` of the chart that has triggered this event.
                 *
                 * @param {string} height - The height of the chart specified at the time of rendering the chart in
                 * pixels or percent.
                 * @param {string} width - The width of the chart specified at the time of rendering the chart in pixels
                 * or percent.
                 *
                 * @param {number} chartX - The x-coordinate of the mouse relative to the position of the chart.
                 * @param {number} chartY - The y-coordinate of the mouse relative to the position of the chart.
                 *
                 * @param {number} pageX - The x-coordinate of the mouse relative to the document.
                 * @param {number} pageY - The y-coordinate of the mouse relative to the document.
                 *
                 * @param {number} pixelHeight - The height of the chart in pixels. This is equivalent to the
                 * `offsetHeight` of the chart container.
                 * @param {number} pixelWidth - The width of the chart in pixels. This is equivalent to the
                 * `offsetWidth` of the chart container.
                 *
                 * @example
                 * FusionCharts.ready(function () {
                 *     var chart = new FusionCharts({
                 *         type: 'column2d',
                 *         dataFormat: 'jsonurl',
                 *         dataSource: 'chart-data.json',
                 *         renderAt: 'chart-container-div',
                 *
                 *         events: {
                 *             chartClick: function (eventObj, argsObj) {
                 *                 console.log('Chart clicked at ' + argsObj.chartX + ',' + argsObj.chartY);
                 *             }
                 *         }
                 *     });
                 *
                 *     chart.render();
                 * });
                 */
                global.raiseEvent('chartclick', args, chart.logic.chartInstance);

                // do not receive event if the clicked target element is marked as
                // hot
                if (tgt && tgt.ishot && chart) {
                    return;
                }

                chart.options.chart.link && chart.linkClickFN.call(chart, chart);
            },

            onContainerMouseMove: function (e) {
                var chart = e.data,
                    fusionCharts = chart.fusionCharts,
                    oriEvent = e.originalEvent,
                    coordinate = lib.getMouseCoordinate(chart.container, oriEvent),
                    args;

                if (!fusionCharts.ref) {
                    return;
                }

                args = extend2({
                    height: fusionCharts.args.height,
                    width: fusionCharts.args.width,
                    pixelHeight: fusionCharts.ref.offsetHeight,
                    pixelWidth: fusionCharts.ref.offsetWidth,
                    id: fusionCharts.args.id,
                    renderer: fusionCharts.args.renderer,
                    container: fusionCharts.options.containerElement
                }, coordinate);

                /**
                 * This event is triggered whenever user moves the mouse pointer over a chart. The event
                 * arguments pass useful information such as the pointer location relative to both chart and the page,
                 * which can be utilised to perform various actions on the chart such as position an annotation or
                 * integrate charts with custom tooltip libraries.
                 *
                 * > This event is not fired by default and needs to be enabled for individual charts by setting the
                 * > value of chart attribute `enableChartMouseMoveEvent` to `1`.
                 *
                 * @see FusionCharts#event:chartRollOver
                 * @see FusionCharts#event:chartRollOut
                 * @see FusionCharts#event:chartClick
                 * @event FusionCharts#chartMouseMove
                 * @since  3.4.0
                 * @group chart
                 *
                 * @param {string} container - The DOM element within which the chart has been rendered.
                 * @param {string} id - The `id` of the chart that has triggered this event.
                 *
                 * @param {string} height - The height of the chart specified at the time of rendering the chart in
                 * pixels or percent.
                 * @param {string} width - The width of the chart specified at the time of rendering the chart in pixels
                 * or percent.
                 *
                 * @param {number} chartX - The x-coordinate of the mouse relative to the position of the chart.
                 * @param {number} chartY - The y-coordinate of the mouse relative to the position of the chart.
                 *
                 * @param {number} pageX - The x-coordinate of the mouse relative to the document.
                 * @param {number} pageY - The y-coordinate of the mouse relative to the document.
                 *
                 * @param {number} pixelHeight - The height of the chart in pixels. This is equivalent to the
                 * `offsetHeight` of the chart container
                 * @param {number} pixelWidth - The width of the chart in pixels. This is equivalent to the
                 * `offsetWidth` of the chart container
                 */
                global.raiseEvent('chartMouseMove', args, chart.logic.chartInstance);
            },

            onContainerRollOver: function (e) {
                var chart = e.data,
                    fusionCharts = chart.fusionCharts,
                    oriEvent = e.originalEvent,
                    coordinate = lib.getMouseCoordinate(chart.container, oriEvent),
                    args;

                if (!fusionCharts.ref) {
                    return;
                }

                args = extend2({
                    height: fusionCharts.args.height,
                    width: fusionCharts.args.width,
                    pixelHeight: fusionCharts.ref.offsetHeight,
                    pixelWidth: fusionCharts.ref.offsetWidth,
                    id: fusionCharts.args.id,
                    renderer: fusionCharts.args.renderer,
                    container: fusionCharts.options.containerElement
                }, coordinate);

                /**
                 * This event is fired when the mouse pointer moves over the chart. For touch devices,
                 * this event is raised when user taps on to the chart after previously tapping onto anywhere outside
                 * the chart.
                 *
                 * One can listen to this event and track when user is pointing to a chart and perform relevant actions
                 * such as highlighting information anywhere else on the page that is relevant to the chart.
                 * @see FusionCharts#event:chartRollOut
                 * @see FusionCharts#event:chartClick
                 * @see FusionCharts#event:chartMouseMove
                 * @event FusionCharts#chartRollOver
                 * @since 3.4.0
                 * @group chart
                 *
                 * @param {string} container - The DOM element within which the chart has been rendered.
                 * @param {string} id - The `id` of the chart that has triggered this event.
                 *
                 * @param {string} height - The height of the chart specified at the time of rendering the chart in
                 * pixels or percent.
                 * @param {string} width - The width of the chart specified at the time of rendering the chart in pixels
                 * or percent.
                 *
                 * @param {number} chartX - The x-coordinate of the mouse relative to the position of the chart.
                 * @param {number} chartY - The y-coordinate of the mouse relative to the position of the chart.
                 *
                 * @param {number} pageX - The x-coordinate of the mouse relative to the document.
                 * @param {number} pageY - The y-coordinate of the mouse relative to the document.
                 *
                 * @param {number} pixelHeight - The height of the chart in pixels. This is equivalent to the
                 * `offsetHeight` of the chart container
                 * @param {number} pixelWidth - The width of the chart in pixels. This is equivalent to the
                 * `offsetWidth` of the chart container
                 *
                 * @example
                 * // Create a chart and display the caption of the chart over which the mouse has been hovered. The
                 * // event is attached to the FusionCharts global `addEventListener` function so that it is fired for
                 * // all charts rendered on that page Once this event listener has been attached, any chart rendered on
                 * // page will cause a console log when hovered or tapped.
                 * FusionCharts.addEventListener('chartRollOver', function (event) {
                 *     var chart = event.sender, // access the chart that raised this event
                 *         caption = chart && chart.getChartAttribute('caption'); // get the chart caption
                 *
                 *     // Output the caption in JavaScript console
                 *     console.log('Mouse entered on the chart with caption: ' + caption);
                 * });
                 */
                global.raiseEvent('chartRollOver', args, chart.logic.chartInstance);
            },

            onContainerRollOut: function (e) {
                var chart = e.chart,
                    fusionCharts = chart.fusionCharts,
                    oriEvent = e.event,
                    coordinate = lib.getMouseCoordinate(chart.container, oriEvent),
                    args;

                if (!fusionCharts.ref) {
                    return;
                }

                args = extend2({
                    height: fusionCharts.args.height,
                    width: fusionCharts.args.width,
                    pixelHeight: fusionCharts.ref.offsetHeight,
                    pixelWidth: fusionCharts.ref.offsetWidth,
                    id: fusionCharts.args.id,
                    renderer: fusionCharts.args.renderer,
                    container: fusionCharts.options.containerElement
                }, coordinate);

                /**
                 * This event is fired when the mouse pointer moves out of the chart. For touch devices,
                 * this event is raised when user taps on to anywhere outside the chart after previously tapping on the
                 * chart.
                 *
                 * One can listen to this event and track when user is no longer pointing to a particular chart.
                 * @see FusionCharts#event:chartRollOver
                 * @see FusionCharts#event:chartClick
                 * @see FusionCharts#event:chartMouseMove
                 * @event FusionCharts#chartRollOut
                 * @since 3.4.0
                 * @group chart
                 *
                 * @param {string} container - The DOM element within which the chart has been rendered.
                 * @param {string} id - The `id` of the chart that has triggered this event.
                 *
                 * @param {string} height - The height of the chart specified at the time of rendering the chart in
                 * pixels or percent.
                 * @param {string} width - The width of the chart specified at the time of rendering the chart in pixels
                 * or percent.
                 *
                 * @param {number} chartX - The x-coordinate of the mouse relative to the position of the chart.
                 * @param {number} chartY - The y-coordinate of the mouse relative to the position of the chart.
                 *
                 * @param {number} pageX - The x-coordinate of the mouse relative to the document.
                 * @param {number} pageY - The y-coordinate of the mouse relative to the document.
                 *
                 * @param {number} pixelHeight - The height of the chart in pixels. This is equivalent to the
                 * `offsetHeight` of the chart container
                 * @param {number} pixelWidth - The width of the chart in pixels. This is equivalent to the
                 * `offsetWidth` of the chart container
                 *
                 * @example
                 * // Create a chart and display the caption of the chart over which the mouse has been hovered. The
                 * // event is attached to the FusionCharts global `addEventListener` function so that it is fired for
                 * // all charts rendered on that page Once this event listener has been attached, any chart rendered on
                 * // page will cause a console log when hovered out or tapped away.
                 * FusionCharts.addEventListener('chartRollOut', function (event) {
                 *     var chart = event.sender, // access the chart that raised this event
                 *         caption = chart && chart.getChartAttribute('caption'); // get the chart caption
                 *
                 *     // Output the caption in JavaScript console
                 *     console.log('Mouse left the chart with caption: ' + caption);
                 * });
                 */
                global.raiseEvent('chartRollOut', args, chart.logic.chartInstance);
            },

            mouseStateIn: false,

            winMouseHover: function (e) {
                var event = e.originalEvent,
                    tgt = event.target || event.originalTarget || event.srcElement ||
                        event.relatedTarget || event.fromElement,
                    chart = e.data,
                    paper = chart.paper,
                    eve = {
                        chart: chart,
                        event: e.originalEvent
                    };

                // On mouse rollout of the chart, detach window mouseover event
                if (isVML) {
                    if (!paper.getById(tgt.parentNode.raphaelid)) {
                        chart.onContainerRollOut(eve);
                        chart.mouseStateIn = false;
                        removeEvent(doc, 'mouseover', chart.winMouseHover);
                    }
                } else {
                    if (!tgt.viewportElement) {
                        chart.mouseStateIn = false;
                        chart.onContainerRollOut(eve);
                        removeEvent(win, 'mouseover', chart.winMouseHover);
                    }
                }
            },

            chartHoverManager: (function () {

                return function (e) {
                    var type = e.type,
                        chart = e.data,
                        listeners = chart.eventListeners || (chart.eventListeners = []);
                    // rollover
                    if ((type === 'mouseover' || type === 'touchstart') && chart.mouseStateIn === false) {
                        chart.mouseStateIn = true;
                        chart.onContainerRollOver(e);
                        // On mouse rollover on the chart, attach window mouseover event
                        listeners.push(addEvent(isVML ? doc : win, 'mouseover', chart.winMouseHover, chart));
                    }
                };
            })(),

            setChartEvents: function () {
                var chart = this,
                    options = chart.options,
                    listeners = chart.eventListeners || (chart.eventListeners = []),
                    // store the link in chart
                    link = chart.link = options.chart.link,
                    container = chart.container,
                    // EnableChartMouseMoveEvent attribute to enable chartMouseMove event
                    enableMouseMove = pluckNumber(chart.definition &&
                        chart.definition.chart.enablechartmousemoveevent, 0);

                // In case link is not defined, but chart has a previously attached
                // link, then we remove the same from container and from chart.
                removeEvent(container, 'click', chart.onContainerClick);

                // Check if link has been defined or not. If defined, then append
                // the click event to the chart container and pass on the relevant
                // information as event data
                listeners.push(addEvent(container, 'click', chart.onContainerClick, chart));

                // Remove mouseover, touchstart, mouseout or touchend events if attached previously
                removeEvent(chart.paper.canvas, 'mouseover',
                    chart.chartHoverManager, chart);
                removeEvent(chart.paper.canvas, 'touchstart',
                    chart.chartHoverManager, chart);
                removeEvent(chart.paper.canvas, 'mouseout',
                    chart.chartHoverManager, chart);
                removeEvent(chart.paper.canvas, 'touchend',
                    chart.chartHoverManager, chart);

                // Attach mouseover, touchstart, mouseout or touchend events.
                listeners.push(addEvent(chart.paper.canvas, 'mouseover touchstart mouseout touchend',
                    chart.chartHoverManager, chart));

                // Remove mousemove and touchmove events if previously attached.
                removeEvent(container, 'mousemove', chart.onContainerMouseMove, chart);
                removeEvent(container, 'touchmove', chart.onContainerMouseMove, chart);

                if (enableMouseMove) {
                    // Attach mousemove and touchmove events.
                    listeners.push(addEvent(container, 'mousemove touchmove', chart.onContainerMouseMove, chart));
                }

                // Set the cursor based on the presense of link. Note that IE and
                // other browsers have separate css value.
                if (R.svg) {
                    chart.paper.canvas.style.cursor = link && 'pointer' || 'default';
                } else {
                    chart.paper.canvas.style.cursor = link && 'hand' || 'default';
                }
            },

            onOverlayMessageClick: function () {
                var chart = this,
                    elements = chart.elements;
                R.animation({
                    opacity: 0
                }, 1000);

                elements.messageText && elements.messageText.hide();
                elements.messageVeil && elements.messageVeil.hide();
            },

            showMessage: function (msg, cancelable) {
                var chart = this,
                    paper = chart.paper,
                    options = chart.options,
                    optionsChart = options.chart,
                    elements = chart.elements,
                    messageText = elements.messageText,
                    messageVeil = elements.messageVeil,
                    w = paper.width,
                    h = paper.height,
                    text;

                // create the layer at the first call
                if (!messageVeil) {
                    messageVeil = elements.messageVeil = paper.rect(0, 0, w, h).attr({
                        fill: 'rgba(0,0,0,0.2)',
                        stroke: 'none'
                    });
                }
                messageVeil.show().toFront()
                    .attr('cursor', cancelable ? 'pointer' : 'default')[cancelable ?
                        'click' : 'unclick'](chart.onOverlayMessageClick, chart);

                if (!messageText) {
                    messageText = elements.messageText = paper.text(w / 2, h / 2, BLANK).attr({
                        fill: 'rgba(255,255,255,1)',
                        'font-family': 'Verdana,sans',
                        'font-size': 10,
                        'line-height': 14,
                        ishot: true
                    });
                }

                msg = msg || BLANK;
                chart.smartLabel.setStyle({
                    'line-height': '14px',
                    'font-family': 'Verdana,sans',
                    'font-size': '10px'
                });

                text = chart.smartLabel.getSmartText(msg, w -
                    (optionsChart.spacingRight || 0) - (optionsChart.spacingLeft || 0), h -
                    (optionsChart.spacingTop || 0) - (optionsChart.spacingBotton || 0));

                messageText.attr({
                    text: text.text,
                    ishot: true,
                    cursor: cancelable ? 'pointer' : 'default'
                })[cancelable ? 'click' : 'unclick'](chart.onOverlayMessageClick, chart)
                    .show().toFront();
            },

            // draws export and print buttons
            drawButtons: function () {

                var chart = this,
                    logic = chart.logic,
                    isZoomLine = logic.rendererId === 'zoomline',
                    paper = chart.paper,
                    elements = chart.elements,
                    toolbar = chart.toolbar || (chart.toolbar = []),
                    menus = chart.menus || (chart.menus = []),
                    layers = chart.layers,
                    options = chart.options,
                    conf = options[CONFIGKEY],
                    outCanvasStyle = conf && conf.outCanvasStyle || logic.outCanvasStyle || {},
                    chartOptions = options.chart,
                    toolbarOptions = chartOptions.toolbar || {},
                    hDirection = toolbarOptions.hDirection,
                    vDirection = isZoomLine ? 1 : toolbarOptions.vDirection,
                    button = toolbarOptions.button || {},
                    scale = button.scale,
                    width = button.width * button.scale,
                    height = button.height * button.scale,
                    spacing = hDirection * (button.spacing * button.scale + width),
                    radius = button.radius,
                    x,
                    y,
                    exportOptions = options.exporting,
                    buttonConfig = exportOptions && exportOptions.buttons || {},
                    isExportButton = buttonConfig.exportButton && buttonConfig.exportButton.enabled !== false,
                    isPrintButton = buttonConfig.printButton && buttonConfig.printButton.enabled !== false,
                    exportContextMenu,
                    buttonsLayer = layers.buttons || (layers.buttons = paper.group('buttons').trackTooltip(true));

                y = toolbar.y ||
                    (toolbar.y = (isZoomLine ? 0 : toolbarOptions.y) + toolbarOptions.vMargin * vDirection +
                    mathMin(0, height * vDirection));
                x = toolbar.x || (toolbar.x = toolbarOptions.x + toolbarOptions.hMargin * hDirection -
                    mathMax(0, width * hDirection));
                toolbar.count = 0;

                toolbar.add = function (symbol, callback, options) {
                    var buttonElem,
                        opt = isString(options) ? {
                            tooltip: options
                        } : options || {},
                        offsetX = toolbar.count === 0 ? spacing - hDirection * button.spacing * button.scale : spacing,
                        x = opt.x || (toolbar.x += offsetX),
                        y = opt.y || toolbar.y,
                        tooltip = opt.tooltip || '';

                    toolbar.push(buttonElem = paper.button(x, y, UNDEFINED, symbol, {
                            width: width,
                            height: height,
                            r: radius,
                            id: toolbar.count++,
                            verticalPadding: button.symbolHPadding * scale,
                            horizontalPadding: button.symbolHPadding
                        }, buttonsLayer)
                        .attr({
                            'ishot': true,
                            fill: [button.fill, button.labelFill,
                                button.symbolFill, button.hoverFill
                            ],
                            stroke: [button.stroke, button.symbolStroke],
                            'stroke-width': [button.strokeWidth,
                                button.symbolStrokeWidth
                            ]
                        })
                        .tooltip(tooltip)
                        .buttonclick(callback)
                    );
                    return buttonElem;
                };

                if (isExportButton) {
                    menus.push(exportContextMenu = elements.exportMenu = createContextMenu({
                        chart: chart,
                        basicStyle: outCanvasStyle,
                        items: (function (formats) {
                            var ret = [],
                                responseSetter = function (format) {
                                    return function () {
                                        chart.logic.chartInstance.exportChart({
                                            exportFormat: format
                                        });
                                    };
                                },
                                i;
                            for (i in formats) {
                                ret.push({
                                    text: formats[i],
                                    onclick: responseSetter(i)
                                });
                            }
                            return ret;
                        }(exportOptions.exportformats))
                    }));

                    elements.exportButton = toolbar.add('exportIcon', (function (x, y) {
                        return function () {
                            if (exportContextMenu.visible) {
                                exportContextMenu.hide();
                                return;
                            }
                            exportContextMenu.show({
                                x: x,
                                y: y + 1
                            });
                        };
                    }(toolbar.x + width, toolbar.y + height)), {
                        tooltip: 'Export chart'
                    });
                }

                if (isPrintButton) {
                    elements.printButton = toolbar.add('printIcon', function () {
                        chart.print();
                    }, {
                        tooltip: 'Print chart'
                    });
                }
            },

            setMargins: function () {
                var chart = this,
                    paper = chart.paper,
                    options = chart.options,
                    chartOptions = options.chart || {},
                    round = mathRound;

                chart.canvasBorderWidth = chartOptions.plotBorderWidth || 0;

                chart.canvasTop = round(chartOptions.marginTop) || 0;
                chart.canvasLeft = round(chartOptions.marginLeft) || 0;
                chart.canvasWidth = round(paper.width - (chartOptions.marginLeft || 0) -
                    (chartOptions.marginRight || 0));
                chart.canvasHeight = round(paper.height - (chartOptions.marginTop || 0) -
                    (chartOptions.marginBottom || 0));
                chart.canvasRight = chart.canvasLeft + chart.canvasWidth;
                chart.canvasBottom = chart.canvasTop + chart.canvasHeight;
            },

            drawBackground: function () {
                var chart = this,
                    paper = chart.paper,
                    layers = chart.layers,
                    elements = chart.elements,
                    group = layers.background,
                    background = elements.background,
                    border = elements.chartborder,
                    options = chart.options,
                    chartOptions = options.chart || {},
                    sw = toFloat(chartOptions.borderWidth) || 0,
                    ssw = sw * 0.5,
                    dsw = sw * 2,
                    chartBorderWidth = chartOptions.borderWidth || 0,
                    chartHeight = chart.chartHeight,
                    chartWidth = chart.chartWidth,
                    chartBGImage = elements.backgroundImage,
                    bgSWF = chartOptions.bgSWF,
                    bgSWFAlpha = chartOptions.bgSWFAlpha / 100,
                    bgImageDisplayMode = chartOptions.bgImageDisplayMode,
                    bgImageVAlign = chartOptions.bgImageVAlign,
                    bgImageHAlign = chartOptions.bgImageHAlign,
                    bgImageScale = chartOptions.bgImageScale,
                    imgClipRect = chartBorderWidth + COMMA + chartBorderWidth + COMMA +
                        (chartWidth - chartBorderWidth * 2) + COMMA + (chartHeight - chartBorderWidth * 2),
                    referenceImage,
                    bgImageAttr,
                    xRepeatCount,
                    imageElement,
                    yRepeatCount,
                    yCount,
                    counter,
                    attrObj,
                    imgY;

                // Apply the container's bg color to SVG element. That will ensure
                // we do not have bleeding background-color due to CTM fixes done
                // to rendering.
                paper.canvas.style.backgroundColor = chartOptions.containerBackgroundColor;

                // Create a border and background group
                !group && (group = (layers.background = paper.group('background')));

                // Note that background and border are two separate elements to allow stroke to be fully within the
                // chart area

                // Prepare properties for background and apply them.
                attrObj = {
                    x: sw,
                    y: sw,
                    width: (paper.width - dsw),
                    height: (paper.height - dsw),
                    stroke: NONE,
                    fill: toRaphaelColor(chartOptions.backgroundColor)
                };

                if (!background) {
                    background = (elements.background = paper.rect(attrObj, group));
                }
                else {
                    background.attr(attrObj);
                }

                // Prepare properties for border and apply them.
                attrObj = {
                    x: ssw,
                    y: ssw,
                    width: (paper.width - sw),
                    height: (paper.height - sw),
                    stroke: chartOptions.borderColor,
                    'stroke-width': sw,
                    'stroke-dasharray': chartOptions.borderDashStyle,
                    fill: NONE,
                    r: chartOptions.borderRadius || 0
                };

                if (!border) {
                    border = (elements.chartborder = paper.rect(attrObj, group));
                }
                else {
                    border.attr(attrObj);
                }

                if (bgSWF) {
                    referenceImage = new Image();
                    xRepeatCount = 1;
                    yRepeatCount = 1;

                    //create the blank array as onload may called after the
                    //chart._chartBGImage reference passed
                    chartBGImage = [];

                    referenceImage.onload = function () {
                        bgImageAttr = setImageDisplayMode(bgImageDisplayMode,
                            bgImageVAlign, bgImageHAlign, bgImageScale,
                            chartBorderWidth, chartWidth, chartHeight,
                            referenceImage);
                        bgImageAttr['clip-rect'] = imgClipRect;
                        if (bgImageAttr.tileInfo) {
                            xRepeatCount = bgImageAttr.tileInfo.xCount;
                            yRepeatCount = yCount = bgImageAttr.tileInfo.yCount;
                            imgY = bgImageAttr.y;

                            delete bgImageAttr.tileInfo;

                            while (xRepeatCount && bgImageAttr.width && bgImageAttr.height) {
                                yCount -= 1;
                                //Use the renderer ref from chartBGImageGroup
                                //as in case of realtime chart the renderer may be
                                // destroyed before onload
                                if (!imageElement) {
                                    chartBGImage[counter] = imageElement = paper.image(bgSWF, group)
                                        .attr(bgImageAttr)
                                        .css({
                                            opacity: bgSWFAlpha
                                        });
                                } else {
                                    chartBGImage[counter] = imageElement.clone()
                                        .attr({
                                            x: bgImageAttr.x,
                                            y: bgImageAttr.y
                                        });
                                    group.appendChild(chartBGImage[counter]);
                                }

                                bgImageAttr.y += bgImageAttr.height;
                                if (yCount === 0) {
                                    yCount = yRepeatCount;
                                    xRepeatCount -= 1;
                                    bgImageAttr.x += bgImageAttr.width;
                                    bgImageAttr.y = imgY;
                                }
                            }

                        } else {
                            chartBGImage[0] = paper.image(bgSWF, group);
                            chartBGImage[0].attr(bgImageAttr)
                                .css({
                                    opacity: bgSWFAlpha
                                })
                                .attr({
                                    visibility: VISIBLE,
                                    'clip-rect': imgClipRect
                                });
                        }

                        /**
                         * This event is fired for external background image for a chart has loaded succesfully. These
                         * background images are applied using the `bgImage` chart attribute. In case loading fails, the
                         * {@link FusionCharts#event.backgroundLoadError} event is fired.
                         *
                         * To know more about how to load and configure chart background image, see:
                         * {@tutorial configuring-your-chart-border-and-background}.
                         *
                         * > This event is not fired if `bgImage` attribute is not provided.
                         * @see FusionCharts#event:backgroundLoadError
                         * @event FusionCharts#backgroundLoaded
                         * @group chart
                         * @param {string} url - URL of the background image
                         * @param {number} bgImageAlpha - The value of the image alpha
                         * @param {string} bgImageDisplayMode - The mode in which the images are displayed in background
                         * of the chart
                         * @param {string} bgImageVAlign - The vertical alignment of the background image
                         * @param {string} bgImageHAlign -The horizontal alignment of the background image
                         * @param {number} imageWidth - The width of the background image
                         * @param {number} imageHeight - The height of the background image
                         */
                        global.raiseEvent(BACKGROUNDLOADED, {
                            url: bgSWF,
                            bgImageAlpha: bgSWFAlpha * 100,
                            bgImageDisplayMode: bgImageDisplayMode,
                            bgImageVAlign: bgImageVAlign,
                            bgImageHAlign: bgImageHAlign,
                            bgImageScale: bgImageScale,
                            imageWidth: referenceImage.width,
                            imageHeight: referenceImage.height
                        }, chart.logic.chartInstance);
                    };
                    //error event
                    referenceImage.onerror = function (e) {

                        /**
                         * This event is fired for external background image for a chart failed to load. These
                         * background images are applied using the `bgImage` chart attribute.
                         *
                         * The cause of failure can be network connectivity issues or invalid value passed to the
                         * `bgImage` attribute. There can also be errors due to cross-domain policies and other security
                         * restrictions enforced by browsers.
                         *
                         * To know more about how to load and configure chart background image, see:
                         * {@tutorial configuring-your-chart-border-and-background}.
                         *
                         * > This event is not fired if `bgImage` attribute is not provided.
                         * @see FusionCharts#event:backgroundLoaded
                         * @event FusionCharts#backgroundLoadError
                         * @group chart
                         *
                         * @param {string} url - The URL of the background image
                         * @param {number} bgImageAlpha - The alpha value of the image.
                         * @param {string} error - Contains error message.
                         * @param {string} bgImageDisplayMode - The mode in which the images are displayed in the
                         * background of the chart.
                         * @param {string} bgImageVAlign - Vertical alignment of the background image.
                         * @param {string} bgImageHAlign - Horizontal alignment of the background image.
                         * @param {number} bgImageScale - The value of the scaling of the image.
                         * @param {number} imageHeight - The height of the background image.
                         */
                        global.raiseEvent(BACKGROUNDLOADERROR, {
                            url: bgSWF,
                            bgImageAlpha: bgSWFAlpha * 100,
                            error: e,
                            bgImageDisplayMode: bgImageDisplayMode,
                            bgImageVAlign: bgImageVAlign,
                            bgImageHAlign: bgImageHAlign,
                            bgImageScale: bgImageScale
                        }, chart.logic.chartInstance);
                    };

                    referenceImage.src = bgSWF;
                    elements.backgroundImage = chartBGImage;
                }
            },

            drawGraph: function () {
                var chart = this,
                    paper = chart.paper,
                    /** @todo remove  = chart.elements.plots */
                    plots = chart.plots = chart.elements.plots,
                    logic = chart.logic,
                    layers = chart.layers,
                    options = chart.options,
                    elements = chart.elements,
                    chartOptions = options.chart,
                    // chart data to be plotted
                    datasets = chart.datasets = options.series,
                    // series type
                    renderAs = getFirstValue(chartOptions.rendererId, chartOptions.defaultSeriesType),
                    // initial layers
                    backgroundLayer = layers.background,
                    datasetLayer = layers.dataset = layers.dataset ||
                        paper.group('dataset').insertAfter(backgroundLayer),
                    DRAWPLOT = 'drawPlot',
                    UPDATEPLOT = 'updatePlot',
                    LEGENDCLICK = 'legendClick',
                    drawPlotFunctionName,
                    updatePlotFunctionName,
                    drawPlotFunction,
                    updatePlotFunction,
                    datasetOptions,
                    plot,
                    i,
                    l,
                    visibilitySetter = function (i, datasetOptions) {
                        return function (isVisible) {
                            var plot = plots[i],
                                visibility,
                                reflowUpdate = {
                                    hcJSON: {
                                        series: []
                                    }
                                },
                                reflowPlot = reflowUpdate.hcJSON.series[i] ||
                                    (reflowUpdate.hcJSON.series[i] = {}),
                                reflowData = logic.chartInstance.jsVars._reflowData;

                            isVisible = getFirstValue(isVisible, !plot.visible);
                            visibility = isVisible ? 'visible' : 'hidden';

                            // hide plots
                            each(plot.graphics, function (graphic) {
                                if (graphic.data('alwaysInvisible') !== true) {
                                    graphic.attr('visibility', visibility);
                                }
                            });

                            // Update plot visibility
                            plot.visible = isVisible;
                            datasetOptions.visible = isVisible;
                            // Save state of the updated visibility
                            reflowPlot.visible = isVisible;
                            extend2(reflowData, reflowUpdate, true);
                        };
                    },
                    legendClickResposeSetter = function (i) {
                        return function (isVisible, restrainEvent) {
                            chart[LEGENDCLICK + renderAs] &&
                                chart[LEGENDCLICK + renderAs](plots[i], isVisible, restrainEvent) ||
                                chart[LEGENDCLICK] && chart[LEGENDCLICK](plots[i], isVisible, restrainEvent);
                        };
                    },
                    argFetchSetter = function (i) {
                        return function () {
                            return chart.getEventArgs && chart.getEventArgs(plots[i]);
                        };
                    },
                    realtimeUpdateSetter = function (i, drawPlotFunction, datasetOptions) {
                        return function (numUpdate, hasAxisChanged) {
                            drawPlotFunction.call(chart, plots[i], datasetOptions, {
                                numUpdate: numUpdate,
                                hasAxisChanged: hasAxisChanged
                            });
                        };
                    };

                layers.tracker = layers.tracker || paper.group('hot').insertAfter(datasetLayer);

                // draw canvas where required
                chart.drawCanvas();
                // draw axes labels, divlines, divgrids, trendlines/zones where required
                chart.drawAxes();

                if (!plots) {
                    plots = chart.plots = (chart.plots || []);
                    /** @todo remove elements.plots =  */
                    elements.plots = plots;
                }

                // draw all dataplots along with datalabels
                for (i = 0, l = datasets.length; i < l; i++) {
                    datasetOptions = datasets[i] || {};
                    updatePlotFunctionName = datasetOptions.updatePlot = UPDATEPLOT +
                        getSentenceCase(pluck(datasetOptions.type, datasetOptions.plotType, renderAs));
                    updatePlotFunction = chart[updatePlotFunctionName];
                    drawPlotFunctionName = datasetOptions.drawPlot = DRAWPLOT +
                        getSentenceCase(pluck(datasetOptions.type, datasetOptions.plotType, renderAs));
                    drawPlotFunction = chart[drawPlotFunctionName] || chart[DRAWPLOT];

                    if (!(plot = plots[i])) {
                        plots.push(plot = {
                            index: i,
                            items: [],
                            data: datasetOptions.data || [],
                            name: datasetOptions.name,
                            userID: datasetOptions.userID,
                            setVisible: visibilitySetter(i, datasetOptions),
                            legendClick: legendClickResposeSetter(i),
                            getEventArgs: argFetchSetter(i),
                            realtimeUpdate: realtimeUpdateSetter(i, updatePlotFunction ||
                                drawPlotFunction, datasetOptions)
                        });

                        datasetOptions.plot = plot;
                        datasetOptions.legendClick = plot.legendClick;
                        datasetOptions.getEventArgs = plot.getEventArgs;
                        datasetOptions.setVisible = plot.setVisible;
                    }

                    drawPlotFunction.call(chart, plot, datasetOptions);
                }

                if (chartOptions.hasScroll) {
                    chart.drawScroller();
                    // finalize scroll
                    chart.finalizeScrollPlots();
                }
            },

            drawPlot: stubFN,
            drawCanvas: stubFN,
            drawAxes: stubFN,

            drawScroller: function () {},

            drawLegend: function () {
                var chart = this,
                    options = chart.options,
                    paper = chart.paper,
                    optionsChart = options.chart || {},
                    legendOptions = options.legend,
                    scrollOptions = legendOptions.scroll,
                    legend = {
                        elements: {}
                    },
                    elements = legend.elements,
                    legendGroup = chart.layers.legend,
                    box = elements.box,
                    caption = elements.caption,
                    elementGroup = elements.elementGroup,
                    isVertical = legendOptions.layout === 'vertical',
                    canvasBottom = optionsChart.marginBottom,
                    marginBottom = optionsChart.spacingBottom,
                    marginLeft = optionsChart.spacingLeft,
                    marginRight = optionsChart.spacingRight,
                    chartWidth = paper.width,
                    chartHeight = paper.height,
                    canvasTop = chart.canvasTop,
                    width = legendOptions.width,
                    height = legendOptions.height,
                    r = legendOptions.borderRadius,
                    backgroundColor = legendOptions.backgroundColor,
                    borderColor = legendOptions.borderColor,
                    borderWidth = legendOptions.borderWidth || 0,
                    semiBorder = borderWidth * 0.5,
                    translationLimit = (borderWidth * 0.5) + 2, //2px gutter
                    padding = pluckNumber(legendOptions.padding, 4),
                    halfPad = padding * 0.5,
                    scrollerWidth = 10, //hardcoded value
                    xPos,
                    yPos,
                    clipSTR1,
                    clipH,
                    clipSTR2,
                    dragX,
                    dragY,
                    dragOffsetX,
                    dragOffsetY,
                    dragInitX,
                    dragInitY,
                    scroller,
                    crispBox,
                    captionX,
                    attrObj,
                    scrollEnabled = scrollOptions && scrollOptions.enabled;

                /*
                 * NOTE: If any change in xpos/ypos calculation is required then
                 * apply the changes in corresponding snapLiterals also.
                 */
                if (isVertical) {
                    xPos = chartWidth - marginRight - width;
                    yPos = canvasTop + ((chartHeight - canvasBottom - canvasTop - height) * 0.5) +
                        (legendOptions.y || 0);
                } else {
                    xPos = marginLeft + ((chartWidth - marginLeft - marginRight - width) * 0.5) +
                        (legendOptions.x || 0);
                    yPos = chartHeight - marginBottom - height;
                }

                // Crispen the legend box
                crispBox = R.crispBound(xPos, yPos, width, height, borderWidth);
                xPos = crispBox.x;
                yPos = crispBox.y;
                width = crispBox.width;
                height = crispBox.height;

                // Draw the parent group.
                if (!legendGroup) {
                    legendGroup = chart.layers.legend = paper.group('legend')
                        .insertBefore(chart.layers.tracker)
                        .translate(xPos, yPos)
                        .attr('class', 'fusioncharts-legend');
                }

                chart.addCSSDefinition('.fusioncharts-legend .fusioncharts-caption',
                    extend2({'text-anchor': legendOptions.title.align}, legendOptions.title.style));

                // Add legend dragging events and configuration.
                if (legendOptions.legendAllowDrag) {

                    chart.addCSSDefinition('.fusioncharts-legend', {cursor: 'move'});

                    dragX = xPos;
                    dragY = yPos;
                    legendGroup/*.css({
                        cursor: 'move'
                    })*/.drag(function (dx, dy) {
                        /** @todo implement tooltip block during drag */
                        dragOffsetX = dragInitX + dx;
                        dragOffsetY = dragInitY + dy;
                        if (dragOffsetX + width + translationLimit > chartWidth) {
                            dragOffsetX = chartWidth - width - translationLimit;
                        }
                        if (dragOffsetY + height + translationLimit > chartHeight) {
                            dragOffsetY = chartHeight - height - translationLimit;
                        }
                        if (dragOffsetX < translationLimit) {
                            dragOffsetX = translationLimit;
                        }
                        if (dragOffsetY < translationLimit) {
                            dragOffsetY = translationLimit;
                        }
                        legendGroup.translate(dragOffsetX - dragX, dragOffsetY - dragY);
                        dragX = dragOffsetX;
                        dragY = dragOffsetY;
                    }, function () {
                        dragInitX = dragX;
                        dragInitY = dragY;
                    });
                }

                // store the attrs
                attrObj = {
                    x: 0,
                    y: 0,
                    width: width,
                    height: height,
                    r: r,
                    stroke: borderColor,
                    'stroke-width': borderWidth,
                    fill: backgroundColor || NONE,
                    ishot: legendOptions.legendAllowDrag
                };

                // draw the background
                if (!box) {
                    box = elements.box = paper.rect(attrObj, legendGroup);
                }
                else {
                    // apply all atributes
                    box.attr(attrObj);
                }

                box.shadow(legendOptions && legendOptions.shadow);

                if (scrollEnabled) {
                    clipSTR1 = '0,';
                    clipH = height - padding;
                    clipSTR2 = COMMA + width + COMMA + clipH;
                    elementGroup = elements.elementGroup = paper.group('legenditems', legendGroup)
                        .attr({
                            'clip-rect': clipSTR1 + halfPad + clipSTR2
                        });
                    scroller = elements.scroller || (elements.scroller = paper.scroller(width - scrollerWidth +
                        halfPad - borderWidth, semiBorder, scrollerWidth, height - borderWidth, false, {
                            scrollPosition: scrollOptions.scrollPosition || 0,
                            scrollRatio: (clipH + padding) / legendOptions.totalHeight,
                            showButtons: false,
                            displayStyleFlat: scrollOptions.flatScrollBars
                        }, legendGroup));

                    scroller.attr('fill', legendOptions.legendScrollBgColor).scroll(function (pos) {
                        elementGroup.transform(['T', 0, (clipH - legendOptions.totalHeight) * pos]);
                        extend2(chart.fusionCharts.jsVars._reflowData, {
                            hcJSON: {
                                legend: {
                                    scroll: {
                                        position: arguments[0]
                                    }
                                }
                            }
                        }, true);
                    });
                } else {
                    elementGroup = elements.elementGroup = legendGroup;
                }

                //draw the caption
                if (legendOptions.title && legendOptions.title.text !== BLANK) {

                    switch (legendOptions.title.align) {
                        case 'start':
                            captionX = padding;
                            break;
                        case 'end':
                            captionX = width - padding - (scrollEnabled ? scrollerWidth : 0);
                            break;
                        default:
                            captionX = width * 0.5;
                    }

                    attrObj = {
                        'class': 'fusioncharts-caption',
                        'text-anchor': legendOptions.title.align,
                        text: legendOptions.title.text,
                        title: (legendOptions.title.originalText || ''),
                        x: captionX,
                        y: padding,
                        fill: legendOptions.title.style.color,
                        'vertical-align': 'top',
                        'line-height': legendOptions.title.style.lineHeight
                    };

                    if (!caption) {
                        caption = elements.caption = paper.text(attrObj, elementGroup).attr('class',
                            'fusioncharts-caption');
                    }
                    else {
                        caption.attr(attrObj);
                    }
                }

                //draw legend items
                this['draw' + getSentenceCase(legendOptions.type || 'point') + 'LegendItem'](legend);
            },

            //Function to draw point type legend's item
            drawPointLegendItem: function (legend) {
                var chart = this,
                    paper = chart.paper,
                    options = chart.options,
                    series = options.series,
                    optionsChart = options.chart,
                    defaultSeriesType = optionsChart.defaultSeriesType,
                    legendOptions = options.legend,
                    symbolBoxW = legendOptions.legendHeight,
                    symbolPadding = legendOptions.symbolPadding,
                    textPadding = legendOptions.textPadding || 2,
                    padding = pluckNumber(legendOptions.padding, 4),
                    itemHoverStyle = legendOptions.itemHoverStyle,
                    itemHiddenStyle = legendOptions.itemHiddenStyle,
                    itemStyle = legendOptions.itemStyle,
                    itemTextColor = itemStyle.color,
                    hiddenColor = itemHiddenStyle && itemHiddenStyle.color || '#CCCCCC',
                    hoverColor = itemHoverStyle && itemHoverStyle.color || itemTextColor,
                    item3dlighting = legendOptions.symbol3DLighting,
                    symbolWidth = legendOptions.symbolWidth,
                    interactiveLegend = legendOptions.interactiveLegend !== false,
                    elements = legend.elements,
                    elementGroup = elements.elementGroup,
                    item = legend.item = [], //store for individual legend item
                    elementItem = elements.item = [], //store for drawing elements
                    allItems = [],
                    //store all series type that has no special legend symbol
                    markerLegend = {
                        line: true,
                        spline: true,
                        scatter: true,
                        bubble: true,
                        dragnode: true,
                        zoomline: true
                    },
                    initialItemX,
                    initialItemY,
                    legendItem,
                    legendType,
                    visible,
                    itemLineColor,
                    itemClickFN,
                    itemRollOver,
                    itemRollOut,
                    legendItemText,
                    legendItemBackground,
                    serie,
                    data,
                    type,
                    point,
                    itemX,
                    itemY,
                    itemHeight,
                    i,
                    j,
                    ln,
                    ln1,
                    cx,
                    cy,
                    radius,
                    symbol,
                    dip,
                    marker,
                    mLineColor,
                    mFillColor,
                    legendItemSymbol,
                    symbolConfig,
                    legendItemLine,
                    newLegendItem,
                    symbolColor;

                //collect all element that has a valid legend
                for (i = 0, ln = series.length; i < ln; i += 1) {
                    serie = series[i];
                    if (serie && serie.showInLegend !== false) {
                        type = serie.type || defaultSeriesType;
                        // use points or series for the legend item depending on legendType
                        if (serie.legendType === 'point') {
                            data = serie.data || [];
                            for (j = 0, ln1 = data.length; j < ln1; j += 1) {
                                point = data[j] || {};
                                if (point.showInLegend !== false) {
                                    point._legendType = type;
                                    allItems.push(point);
                                }
                            }
                        } else {
                            serie._legendType = type;
                            switch (type) {
                                case 'pie':
                                case 'pie3d':
                                case 'funnel':
                                case 'pyramid':
                                    allItems = serie.data;
                                    break;

                                default:
                                    allItems.push(serie);
                                    break;
                            }
                        }
                    }
                }
                // sort by legendIndex
                allItems.sort(function (a, b) {
                    return ((a.legendIndex || 0) - (b.legendIndex || 0)) ||
                        (a.__i - b.__i);
                });
                // reversed legend
                if (legendOptions.reversed) {
                    // This reverse the main items as pie, so required to be reversed
                    // again after legend item creation is over.
                    allItems.reverse();
                }

                initialItemX = legendOptions.initialItemX || 0;
                initialItemY = legendOptions.initialItemY || 0;

                itemClickFN = function (e) {
                    var legendItem = this.data('legendItem'),
                        eventArgs = legendItem.getEventArgs ? legendItem.getEventArgs() : {},
                        interactivityCancelled,
                        cord = getMouseCoordinate(chart.logic.chartInstance.ref, e);
                    eventArgs.chartX = cord.chartX;
                    eventArgs.chartY = cord.chartY;
                    eventArgs.pageX = cord.pageX;
                    eventArgs.pageY = cord.pageY;
                    eventArgs.preventDefaults = function () {
                        interactivityCancelled = true;
                    };
                    /**
                     * This event is fired when user clicks on individual legend items. By default, the legend items on
                     * a chart are configured to toggle the visibility of the dataset (series) that the legend item
                     * points to.
                     *
                     * @see FusionCharts#event:legendItemRollover
                     * @see FusionCharts#event:legendItemRollout
                     * @event FusionCharts#legendItemClicked
                     * @group legend
                     *
                     * @param {number} minRange - Minimum value of the color range represented by the legend item.
                     * @param {number} maxRange - Maximum value of the color range represented by the legend item.
                     *
                     */
                    global.raiseEvent(LEGENDITEMCLICKED, eventArgs, chart.logic.chartInstance);

                    if (interactiveLegend && !interactivityCancelled) {
                        legendItem.legendClick();
                    }
                };

                itemRollOver = function (e) {
                    var legendItem = this.data('legendItem'),
                        eventArgs = legendItem.getEventArgs ? legendItem.getEventArgs() : {},
                        cord = getMouseCoordinate(chart.logic.chartInstance.ref, e),
                        visible = (legendItem.visible !== false),
                        legendItemText = legendItem.plot.legend.elements.legendItemText;

                    eventArgs.chartX = cord.chartX;
                    eventArgs.chartY = cord.chartY;
                    eventArgs.pageX = cord.pageX;
                    eventArgs.pageY = cord.pageY;

                    //change text color
                    if (visible) {
                        legendItemText && legendItemText.attr({
                            fill: hoverColor
                        });
                    }
                    /**
                     * This event is fired when the mouse pointer is moved over any individual legend item.
                     *
                     * @see FusionCharts#event:legendItemRollout
                     * @see FusionCharts#event:legendItemClicked
                     *
                     * @event FusionCharts#legendItemRollover
                     * @group legend
                     *
                     * @param {number} chartX - The relative X-Cordinate to chart container where the legend item was
                     * hovered.
                     * @param {number} chartY - The relative Y-Cordinate to chart container where the legend item was
                     * hovered
                     * @param {number} datasetIndex - The index of the dataset
                     * @param {string} datasetName - The name of the dataset
                     * @param {string} id - User-defined Id of the dataset.
                     * @param {number} pageX - The relative X-Cordinate to screen where the legend item was hovered.
                     * @param {number} pageY - The relative Y-Cordinate to screen where the legend item was hovered.
                     * @param {boolean} visible - `true` if the legend item is visible in the chart or false if it is
                     * hidden.
                     */
                    global.raiseEvent(LEGENDITEMROLLOVER, eventArgs, chart.logic.chartInstance);
                };

                itemRollOut = function (e) {
                    var legendItem = this.data('legendItem'),
                        eventArgs = legendItem.getEventArgs ? legendItem.getEventArgs() : {},
                        cord = getMouseCoordinate(chart.logic.chartInstance.ref, e),
                        visible = (legendItem.visible !== false),
                        legendItemText = legendItem.plot.legend.elements.legendItemText;

                    eventArgs.chartX = cord.chartX;
                    eventArgs.chartY = cord.chartY;
                    eventArgs.pageX = cord.pageX;
                    eventArgs.pageY = cord.pageY;

                    //change text color
                    if (visible) {
                        legendItemText && legendItemText.attr({
                            fill: itemTextColor
                        });
                    }
                    /**
                     * This event is fired when the mouse is hovered out of the chart's legend item.
                     *
                     * @see FusionCharts#event:legendItemRollover
                     * @see FusionCharts#event:legendItemClicked
                     * @event FusionCharts#legendItemRollout
                     * @group legend
                     *
                     * @param {number} chartX - The relative X-Cordinate to chart container where the mouse is hovered
                     * out of legend item.
                     * @param {number} chartY - The relative Y-Cordinate to chart container where the mouse is hovered
                     * out of legend item.
                     * @param {number} datasetIndex - The index of the dataset.
                     * @param {string} datasetName - The name of the dataset.
                     * @param {string} id - User-defined Id of the dataset.
                     * @param {number} pageX - The relative X-Cordinate to screen where the mouse is hovered out of
                     * legend item.
                     * @param {number} pageY - The relative Y-Cordinate to screen where the mouse is hovered out of
                     * legend item.
                     * @param {boolean} visible - `true` if the legend item is visible in the chart or false if it is
                     * hidden.
                     */
                    global.raiseEvent(LEGENDITEMROLLOUT, eventArgs, chart.logic.chartInstance);
                };

                chart.addCSSDefinition('.fusioncharts-legend .fusioncharts-legenditem', legendOptions.itemStyle);

                //draw all items
                for (i = 0, ln = allItems.length; i < ln; i += 1) {
                    if (allItems[i].showInLegend === false) {
                        continue;
                    }
                    newLegendItem = {
                        elements: {},
                        hiddenColor: hiddenColor,
                        itemTextColor: itemTextColor,
                        hoverColor: hoverColor
                    };
                    item.push(newLegendItem);
                    elementItem.push(newLegendItem.elements);
                    legendItem = allItems[i];
                    itemX = initialItemX + legendItem._legendX + padding;
                    itemY = initialItemY + legendItem._legendY - padding;
                    itemHeight = legendItem._legendH;
                    legendType = legendItem._legendType || type;
                    visible = (legendItem.visible !== false);
                    /** @todo remove the last || {}  it is used temporarily to prevent error */
                    itemLineColor = newLegendItem.itemLineColor = toRaphaelColor(legendItem.color || {});

                    //store the legend elements into plot
                    legendItem.plot.legend = newLegendItem;

                    // create the text
                    legendItemText = newLegendItem.elements.legendItemText =
                        paper.text({
                            'class': 'fusioncharts-legenditem',
                            x: itemX + symbolBoxW + textPadding - 2,
                            y: itemY + (legendItem._legendTestY || 0), //text gutter
                            text: legendItem.name,
                            fill: visible ? itemTextColor : hiddenColor,
                            'vertical-align': 'top',
                            'text-anchor': 'start',
                            cursor: itemStyle.cursor || 'pointer',
                            //title: (legendItem.originalText || ''),
                            ishot: interactiveLegend,
                            'line-height': itemStyle.lineHeight,
                            'font-size': itemStyle.fontSize
                        }, elementGroup)
                        //.css(itemStyle)
                        .data('legendItem', legendItem);

                    //create the symbol
                    if (markerLegend[legendType]) {
                        cy = itemY + symbolPadding + (symbolWidth * 0.5);
                        //draw the line
                        if (legendItem.lineWidth) {
                            legendItemLine = newLegendItem.elements.legendItemLine =
                                paper.path({
                                    'stroke-width': legendItem.lineWidth,
                                    stroke: visible ? itemLineColor : hiddenColor,
                                    cursor: itemStyle.cursor || 'pointer',
                                    ishot: interactiveLegend,
                                    path: [
                                        M,
                                        itemX + symbolPadding,
                                        cy,
                                        L,
                                        itemX + symbolPadding + symbolWidth,
                                        cy
                                    ]
                                }, elementGroup)
                                .data('legendItem', legendItem);
                        }

                        //draw the marker
                        if (legendItem && (marker = legendItem.marker) && marker.enabled !== false) {
                            newLegendItem.symbolStroke = toRaphaelColor(pluck((mLineColor = marker.lineColor) &&
                                (mLineColor.FCcolor && mLineColor.FCcolor.color.split(COMMA)[0] || mLineColor),
                                itemLineColor));

                            if (item3dlighting) {
                                if (marker.fillColor && marker.fillColor.FCcolor) {
                                    symbolColor = extend2({}, marker.fillColor);
                                    symbolColor.FCcolor.alpha = '100';
                                } else {
                                    symbolColor = pluck(marker.fillColor, itemLineColor);
                                }
                            }
                            else {
                                symbolColor = {
                                    FCcolor: {
                                        color: pluck((mFillColor = marker.fillColor) &&
                                            (mFillColor.FCcolor && mFillColor.FCcolor.color.split(COMMA)[0] ||
                                            mFillColor), itemLineColor),
                                        angle: 0,
                                        ratio: '0',
                                        alpha: '100'
                                    }
                                };
                            }

                            newLegendItem.symbolColor = toRaphaelColor(symbolColor);
                            radius = symbolWidth * 0.5;
                            cx = itemX + symbolPadding + radius;
                            cy = itemY + symbolPadding + radius;

                            if (legendItemLine) {
                                radius *= 0.6;
                            }

                            symbol = marker.symbol.split('_');
                            dip = symbol[0] === 'spoke' ? 1 : 0;

                            if (symbol[1]) {
                                legendItemSymbol = newLegendItem.elements.legendItemSymbol =
                                    paper.polypath(symbol[1], cx, cy, radius, marker.startAngle, dip, elementGroup);
                            } else {
                                legendItemSymbol = newLegendItem.elements.legendItemSymbol =
                                    paper.circle(cx, cy, radius, elementGroup);
                            }
                            legendItemSymbol
                                .data('legendItem', legendItem)
                                .attr({
                                    cursor: itemStyle.cursor || 'pointer',
                                    stroke: visible ? newLegendItem.symbolStroke : hiddenColor,
                                    fill: visible ? newLegendItem.symbolColor : hiddenColor,
                                    'stroke-width': 1,
                                    ishot: interactiveLegend
                                });
                        }
                    } else {
                        symbolConfig = chart.getSymbolPath(itemX + symbolPadding, itemY + symbolPadding,
                            symbolWidth, symbolWidth, legendType, legendItem, !item3dlighting);
                        newLegendItem.symbolColor = toRaphaelColor(symbolConfig.color);
                        newLegendItem.symbolStroke = toRaphaelColor(symbolConfig.strokeColor);
                        legendItemSymbol = newLegendItem.elements.legendItemSymbol =
                            paper.path({
                                path: symbolConfig.path,
                                'stroke-width': symbolConfig.strokeWidth,
                                stroke: visible ? newLegendItem.symbolStroke : hiddenColor,
                                fill: visible ? newLegendItem.symbolColor : hiddenColor,
                                cursor: itemStyle.cursor || 'pointer',
                                ishot: interactiveLegend
                            }, elementGroup)
                            .data('legendItem', legendItem);
                    }

                    // draw background
                    legendItemBackground = newLegendItem.elements.legendItemBackground =
                        paper.rect({
                            x: itemX,
                            y: itemY, //text gutter
                            width: legendItem._totalWidth,
                            height: itemHeight,
                            r: 0,
                            fill: toRaphaelColor(legendItem.legendFillColor || TRACKER_FILL),
                            'stroke-width': 1,
                            stroke: toRaphaelColor(legendItem.legendBorderColor || NONE),
                            cursor: itemStyle.cursor || 'pointer',
                            ishot: interactiveLegend
                        }, elementGroup)
                        // @todo @performance - attach event handlers to the parent group
                        .click(itemClickFN)
                        .mouseover(itemRollOver)
                        .mouseout(itemRollOut)
                        .data('legendItem', legendItem);
                }

                if (legendOptions.reversed) {
                    // As stated above, the array is reversed once again to maintain
                    // the right order, like for the case of pie.
                    allItems.reverse();
                }
            },

            drawCaption: function () {
                var chart = this,
                    optionsChart = chart.options.chart,
                    optionsCap = chart.options.title,
                    optionsSubcap = chart.options.subtitle,
                    paper = chart.paper,
                    smartLabel = chart.smartLabel,
                    elements = chart.elements,
                    layers = chart.layers,
                    captionGroup = layers.caption,
                    caption = elements.caption,
                    subcaption = elements.subcaption,
                    interCaptionGap = 2,
                    hasCaption = optionsCap.text,
                    hasSubcaption = (optionsSubcap && optionsSubcap.text),
                    captionX = optionsCap.x,
                    attrObj,
                    captionHeight;

                // if captions are needed, then we need to ensure that it is placed
                // within a group.
                if (hasCaption || hasSubcaption) {
                    if (!captionGroup) {
                        captionGroup = layers.caption = paper.group('caption');

                        if (layers.tracker) {
                            captionGroup.insertBefore(layers.tracker);
                        } else {
                            captionGroup.insertAfter(layers.dataset);
                        }
                    }
                }

                // if definition has caption, we proceed creating one and if there
                // is no caption we remove any previously created caption element.

                if (hasCaption) {
                    chart.addCSSDefinition('.fusioncharts-caption', optionsCap.style);
                    attrObj = {
                        'class': 'fusioncharts-caption',
                        text: optionsCap.text,
                        fill: optionsCap.style.color,
                        x: captionX,
                        y: (optionsCap.y || optionsChart.spacingTop || 0),
                        'text-anchor': (optionsCap.align) || POSITION_MIDDLE,
                        'vertical-align': optionsCap.verticalAlign || 'top',
                        visibility: 'visible',
                        title: (optionsCap.originalText || '')
                    };

                    if (!caption) {
                        caption = elements.caption = paper.text(attrObj, captionGroup).attr('class',
                            'fusioncharts-caption');
                    }
                    else {
                        caption.attr(attrObj);
                    }

                    caption.css(optionsCap.style);
                    if (smartLabel) {
                        smartLabel.setStyle(optionsCap.style);
                        captionHeight = smartLabel.getOriSize(optionsCap.text).height;
                    }
                    else {
                        captionHeight = 10;
                    }

                } else if (caption) {
                    caption = elements.caption = caption.remove();
                }

                if (hasSubcaption) {
                    chart.addCSSDefinition('.fusioncharts-subcaption', optionsSubcap.style);
                    attrObj = {
                        'class': 'fusioncharts-subcaption',
                        text: optionsSubcap.text,
                        title: (optionsSubcap.originalText || ''),
                        fill: optionsSubcap.style.color,
                        x: captionX,
                        y: hasCaption ?
                            (caption.attrs.y + captionHeight + interCaptionGap) :
                            (optionsCap.y || optionsChart.spacingTop || 0),
                        'text-anchor': optionsCap.align || POSITION_MIDDLE,
                        'vertical-align': 'top',
                        visibility: 'visible'
                    };

                    if (!subcaption) {
                        subcaption = elements.subcaption = paper.text(attrObj, captionGroup).attr('class',
                            'fusioncharts-subcaption');
                    }
                    else {
                        subcaption.attr(attrObj);
                    }
                    subcaption.css(optionsSubcap.style);

                } else if (subcaption) {
                    subcaption = elements.subcaption = subcaption.remove();
                }

                // if neither caption or subcaption is needed, we need to dump the
                // group as well.
                if (!(hasCaption || hasSubcaption || !captionGroup)) {
                    captionGroup = layers.caption = captionGroup.remove();
                }
            },

            drawLogo: function () {
                var chart = this,
                    paper = chart.paper,
                    elements = chart.elements,
                    options = chart.options,
                    logic = chart.logic,
                    credits = options.credits,
                    chartOptions = options.chart || {},
                    chartBorderWidth = chartOptions.borderWidth || 0,
                    chartHeight = chart.chartHeight,
                    chartWidth = chart.chartWidth,
                    chartLogoImage = elements.logoImage,
                    logoURL = chartOptions.logoURL,
                    logoAlpha = chartOptions.logoAlpha / 100,
                    logoPositionSTR = chartOptions.logoPosition,
                    logoLink = chartOptions.logoLink,
                    logoScale = chartOptions.logoScale,
                    logoLeftMargin = chartOptions.logoLeftMargin,
                    logoTopMargin = chartOptions.logoTopMargin,
                    position = {
                        tr: {
                            vAlign: POSITION_TOP,
                            hAlign: POSITION_RIGHT
                        },
                        bl: {
                            vAlign: POSITION_BOTTOM,
                            hAlign: POSITION_LEFT
                        },
                        br: {
                            vAlign: POSITION_BOTTOM,
                            hAlign: POSITION_RIGHT
                        },
                        cc: {
                            vAlign: POSITION_MIDDLE,
                            hAlign: POSITION_MIDDLE
                        }
                    },
                    logoReferenceImage,
                    logoImageAttr,
                    creditLabel,
                    logoPosition;

                // Drawing of the credit-label.
                if (logic && credits.enabled) {
                    // paper.rect(1, chartHeight - 16, 100, 15).attr({
                    //    stroke: 'none',
                    //    fill: '180-rgba(255,255,255,0)-rgba(255,255,255,255)'
                    // });
                    creditLabel = paper.text()
                        .attr({
                            text: credits.text,
                            x: 6,
                            y: chartHeight - 4,
                            'vertical-align': POSITION_BOTTOM,
                            'text-anchor': POSITION_START,
                            fill: 'rgba(0,0,0,0.5)',
                            title: credits.title || ''
                        })
                        .css({
                            fontSize: 9,
                            fontFamily: 'Verdana,sans',
                            cursor: 'pointer',
                            '_cursor': 'hand'
                        })
                        .click(function () {
                            try {
                                win.open(credits.href);
                            }
                            catch (err) {
                                (win.top || win).location.href = credits.href;
                            }
                        });
                }

                if (logoURL) {
                    logoReferenceImage = new Image();
                    logoPosition = position[logoPositionSTR];
                    if (!logoPosition) {
                        logoPosition = {
                            vAlign: POSITION_TOP,
                            hAlign: POSITION_LEFT
                        };
                    }

                    //create the image element as before onload the chart may be
                    // destroyed in case of realtime chart with small updateInterval
                    logoReferenceImage.onload = function () {
                        if (chart.disposed || paper.disposed) {
                            return;
                        }

                        logoImageAttr = setImageDisplayMode(NONE, logoPosition.vAlign, logoPosition.hAlign,
                            logoScale, chartBorderWidth, chartWidth, chartHeight, logoReferenceImage);

                        /*
                         * In VML, RedRphael looks for attribute 'w' & 'h' instead of width and height. As
                         * same type of rendering is also used for background image but the issue could not be
                         * replicated for bgImage, it is best to keep this small change tied to logo image only.
                         */
                        if(isVML){
                            logoImageAttr.w = logoImageAttr.width || 0;
                            logoImageAttr.h = logoImageAttr.height || 0;
                        }

                        logoImageAttr.src = logoURL;
                        chartLogoImage = chart.paper.image(logoImageAttr).translate(logoLeftMargin, logoTopMargin)
                            .css('opacity', logoAlpha);

                        if (logoLink) {
                            chartLogoImage.css({
                                cursor: 'pointer',
                                '_cursor': 'hand'
                            });
                        }
                        //create event for LogoClick, LogoRollover & LogoRollout
                        chartLogoImage.mouseover(function (e) {
                            var cord = getMouseCoordinate(chart.logic.chartInstance.ref, e);

                            /**
                             * This event is fired when the mouse is hovered over external logo added to the chart using
                             * `logoURL` attribute.
                             *
                             * To know more about external logos, see
                             * {@tutorial configuring-your-chart-loading-external-logos}
                             *
                             * @see FusionCharts#event:logoRollout
                             * @see FusionCharts#event:logoClick
                             * @see FusionCharts#event:logoLoaded
                             * @see FusionCharts#event:logoLoadError
                             *
                             * @event FusionCharts#logoRollover
                             * @group chart:logo
                             * @tutorial configuring-your-chart-loading-external-logos
                             *
                             * @param {string} logoURL - The URL of the logo image.
                             * @param {number} logoAlpha - The value of the alpha
                             *                 of the logo image.
                             * @param {string} logoPosition - The position of the
                             *                 logo.
                             * @param {number} logoScale - The value of scaling of
                             *                  the logo image.
                             * @param {string} logoLink - The URL linked to the logo
                             *               which on clicking will be taken to the
                             *               URL link.
                             * @param {number} chartX - The relative X-Cordinate
                             *                 to screen where the mouse was
                             *                 hovered over the logo.
                             * @param {number} chartY - The relative Y-Cordinate
                             *                 to screen where the mouse was
                             *                 hovered over the logo.
                             * @param {number} pageX - The relative Y-Cordinate
                             *                 to screen where the mouse was
                             *                 hovered over the logo.
                             * @param {number} pageY - The relative Y-Cordinate
                             *                 to screen where the mouse was
                             *                 hovered over the logo.
                             */
                            global.raiseEvent(LOGOROLLOVER, {
                                logoURL: logoURL,
                                logoAlpha: logoAlpha * 100,
                                logoPosition: logoPositionSTR || TL,
                                logoScale: logoScale,
                                logoLink: logoLink,
                                chartX: cord.chartX,
                                chartY: cord.chartY,
                                pageX: cord.pageX,
                                pageY: cord.pageY
                            }, chart.logic.chartInstance);
                        });
                        chartLogoImage.mouseout(function (e) {
                            var cord = getMouseCoordinate(chart.logic.chartInstance.ref, e);
                            //raise event of logo load
                            /**
                             * This event is fired when the mouse is moved outside external logo added to the chart
                             * using `logoURL` attribute.
                             *
                             * To know more about external logos, see
                             * {@tutorial configuring-your-chart-loading-external-logos}
                             *
                             * @see FusionCharts#event:logoRollover
                             * @see FusionCharts#event:logoClick
                             * @see FusionCharts#event:logoLoaded
                             * @see FusionCharts#event:logoLoadError
                             *
                             * @event FusionCharts#logoRollout
                             * @group chart:logo
                             * @tutorial configuring-your-chart-loading-external-logos
                             *
                             * @param {string} logoURL - The URL of the logo image.
                             * @param {number} logoAlpha - The value of the alpha
                             *                 of the logo image.
                             * @param {string} logoPosition - The position of the
                             *                 logo.
                             * @param {string} logoScale - The value of scaling for
                             *                  logo image.
                             * @param {string} logoLink - The URL linked to the
                             *                 logo which on clicking will be taken
                             *                 to the URL link.
                             * @param {number} chartX - The relative X-Cordinate
                             *                 to screen where the mouse was
                             *                 hovered out of logo image.
                             * @param {number} chartY - The relative Y-Cordinate
                             *                 to screen where the mouse was
                             *                 hovered out of the logo image.
                             * @param {number} pageX - The relative Y-Cordinate
                             *                 to screen where the mouse was
                             *                 hovered out of the logo image.
                             * @param {number} pageY - The relative Y-Cordinate
                             *                 to screen where the mouse was
                             *                 hovered out of the logo image.
                             */
                            global.raiseEvent(LOGOROLLOUT, {
                                logoURL: logoURL,
                                logoAlpha: logoAlpha * 100,
                                logoPosition: logoPositionSTR || TL,
                                logoScale: logoScale,
                                logoLink: logoLink,
                                chartX: cord.chartX,
                                chartY: cord.chartY,
                                pageX: cord.pageX,
                                pageY: cord.pageY
                            }, chart.logic.chartInstance);
                        });
                        chartLogoImage.click(function (e) {

                            var cord = getMouseCoordinate(chart.logic.chartInstance.ref, e);

                            /**
                             * This event is fired when the mouse is clicked on external logo added to the chart using
                             * `logoURL` attribute. For touch devices, this event is fired when user taps on the logo.
                             *
                             * To know more about external logos, see
                             * {@tutorial configuring-your-chart-loading-external-logos}
                             *
                             * @see FusionCharts#event:logoRollover
                             * @see FusionCharts#event:logoRollout
                             * @see FusionCharts#event:logoLoaded
                             * @see FusionCharts#event:logoLoadError
                             *
                             * @event FusionCharts#logoClick
                             * @group chart:logo
                             * @tutorial configuring-your-chart-loading-external-logos
                             *
                             * @param {string} logoURL - The URL of the logo image.
                             * @param {number} logoAlpha - The value of the alpha of the logo image.
                             * @param {string} logoPosition - The position of the position of the logo.
                             * @param {number} logoScale - The value of scaling for logo image.
                             * @param {string} logoLink - The URL linked to the logo which on clicking will be taken to
                             * the URL link.
                             * @param {number} chartX - The relative X-Cordinate to screen where the mouse was hovered
                             * out of the chart logo.
                             * @param {number} chartY - The relative Y-Cordinate to screen where the mouse was hovered
                             * out of the chart logo.
                             * @param {number} pageX - The relative Y-Cordinate to screen where the mouse was hovered
                             * out of the chart logo.
                             * @param {number} pageY - is the relative Y-Cordinate to screen where the mouse was hovered
                             * out of the chart logo.
                             */
                            global.raiseEvent(LOGOCLICK, {
                                logoURL: logoURL,
                                logoAlpha: logoAlpha * 100,
                                logoPosition: logoPositionSTR || TL,
                                logoScale: logoScale,
                                logoLink: logoLink,
                                chartX: cord.chartX,
                                chartY: cord.chartY,
                                pageX: cord.pageX,
                                pageY: cord.pageY
                            }, chart.logic.chartInstance, undefined, function () {
                                logoLink && chartOptions.events.click.call({
                                    link: logoLink
                                });
                            });
                        });

                        //raise event of logo load
                        /**
                         * This event is fired when external logo added to the chart using `logoURL` attribute has
                         * finished loading.
                         *
                         * To know more about external logos, see
                         * {@tutorial configuring-your-chart-loading-external-logos}
                         *
                         * @see FusionCharts#event:logoRollover
                         * @see FusionCharts#event:logoRollout
                         * @see FusionCharts#event:logoClick
                         * @see FusionCharts#event:logoLoadError
                         *
                         * @event FusionCharts#logoLoaded
                         * @group chart:logo
                         * @tutorial configuring-your-chart-loading-external-logos
                         *
                         * @param {string} logoURL - is the URL of the logo image.
                         * @param {number} logoAlpha - is the value of the alpha
                         *                 of the logo image.
                         * @param {string} logoPosition - is the position of the chart
                         *                  logo.
                         * @param {number} logoScale - is the value of scaling for
                         *                 logo image.
                         * @param {string} logoLink - is the URL linked to the logo
                         *                 which on clicking will be taken to the
                         *                 URL link.
                         */
                        global.raiseEvent(LOGOLOADED, {
                            logoURL: logoURL,
                            logoAlpha: logoAlpha * 100,
                            logoPosition: logoPositionSTR || TL,
                            logoScale: logoScale,
                            logoLink: logoLink
                        }, chart.logic.chartInstance);

                    };
                    //error event
                    logoReferenceImage.onerror = function (e) {

                        /**
                         * This event is fired when there was an error in loading external logo added to the chart
                         * using `logoURL` attribute.
                         *
                         * To know more about external logos, see
                         * {@tutorial configuring-your-chart-loading-external-logos}
                         *
                         * @see FusionCharts#event:logoRollover
                         * @see FusionCharts#event:logoRollout
                         * @see FusionCharts#event:logoClick
                         * @see FusionCharts#event:logoLoaded
                         *
                         * @event FusionCharts#logoLoadError
                         * @group chart:logo
                         * @tutorial configuring-your-chart-loading-external-logos
                         *
                         * @param {string} logoURL - is the URL of the logo image.
                         * @param {number} logoAlpha - is the value of the alpha of the logo image.
                         * @param {string} logoPosition - is the position of the chart logo.
                         * @param {number} logoScale - is the value of scaling for logo image.
                         * @param {string} logoLink - is the URL linked to the logo which on clicking will be taken to
                         * the URL link.
                         * @param {string} error - is the error message.
                         */
                        global.raiseEvent(LOGOLOADERROR, {
                            logoURL: logoURL,
                            logoAlpha: logoAlpha * 100,
                            logoPosition: logoPositionSTR || TL,
                            logoScale: logoScale,
                            logoLink: logoLink,
                            error: e
                        }, chart.logic.chartInstance);
                    };

                    logoReferenceImage.src = logoURL;
                    elements.logoImage = chartLogoImage;
                }
            },

            getEventArgs: function (plot) {
                plot = plot || {};
                // fire legenditemclicked event
                var eventArgs = {
                    datasetName: plot.name,
                    datasetIndex: plot.index,
                    id: plot.userID,
                    visible: plot.visible
                };
                return eventArgs;
            },

            legendClick: function (plot, isVisible) {

                var chart = this,
                    item = plot.legend,
                    elements = item && item.elements,
                    legendText = elements && elements.legendItemText,
                    legendIcon = elements && elements.legendItemSymbol,
                    legendIconLine = elements && elements.legendItemLine,
                    hiddenColor = item && item.hiddenColor,
                    itemLineColor = item && item.itemLineColor,
                    itemTextColor = item && item.itemTextColor,
                    symbolColor = item && item.symbolColor,
                    symbolStroke = item && item.symbolStroke,
                    targetVisibility = pluck(isVisible, !plot.visible),
                    relatedSeries,
                    plotIndex,
                    seriesCounter,
                    relatedPlot;

                // toggle visibility
                plot.setVisible(isVisible);

                //change the color of all legend elements depemding upon state
                //show/hide series or point elements
                if (targetVisibility) {
                    legendIcon && legendIcon.attr({
                        fill: symbolColor || itemLineColor,
                        'stroke': symbolStroke
                    });
                    legendText && legendText.attr({
                        fill: itemTextColor
                    });
                    legendIconLine && (legendIconLine.attr({
                        'stroke': itemLineColor
                    }));
                } else {
                    legendIcon && legendIcon.attr({
                        fill: hiddenColor,
                        'stroke': hiddenColor
                    });
                    legendText && legendText.attr({
                        fill: hiddenColor
                    });
                    legendIconLine && (legendIconLine.attr({
                        'stroke': hiddenColor
                    }));
                }

                //get any related series
                relatedSeries = chart.datasets && chart.datasets[plot.index] &&
                    chart.datasets[plot.index].relatedSeries;

                if (relatedSeries && (relatedSeries instanceof Array) && relatedSeries.length > 0) {
                    seriesCounter = relatedSeries.length;
                    while (seriesCounter--) {
                        plotIndex = parseFloat(relatedSeries[seriesCounter]);
                        relatedPlot = chart.plots[plotIndex];
                        //invoke legendClick of the related plot
                        relatedPlot.legendClick.call(relatedPlot, targetVisibility, false);
                    }
                }
            },

            /*
             * This function is used to export a chart
             *
             * ~param {object} exportOption optional exporting configuration
             */
            exportChart: function (exportOption) {
                var renderer = this,
                    fusionCharts = renderer.fusionCharts,

                    options = renderer.options,
                    exportOptions_lowerKeys = isObject(exportOption) && (function (object) { // jshint ignore:line
                        var newObject = {}, key;
                        for (key in object) {
                            newObject[key.toLowerCase()] = object[key];
                        }
                        return newObject;
                    }(exportOption)) || {},
                    optionsExport = extend2(extend2({}, options.exporting),
                        exportOptions_lowerKeys), // jshint ignore:line

                    exportFormat = (optionsExport.exportformat || PNG).toLowerCase(),
                    exportHandler = optionsExport.exporthandler,
                    exportAction = (optionsExport.exportaction || BLANK).toLowerCase(),
                    exportTargetWindow = optionsExport.exporttargetwindow || BLANK,
                    exportFileName = optionsExport.exportfilename,
                    exportParameters = optionsExport.exportparameters;

                // In case exporting is disabled, we need not proceed any further.
                if (!options.exporting || !options.exporting.enabled || !exportHandler) {
                    return false;
                }

                /**
                 * This event is fired before the exporting process of the chart is triggered. This may happen when user
                 * clicks the export context menu on the chart or when programmatically {@link FusionCharts#exportChart}
                 * is called.
                 *
                 * @see FusionCharts#exportChart
                 * @see FusionCharts#event:exported
                 * @see FusionCharts#event:exportCancelled
                 * @tutorial interactivity-export-to-image-or-pdf
                 * @event FusionCharts#beforeExport
                 * @group export
                 *
                 * @param {string} bgcolor - The background color of the exported chart.
                 * @param {string} exportaction - Specifies whether the exported image will be sent back to client as
                 * download, or whether it'll be saved on the server. Possible values are save/download
                 * @param {boolean} exportatclient - Whether to use client side export handlers (the value would be 1),
                 * or server side export handlers (the value would be 0).
                 * @param {string} exportfilename - This attribute specifies the name (excluding the extension) of the
                 * file to be exported.
                 * @param {string} exportformat - The format in which the chart is exported. `jpg`, `png`, pdf`.
                 * @param {string} exporthandler - This refers to the path of the server-side export handler
                 * @param {string} exportparameters - Additional parameters sent by the chart when defined on the chart
                 * data using the `exportParameters` chart attribute.
                 * @param {string} exporttargetwindow - In case of server-side exporting and when using download as
                 * action, this shows whether the return image/PDF would open in same window (as an attachment for
                 * download), or whether it will open in a new window. NOTE: Thus is only available for server side
                 * export.
                 */
                global.raiseEvent('beforeExport', optionsExport, fusionCharts, undefined, function () {

                    var buttons = renderer.layers.buttons,
                        chartId = fusionCharts.id,
                        paper = renderer.paper,
                        postData,
                        frameid,
                        iframe,
                        form,
                        ajax,
                        svg,
                        item;

                    // hide the buttons layer before export
                    buttons && buttons.attr('visibility', 'hidden');

                    // procure the SVG of the current paper.
                    svg = paper.toSVG();

                    // show the buttons layer after export
                    buttons && buttons.attr('visibility', 'visible');

                    // remove the no-effect paths
                    svg = svg.replace(/(\sd\s*=\s*["'])[M\s\d\.]*(["'])/ig, '$1M 0 0 L 0 0$2'); // jshint ignore:line

                    // create the server-side post object
                    postData = {
                        charttype: fusionCharts.chartType(),
                        stream: svg,
                        stream_type: SVG, // jshint ignore:line
                        meta_bgColor: optionsExport.bgcolor || '', // jshint ignore:line
                        meta_bgAlpha: optionsExport.bgalpha || '1', // jshint ignore:line
                        meta_DOMId: fusionCharts.id, // jshint ignore:line
                        meta_width: paper.width, // jshint ignore:line
                        meta_height: paper.height, // jshint ignore:line
                        parameters: [
                            'exportfilename=' + exportFileName,
                            'exportformat=' + exportFormat,
                            'exportaction=' + exportAction,
                            'exportparameters=' + exportParameters
                        ].join('|')
                    };

                    /**
                     * This event is fired before data to be exported is ready.
                     * @event FusionCharts#exportDataReady
                     * @private
                     * @group export
                     *
                     * @param {string} charttype - Name of the chart type that is being exported.
                     * @param {string} meta_DOMId - ID of the span DOM element where the chart was rendered.
                     * @param {string} meta_bgColor - Background color of the span DOM element where the chart is
                     * rendered.
                     * @param {number} meta_height - Height of the span DOM element where the chart is rendered.
                     * @param {number} meta-width - Width of the span DOM element where the chart is rendered.
                     * @param {string} parameters - Contains export related parameters like exportfilename,
                     * exportformat, exportaction, exportparameters. See example below.
                     * @param {string} stream - Contains the vector image format string.
                     * @param {string} stream_type - Type of vector image format.
                     *
                     */
                    global.raiseEvent('exportDataReady', postData, fusionCharts);

                    // In case export action is to download the exported
                    // object, we simply post the chart as a form.
                    if (exportAction === DOWNLOAD) {
                        if (/webkit/ig.test(win.navigator.userAgent) && exportTargetWindow === '_self') {
                            exportTargetWindow = frameid = chartId + 'export_iframe';
                            if (!renderer.exportIframe) {
                                renderer.exportIframe = iframe = createElement('IFRAME', {
                                    name: frameid,
                                    width: '1px',
                                    height: '1px'
                                }, doc.body);
                                iframe.style.cssText = 'position:absolute;left:-10px;top:-10px;';
                            }
                        }
                        // We create a hidden form in the page body and
                        // populate with input elements that contain the
                        // required post data and then submit the form.
                        form = createElement(FORM, {
                            method: POST,
                            action: exportHandler,
                            target: exportTargetWindow,
                            style: 'display:none;'
                        }, doc.body);

                        for (item in postData) {
                            createElement(INPUT, {
                                type: HIDDEN,
                                name: item,
                                value: postData[item]
                            }, form);
                        }

                        form.submit();
                        doc.body.removeChild(form);
                        form = undefined;

                        return true;
                    }
                    // In case we need to save data on server, we would need
                    // to send it as AJAX call and not as form post;
                    else {
                        ajax = new global.ajax(function (resp) {
                            var responseObj = {};
                            // Creete the responce object from responce text.
                            resp.replace(new RegExp('([^?=&]+)(=([^&]*))?', 'g'), function ($0, $1, $2, $3) {
                                responseObj[$1] = $3;
                            });
                            /**
                             * This event is fired if the chart has been successfully exported, i.e., this event is
                             * fired only when value of `exportAction` is `save`. The export could be triggered by
                             * clicking on context menu or by calling the {@link FusionCharts#exportChart} function.
                             *
                             * @see FusionCharts#exportChart
                             * @see FusionCharts#event:beforeExport
                             * @see FusionCharts#event:exportCancelled
                             * @tutorial interactivity-export-to-image-or-pdf
                             * @event FusionCharts#exported
                             * @group export
                             *
                             * @param {string} DOMId - ID of the chart that has been exported
                             * @param {string} statusCode - Indicated the success status of the export process. In case
                             * of failure the value is passed as 0. On success, 1 is provided
                             * @param {string} statusMessage - Success or failure message
                             * @param {string} fileName - The name and path of the file where the exported file has been
                             * saved.
                             * @param {string} width - The width of the chart
                             * @param {string} height - The height of the chart
                             */
                            lib.raiseEvent('exported', responseObj, fusionCharts);
                        }, function (err) {
                            var responseObj = {
                                statusCode: 0,
                                statusMessage: 'failure',
                                error: err,
                                DOMId: chartId,
                                width: paper.width,
                                height: paper.height
                            };

                            lib.raiseEvent('exported', responseObj, fusionCharts, [responseObj]);
                        });
                        ajax.post(exportHandler, postData);
                    }

                }, function () {
                    /**
                     * This event is fired when chart export is cancelled by calling `eventObject.preventDefault()`
                     * during the {@link FusionCharts#event:beforeExport}.
                     *
                     * @see FusionCharts#exportChart
                     * @see FusionCharts#event:beforeExport
                     * @see FusionCharts#event:exported
                     * @tutorial interactivity-export-to-image-or-pdf
                     * @event FusionCharts#exportCancelled
                     * @group export
                     */
                    global.raiseEvent('exportCancelled', optionsExport, fusionCharts);
                });
            },

            print: function (options) {

                var chart =  this,
                    args = extend2({}, options);

                // Block the button while in printing mode
                if (chart.isPrinting) {
                    return false;
                }

                /**
                 * This event is fired before printing has started after calling {@link FusionCharts#print} on a chart.
                 * The {@link FusionCharts#print} method is used to print individual charts on a page.
                 * @see FusionCharts#event:printComplete
                 * @see FusionCharts#event:printCancelled
                 * @see FusionCharts#print
                 * @event FusionCharts#beforePrint
                 * @group export
                 */
                global.raiseEvent(BEFOREPRINT, args, chart.logic.chartInstance, undefined, function () {
                    var container = chart.container,
                        elements = chart.elements,
                        printButton = elements.printButton,
                        exportButton = elements.exportButton,
                        origDisplay = [],
                        origParent = container.parentNode,
                        body = doc.body || doc.getElementsByTagName('body')[0],
                        childNodes = body.childNodes;

                    chart.isPrinting = true;

                    // hide all body content
                    each(childNodes, function (node, i) {
                        if (node.nodeType == 1) {
                            origDisplay[i] = node.style.display;
                            node.style.display = NONE;
                        }
                    });

                    // hide print and export buttons before capturing export data
                    if (args.hideButtons !== false) {
                        printButton && printButton.attrs.visibility != 'hidden' && (printButton.attr({
                            'visibility': 'hidden'
                        }));

                        exportButton && exportButton.attrs.visibility != 'hidden' && (exportButton.attr({
                            'visibility': 'hidden'
                        }));
                    }

                    // pull out the chart
                    body.appendChild(container);

                    // print
                    win.print();

                    // allow the browser to prepare before reverting
                    setTimeout(function () {

                        // show print and export buttons before capturing export data
                        printButton && (printButton.attr({
                            'visibility': 'visible'
                        }));
                        exportButton && (exportButton.attr({
                            'visibility': 'visible'
                        }));

                        // put the chart back in
                        origParent.appendChild(container);

                        // restore all body content
                        each(childNodes, function (node, i) {
                            if (node.nodeType == 1) {
                                node.style.display = origDisplay[i];
                            }
                        });

                        chart.isPrinting = false;
                        /**
                         * This event is fired after user accepts or cancels the browser's print dialog box that was
                         * originally triggered by calling {@link FusionCharts#print} on the chart. The
                         * {@link FusionCharts#print} method is used to print individual charts on a page.
                         * @see FusionCharts#event:beforePrint
                         * @see FusionCharts#event:printCancelled
                         * @see FusionCharts#print
                         * @event FusionCharts#printComplete
                         * @group export
                         */
                        global.raiseEvent(PRINTCOMPLETE, args, chart.logic.chartInstance);
                    }, 1000);
                }, function () {
                    /**
                     * This  event is fired when the printing request from a chart has been  __programmatically__
                     * cancelled by calling `eventObject.preventDefault()` from the
                     * {@link FusionCharts#events:beforePrint} event.
                     *
                     * > Note that this event is not fired when user clicks on the "cancel" button of the
                     * browser-triggered print dialog box resulting from calling the {@link FusionCharts#print}
                     * function.
                     * @see FusionCharts#event:beforePrint
                     * @see FusionCharts#event:printComplete
                     * @see FusionCharts#print
                     * @event FusionCharts#printCancelled
                     * @group export
                     */
                    global.raiseEvent(PRINTCANCELLED, args, chart.logic.chartInstance);
                });
            },

            //function that will create a symbol path for a legend icon.
            getSymbolPath: function (x, y, w, h, seriesType, item, isFlat) {
                /** @todo: have to add group and group style so that we can replivate the safme as fc */
                var path = [M],
                    colorStr = item.color && getFirstColor(typeof item.color === 'string' ?
                        item.color : item.color.FCcolor.color) || BLANK,
                    color, w1, w2, h1, h2, height3, cx1, cx2, cy1, cy2, d1, d2,
                    Z = 'Z',
                    A = 'A',
                    lightColor, strokeWidth = 0.5,
                    strokeColor;

                color = colorStr.replace(dropHash, '');
                strokeColor = getLightColor(color, 60).replace(dropHash, HASHSTRING);
                if (!isFlat) {
                    lightColor = getLightColor(color, 40);
                    color = {
                        FCcolor: {
                            color: color + ',' + color + ',' + lightColor + ',' + color + ',' + color,
                            ratio: '0,30,30,30,10',
                            angle: 0,
                            alpha: '100,100,100,100,100'
                        }
                    };
                }
                else {
                    color = {
                        FCcolor: {
                            color: color,
                            angle: 0,
                            ratio: '0',
                            alpha: '100'
                        }
                    };
                }

                switch (seriesType) {
                case 'column':
                case 'dragcolumn':
                case 'column3d':
                    w1 = w * 0.25;
                    w2 = w1 * 0.5;
                    h1 = h * 0.7;
                    h2 = h * 0.4;

                    path = path.concat([x, y + h, 'l', 0, -h1, w1, 0, 0, h1, 'z',
                        'm', w1 + w2, 0, 'l', 0, -h, w1, 0, 0, h, 'z',
                        'm', w1 + w2, 0, 'l', 0, -h2, w1, 0, 0, h2, 'z'
                    ]);
                    color.FCcolor.angle = 270;
                    break;

                case 'bar':
                case 'bar3d':
                    w1 = w * 0.3;
                    w2 = w * 0.6;
                    h1 = h / 4;
                    h2 = h1 / 2;
                    path = path.concat([x, y, L, x + w2, y, x + w2, y + h1, x, y + h1, Z,
                        M, x, y + h1 + h2, L, x + w, y + h1 + h2, x + w, y + h1 + h2 + h1, x, y + (2 * h1) + h2, Z,
                        M, x, y + 2 * (h1 + h2), L, x + w1, y + 2 * (h1 + h2), x + w1, y + h, x, y + h, Z
                    ]);
                    break;

                case 'area':
                case 'area3d':
                case 'areaspline':
                case 'dragarea':
                    w1 = w * 0.3;
                    w2 = w * 0.6;
                    h1 = h * 0.6;
                    h2 = h * 0.2;
                    height3 = h * 0.8;
                    path = path.concat([x, y + height3, L, x, y + h1, x + w1, y + h2,
                        x + w2, y + h1, x + w, y + h2, x + w, y + height3, Z
                    ]);
                    color.FCcolor.angle = 270;
                    break;

                case 'pie':
                case 'pie3d':

                    w1 = w * 0.5;
                    // Radius
                    w2 = w1 * 0.9;
					d1 = 1;
                    d2 = 1;
                    cx1 = x + w1 + d1;
                    cy1 = y + w1 - d1;
                    cx2 = x + w1 - d2;
                    cy2 = y + w1 + d2;

                    path = path.concat([
                        M, cx1, cy1,
                        L, cx1, cy1 - w2 + d1,
                        A, w2 - d1, w2 - d1, 0, 0, 1, cx1 + w2 - d1, cy1,
                        Z,

                        M, cx2, cy2,
                        L, cx2, cy2 - w2,
                        A, w2, w2, 0, 1, 0, cx2 + w2, cy2,
                        Z
                    ]);

                    color.FCcolor.radialGradient = '1';
                    color.FCcolor.ratio = '0,0,0,100,0';
                    break;
                case 'boxandwhisker2d':
                    path = path.concat([x, y, L, x + w, y, x + w, y + h, x, y + h, Z]);
                    color = item.color;
                    strokeColor = '#000000';
                    break;

                    // A square line for every other request.
                default:
                    path = path.concat([x, y, L, x + w, y, x + w, y + h, x, y + h, Z]);
                    color.FCcolor.angle = 270;
                    color.FCcolor.ratio = '0,70,30';
                }

                return {
                    path: path,
                    color: color,
                    strokeWidth: strokeWidth,
                    strokeColor: strokeColor
                };
            }
        });


        /******************************************************************************
         * Raphael Renderer Extension
         ******************************************************************************/

        function Axis (axisData, renderer, isVertical, isReverse) {

            var axis = this,
                paper = renderer.paper,
                layers = renderer.layers,
                groupName = isVertical ? 'y-axis' : 'x-axis',
                upGroup = axis.layerAboveDataset = layers.layerAboveDataset,
                dipGroup = axis.layerBelowDataset = layers.layerBelowDataset,
                uBands = upGroup.bands || (upGroup.bands = []),
                uBandsLen = uBands.length,
                dBands = dipGroup.bands || (dipGroup.bands = []),
                dBandsLen = dBands.length,
                uLines = upGroup.lines || (upGroup.lines = []),
                uLinesLen = uLines.length,
                dLines = dipGroup.lines || (dipGroup.lines = []),
                dLinesLen = dLines.length,
                uLabels = upGroup.labels || (upGroup.labels = []),
                uLabelsLen = uLabels.length,
                dLabels = dipGroup.labels || (dipGroup.labels = []),
                dLabelsLen = dLabels.length;

            axis.renderer = renderer;
            axis.axisData = axisData || {};

            axis.globalOptions = renderer.options;
            axis.isVertical = isVertical;
            //bands
            axis.topBandGroup = axis.topBandGroup || paper.group(groupName + '-bands', axis.layerAboveDataset);
            axis.belowBandGroup = axis.belowBandGroup || paper.group(groupName + '-bands', axis.layerBelowDataset);
            uBands.push(axis.topBandGroup);
            uBandsLen && (uBands[uBandsLen].insertAfter(uBands[uBandsLen - 1]));
            dBands.push(axis.belowBandGroup);
            dBandsLen && (dBands[dBandsLen].insertAfter(dBands[dBandsLen - 1]));

            axis.topLineGroup = axis.topLineGroup || paper.group(groupName + '-lines', axis.layerAboveDataset);
            axis.belowLineGroup = axis.belowLineGroup || paper.group(groupName + '-lines', axis.layerBelowDataset);
            axis.topLabelGroup = axis.topLabelGroup || paper.group(groupName + '-labels', axis.layerAboveDataset);
            axis.belowLabelGroup = axis.belowLabelGroup || paper.group(groupName + '-labels', axis.layerBelowDataset);

            uLines.push(axis.topLineGroup);
            uLinesLen && (uLines[uLinesLen].insertAfter(uLines[uLinesLen - 1]));
            dLines.push(axis.belowLineGroup);
            dLinesLen && (dLines[dLinesLen].insertAfter(dLines[dLinesLen - 1]));
            uLabels.push(axis.topLabelGroup);
            uLabelsLen && (uLabels[uLabelsLen].insertAfter(uLabels[uLabelsLen - 1]));
            dLabels.push(axis.belowLabelGroup);
            dLabelsLen && (dLabels[dLabelsLen].insertAfter(dLabels[dLabelsLen - 1]));

            axis.isReverse = isReverse;
            this.configure();
        }

        Axis.prototype = {
            configure: function () {
                var axis = this,
                    axisData = axis.axisData,
                    renderer = axis.renderer,
                    isVertical = axis.isVertical,
                    isReverse = axis.isReverse,
                    options = renderer.options,
                    chartOptions = options.chart,
                    chartBottomMargin = chartOptions.marginBottom,
                    chartRightMargin = chartOptions.marginRight,
                    canvasTop = renderer.canvasTop,
                    canvasLeft = renderer.canvasLeft,
                    //start and end pixel of an axis
                    axisMin = axis.min = axisData.min,
                    axisMax = axis.max = axisData.max,
                    span = axis.span = (axisMax - axisMin),
                    axisStartX = axis.startX = pluckNumber(axisData.startX, canvasLeft),
                    axisStartY = axis.startY = pluckNumber(axisData.startY, canvasTop),
                    axisEndX = axis.endX = pluckNumber(axisData.endX, renderer.canvasRight),
                    axisEndY = axis.endY = pluckNumber(axisData.endY, renderer.canvasBottom),
                    pixelRatio = axis.pixelRatio = isVertical ?
                        (axisEndY - axisStartY) / span : (axisEndX - axisStartX) / span,
                    relatedObjs = axis.relatedObj = {};

                relatedObjs.marginObj = {
                    top: axisStartY,
                    right: chartRightMargin,
                    bottom: chartBottomMargin,
                    left: axisStartX
                },
                relatedObjs.canvasObj = {
                    x: axisStartX,
                    y: axisStartY,
                    w: (axisEndX - axisStartX),
                    h: (axisEndY - axisStartY),
                    toX: axisEndX,
                    toY: axisEndY
                };

                axis.startPixel = isReverse ?
                    (isVertical ? axisEndY : axisEndX) : (isVertical ? axisStartY : axisStartX);
                axis.pixelValueRatio = isReverse ? -pixelRatio : pixelRatio;
                axis.primaryOffset = axis.secondaryOffset = 0;

                axis.cache = {
                    lowestVal: 0,
                    highestVal: 0,
                    indexArr: [],
                    hashTable: {}
                };

                //due to clipping of band elements while scrolling we need to
                //expose the below band group
                axis.elements = axis.elements || {};
                if (axis.belowBandGroup) {
                    renderer.elements.axes = renderer.elements.axes || {};
                    renderer.elements.axes.belowBandGroup = axis.belowBandGroup;
                    //apply clip only for scroll charts
                    if (options && options.chart && options.chart.hasScroll) {
                        axis.belowBandGroup.attr({
                            'clip-rect': renderer.elements['clip-canvas']
                        });
                    }
                }

                axis.poi = {};
            },
            draw: function () {

                var axis = this,
                    axisData = axis.axisData,
                    plotLines = axisData && axisData.plotLines || [],
                    plotBands = axisData && axisData.plotBands || [],
                    drawPlotLine = axisData && axisData.showLine,
                    tickLength = axisData && axisData.tickLength,
                    tickWidth = axisData && axisData.tickWidth,
                    title = axisData && axisData.title;

                title && axis.drawAxisName();

                if (axisData && axisData.labels) {
                    axis.renderer.addCSSDefinition('.' + axisData.labels.className + ' .fusioncharts-label',
                        axisData.labels.style);
                    axis.belowLabelGroup && axis.belowLabelGroup.attr('class', axisData.labels.className);
                    axis.topLabelGroup && axis.topLabelGroup.attr('class', axisData.labels.className);
                }

                plotLines && (plotLines.length > 0) && axis.drawPlotLine();
                plotBands && (plotBands.length > 0) && axis.drawPlotBands();
                //draw tick marks only if tickLength & tickWidth defined
                (!isNaN(tickLength) && tickLength !== 0) &&
                    (!isNaN(tickWidth) && tickWidth !== 0) && axis.drawTicks();
                //draw lines if axis lines are defined
                drawPlotLine && axis.drawLine();

            },
            scroll: function () {},
            setOffset: function (primaryOffset, secondaryOffset) {
                var axis = this,
                    pOffsetVal = axis.primaryOffset = primaryOffset, // || axis.primaryOffset,
                    sOffsetVal = axis.secondaryOffset = secondaryOffset || axis.secondaryOffset,
                    isVertical = axis.isVertical,
                    newXPos,
                    newYPos,
                    group,
                    groups = [
                        axis.topLabelGroup,
                        axis.belowLabelGroup,
                        axis.topLineGroup,
                        axis.belowLineGroup,
                        axis.topBandGroup,
                        axis.belowBandGroup
                    ],
                    i,
                    num;

                //now shift all the available groups of this axis
                //Zero could also be a valid value
                for (i = 0, num = groups.length; i < num; i += 1) {
                    group = groups[i];
                    if (group) {
                        newXPos = isVertical ? sOffsetVal : pOffsetVal;
                        newYPos = isVertical ? pOffsetVal : sOffsetVal;
                        group.attr({
                            transform: 't' + newXPos + ',' + newYPos
                        });
                    }
                }
                /* redraw axis lines and labels only for vertical axis.
                 * Limitations:
                 * a. There is no bar scroll charts.
                 * b. No usage of scrolling in vertical axis.
                 */

                if (!isVertical) {
                    axis.drawPlotLine && axis.drawPlotLine();
                }
            },
            update: function () {},
            drawTicks: function () {
                var axis = this,
                    axisData = axis.axisData,
                    renderer = axis.renderer,
                    paper = renderer.paper,
                    axisMin = axis.min,
                    axisMax = axis.max,
                    isVertical = axis.isVertical,
                    belowDatasetLayer = axis.layerBelowDataset,
                    tickGroup = axis.tickGroup = axis.tickGroup || paper.group('axis-ticks', belowDatasetLayer),
                    canvasObj = axis.relatedObj.canvasObj,
                    axisOffset = axisData.offset,
                    isOpposite = axisData.opposite,
                    showAxis = axisData.showAxis,
                    tickInterval = axisData.tickInterval,
                    tickLength = axisData.tickLength,
                    tickWidth = axisData.tickWidth,
                    tickColor = axisData.tickColor,
                    startY,
                    endY,
                    xPos,
                    yPos,
                    tickEndX,
                    axisLineElem,
                    axisTickElem,
                    counter = axisMin;

                //draw the axis line with ticks only if vertical
                if (isVertical && showAxis) {
                    startY = axis.getAxisPosition(axisMin);
                    endY = axis.getAxisPosition(axisMax);
                    xPos = !isOpposite ? canvasObj.x - axisOffset :
                        canvasObj.toX + axisOffset;
                    axisLineElem = paper.path(['M', xPos, startY, 'L', xPos, endY], tickGroup)
                        .attr({
                            stroke: tickColor,
                            'stroke-width': tickWidth
                        });

                    while (mathFloor(counter) <= axisMax) {
                        yPos = axis.getAxisPosition(counter);
                        tickEndX = !isOpposite ? xPos - tickLength :
                            xPos + tickLength;
                        axisTickElem = paper.path(['M', xPos, yPos, 'L', tickEndX, yPos], tickGroup)
                            .attr({
                                stroke: tickColor,
                                'stroke-width': tickWidth
                            });
                        counter += tickInterval;
                    }
                }
            },
            getAxisPosition: function (value, pixelToValue) {
                var axis = this,
                    ret;
                if (pixelToValue) {
                    ret = ((value - axis.startPixel) / axis.pixelValueRatio) +
                        axis.min;
                } else {
                    value = axis.axisData.reversed ? axis.min + (axis.max - value) : value;
                    ret = axis.startPixel + ((value - axis.min) *
                        axis.pixelValueRatio);
                }
                return ret;
            },
            drawPlotLine: function () {

                var axis = this,
                    renderer = axis.renderer,
                    paper = renderer.paper,
                    isVertical = axis.isVertical,
                    isHorizontal = +!isVertical,
                    axisLines = axis.lines = axis.lines || [],
                    axisLabels = axis.labels = axis.labels || [],
                    canvasObj = axis.relatedObj.canvasObj,
                    globalOptions = axis.globalOptions || {},
                    axisElements = axis.elements || {},
                    plotLines = axis.axisData.plotLines || [],
                    primaryOffset = axis.primaryOffset,
                    axisStartPixel = isVertical ? axis.startY : axis.startX,
                    axisEndPixel = isVertical ? axis.endY : axis.endX,
                    canvasBorderWidth = parseFloat(renderer.canvasBorderWidth) || 0,
                    num = mathMax(plotLines.length, (mathMax(axisLines.length, axisLabels.length))),
                    datalabelsLayer = renderer.layers.datalabels,
                    belowLineGroup = axis.belowLineGroup,
                    aboveLineGroup = axis.topLineGroup,
                    belowLabelGroup = axis.belowLabelGroup,
                    aboveLabelGroup = axis.topLabelGroup,
                    // tooltip options
                    tooltipOptions = renderer.tooltip || {},
                    isTooltip = tooltipOptions.enabled !== false,
                    raiseEvent = function (event) {
                        return function (data) {
                            var ele = this;
                            plotEventHandler.call(ele, renderer, data, event);
                        };
                    },
                    xDepth = globalOptions.chart.xDepth || 0,
                    stackSumLabels = [],
                    dataLabelIndex = 0,
                    lineGroupToAdd,
                    labelGroupToAdd,
                    lineElement,
                    labelElement,
                    trackerElement,
                    eventArgs,
                    plotLineObj,
                    plotLineWidth,
                    isVLine,
                    isTrend,
                    isGrid,
                    toolText,
                    plotValue,
                    plotLineColor,
                    plotLineDashStyle,
                    plotLineTrendTo,
                    isStackSum,
                    plotLabel,
                    plotLabelStyle,
                    plotLabelText,
                    plotLabelColor,
                    plotLabeloffsetScaleIndex,
                    plotLabelOffsetScale,
                    plotLabelFontSize,
                    labelFontSize, // redundant usage
                    plotLabelLineHeight,
                    labelLineHeight, // redundant usage
                    plotLabelRotation,
                    plotLabelXPos,
                    plotLabelYPos,
                    plotLabelAlign,
                    plotLabelVAlign,
                    plotLabelTextAlign,
                    labelBorderWidth,
                    labelPadding,
                    labelAlign,
                    css,
                    xPos,
                    yPos,
                    toXPos,
                    toYPos,
                    labelXPos,
                    labelYPos,
                    relatedYAxis,
                    isSlanted,
                    textVAlign,
                    lineCordStr,
                    isLineVisible,
                    isLabelVisible,
                    isNegative,
                    i,
                    sumLength,
                    attrObj,
                    animDuration;

                for (i = 0; i < num; i += 1) {
                    lineElement = labelElement = trackerElement = null;
                    //existing elements should only have its property updated
                    lineElement = axisLines[i];
                    labelElement = axisLabels[i];
                    //get the line object
                    plotLineObj = plotLines[i];
                    //if defined get all properties
                    if (plotLineObj) {
                        plotLineWidth = plotLineObj.width;
                        isVLine = plotLineObj.isVline;
                        isTrend = plotLineObj.isTrend;
                        isGrid = plotLineObj.isGrid;
                        toolText = plotLineObj.tooltext;
                        plotValue = plotLineObj.value;
                        plotLineColor = plotLineObj.color;
                        plotLineDashStyle = plotLineObj.dashStyle;
                        plotLineTrendTo = isTrend ? plotLineObj.to : null;
                        isStackSum = plotLineObj._isStackSum;
                        lineGroupToAdd = plotLineObj.zIndex > 3 ? aboveLineGroup : belowLineGroup;

                        //get the label object
                        plotLabel = plotLineObj.label;
                        //if defined get all properties
                        if (plotLabel) {
                            plotLabelStyle = plotLabel.style;
                            plotLabelText = plotLabel.text;
                            plotLabelColor = plotLabelStyle && plotLabelStyle.color;
                            plotLabeloffsetScaleIndex = plotLabel.offsetScaleIndex || 0;
                            plotLabelOffsetScale = plotLabel.offsetScale;
                            plotLabelFontSize = plotLabelStyle && plotLabelStyle.fontSize;
                            //get the font size is defined
                            if (plotLabelFontSize) {
                                labelFontSize = plotLabelFontSize;
                                if (labelFontSize.indexOf('px') !== -1) {
                                    labelFontSize = labelFontSize.replace('px', '');
                                    labelFontSize = parseFloat(labelFontSize);
                                }
                            }
                            plotLabelLineHeight = plotLabelStyle && plotLabelStyle.lineHeight;

                            if (plotLabelStyle) {
                                css = {
                                    fontFamily: plotLabelStyle.fontFamily,
                                    fontSize: plotLabelStyle.fontSize,
                                    lineHeight: plotLabelStyle.lineHeight,
                                    fontWeight: plotLabelStyle.fontWeight,
                                    fontStyle: plotLabelStyle.fontStyle
                                };
                            }
                            else {
                                css = null;
                            }

                            //get the line height if defined
                            if (plotLabelLineHeight) {
                                labelLineHeight = plotLabelLineHeight;
                                if (labelLineHeight.indexOf('px') !== -1) {
                                    labelLineHeight = labelLineHeight.replace('px', '');
                                    labelLineHeight = parseFloat(labelLineHeight);
                                }
                            }
                            plotLabelRotation = plotLabel.rotation;
                            plotLabelXPos = plotLabel.x || 0;
                            plotLabelYPos = plotLabel.y || 0;
                            plotLabelAlign = plotLabel.align;
                            plotLabelVAlign = plotLabel.verticalAlign;
                            plotLabelTextAlign = plotLabel.textAlign;
                            labelBorderWidth = plotLabel.borderWidth;
                            labelBorderWidth = labelBorderWidth ? labelBorderWidth.indexOf('px') !== -1 ?
                                labelBorderWidth.replace('px', '') : 1 : 1;
                            // For stack sum value using datalabelsLayer to manage
                            // animation.
                            labelGroupToAdd = isStackSum ? datalabelsLayer :
                                (plotLineObj.zIndex >= 3 ? aboveLabelGroup : belowLabelGroup);

                            if (plotLabel.backgroundColor) {
                                plotLabel.labelBgClr = toRaphaelColor({
                                    'color': plotLabel.backgroundColor,
                                    'alpha': plotLabel.backgroundOpacity * 100
                                });
                            }
                            if (plotLabel.borderColor) {
                                plotLabel.labelBorderClr = toRaphaelColor({
                                    'color': plotLabel.borderColor,
                                    'alpha': '100'
                                });
                            }

                            labelPadding = labelFontSize ? labelFontSize * 0.2 : 2;
                            labelAlign = plotLabelTextAlign === 'left' ? 'start' :
                                plotLabelTextAlign === 'right' ? 'end' : 'middle';
                        }
                    }

                    // redefine state
                    isLineVisible = 'visible';
                    isLabelVisible = 'visible';
                    isNegative = pluckNumber(plotLabelOffsetScale, plotValue, 0) < 0;

                    // calculate the dynamic attributes
                    // vertical axis
                    if (isVertical) {
                        yPos = axis.getAxisPosition(plotValue);
                        toYPos = isTrend ? axis.getAxisPosition(plotLineTrendTo) || yPos : yPos;
                        isSlanted = yPos !== toYPos ? true : false;
                        lineCordStr = [M, canvasObj.x, yPos, L, canvasObj.toX, toYPos];
                        if (isVLine) {
                            if (renderer.logic.isBar) {
                                relatedYAxis = renderer.yAxis[plotLabeloffsetScaleIndex];
                                if (!isStackSum && !isNaN(plotLabelOffsetScale) && plotLabelOffsetScale >= 0 &&
                                        plotLabelOffsetScale <= 1) {
                                    plotLabelOffsetScale = relatedYAxis.min + (relatedYAxis.max - relatedYAxis.min) *
                                        plotLabelOffsetScale;
                                }
                                /** @todo  Not sure why
                                 * 'getAxisPosition(plotLabelOffsetScale || plotValue)'
                                 * was added instead of using pluckNumber to get the
                                 * value between plotLabelOffsetScale and plotValue
                                 */
                                toXPos = relatedYAxis.getAxisPosition(pluckNumber(plotLabelOffsetScale, plotValue)) +
                                    plotLabelXPos + labelPadding * (isNegative ? -1 : 1);
                            }
                        } else {
                            //in case the plotLabel is not defined // Ex. Log Charts
                            if (plotLabel) {
                                toXPos = xPos = (axis.axisData.isOpposite || plotLabelAlign === 'right') ?
                                    canvasObj.toX + plotLabelXPos :
                                    canvasObj.x + plotLabelXPos;
                            } else {
                                toXPos = xPos = (axis.axisData.isOpposite) ? canvasObj.toX : canvasObj.x;
                            }
                        }
                    }
                    //horizontal axis
                    else {
                        /**
                         * @todo
                         * Not sure why '+ plotLabelXPos' was added in axis.getAxisPosition(plotValue) + plotLabelXPos
                         * Removed '+ plotLabelXPos' presently to fix #RED-460 - VGridColor shifts when
                         * labelDisplay='ROTATE' in MS Line/Area charts
                         *
                         * xPos = isTrend ? axis.getAxisPosition(plotValue) : axis.getAxisPosition(plotValue) || 0;
                         * is re-factored for the above change. these comments should be removed.
                         */
                        xPos = axis.getAxisPosition(plotValue) || 0;
                        toXPos = isTrend ? axis.getAxisPosition(plotLineTrendTo) || xPos : xPos;
                        //Need to shift the div lines in Bar3D by xDepth value
                        //Shift only div lines
                        if (!isTrend && !isVLine && xDepth > 0) {
                            xPos += xDepth;
                            toXPos += xDepth;
                            //shift end pixel so that checking works perfect
                            axisEndPixel += xDepth;
                        }
                        isSlanted = (xPos !== toXPos ? true : false);
                        lineCordStr = [M + xPos, canvasObj.y, L, toXPos, canvasObj.toY];
                        //rotated labels need sligh adjustment for x axis end limit calculation
                        //plotLabelRotation && labelFontSize && (axisEndPixel += labelFontSize * 0.5);

                        isLineVisible = ((xPos + primaryOffset) < axisStartPixel ||
                            (xPos + primaryOffset) > axisEndPixel) ? 'hidden' : isLineVisible;
                        if (isVLine) {
                            //if no scale index is defined take the first one
                            relatedYAxis = renderer.yAxis[plotLabeloffsetScaleIndex];
                            //PATCH-FIX to get relative positions for Vline Label Postion
                            //This SHOULD HAVE BEEN PASSED AS AN ACTUAL VALUE , BUT THEY ARE PASSED
                            //AS PERCENTAGE BETWEEN 0-1
                            if (!isStackSum && !isNaN(plotLabelOffsetScale) && plotLabelOffsetScale >= 0 &&
                                    plotLabelOffsetScale <= 1) {
                                plotLabelOffsetScale = relatedYAxis.min + (relatedYAxis.max - relatedYAxis.min) *
                                    (1 - plotLabelOffsetScale);
                            }
                            /** @todo  Not sure why
                             * 'getAxisPosition(plotLabelOffsetScale || plotValue)'
                             * was added instead of using pluckNumber to get the
                             * value between plotLabelOffsetScale and plotValue
                             */
                            yPos = relatedYAxis.getAxisPosition(pluckNumber(plotLabelOffsetScale, plotValue)) +
                                plotLabelYPos;
                            //in case of v line boder width should be deducted
                            yPos -= (canvasBorderWidth + parseFloat(labelBorderWidth)) *
                                (plotLabelYPos && (plotLabelYPos > 0 ? -1 : 1));
                        } else {
                            //this is a very remote use case - when x axis labels are placed on top of canvas
                            if (axis.axisData.opposite || (plotLabelVAlign === 'top' && !isGrid)) {
                                yPos = canvasObj.y + plotLabelYPos;
                                textVAlign = 'bottom';
                            } else {
                                yPos = canvasObj.toY + plotLabelYPos;
                            }
                        }
                        toYPos = yPos;
                    }

                    // we do not create or draw labels or lines which are
                    //not in the visible area
                    //We do not have y axis scroll feature
                    isLabelVisible = !isVertical ? ((toXPos + primaryOffset) < axisStartPixel ||
                        (toXPos + primaryOffset) > axisEndPixel) ?
                        'hidden' : isLabelVisible :
                        isLabelVisible;

                    //now depending on the conditions either create a new
                    //element or modify, delete the existing element
                    /*
                     * Create line element only if :
                     * A> Line element is not already created.
                     * B> Data to create line is defined
                     * C> line is within the visible area
                     * D> line has a thickness of atleast greater than 0
                     */
                    if (plotLineObj && isLineVisible === 'visible' && plotLineWidth > 0.1) {
                        attrObj = {
                            path: getCrispPath(lineCordStr, plotLineWidth),
                            stroke: plotLineColor,
                            'stroke-width': plotLineWidth,
                            'shape-rendering': !isSlanted && plotLineWidth >= 1 ? CRISP : undefined,
                            // Dash gap
                            'stroke-dasharray': plotLineDashStyle ? plotLineDashStyle : undefined,
                            visibility: isLineVisible
                        };

                        if (!lineElement) {
                            //create with style as style never changes
                            lineElement = axisLines[i] =
                                paper.path(attrObj, lineGroupToAdd).css(plotLineObj.style);

                            //store in axis elements
                            axisElements.lines = axisElements.lines || [];
                            axisElements.lines.push(lineElement);
                        }
                        else {
                            lineElement.attr(attrObj);
                        }

                        if (isTooltip && toolText && plotLineWidth < HTP && isLineVisible) {
                            trackerElement = paper.path({
                                stroke: TRACKER_FILL,
                                'stroke-width': HTP,
                                'ishot': true,
                                path: lineCordStr,
                                fill: TRACKER_FILL
                            }, renderer.layers.tracker);
                        }

                        trackerElement = trackerElement || lineElement;
                        isTooltip && toolText && trackerElement.tooltip(toolText);
                    }
                    /*
                     * Remove existing line element only if
                     * A> Line exists but no data to further modify
                     * B> Line is outside visible area
                     * connected label element also need to be removed
                     * if exists.
                     */
                    else if (lineElement || labelElement) {
                        lineElement && lineElement.remove();
                        lineElement = null;

                        axisLines && (axisLines[i] = null);
                        axisElements && axisElements.lines &&
                            (axisElements.lines[i] = null);
                    }

                    if (plotLabel && plotLineObj && !plotLineObj.stepped && isLabelVisible === 'visible' &&
                        plotLabel.text != BLANK && plotLabel.text != ' ') {

                        //Now for trend lines depending its position
                        //(left or right) we need to set its y position
                        if (isTrend) {
                            labelYPos = plotLabelAlign === 'left' ? yPos : toYPos;
                        } else {
                            labelYPos = toYPos;
                        }
                        labelXPos = toXPos - ((+!isVLine) * isHorizontal * xDepth) +
                            (isHorizontal * (plotLabelXPos || 0));

                        //All stack sum labels should have a vertical align set
                        //as bottom. Trend (stack100Percent) and Vline both are
                        //used to set stack sum
                        if (isStackSum) {
                            textVAlign = (isVertical || plotLabelRotation) ? 'middle' : 'bottom';
                            /** @todo not sure about this padding */
                            labelYPos += (isVertical ? 0 : labelFontSize * (isNegative ? - 0.4 : 0.4));
                            if (plotLabelRotation) {
                                labelYPos += isNegative ? 4 : -2; // this constant compensates text gutter
                                labelAlign = isNegative ? 'end' : 'start';
                            }

                        }
                        else if (isHorizontal && axis.axisData.opposite) {
                            //HeatMap chart placeXAxisLabelsOnTop usage
                            textVAlign = POSITION_BOTTOM;
                            labelAlign = plotLabelRotation ? POSITION_START : POSITION_MIDDLE;
                        } else {
                            textVAlign = plotLabelVAlign;
                        }
                        //for multiLine labels the labels should be aligned to top
                        if ((/\n|<br\s*?\/?>/ig).test(plotLabelText)) {
                            if (isGrid) {
                                if (plotLabelRotation) {
                                    textVAlign = POSITION_MIDDLE;
                                    //Fix for RED-970, posining issue in rotated multiline text.
                                    // @TODO: fix should be in x axis space management.
                                    // plotLabelXPos will be 0 for MUlti-line cat label
                                    labelXPos -= (isHorizontal * (plotLabelXPos || 0));
                                } else {
                                    // HeatMap chart placeXAxisLabelsOnTop usage
                                    textVAlign = (isHorizontal &&
                                        axis.axisData.opposite && !plotLabelRotation) ?
                                        POSITION_MIDDLE : POSITION_TOP;
                                    //but we also have to match the end of first line
                                    //to match previous implementation
                                    labelYPos -= labelLineHeight;
                                }
                            }
                        }

                        //remove all previous applied rotation / transformation
                        attrObj = {
                            'class': 'fusioncharts-label',
                            text: plotLabelText,
                            fill: (css ? (plotLabelColor || plotLineColor) : null),
                            title: plotLabel && (plotLabel.originalText || BLANK),
                            cursor: plotLabel.link ? 'pointer' : BLANK,
                            x: labelXPos,
                            y: labelYPos,
                            'text-anchor': labelAlign,
                            'vertical-align': textVAlign,
                            transform: ' ',
                            'text-bound': [plotLabelStyle.backgroundColor || plotLabel.labelBgClr,
                                plotLabelStyle.borderColor || plotLabel.labelBorderClr,
                                plotLabelStyle.borderThickness || labelBorderWidth,
                                plotLabelStyle.borderPadding || labelPadding,
                                plotLabelStyle.borderRadius, plotLabelStyle.borderDash
                            ],
                            visibility: isLabelVisible,
                            'line-height': plotLabelStyle.lineHeight
                        };

                        /*
                         * Create label element only if :
                         * A> Label element is not already created.
                         * B> Data to create label element is defined.
                         * C> Label is not a stepped label
                         * D> Label is within visible area
                         * E> text for the label is not BLANK
                         * @todo: what if double space is defined?
                         */
                        if (!labelElement) {

                            labelElement = axisLabels[i] = paper.text(attrObj, labelGroupToAdd).attr('class',
                                'fusioncharts-label');

                            if (lineElement) {
                                lineElement.label = labelElement;
                            }
                            //store in axis elements
                            axisElements.labels = axisElements.labels || [];
                            axisElements.labels.push(labelElement);
                        }
                        else {
                            labelElement.attr(attrObj);
                        }

                        css && labelElement.css(css);

                        // Attach the event for datalabels only
                        if (plotLineObj.isDataLabel) {

                            eventArgs = {
                                text: plotLabelText,
                                index: dataLabelIndex,
                                link: plotLabel.link
                            };
                            dataLabelIndex += 1;

                            /**
                             * Data-labels refer to the x-axis labels of the data
                             * This event is fired when a datalabel is clicked.
                             *
                             * This event is applicable to the chart where data labels are present.
                             *
                             * @event FusionCharts#dataLabelClick
                             *
                             * @param {string} text - The data label in the axis
                             * @see FusionCharts#event:dataLabelRollOver
                             * @see FusionCharts#event:dataLabelRollOut
                             */
                            labelElement.click(raiseEvent('dataLabelClick'))
                            /**
                             * Data-labels refer to the x-axis labels of the data
                             * This event is fired when the pointer moves over a datalabel.
                             *
                             * This event is applicable to the chart where data labels are present.
                             *
                             * @event FusionCharts#dataLabelRollOver
                             *
                             * @param {string} text - The data label in the axis
                             * @see FusionCharts#event:dataLabelClick
                             * @see FusionCharts#event:dataLabelRollOut
                             */
                            .hover(raiseEvent('dataLabelRollOver'),
                            /**
                             * Data-labels refer to the x-axis labels of the data
                             * This event is fired when the pointer moves out of a datalabel.
                             *
                             * This event is applicable to the chart where data labels are present.
                             *
                             * @event FusionCharts#dataLabelRollOut
                             *
                             * @param {string} text - The data label in the axis
                             * @see FusionCharts#event:dataLabelRollOver
                             * @see FusionCharts#event:dataLabelClick
                             */
                            raiseEvent('dataLabelRollOut'))
                            .data('eventArgs', eventArgs);
                        }

                        if (plotLabelRotation) {
                            labelElement.attr('transform', ['r', plotLabelRotation, labelXPos, labelYPos]);
                        }

                        if (isStackSum && labelElement) {
                            stackSumLabels.push(labelElement);
                        }
                    }
                    else if (labelElement) {
                        /**
                         * Remove Existing label element only if
                         * A> Label exists but no data to further modify
                         * B> Label is BLANK
                         * C> Label is stepped
                         * D> Label is outside visible area
                         */
                        labelElement.isRotationSet = false;
                        labelElement.remove();
                        axisLabels && (axisLabels[i] = null);
                        axisElements && axisElements.labels &&
                            (axisElements.labels[i] = null);
                    }

                    /* At this we need not proceed further if
                     * 1. Line and Label element both does not exist
                     * 2. plot line object has no value defined
                     */
                    if ((!lineElement && !labelElement) || (plotLineObj && plotLineObj.value === null)) {
                        //remove references
                        lineElement = labelElement = null;
                        continue;
                    }

                    if (plotLineObj && plotLineObj.isMinLabel) {
                        axis.poi.min = {
                            label: labelElement,
                            index: i,
                            line: lineElement
                        };
                    } else if (plotLineObj && plotLineObj.isMaxLabel) {
                        axis.poi.max = {
                            label: labelElement,
                            index: i,
                            line: lineElement
                        };
                    } else if (plotLineObj && plotLineObj.isZeroPlane) {
                        axis.poi.zero = {
                            label: labelElement,
                            index: i,
                            line: lineElement
                        };
                    }
                    //remove refernces
                    lineElement = labelElement = null;
                }

                //iterate over all stack sum labels and initially hide them
                //show them after the animation complete
                sumLength = stackSumLabels.length;
                animDuration = pluckNumber(renderer.options.plotOptions.series.animation.duration, 0);
            },

            drawPlotBands: function () {

                var axis = this,
                    renderer = axis.renderer,
                    paper = renderer.paper,
                    isVertical = axis.isVertical,
                    plotBands = axis.axisData.plotBands || [],
                    axisBands = axis.bands = axis.bands || [],
                    axisLabels = axis.bandLabels = axis.bandLabels || [],
                    canvasObj = axis.relatedObj.canvasObj,
                    primaryOffset = axis.primaryOffset,
                    axisStartPixel = isVertical ? axis.startY : axis.startX,
                    axisEndPixel = isVertical ? axis.endY : axis.endX,
                    hasScroll = renderer.options.chart.hasScroll,
                    belowBandGroup = axis.belowBandGroup,
                    aboveBandgroup = axis.topBandGroup,
                    belowLabelGroup = axis.belowLabelGroup,
                    aboveLabelGroup = axis.topLabelGroup,
                    axisElements = axis.elements || {},

                    // tooltip options
                    tooltipOptions = renderer.tooltip || {},
                    isTooltip = tooltipOptions.enabled !== false,

                    plotBandObj,

                    toolText,
                    plotBandTo,
                    plotBandFrom,
                    plotBandValue,
                    plotBandWidth,
                    plotBandColor,

                    plotLabel,
                    plotLabelStyle,
                    plotLabelBorderWidth,
                    plotLabelAlign,
                    plotLabelX,
                    plotLabelY,
                    plotLabelFontSize,
                    plotLabelLineHeight,
                    plotLabelTextAlign,
                    plotLabelVAlign,
                    plotLabelText,
                    plotLabelOriginalText,
                    plotLabelColor,
                    plotLabelBGColor,
                    plotLabelBGOpacity,
                    plotLabelBorderColor,
                    plotLabelBorderType,
                    plotLabelRaphaelColor,
                    plotLabelRaphaelBorderColor,
                    labelBorderWidth,
                    labelFontSize,
                    labelLineHeight,

                    toPx,
                    fromPx,
                    attrObj,

                    bandStartX,
                    bandStartY,
                    bandEndX,
                    bandEndY,

                    bandH,
                    bandW,

                    labelXPos,
                    labelYPos,

                    bandGroupToAdd,
                    labelGroupToAdd,

                    bandElement,
                    labelElement,

                    isBandVisible,
                    isLabelVisible,

                    i,
                    num = mathMax(plotBands.length, axisBands.length);

                for (i = 0; i < num; i += 1) {
                    //refresh state
                    isBandVisible = 'visible';
                    isLabelVisible = 'visible';

                    //existing elements
                    bandElement = axisBands[i];
                    labelElement = axisLabels[i];

                    //get the band object
                    plotBandObj = plotBands[i];
                    if (plotBandObj) {
                        toolText = plotBandObj.tooltext;
                        plotBandTo = plotBandObj.to;
                        plotBandFrom = plotBandObj.from;
                        plotBandValue = plotBandObj.value;
                        plotBandWidth = plotBandObj.width;
                        plotBandColor = plotBandObj.color;
                        bandGroupToAdd = plotBandObj.zIndex > 3 ? aboveBandgroup : belowBandGroup;

                        plotLabel = plotBandObj.label;
                        if (plotLabel) {
                            plotLabelStyle = plotLabel.style;
                            if (plotLabelStyle) {
                                plotLabelFontSize = plotLabelStyle.fontSize;
                                //get the font size is defined
                                if (plotLabelFontSize) {
                                    labelFontSize = plotLabelFontSize;
                                    if (labelFontSize.indexOf('px') !== -1) {
                                        labelFontSize = labelFontSize.replace('px', '');
                                        labelFontSize = parseFloat(labelFontSize);
                                    }
                                }
                                plotLabelLineHeight = plotLabelStyle.lineHeight;
                                //get the line height if defined
                                if (plotLabelLineHeight) {
                                    labelLineHeight = plotLabelLineHeight;
                                    if (labelLineHeight.indexOf('px') !== -1) {
                                        labelLineHeight = labelLineHeight.replace('px', '');
                                        labelLineHeight = parseFloat(labelLineHeight);
                                    }
                                }
                                plotLabelColor = plotLabelStyle.color;
                            }
                            plotLabelBorderWidth = plotLabel.borderWidth;
                            labelBorderWidth = plotLabelBorderWidth ? plotLabelBorderWidth.indexOf('px') !== -1 ?
                                plotLabelBorderWidth.replace('px', '') : 1 : 1;
                            plotLabelAlign = plotLabel.align;
                            plotLabelX = plotLabel.x;
                            plotLabelY = plotLabel.y;
                            plotLabelText = plotLabel.text;
                            plotLabelOriginalText = plotLabel.originalText;
                            plotLabelBGColor = plotLabel.backgroundColor;
                            plotLabelBGOpacity = plotLabel.backgroundOpacity;
                            if (plotLabelBGColor) {
                                plotLabelRaphaelColor = plotLabel.labelBgClr =
                                    toRaphaelColor({
                                        'color': plotLabelBGColor,
                                        'alpha': plotLabelBGOpacity * 100
                                    });
                            }
                            plotLabelBorderColor = plotLabel.borderColor;
                            if (plotLabelBorderColor) {
                                plotLabelRaphaelBorderColor = plotLabel.labelBorderClr =
                                    toRaphaelColor({
                                        'color': plotLabelBorderColor,
                                        'alpha': '100'
                                    });
                            }
                            plotLabelTextAlign = plotLabel.textAlign;
                            plotLabelTextAlign = plotLabelTextAlign === 'left' ? 'start' :
                                plotLabelTextAlign === 'right' ? 'end' : 'middle';
                            plotLabelVAlign = plotLabel.verticalAlign;
                            plotLabelBorderType = plotLabel.borderType;
                            labelGroupToAdd = plotBandObj.zIndex > 3 ?
                                aboveLabelGroup : belowLabelGroup;
                        }
                    }

                    //logic - calculate cords and bands
                    // value might come for drawing lines on bands (HeatMap chart implementation)
                    toPx = axis.getAxisPosition(
                        pluckNumber(plotBandTo, plotBandValue));
                    fromPx = axis.getAxisPosition(
                        pluckNumber(plotBandFrom, plotBandValue));
                    bandStartX = (isVertical) ? canvasObj.x : fromPx;
                    bandStartY = (isVertical) ? toPx : canvasObj.y;
                    bandW = (isVertical) ? canvasObj.w : (!axis.axisData.reversed ?
                        toPx - fromPx : fromPx - toPx) || plotBandWidth || 1;

                    // bandH = (isVertical) ?
                    //           (!axis.axisData.reversed ?
                    //           fromPx - toPx
                    //           : toPx - fromPx) || plotBandWidth || 1 : canvasObj.h;

                    bandH = isVertical ? (fromPx - toPx) || 1 : canvasObj.h;
                    bandEndX = bandStartX + bandW;
                    bandEndY = bandStartY + bandH;

                    //to skip runtime error
                    //negative band width & height may fire error
                    bandW = mathAbs(bandW);
                    //bandH = mathAbs(bandH);
                    if (bandH < 0) {
                        bandH = mathAbs(bandH);
                        bandStartY -= bandH;
                    }

                    /*
                     * vertical bands are not supported in scroll charts yet.
                     * This helps us to ommit bands visibility management for
                     * scroll charts based on scrolling.
                     * for safety we apply the same logic for non-scroll charts
                     * but the chances of bands appearing outside of visible
                     * area in non-scroll charts are almost nill.
                     */

                    //we do not have y axis scroll
                    if (!isVertical) {
                        if (!hasScroll) {
                            isBandVisible = ((bandStartX + primaryOffset) > axisEndPixel ||
                                (bandEndX + primaryOffset) < axisStartPixel) ?
                                'hidden' : isBandVisible;
                        } else {
                            isBandVisible = 'hidden';
                        }
                    }

                    /*
                     * Labels visibility
                     */
                    //we do not have y axis scrolling
                    isLabelVisible = !isVertical ?
                        ((labelXPos + primaryOffset) < axisStartPixel || (labelXPos + primaryOffset) > axisEndPixel) ?
                        'hidden' : isLabelVisible :
                        isLabelVisible;

                    if (plotLabel) {
                        labelXPos = (isVertical) ?
                            plotLabelAlign === 'right' ?
                            (canvasObj.toX + plotLabelX) : (canvasObj.x + plotLabelX) : (bandStartX + bandW / 2);

                        labelYPos = (isVertical) ?
                            (bandStartY + bandH / 2) : (canvasObj.toY + plotLabelY);

                    }

                    // now depending on the condotions either create a new element
                    // or delete / modify the existing element.

                    /*
                     * Create band element only if
                     * A> Band element already does not exist
                     * B> Data for the band is available
                     * C> Band is within the visible area
                     * Connected labels are also created
                     */
                    if (!bandElement && plotBandObj && isBandVisible === 'visible') {
                        //create one rect element
                        //store in axis elements
                        attrObj = {
                            x: bandStartX,
                            y: bandStartY,
                            width: bandW,
                            height: bandH,
                            fill: toRaphaelColor(plotBandColor),
                            'stroke-width': 0
                        };

                        if (!bandElement) {
                            bandElement = axisBands[i] = paper.rect(attrObj, bandGroupToAdd);
                            axisElements.bands = axisElements.bands || [];
                            axisElements.bands[i] = bandElement;
                        }
                        else {
                            bandElement.attr(attrObj);
                        }

                        isTooltip && toolText && bandElement.tooltip(toolText);
                    }
                    /*
                     * Remove a band element only if
                     * A> The element exists
                     * B> No data to update the element
                     * C> The band is not with in the visible area.
                     * Connected labels if found are also removed.
                     */
                    else if (bandElement && (!plotBandObj || isBandVisible === 'hidden')) {
                        //remove labels if found
                        axisElements.labels &&
                            (axisLabels[i] = axisElements.labels[i] = null);
                        bandElement.label && bandElement.label.remove();
                        //remove band
                        axisBands[i] = axisElements.bands[i] = null;
                        bandElement.remove();
                        bandElement = null;
                        //terminate further execution
                        continue;
                    }

                    //create the corresponding label as well
                    if (bandElement && plotLabel && plotLabel.text) {
                        attrObj = {
                            'class': 'fusioncharts-label',
                            text: plotLabelText,
                            title: (plotLabelOriginalText || ''),
                            fill: plotLabelColor,
                            'text-bound': [plotLabelRaphaelColor, plotLabelRaphaelBorderColor,
                                plotLabelBorderWidth, (plotLabelFontSize * 0.2), (plotLabelBorderType === 'solid') ?
                                    false : true
                            ],
                            x: labelXPos,
                            y: labelYPos, // - labelFontSize,
                            'text-anchor': plotLabelTextAlign,
                            'vertical-align': plotLabelVAlign,
                            'line-height': plotLabelStyle.lineHeight
                        };

                        if (!labelElement) {
                            labelElement = axisLabels[i] = bandElement.label =
                                paper.text(attrObj, labelGroupToAdd).attr('class', 'fusioncharts-label');

                            plotLabelStyle && labelElement.css(plotLabelStyle);
                            //store in axis elements
                            axisElements.labels = axisElements.labels || [];
                            axisElements.labels[i] = labelElement;
                        }
                        else {
                            labelElement.attr(attrObj);
                        }
                    }
                }
                //remove refernces
                bandElement = labelElement = null;
            },

            drawAxisName: function () {

                var axis = this,
                    axisData = axis.axisData,
                    axisTitle = axisData.title || {},
                    style = axisTitle && axisTitle.style,
                    axisTitleClass = axisTitle && axisTitle.className,
                    titleAlign = axisTitle.align,
                    centerYAxisName = axisTitle.centerYAxisName || false,
                    paper = axis.renderer.paper,
                    isVertical = axis.isVertical,
                    canvasObj = axis.relatedObj.canvasObj,
                    axisOffset = pluckNumber(axisData.offset, 0),
                    axisDist = axisOffset + pluckNumber(axisTitle.margin, 0),
                    axisName = axisTitle.text || '',
                    axisNameElement = axis.name || undefined,
                    isOpposite = axisData.opposite,
                    belowDatasetLayer = axis.layerBelowDataset,
                    axisNameGroup = belowDatasetLayer.nameGroup = belowDatasetLayer.nameGroup ||
                        paper.group('axis-name', belowDatasetLayer),
                    rotation = pluckNumber(axisTitle.rotation, !isOpposite ? 270 : 90),
                    xPos = isVertical ? (isOpposite ? (canvasObj.toX + axisDist) : (canvasObj.x - axisDist)) :
                        ((canvasObj.x + canvasObj.toX) / 2),
                    css = {
                        fontFamily: style.fontFamily,
                        fontSize: style.fontSize,
                        lineHeight: style.lineHeight,
                        fontWeight: style.fontWeight,
                        fontStyle: style.fontStyle
                    },
                    attrObj,
                    yPos,
                    fontSize,
                    valign;

                if (isVertical) {
                    if (titleAlign === 'low') {
                        yPos = canvasObj.toY;
                    } else {
                        if (centerYAxisName) {
                            yPos = (canvasObj.y + canvasObj.toY) / 2;
                        } else {
                            yPos = axis.renderer.chartHeight / 2;
                        }

                    }
                } else {
                    yPos = canvasObj.toY + axisDist;
                }

                if (axisName) {

                    // In case of rotated vertical axis names & to match the default SVG
                    // first line base as the YPos need to shift one line
                    // no need to manage if rotation is 0.
                    if (!isNaN(rotation) && rotation && isVertical) {
                        fontSize = style.fontSize;
                        fontSize = fontSize.indexOf('px') != -1 ? fontSize.replace('px', '') : fontSize;
                        if (isOpposite) {
                            xPos = xPos + parseFloat(fontSize);
                            valign = (rotation === 270) ? 'bottom' : 'top';
                        } else {
                            xPos = xPos - parseFloat(fontSize);
                            valign = (rotation === 270) ? 'top' : 'bottom';
                        }
                    }

                    axis.renderer.addCSSDefinition('.' + axisTitleClass, css);

                    attrObj = {
                        'class': axisTitleClass,
                        x: 0,
                        y: 0,
                        text: axisName,
                        fill: style.color,
                        'text-anchor': titleAlign === 'low' ? isOpposite ? rotation == 90 ?
                            POSITION_END : POSITION_START : rotation == 90 ? POSITION_END :
                            POSITION_START : POSITION_MIDDLE,
                        'vertical-align': isVertical ? (!rotation ? POSITION_MIDDLE : valign) :
                            (isOpposite ? POSITION_BOTTOM : 'top'),
                        transform: isVertical ? 't' + xPos + ',' + yPos + 'r' + rotation :
                            't' + xPos + ',' + yPos,
                        'font-size': style.fontSize
                    };

                    axisTitle.originalText && (attrObj.title = axisTitle.originalText);

                    if (!axisNameElement) {
                        axisNameElement = axis.name = paper.text(attrObj, axisNameGroup);
                    }
                    else {
                        axisNameElement.attr(attrObj);
                    }

                    // Axis name border attributes need to be applied after applying the attributes of axis element.
                    axisNameElement.attr({
                        'line-height': style.lineHeight,
                        'text-bound': [style.backgroundColor, style.borderColor,
                        style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash]
                    });
                }
                else {
                    //no eist but no data to update; remove the name
                    if (axisNameElement) {
                        axisNameElement.remove();
                    }
                }
                //store to elements
                axis.elements.name = axisNameElement;
            },

            drawLine: function () {

                var axis = this,
                    axisData = axis.axisData,
                    renderer = axis.renderer,
                    paper = renderer.paper,
                    axisMin = axis.min,
                    axisMax = axis.max,
                    isVertical = axis.isVertical,
                    isOpposite = axisData.opposite,
                    belowDatasetLayer = axis.layerBelowDataset,
                    axisLineGroup = axis.lineGroup = axis.lineGroup ||
                        paper.group('axis-lines', belowDatasetLayer),
                    lineColor = axisData.lineColor,
                    lineThickness = axisData.lineThickness,
                    lineEndExtension = axisData.lineEndExtension || 0,
                    lineStartExtension = axisData.lineStartExtension || 0,
                    canvasObj = axis.relatedObj.canvasObj,
                    startY,
                    endY,
                    startX,
                    endX,
                    axisLineElem;

                //draw the axis lines
                if (isVertical) {
                    startY = axis.getAxisPosition(axisMin) - lineStartExtension;
                    endY = axis.getAxisPosition(axisMax) + lineEndExtension;
                    /** @todo: here we need to add the line padding */
                    startX = endX = !isOpposite ?
                        canvasObj.x - (lineThickness / 2) : canvasObj.toX + (lineThickness / 2);
                } else {
                    startX = canvasObj.x - lineStartExtension;
                    endX = canvasObj.toX + lineEndExtension;
                    startY = endY = !isOpposite ?
                        canvasObj.toY + (lineThickness / 2) : canvasObj.y - (lineThickness / 2);
                }

                axisLineElem = paper.path({
                    path: ['M', startX, startY, 'L', endX, endY],
                    stroke: lineColor,
                    'stroke-width': lineThickness
                }, axisLineGroup);

                //store to elements
                axis.elements.axisLine = axisLineElem;
                // console.log("Axis Line");
                // console.log(new Date() - timeS);
            },
            /*
             * update the drawing of the x axis during realtime update
             */
            realtimeUpdateX: function (shift) {
                if (shift > 0) {
                    var axis = this,
                        axisData = axis.axisData,
                        plotBands = axisData.plotBands,
                        plotLines = axisData.plotLines,
                        min = axis.min,
                        virtualMin = min + shift,
                        plotElement,
                        i = plotBands.length;

                    //remove or reposition old bands
                    while (i--) {
                        if ((plotElement = plotBands[i])) {
                            //do not shift divlines calcuted by numdivlines
                            if (!plotElement.isNumVDIV) {
                                //if this element would be removed
                                if (plotElement.value < virtualMin ||
                                    plotElement.from < virtualMin || plotElement.to < virtualMin) {
                                    plotBands.splice(i, 1);
                                } else { //else change the position
                                    if (plotElement.value !== undefined) {
                                        plotElement.value -= shift;
                                    }
                                    if (plotElement.from !== undefined) {
                                        plotElement.from -= shift;
                                    }
                                    if (plotElement.to !== undefined) {
                                        plotElement.to -= shift;
                                    }
                                }
                            }
                        }
                    }
                    i = plotLines.length;
                    axis.drawPlotLine();
                    axis.drawPlotBands();
                }
            },
            realtimeUpdateY: function (newMin, newMax) {
                var axis = this,
                    axisData = axis.axisData,
                    axisMin = axis.min = axisData.min = newMin,
                    axisMax = axis.max = axisData.max = newMax,
                    span = axis.span = (axisMax - axisMin),
                    pixelRatio = axis.pixelRatio = axis.isVertical ? axis.relatedObj.canvasObj.h / span :
                        axis.relatedObj.canvasObj.w / span;
                axis.pixelValueRatio = axis.isReverse ? -pixelRatio : pixelRatio;
                axis.drawPlotLine();
                axis.drawPlotBands();
            }
        };

        Axis.prototype.constructor = Axis;

        /**
         * Function that returns the arcTangent of a mouse-click with respect to a point.
         * @param {array} center has the x,y point for which the tangent has to be
         * calculated.
         * @param {object} ref is the reference frame ofsset w.r.t the current page.
         * {left, top}
         */
        function getClickArcTangent (x, y, center, ref) {
            return mathATan2(y - center[1] - ref.top, x - center[0] - ref.left);
        }

        function normalizeAngle(angle, inDegrees) {
            var fullCycle = inDegrees ? 360 : pi2;
            angle = (angle || 0) % fullCycle;
            return angle < 0 ? fullCycle + angle : angle;
        }

        renderer('renderer.cartesian', {
            drawCanvas: function () {
                var chart = this,
                    options = chart.options,
                    optionsChart = options.chart || {},
                    canvasBgColor = optionsChart.plotBackgroundColor,
                    paper = chart.paper,
                    elements = chart.elements,
                    canvas = elements.canvas,
                    canvas3DBase = elements.canvas3DBase,
                    canvas3dbaseline = elements.canvas3dbaseline,
                    canvasBorder = elements.canvasBorder,
                    canvasBg = elements.canvasBg,
                    canvasTop = chart.canvasTop,
                    canvasLeft = chart.canvasLeft,
                    canvasWidth = chart.canvasWidth,
                    canvasHeight = chart.canvasHeight,
                    canvasBorderRadius = pluckNumber(optionsChart.plotBorderRadius, 0),
                    canvasBorderWidth = optionsChart.plotBorderWidth,
                    borderWHlf = canvasBorderWidth * 0.5,
                    canvasBorderColor = optionsChart.plotBorderColor,
                    isBar = optionsChart.isBar,
                    is3D = optionsChart.is3D,
                    use3DLighting = optionsChart.use3DLighting,
                    showCanvasBg = optionsChart.showCanvasBg,
                    canvasBgDepth = optionsChart.canvasBgDepth,
                    showCanvasBase = optionsChart.showCanvasBase,
                    canvasBaseColor3D = optionsChart.canvasBaseColor3D,
                    canvasBaseDepth = optionsChart.canvasBaseDepth,

                    shadow = optionsChart.plotShadow,
                    shadowOnCanvasFill = isVML && canvasBorderWidth === 0 &&
                        shadow && shadow.enabled,

                    xDepth = optionsChart.xDepth || 0,
                    yDepth = optionsChart.yDepth || 0,

                    layers = chart.layers,
                    backgroundLayer = layers.background,
                    datasetlayer = layers.dataset,
                    canvasLayer;

                layers.tracker = layers.tracker || paper.group('hot').insertAfter(datasetlayer);
                layers.datalabels = layers.datalabels || paper.group('datalabels').insertAfter(datasetlayer);
                canvasLayer = layers.canvas = layers.canvas || paper.group('canvas').insertAfter(backgroundLayer);

                if (!canvasBorder) {
                    canvasBorder = elements.canvasBorder =
                        paper.rect({
                            x: canvasLeft - borderWHlf,
                            y: canvasTop - borderWHlf,
                            width: canvasWidth + canvasBorderWidth,
                            height: canvasHeight + canvasBorderWidth,
                            r: canvasBorderRadius,
                            'stroke-width': canvasBorderWidth,
                            stroke: canvasBorderColor,
                            'stroke-linejoin': canvasBorderWidth > MAX_MITER_LINEJOIN ? 'round' : 'miter'
                        }, canvasLayer)
                        .shadow(shadow);
                }

                // create a clip-rect to clip canvas for later use
                elements['clip-canvas'] = [
                    mathMax(0, canvasLeft - xDepth),
                    mathMax(0, canvasTop - yDepth),
                    mathMax(1, canvasWidth + xDepth * 2),
                    mathMax(1, canvasHeight + yDepth * 2)
                ];
                elements['clip-canvas-init'] = [
                    mathMax(0, canvasLeft - xDepth),
                    mathMax(0, canvasTop - yDepth),
                    1,
                    mathMax(1, canvasHeight + yDepth * 2)
                ];

                if (is3D) {
                    if (showCanvasBg) {
                        // Vertical 3D Base
                        if (isBar) {

                            canvasBg = elements.canvasBg = paper.path([
                                M, canvasLeft, COMMA, canvasTop,
                                L, (canvasLeft + (canvasBgDepth * 1.2)),
                                COMMA, (canvasTop - canvasBgDepth), COMMA, (canvasLeft + canvasWidth - canvasBgDepth),
                                COMMA, (canvasTop - canvasBgDepth), COMMA, (canvasLeft + canvasWidth), COMMA, canvasTop,
                                Z
                            ], canvasLayer);
                        }
                        // Horizontal 3D Base
                        else {
                            canvasBg =
                                elements.canvasBg = paper.path([
                                    M, (canvasLeft + canvasWidth), COMMA, canvasTop,
                                    L, (canvasLeft + canvasWidth + canvasBgDepth), COMMA,
                                    (canvasTop + (canvasBgDepth * 1.2)), COMMA,
                                    (canvasLeft + canvasWidth + canvasBgDepth), COMMA,
                                    (canvasTop + canvasHeight - canvasBgDepth), COMMA,
                                    (canvasLeft + canvasWidth), COMMA, (canvasTop + canvasHeight),
                                    Z
                                ], canvasLayer);
                        }

                        canvasBg.attr({
                            'stroke-width': 0,
                            'stroke': NONE,
                            fill: toRaphaelColor(canvasBgColor)
                        });
                    }

                    if (showCanvasBase) {
                        if (isBar) {
                            canvas3DBase = elements.canvas3DBase = paper.cubepath(
                                canvasLeft - xDepth - canvasBaseDepth - 1,
                                canvasTop + yDepth + 1,
                                canvasBaseDepth,
                                canvasHeight,
                                xDepth + 1,
                                yDepth + 1,
                                canvasLayer);
                        } else {
                            canvas3DBase = elements.canvas3DBase = paper.cubepath(
                                canvasLeft - xDepth - 1,
                                canvasTop + canvasHeight + yDepth + 1,
                                canvasWidth,
                                canvasBaseDepth,
                                xDepth + 1,
                                yDepth + 1,
                                canvasLayer);
                        }
                        canvas3DBase.attr({
                            'stroke': NONE,
                            'stroke-width': 0,
                            'fill': [canvasBaseColor3D.replace(dropHash, HASHSTRING), !use3DLighting]
                        });

                        if (!canvas3dbaseline) { // to give 3d feel
                            canvas3dbaseline = elements.canvas3dbaseline =
                                paper.path(undefined, canvasLayer);
                        }

                        canvas3dbaseline.attr({
                            path: isBar ? [M, canvasLeft, canvasTop, V, canvasHeight + canvasTop] :
                                [M, canvasLeft, canvasTop + canvasHeight, H, canvasWidth + canvasLeft],
                            stroke: R.tintshade(canvasBaseColor3D.replace(dropHash, HASHSTRING), 0.05).rgba
                        });
                    }
                }

                if (!canvas) {
                    if (canvasBgColor) {
                        canvas = elements.canvas =
                            paper.rect({
                                x: canvasLeft,
                                y: canvasTop,
                                width: canvasWidth,
                                height: canvasHeight,
                                r: canvasBorderRadius,
                                'stroke-width': 0,
                                'stroke': NONE,
                                fill: toRaphaelColor(canvasBgColor)
                            }, canvasLayer)
                            .shadow(shadowOnCanvasFill);
                    }
                }
            },

            drawAxes: function () {
                var chart = this,
                    logic = chart.logic,
                    options = chart.options,
                    paper = chart.paper,
                    layers = chart.layers,
                    datasetLayer = layers.dataset,
                    layerBelowDataset = layers.layerBelowDataset = layers.layerBelowDataset ||
                        paper.group('axisbottom').trackTooltip(true),
                    layerAboveDataset = layers.layerAboveDataset = layers.layerAboveDataset ||
                        paper.group('axistop').trackTooltip(true),
                    xAxis = chart.xAxis = [],
                    yAxis = chart.yAxis = [],
                    i,
                    l;

                layerBelowDataset.insertBefore(datasetLayer);
                layerAboveDataset.insertAfter(datasetLayer);

                if (options.xAxis && options.xAxis.length) {
                    for (i = 0, l = options.xAxis.length; i < l; i += 1) {
                        xAxis[i] = chart.xAxis[i] = new Axis(options.xAxis[i], chart, logic.isBar);
                    }
                } else {
                    xAxis[0] = chart.xAxis[0] = new Axis(options.xAxis, chart, logic.isBar);
                }

                /** @todo  define proper store for axis */
                if (options.yAxis) {
                    for (i = 0, l = options.yAxis.length; i < l; i += 1) {
                        yAxis[i] = chart.yAxis[i] = new Axis(options.yAxis[i], chart, !logic.isBar, !logic.isBar);
                    }
                }

                //render all Y axis first
                for (i = 0, l = yAxis.length; i < l; i += 1) {
                    /** @todo: Move to the correct place according to the architecture */
                    if (yAxis[i].axisData) {
                        yAxis[i].axisData.title &&
                            (yAxis[i].axisData.title.className = 'fusioncharts-yaxis-' + i + '-title');
                        yAxis[i].axisData.labels &&
                            (yAxis[i].axisData.labels.className = 'fusioncharts-yaxis-' + i + '-gridlabels');
                    }

                    yAxis[i].draw();
                }
                //render all X axis
                for (i = 0, l = xAxis.length; i < l; i += 1) {
                    /** @todo: Move to the correct place according to the architecture */
                    if (xAxis[i].axisData) {
                        xAxis[i].axisData.title &&
                            (xAxis[i].axisData.title.className = 'fusioncharts-xaxis-' + i + '-title');
                        xAxis[i].axisData.labels &&
                            (xAxis[i].axisData.labels.className = 'fusioncharts-xaxis-' + i + '-gridlabels');
                    }

                    xAxis[i].draw();
                }
            },

            drawScroller: function () {

                var chart = this,
                    options = chart.options,
                    paper = chart.paper,
                    layers = chart.layers,
                    axis = chart.xAxis['0'] || {},

                    axisData = axis.axisData || {},
                    scroll = axisData.scroll || {},
                    canvasTop = chart.canvasTop,
                    canvasLeft = chart.canvasLeft,
                    canvasWidth = chart.canvasWidth,
                    canvasHeight = chart.canvasHeight,
                    canvasBorderWidth = chart.canvasBorderWidth,
                    aXisLineWidth = canvasBorderWidth || (axisData.showLine ? axisData.lineThickness : 0),
                    aXisLineStartExtension = canvasBorderWidth || axisData.lineStartExtension,
                    aXisLineEndExtension = canvasBorderWidth || axisData.lineEndExtension,
                    roundEdges = options.chart.useRoundEdges,

                    // actual scale
                    fullCanvasWidth,
                    windowedCanvasWidth,
                    offset,
                    // scroll properties
                    ratio,
                    startPercent,
                    viewMax,
                    viewMin,
                    vxLength,
                    vxLengthCeil,
                    buttonPadding,
                    showButtons,
                    height,
                    padding,
                    color,
                    scrollDisplayStyle,
                    scrollBar3DLighting,

                    reflowData,
                    reflowUpdate,
                    reflowScroll,

                    datasetGroup = layers.dataset,
                    datalabelsGroup = layers.datalabels,
                    hotGroup = layers.tracker,
                    referenceLayer = layers.layerAboveDataset,
                    scrollLayer,
                    i;

                if (scroll.enabled) {
                    scrollLayer = layers.scroll = layers.scroll || paper.group('scroll').insertAfter(referenceLayer),
                    ratio = scroll.scrollRatio;

                    startPercent = pluckNumber(options[CONFIGKEY].xAxisScrollPos, scroll.startPercent);
                    viewMax = scroll.viewPortMax;
                    viewMin = scroll.viewPortMin;
                    vxLength = scroll.vxLength;
                    vxLengthCeil = mathCeil(vxLength);
                    buttonPadding = scroll.buttonPadding;
                    showButtons = scroll.showButtons;
                    height = scroll.height;
                    padding = scroll.padding;
                    color = scroll.color;
                    scrollDisplayStyle = scroll.flatScrollBars;
                    scrollBar3DLighting = scroll.scrollBar3DLighting;
                    windowedCanvasWidth = scroll.windowedCanvasWidth = axis.getAxisPosition(vxLength);
                    fullCanvasWidth = scroll.fullCanvasWidth =
                        axis.getAxisPosition(viewMax - viewMin) - windowedCanvasWidth,
                    offset = mathRound(startPercent * fullCanvasWidth);

                    reflowData = chart.fusionCharts.jsVars._reflowData;
                    reflowUpdate = {
                        hcJSON: {
                            _FCconf: {
                                xAxisScrollPos: 0
                            }
                        }
                    };
                    reflowScroll = reflowUpdate.hcJSON._FCconf;

                    layers.scroller = paper.scroller(
                        canvasLeft - aXisLineStartExtension,
                        canvasTop + canvasHeight + aXisLineWidth +
                        padding - ( !! aXisLineWidth),
                        canvasWidth + aXisLineStartExtension + aXisLineEndExtension,
                        height, true, {
                            showButtons: showButtons,
                            displayStyleFlat: scrollDisplayStyle,
                            scrollRatio: ratio,
                            scrollPosition: startPercent
                        },
                        scrollLayer)
                        .data('fullCanvasWidth', fullCanvasWidth)
                        .data('windowedCanvasWidth', windowedCanvasWidth)
                        .attr({
                            'scroll-display-style': scrollDisplayStyle,
                            'fill': color,
                            r: roundEdges && 2 || 0
                        })
                        .scroll(function (pos) {
                            var scrollStateObj;

                            offset = -mathRound(pos * fullCanvasWidth);
                            datasetGroup && datasetGroup.transform(['T', offset, 0]);
                            datalabelsGroup && datalabelsGroup.transform(['T', offset, 0]);
                            hotGroup && hotGroup.transform(['T', offset, 0]);
                            axis.setOffset && axis.setOffset(offset);
                            // save state
                            scrollStateObj = {
                                position: pos,
                                direction: pos - scroll.lastPos || 0,
                                vxLength: vxLengthCeil
                            };

                            reflowScroll.xAxisScrollPos = scroll.lastPos = pos;
                            extend2(reflowData, reflowUpdate, true);

                            // staggered rendering of column plots while scrolling
                            if (scrollStateObj.direction !== 0) {
                                for (i = 0; i < chart.datasets.length; i++) {
                                    chart[chart.datasets[i].drawPlot + 'Scroll'] &&
                                        chart[chart.datasets[i].drawPlot + 'Scroll']
                                        .call(chart,
                                            chart.plots[i],
                                            chart.datasets[i],
                                            scrollStateObj
                                    );
                                }
                            }
                        });

                    (function () {
                        var prevPos;
                        R.eve.on('raphael.scroll.start.' + layers.scroller.id, function (pos) {
                            prevPos = pos;
                            /**
                             * This event is fired when chart reaches a scroll point.
                             *
                             * @event FusionCharts#scrollStart
                             * @group chart:scroll
                             */
                            global.raiseEvent('scrollstart', {
                                scrollPosition: pos
                            }, chart.logic.chartInstance);
                        });

                        R.eve.on('raphael.scroll.end.' + layers.scroller.id, function (pos) {
                            /**
                             * This event is fired when a chart reaches end of scroll.
                             *
                             * @event FusionCharts#scrollEnd
                             * @group chart:scroll
                             */
                            global.raiseEvent('scrollend', {
                                prevScrollPosition: prevPos,
                                scrollPosition: pos
                            }, chart.logic.chartInstance);

                        });
                    }());
                }

                return scroll.enabled;
            },

            finalizeScrollPlots: function () {
                var chart = this,
                    options = chart.options,
                    container = chart.container,
                    elements = chart.elements,

                    layers = chart.layers,
                    scroller = layers.scroller,
                    datasetGroup = layers.dataset,
                    datalabelsGroup = layers.datalabels,
                    hotGroup = layers.tracker,
                    chartPosition,
                    config = {},
                    touchScrollBodyEventHandler,
                    isDraggedInsideCanvas,

                    axis = chart.xAxis['0'] || {},
                    axisData = axis.axisData || {},
                    scroll = axisData.scroll || {},
                    startPercent = pluckNumber(options[CONFIGKEY].xAxisScrollPos, scroll.startPercent),
                    // actual scale
                    fullCanvasWidth = scroll.fullCanvasWidth,
                    offset;

                if (scroll.enabled) {
                    datasetGroup.attr({
                        'clip-rect': elements['clip-canvas']
                    });

                    datalabelsGroup.attr({
                        'clip-rect': elements['clip-canvas']
                    });

                    hotGroup.attr({
                        'clip-rect': elements['clip-canvas']
                    });

                    touchScrollBodyEventHandler = function (event) {

                        var canvas = chart.elements.canvas,
                            chartPosLeft = chartPosition.left,
                            chartPosTop = chartPosition.top,

                            type = event.state,
                            touchEvent = (hasTouch && lib.getTouchEvent(event)) ||
                                stubEvent,

                            evt = event.originalEvent,
                            layerX = ((evt.clientX || evt.pageX || touchEvent.pageX) - chartPosLeft),
                            layerY = ((evt.clientY || evt.pageY || touchEvent.pageY) - chartPosTop),

                            dx;

                        switch (type) {
                        case 'start': // DragStart
                            isDraggedInsideCanvas = canvas.isPointInside(layerX, layerY);
                            config.ox = isDraggedInsideCanvas && layerX || null;
                            if (!isDraggedInsideCanvas) {
                                return false;
                            }
                            config.prevScrollPosition = scroller.attrs['scroll-position'];
                            /**
                             * @fires FusionCharts#scrollStart
                             */
                            global.raiseEvent('scrollstart', {
                                scrollPosition: config.prevScrollPosition
                            }, chart.logic.chartInstance);

                            break;

                        case 'end': // DragEnd
                            /**
                             * @fires FusionCharts#scrollEnd
                             */
                            global.raiseEvent('scrollend', {
                                prevScrollPosition: config.prevScrollPosition,
                                scrollPosition: config.scrollPosition
                            }, chart.logic.chartInstance);

                            isDraggedInsideCanvas = false;
                            config = {};
                            break;

                        default: // DragMove
                            if (!isDraggedInsideCanvas) {
                                return;
                            }

                            dx = layerX - config.ox;
                            config.ox = layerX;
                            config.scrollPosition = scroller.attrs['scroll-position'] -
                                dx / fullCanvasWidth;
                            scroller.attr({
                                'scroll-position': config.scrollPosition
                            });

                            break;
                        }

                    };
                    // bind touch scroll on canvas
                    if (hasTouch) {
                        chartPosition = lib.getPosition(container);

                        if (container) {
                            removeEvent(container, 'pointerdrag', touchScrollBodyEventHandler);
                            addEvent(container, 'pointerdrag', touchScrollBodyEventHandler);
                        }
                    }

                    // offset layers based on scroll initial position
                    if (startPercent > 0) {
                        offset = -mathRound(startPercent * fullCanvasWidth);
                        datasetGroup && datasetGroup.transform(['T', offset, 0]);
                        datalabelsGroup && datalabelsGroup.transform(['T', offset, 0]);
                        hotGroup && hotGroup.transform(['T', offset, 0]);
                        axis.setOffset && axis.setOffset(offset);
                    }

                }
            },

            drawPlotColumn: function (plot, dataOptions, sconfig) {
                var chart = this,
                    data = plot.data,
                    ln = data.length,
                    plotItems = plot.items,
                    datasetGraphics = plot.graphics || (plot.graphics = []),
                    paper = chart.paper,
                    smartLabel = chart.smartLabel,
                    logic = chart.logic,
                    layers = chart.layers,
                    options = chart.options,
                    elements = chart.elements,
                    chartOptions = options.chart,
                    // tooltip options
                    tooltipOptions = options.tooltip || {},
                    isTooltip = tooltipOptions.enabled !== false,
                    toolText,
                    // Directly Accessing chart definition JSON Data
                    chartAttributes = chart.definition.chart,
                    seriesOptions = options.plotOptions.series,
                    style = seriesOptions.dataLabels.style,
                    xAxis = chart.xAxis[dataOptions.xAxis || 0],
                    yAxis = chart.yAxis[dataOptions.yAxis || 0],
                    chartW = chart.chartWidth,
                    chartH = chart.chartHeight,
                    // is inverse chart
                    isInverseAxis = yAxis.axisData.reversed,
                    // is log chart
                    isLog = logic.isLog,
                    // is 3D
                    is3D = logic.is3D,
                    // is stacked chart
                    isStacked = logic.isStacked,
                    // is waterfall
                    isWaterfall = logic.isWaterfall,
                    // is candlestick
                    isCandleStick = logic.isCandleStick,
                    // is scroll chart
                    scrollObj = pluck(xAxis.axisData.scroll, {}),
                    scrollConfig = sconfig || {},
                    isScroll = scrollObj.enabled,
                    scrollPosition = pluckNumber(scrollConfig.position, options[CONFIGKEY].xAxisScrollPos,
                        scrollObj.startPercent),
                    scrollVxLength = scrollConfig.vxLength || mathCeil(scrollObj.vxLength),
                    scrollStart = scrollConfig.scrollStart ||
                        mathMax(0, mathRound((ln - scrollVxLength) * scrollPosition) - 1) || 0,
                    scrollEnd = scrollConfig.scrollEnd || mathMin(ln, scrollStart + scrollVxLength + 2) || ln,

                    canvasBorderOpacity = chartOptions.canvasBorderOpacity =
                        R.color(chartOptions.plotBorderColor).opacity,

                    canvasBorderWidth = chart.canvasBorderWidth,
                    hasValidCanvasBorder = chartOptions.isCanvasBorder =
                        canvasBorderOpacity !== 0 && canvasBorderWidth > 0,

                    columnBaseHotFixDelta,

                    animationDuration = sconfig !== UNDEFINED ? 0 : isNaN(+seriesOptions.animation) &&
                        seriesOptions.animation.duration || seriesOptions.animation * 1000,

                    numColumns = dataOptions.numColumns || 1,
                    columnPosition = dataOptions.columnPosition || 0,

                    use3DLighting = chartOptions.use3DLighting,
                    seriesVisibility = dataOptions.visible === false ? 'hidden' : 'visible',
                    overlapColumns = chartOptions.overlapColumns,

                    xAxisZeroPos = xAxis.getAxisPosition(0),
                    xAxisFirstPos = xAxis.getAxisPosition(1),
                    groupMaxWidth = xAxisFirstPos - xAxisZeroPos,
                    definedGroupPadding = chartAttributes && chartAttributes.plotspacepercent,
                    plotPaddingPercent = pluckNumber(chartAttributes && chartAttributes.plotpaddingpercent),
                    groupPadding = seriesOptions.groupPadding,
                    maxColWidth = seriesOptions.maxColWidth,
                    groupNetWidth = (1 - definedGroupPadding * 0.01) * groupMaxWidth || mathMin(
                        groupMaxWidth * (1 - groupPadding * 2),
                        maxColWidth * numColumns
                    ),
                    groupNetHalfWidth = groupNetWidth / 2,
                    columnWidth = groupNetWidth / numColumns,
                    plotPadding = numColumns > 1 ? !overlapColumns && plotPaddingPercent === UNDEFINED ?
                        4 :
                        plotPaddingPercent > 0 ? (columnWidth * plotPaddingPercent / 100) : 0 : 0,
                    plotEffectivePadding = mathMin(columnWidth - 1, plotPadding),
                    xPosOffset = (columnPosition * columnWidth) - groupNetHalfWidth + plotEffectivePadding / 2,

                    yMax = yAxis.max,
                    yMin = yAxis.min,
                    isAllPositiveZero = yMax > 0 && yMin >= 0,
                    isAllNegativeZero = yMax <= 0 && yMin < 0,
                    isPositiveNegative = yMax > 0 && yMin < 0,

                    yBase = isAllNegativeZero ||
                        (isInverseAxis && isAllPositiveZero) ? yMax :
                        isLog || isAllPositiveZero ? yMin : 0,

                    yBasePos = yAxis.yBasePos = yAxis.getAxisPosition(yBase),
                    heightBase,
                    plotRadius = pluckNumber(chartOptions.useRoundEdges, 0),

                    datasetLayer = layers.dataset = layers.dataset || paper.group('dataset-orphan'),
                    dataLabelsLayer = layers.datalabels = layers.datalabels ||
                        paper.group('datalabels').insertAfter(datasetLayer),
                    trackerLayer = layers.tracker,

                    canvasTop = chart.canvasTop,
                    canvasLeft = chart.canvasLeft,
                    canvasWidth = chart.canvasWidth,
                    canvasBottom = chart.canvasBottom,
                    canvasRight = chart.canvasRight,
                    animationComplete,
                    groupId,
                    // Zero plane settings
                    zeroPlaneColor,
                    zeroPlaneBorderColor,
                    zeroPlaneShowBorder,

                    MINHEIGHT = 1,
                    xDepth,
                    yDepth,
                    isNegative,
                    valueBelowPlot,
                    plotItem,
                    i,
                    set,
                    setLink,
                    setBorderWidth,
                    x,
                    y,
                    previousY,
                    xPos,
                    yPos,
                    previousYPos,
                    valEle,
                    height,
                    width,
                    labelCSS = {
                        fontFamily: style.fontFamily,
                        fontSize: style.fontSize,
                        lineHeight: style.lineHeight,
                        fontWeight: style.fontWeight,
                        fontStyle: style.fontStyle,
                        color: style.color
                    },
                    // Hover settings
                    setHoverEffect,
                    setRolloverProperties,
                    setRolloutAttr,
                    setRolloverAttr,
                    // marimekko variables
                    fixedWidth,
                    setElem,
                    hotElem,
                    group,
                    plotGroup,
                    plotNegativeGroup,
                    plotNegativeGroupArray,
                    zeroPlaneGroup,
                    plotPositiveGroup,
                    plotPositiveGroupArray,
                    targetGroup,
                    shadowGroup,
                    crispBox,
                    attrObj,
                    eventArgs,
                    clickFunc = function (data) {
                        var ele = this;
                        plotEventHandler.call(ele, chart, data);
                    },
                    rolloverResponseSetter = function (elem, elemHoverAttr) {
                        return function (data) {
                            var ele = this;
                            elem.attr(elemHoverAttr);
                            plotEventHandler.call(ele, chart, data, ROLLOVER);
                        };
                    },
                    rolloutResponseSetter = function (elem, elemUnHoverAttr) {
                        return function (data) {
                            var ele = this;
                            elem.attr(elemUnHoverAttr);
                            plotEventHandler.call(ele, chart, data, ROLLOUT);
                        };
                    };

                /** @todo: Move to the proper place according to the architecture. */
                chart.addCSSDefinition('.fusioncharts-datalabels .fusioncharts-label', labelCSS);
                dataLabelsLayer.attr('class', 'fusioncharts-datalabels');

                // hide the data labels group. Will be visible after animation completes
                if (animationDuration) {
                    !sconfig && dataLabelsLayer.attr({
                        transform: '...t' + chartW + COMMA + chartH
                    });
                    chart.animationCompleteQueue.push({
                        fn: function () {
                            dataLabelsLayer.attr({
                                transform: '...t' + -chartW + COMMA + -chartH
                            });
                        },
                        scope: chart
                    });
                }

                // adjust column width based on plotPadding
                columnWidth = columnWidth - plotEffectivePadding;

                //adjust scroll start
                if (isScroll && scrollStart > scrollEnd - scrollVxLength - 2) {
                    scrollStart = mathMax(0, scrollEnd - scrollVxLength - 2);
                }

                // define groups
                group = datasetLayer;
                if (isStacked) {
                    shadowGroup = group.shadows || (group.shadows = paper.group('shadows', group).toBack());
                }

                plotGroup = group.column || (group.column = paper.group('columns', group));

                // clip column inside canvas
                if (!isCandleStick && !is3D && !isScroll) {
                    if (!plotGroup.attrs['clip-rect']) {
                        plotGroup.attr({
                            'clip-rect': elements['clip-canvas']
                        });
                    }
                }

                // put column group below connector line group in waterfall chart
                if (isWaterfall) {
                    plotGroup.toBack();
                }
                // Assign target group(s)
                // In 3D chart separate groups for positive and negative values
                // Additionally draw 3D Zero Plane if 3D
                if (is3D) {

                    xDepth = chartOptions.xDepth || 0;
                    yDepth = chartOptions.yDepth || 0;

                    plotNegativeGroup = plotGroup.negative =
                        (plotGroup.negative || paper.group('negative-values', plotGroup));

                    plotPositiveGroup = plotGroup.column =
                        (plotGroup.column || paper.group('positive-values', plotGroup));

                    // Draw zero plane
                    zeroPlaneGroup = plotGroup.zeroPlane;
                    if (!zeroPlaneGroup && yMin < 0 && yMax >= 0) {

                        zeroPlaneGroup = plotGroup.zeroPlane =
                            paper.group('zero-plane', plotGroup)
                            .insertBefore(plotPositiveGroup);

                        zeroPlaneColor = chartOptions.zeroPlaneColor;
                        zeroPlaneBorderColor = chartOptions.zeroPlaneBorderColor;
                        zeroPlaneShowBorder = chartOptions.zeroPlaneShowBorder;

                        elements.zeroplane = paper.cubepath(
                            canvasLeft - xDepth, yBasePos + yDepth,
                            canvasWidth, MINHEIGHT, xDepth, yDepth,
                            zeroPlaneGroup
                        )
                            .attr({
                                'fill': [zeroPlaneColor, !use3DLighting],
                                'stroke': zeroPlaneBorderColor || NONE,
                                'stroke-width': zeroPlaneShowBorder ? 1 : 0
                            });
                    }

                    if (!(plotNegativeGroupArray = plotNegativeGroup.data('categoryplots'))) {
                        plotNegativeGroup.data('categoryplots', new Array(ln));
                        plotNegativeGroupArray = plotNegativeGroup.data('categoryplots');
                    }
                    if (!(plotPositiveGroupArray = plotPositiveGroup.data('categoryplots'))) {
                        plotPositiveGroup.data('categoryplots', new Array(ln));
                        plotPositiveGroupArray = plotPositiveGroup.data('categoryplots');

                    }

                    for (i = 0; i < ln; i += 1) {
                        plotNegativeGroupArray[i] = plotNegativeGroupArray[i] ||
                            paper.group(plotNegativeGroup);
                        plotPositiveGroupArray[i] = plotPositiveGroupArray[i] ||
                            paper.group(plotPositiveGroup);
                    }
                } else {
                    targetGroup = plotGroup;
                }

                smartLabel.setStyle({
                    fontFamily: style.fontFamily,
                    fontSize: style.fontSize,
                    lineHeight: style.lineHeight,
                    fontWeight: style.fontWeight,
                    fontStyle: style.fontStyle
                });

                //draw columns
                for (i = scrollStart; i < scrollEnd; i += 1) {
                    set = data[i];
                    y = set.y;
                    toolText = set.toolText;
                    groupId = plot.index + '_' + i;
                    setElem = hotElem = null;

                    if (y === null) {
                        if ((plotItem = plotItems[i])) {
                            setElem = plotItem.graphic;
                            if (!is3D) {
                                setElem.attr({
                                    height: 0
                                });
                            }
                        }
                    }
                    // when valid value
                    else {
                        isNegative = false;

                        x = pluckNumber(set.x, i);
                        setLink = set.link;
                        setBorderWidth = toFloat(set.borderWidth) || 0;

                        // for marimekko
                        /** @todo  Rename _FCW and _FCX to width and xPos */
                        fixedWidth = set._FCW * groupMaxWidth;

                        xPos = xAxis.getAxisPosition(set._FCX) ||
                            xAxis.getAxisPosition(x) + xPosOffset;

                        previousY = set.previousY;

                        previousYPos = yAxis.getAxisPosition(previousY || yBase);
                        yPos = yAxis.getAxisPosition(y + (previousY || 0));

                        height = mathAbs(yPos - previousYPos);
                        width = fixedWidth || columnWidth;

                        eventArgs = {
                            index: i,
                            link: setLink,
                            value: set.y,
                            displayValue: set.displayValue,
                            categoryLabel: set.categoryLabel,
                            toolText: set.toolText,
                            id: plot.userID,
                            datasetIndex: plot.index,
                            datasetName: plot.name,
                            visible: plot.visible
                        };

                        if (is3D) {

                            if (y < 0) {
                                yPos = previousYPos;
                                isNegative = true;
                            }

                            // manage positive and negative group
                            targetGroup = y < 0 ? plotNegativeGroupArray :
                                plotPositiveGroupArray;

                            if (!(plotItem = plotItems[i])) {
                                plotItem = plotItems[i] = {
                                    index: i,
                                    value: y,
                                    graphic: paper.cubepath(targetGroup[i]),
                                    dataLabel: null,
                                    tracker: null,
                                    hot: null
                                };
                            }
                            setElem = plotItem.graphic;

                            // Hover consmetics
                            setRolloutAttr = setRolloverAttr = {};
                            if ((setHoverEffect = set.hoverEffects)) {
                                setRolloutAttr = {
                                    'fill': [toRaphaelColor(set.color), !use3DLighting],
                                    stroke: setBorderWidth &&
                                        toRaphaelColor(set.borderColor) || 'NONE',
                                    'stroke-width': setBorderWidth
                                };

                                setRolloverProperties = set.rolloverProperties;

                                setRolloverAttr = {
                                    'fill': [toRaphaelColor(setRolloverProperties.color), !use3DLighting],
                                    stroke: setRolloverProperties.borderWidth &&
                                        toRaphaelColor(setRolloverProperties.borderColor) || 'NONE',
                                    'stroke-width': setRolloverProperties.borderWidth
                                };
                            }

                            setElem.attr({
                                    cubepath: [
                                        xPos - xDepth,
                                        animationDuration ? yBasePos + yDepth : yPos + yDepth,
                                        width,
                                        animationDuration ? 0 : height,
                                        xDepth,
                                        yDepth
                                    ],
                                    'fill': [toRaphaelColor(set.color), !use3DLighting],
                                    stroke: setBorderWidth &&
                                        toRaphaelColor(set.borderColor) || 'NONE',
                                    'stroke-width': setBorderWidth,
                                    'visibility': seriesVisibility
                                })
                                .shadow(seriesOptions.shadow && set.shadow, shadowGroup)
                                .data('BBox', {
                                    height: height,
                                    width: width,
                                    x: xPos,
                                    y: yPos
                                });

                            if (animationDuration) {
                                setElem.animate({
                                    cubepath: [
                                        xPos - xDepth,
                                        yPos + yDepth,
                                        width,
                                        height,
                                        xDepth,
                                        yDepth
                                    ]
                                }, animationDuration, 'normal', chart.getAnimationCompleteFn());
                            }

                            if (setLink || isTooltip) {
                                if (!isStacked && height < HTP) {
                                    yPos -= (HTP - height) / 2;
                                    height = HTP;
                                }

                                if (!plotItem.tracker) {
                                    plotItem.tracker = paper.cubepath(trackerLayer);
                                }
                                hotElem = plotItem.tracker;
                                hotElem.attr({
                                    cubepath: [
                                        xPos - xDepth,
                                        yPos + yDepth,
                                        width,
                                        height,
                                        xDepth,
                                        yDepth
                                    ],
                                    cursor: setLink ? 'pointer' : '',
                                    stroke: setBorderWidth && TRACKER_FILL || 'NONE',
                                    'stroke-width': setBorderWidth,
                                    fill: TRACKER_FILL,
                                    ishot: true,
                                    visibility: seriesVisibility
                                });
                            }

                            (hotElem || setElem)
                                .data('eventArgs', eventArgs)
                                .data('groupId', groupId)
                                .click(clickFunc)
                                .hover(
                                    rolloverResponseSetter(setElem, setRolloverAttr),
                                    rolloutResponseSetter(setElem, setRolloutAttr)
                                )
                                .tooltip(toolText);

                            (hotElem || setElem)._.cubetop
                                .data('eventArgs', eventArgs)
                                .data('groupId', groupId)
                                .click(clickFunc)
                                .hover(
                                    rolloverResponseSetter(setElem, setRolloverAttr),
                                    rolloutResponseSetter(setElem, setRolloutAttr)
                                )
                                .tooltip(toolText);

                            (hotElem || setElem)._.cubeside
                                .data('eventArgs', eventArgs)
                                .data('groupId', groupId)
                                .click(clickFunc)
                                .hover(
                                    rolloverResponseSetter(setElem, setRolloverAttr),
                                    rolloutResponseSetter(setElem, setRolloutAttr)
                                )
                                .tooltip(toolText);

                            if (isStacked && isNegative) {
                                setElem.toBack();
                                hotElem && hotElem.toBack();
                            }
                        }
                        // 2D column
                        else {
                            valueBelowPlot = false;

                            // set correct yPos for all plots drawn from top to bottom
                            if ((!isLog && !isInverseAxis && y < 0) ||
                                (!isLog && isInverseAxis && y > 0)) {
                                yPos = previousYPos;
                                valueBelowPlot = true;
                            }
                            if ((isInverseAxis && !isPositiveNegative && y > 0)) {
                                yPos = previousYPos - height;
                                valueBelowPlot = false;
                            }
                            // inverse direction management for waterfall charts
                            if (isWaterfall && y < 0 && defined(previousY)) {
                                yPos -= height;
                                valueBelowPlot = true;
                            }


                            if (!isCandleStick && !isScroll) {

                                /* hotfixes start */
                                // in case yPos is above canvas-top position -
                                // normalize
                                if (toInt(yPos) <= canvasTop) {
                                    height -= canvasTop - yPos -
                                        (+hasValidCanvasBorder);
                                    yPos = canvasTop - (+hasValidCanvasBorder);
                                }
                                // in case plot exceeds canvas-bottom position -
                                // normalize height
                                if (mathRound(yPos + height) >= canvasBottom) {

                                    height -= mathRound(yPos + height) -
                                        canvasBottom +
                                        ((+ !! setBorderWidth)) +
                                        (+hasValidCanvasBorder);
                                    // compensate crispening of axisline
                                    if (chartOptions.xAxisLineVisible && !hasValidCanvasBorder) {
                                        height += 1;
                                    }
                                }

                                if (setBorderWidth <= 1) {
                                    // in case xPos is right of canvas-left position -
                                    // normalize
                                    if (mathRound(xPos) <= canvasLeft) {
                                        width += xPos;
                                        xPos = canvasLeft - (setBorderWidth / 2) +
                                            (+ !! setBorderWidth) - (+hasValidCanvasBorder);
                                        width -= xPos;
                                    }
                                    // in case plot exceeds canvas-right position -
                                    // normalize width
                                    if (mathRound(xPos + width) >= canvasRight) {
                                        width = canvasRight - xPos + (setBorderWidth / 2) -
                                            (+ !! setBorderWidth) + (+hasValidCanvasBorder);
                                    }
                                }
                            }
                            /* hotfixes end */

                            // crisp column
                            crispBox = R.crispBound(xPos, yPos, width, height,
                                setBorderWidth);
                            xPos = crispBox.x;
                            yPos = crispBox.y;
                            width = crispBox.width;
                            height = crispBox.height;

                            // start base hotfix
                            if (!isCandleStick && hasValidCanvasBorder &&
                                (!defined(previousY) ||
                                    (isWaterfall && previousY === y && y === set._FCY))) {

                                // hotfix top when all columns are drawn from top
                                if (isAllNegativeZero && !isInverseAxis) {

                                    columnBaseHotFixDelta = yPos - (canvasTop -
                                        setBorderWidth / 2);
                                    height += columnBaseHotFixDelta;
                                    yBasePos = yPos = yPos - columnBaseHotFixDelta;

                                }

                                // hotfix bottom when all columns are drawn from bottom
                                else if (isLog || isAllPositiveZero ||
                                    (isInverseAxis && isAllNegativeZero)) {

                                    height = (canvasBottom - yPos) + setBorderWidth / 2;
                                    yBasePos = yPos + height;

                                }
                            }

                            // end base hotfix

                            // special treatment of columns in waterfall when
                            // connector lines are dashed and only 1px thick:
                            // reduce the height of the columns to 1px to show the
                            // 1px dashed connector lines
                            // adjust y of the column  if required
                            if (isWaterfall) {

                                if (previousY && setBorderWidth > 0 &&
                                    seriesOptions.connectorOpacity !== 0 &&
                                    seriesOptions.connectorWidth === 1 &&
                                    seriesOptions.connectorDashStyle) {

                                    height -= 1;
                                    if (y < 0) {
                                        yPos += 1;
                                    }
                                }
                            }

                            if (height <= MINHEIGHT) {
                                height = MINHEIGHT;
                                yPos += y < 0 ? MINHEIGHT : y === 0 ? 0 :-height;
                            }

                            dataOptions._columnWidth = width;

                            if (!(plotItem = plotItems[i])) {
                                plotItem = plotItems[i] = {
                                    index: i,
                                    value: y,
                                    width: width,
                                    graphic: null,
                                    valueBelowPlot: valueBelowPlot,
                                    dataLabel: null,
                                    tracker: null
                                };

                                heightBase = 0;
                                if (!animationDuration) {
                                    yBasePos = yPos;
                                    heightBase = height || 1;
                                }

                                // Hover consmetics
                                setRolloutAttr = setRolloverAttr = {};
                                if ((setHoverEffect = set.hoverEffects)) {
                                    setRolloutAttr = {
                                        fill: toRaphaelColor(set.color),
                                        stroke: toRaphaelColor(set.borderColor),
                                        'stroke-width': setBorderWidth,
                                        'stroke-dasharray': set.dashStyle
                                    };

                                    setRolloverProperties = set.rolloverProperties;

                                    setRolloverAttr = {
                                        fill: toRaphaelColor(setRolloverProperties.color),
                                        stroke: toRaphaelColor(setRolloverProperties.borderColor),
                                        'stroke-width': setRolloverProperties.borderWidth,
                                        'stroke-dasharray': setRolloverProperties.dashStyle
                                    };
                                }

                                attrObj = {
                                    x: xPos,
                                    y: yBasePos,
                                    width: width,
                                    height: heightBase,
                                    r: plotRadius,
                                    fill: toRaphaelColor(set.color),
                                    stroke: toRaphaelColor(set.borderColor),
                                    'stroke-width': setBorderWidth,
                                    'stroke-dasharray': set.dashStyle,
                                    'stroke-linejoin': 'miter',
                                    'visibility': seriesVisibility
                                };

                                if (!setElem) {
                                    setElem = plotItem.graphic =
                                        paper.rect(attrObj, targetGroup);
                                }
                                else {
                                    setElem.attr(attrObj);
                                }

                                setElem
                                    .shadow(seriesOptions.shadow && set.shadow, shadowGroup)
                                    .data('BBox', crispBox);

                                if (animationDuration) {
                                    setElem.animate({
                                            y: yPos,
                                            height: height || 1
                                        },
                                        animationDuration, 'normal',
                                        chart.getAnimationCompleteFn());
                                    // Remove animation complete callback function, so that
                                    // this will be called only once
                                    animationComplete = undefined;
                                }

                                if (setLink || isTooltip) {
                                    if (!isStacked && height < HTP) {
                                        yPos -= (HTP - height) / 2;
                                        height = HTP;
                                    }

                                    attrObj = {
                                        x: xPos,
                                        y: yPos,
                                        width: width,
                                        height: height,
                                        r: plotRadius,
                                        cursor: setLink ? 'pointer' : '',
                                        stroke: TRACKER_FILL,
                                        'stroke-width': setBorderWidth,
                                        fill: TRACKER_FILL,
                                        ishot: true,
                                        visibility: seriesVisibility
                                    };

                                    hotElem = plotItem.tracker;

                                    if (!hotElem) {
                                        hotElem = plotItem.tracker = paper.rect(attrObj, trackerLayer);
                                    }
                                    else {
                                        hotElem.attr(attrObj);
                                    }
                                }
                                hotElem = plotItem.tracker;

                                (hotElem || setElem)
                                    .data('eventArgs', eventArgs)
                                    .data('groupId', groupId)
                                    .click(clickFunc)
                                    .hover(
                                        rolloverResponseSetter(setElem, setRolloverAttr),
                                        rolloutResponseSetter(setElem, setRolloutAttr)
                                    )
                                    .tooltip(toolText);
                            }
                        }

                        // Drawing of displayValue
                        valEle = chart.drawPlotColumnLabel(plot, dataOptions, i, xPos, yPos);
                    }

                    valEle && datasetGraphics.push(valEle);
                    setElem && datasetGraphics.push(setElem);
                    hotElem && datasetGraphics.push(hotElem);

                    chart.drawTracker &&
                        chart.drawTracker.call(chart, plot, dataOptions, i);
                }

                plot.visible = (dataOptions.visible !== false);

                return plot;
            },

            drawPlotColumnScroll: function (plot, dataOptions, config) {
                var chart = this,
                    data = plot.data,
                    ln = data.length,
                    plotItems = plot.items,
                    i,
                    scrollPosition = config.position,
                    scrollVxLength = config.vxLength,
                    scrollStart = mathMax(0,
                        mathRound((ln - scrollVxLength) * scrollPosition) - 1) || 0,
                    scrollEnd = mathMin(ln, scrollStart + scrollVxLength + 2) || ln;

                //adjust scroll start
                if (scrollStart > scrollEnd - scrollVxLength - 2) {
                    scrollStart = mathMax(0, scrollEnd - scrollVxLength - 2);
                }

                config.scrollEnd = scrollEnd;

                for (i = scrollStart; i < scrollEnd; i++) {
                    if (!plotItems[i]) {
                        config.scrollStart = i;
                        chart.drawPlotColumn(plot, dataOptions, config);
                        break;
                    }
                }
            },

            drawPlotColumnLabel: function (plot, dataOptions, i, xPos, yPos, dataLabelsLayer) {
                var chart = this,
                    options = chart.options,
                    logic = chart.logic,
                    chartOptions = options.chart,
                    seriesOptions = options.plotOptions.series,
                    paper = chart.paper,
                    smartLabel = chart.smartLabel,
                    layers = chart.layers,
                    style = seriesOptions.dataLabels.style,
                    rotateValues = chartOptions.rotateValues === 1 ? 270 : 0,
                    canvasHeight = chart.canvasHeight,
                    canvasTop = chart.canvasTop,
                    plotItems = plot.items,
                    data = plot.data,
                    set = data[i],
                    plotItem = plotItems[i],
                    valuePadding = chartOptions.valuePadding + GUTTER_2,
                    setElem = plotItem.graphic,
                    valEle = plotItem.dataLabel,
                    isNegative = pluck(plotItem.valueBelowPlot, set.y < 0),
                    // is stacked chart
                    isStacked = logic.isStacked,
                    // is 3D
                    is3D = logic.is3D,
                    xDepth = chartOptions.xDepth || 0,
                    yDepth = chartOptions.yDepth || 0,
                    displayValue = set.displayValue,
                    seriesVisibility = dataOptions.visible === false ? 'hidden' : 'visible',
                    placeValuesInside = chartOptions.placeValuesInside,
                    // css = {
                    //     fontFamily: style.fontFamily,
                    //     fontSize: style.fontSize,
                    //     lineHeight: style.lineHeight,
                    //     fontWeight: style.fontWeight,
                    //     fontStyle: style.fontStyle
                    // },
                    height,
                    colBBox,
                    yAdjust,
                    insideColSpace,
                    outsideColSpace,
                    textHeight,
                    origTextHeight,
                    textY,
                    textX,
                    bBoxObj;

                dataLabelsLayer = dataLabelsLayer || layers.datalabels;

                // Drawing of displayValue
                if (defined(displayValue) && displayValue !== BLANK && set.y !== null) {
                    if (!plotItem._state || !plotItem._state.labelWidth) {

                        // get the bBox to find height and width of the text.
                        bBoxObj = smartLabel.getOriSize(displayValue);

                        // store the width and height for optimization in realtime charts.
                        if (rotateValues) {
                            // If rotated values we use the width of
                            // the text as height
                            plotItem._state = {
                                labelWidth: bBoxObj.height,
                                labelHeight: bBoxObj.width
                            };
                        }
                        else {
                            plotItem._state = {
                                labelWidth: bBoxObj.width,
                                labelHeight: bBoxObj.height
                            };
                        }
                    }

                    colBBox = setElem.data('BBox');
                    height = colBBox.height;

                    textHeight = origTextHeight = plotItem._state.labelHeight + valuePadding;

                    // in case of negative value place the value text below the
                    insideColSpace = height;
                    yAdjust = (origTextHeight * 0.5) + valuePadding;
                    textY = yPos - yAdjust;
                    /**
                     * @todo since bbox was crispened during drawing, stack sum and plot label are not properly aligned
                     */
                    textX = colBBox.x + (colBBox.width * 0.5);

                    if (isNegative) {
                        outsideColSpace = (canvasTop + canvasHeight) - (yPos + height);
                        textY = yPos + height;
                    } else {
                        outsideColSpace = yPos - canvasTop;
                    }

                    // Stacked Chart always display values inside
                    // and center of the column.
                    if (isStacked) {
                        textY = yPos + (height * 0.5) + (yDepth || 0);
                        textX -= xDepth;
                    } else {
                        if (placeValuesInside) {
                            // If space available inside column
                            if (insideColSpace >= textHeight) {
                                textY = yPos + (isNegative ? height - yAdjust : yAdjust);
                                set._valueBelowPoint = 1;
                                if (is3D) {
                                    textX -= xDepth;
                                    textY += yDepth;
                                }
                            }
                            // If space not available inside column
                            // Try to fit the label outside column
                            else if (outsideColSpace >= textHeight) {
                                textY = yPos + (isNegative ? height + yAdjust : -yAdjust);
                                if (is3D && isNegative) {
                                    textX -= xDepth;
                                    textY += yDepth;
                                }
                            } else {
                                textY = yPos + (isNegative ? height - yAdjust : yAdjust);
                                set._valueBelowPoint = 1;
                                if (is3D) {
                                    textX -= xDepth;
                                    textY += yDepth;
                                }
                            }
                            // If space not available inside or outside column
                            // find the larger space available and place the column
                        } else {
                            // If space is available inside column
                            if (outsideColSpace >= textHeight) {
                                textY = yPos + (isNegative ? height + yAdjust : -yAdjust);
                                //textX += xDepth || 0;
                                if (is3D) {
                                    if (isNegative) {
                                        textX -= xDepth;
                                        textY += yDepth;
                                    }
                                    else {
                                        textX -= xDepth / 2;
                                    }

                                }
                            } else if (insideColSpace >= textHeight) {
                                textY = yPos + (isNegative ? height - yAdjust : yAdjust);
                                set._valueBelowPoint = 1;
                                if (is3D) {
                                    textX -= xDepth;
                                    textY += yDepth;
                                }
                            } else {
                                textY = yPos + (isNegative ? height - yAdjust : yAdjust);
                                set._valueBelowPoint = 1;
                                if (is3D) {
                                    textX -= xDepth;
                                    textY += yDepth;
                                }
                            }
                        }
                    }

                    if (!valEle) {
                        /** @todo
                         * Code to be checked on bBOX calc.
                         * Related code is in widgets.js
                         * => paper.text(dataLabelsLayer).css(style)
                         */
                        valEle = plotItem.dataLabel = paper.text({
                            text: displayValue,
                            'class': 'fusioncharts-label',
                            x: textX,
                            y: textY,
                            fill: style.color,
                            'font-size': style.fontSize,
                            visibility: seriesVisibility
                        }, dataLabelsLayer)
                        .attr({
                            'line-height': style.lineHeight,
                            'text-bound': [style.backgroundColor, style.borderColor,
                                style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash]
                        });
                    } else {
                        valEle.attr({
                            x: textX,
                            y: textY,
                            visibility: seriesVisibility
                        });
                    }

                    //css && valEle.css(css);
                    rotateValues && valEle.attr('transform', 'T0,0,R' + rotateValues);

                } else if (valEle) {
                    valEle.attr({
                        text: BLANK
                    });
                }

                return valEle;
            },

            /** @todo remove use of floated column type */
            drawPlotFloatedcolumn: function (plot, dataOptions) {
                this.drawPlotColumn.call(this, plot, dataOptions);
            },

            drawPlotColumn3d: function (plot, dataOptions) {
                this.drawPlotColumn.call(this, plot, dataOptions);
            },

            drawPlotBar: function (plot, dataOptions) {
                var chart = this,
                    data = plot.data,
                    ln = data.length,
                    plotItems = plot.items,
                    datasetGraphics = plot.graphics = [],
                    paper = chart.paper,
                    logic = chart.logic,
                    layers = chart.layers,
                    options = chart.options,
                    elements = chart.elements,
                    chartOptions = options.chart,
                    // tooltip options
                    tooltipOptions = options.tooltip || {},
                    isTooltip = tooltipOptions.enabled !== false,
                    toolText,
                    // Directly Accessing chart definition JSON Data
                    chartAttributes = chart.definition.chart,
                    seriesOptions = options.plotOptions.series,
                    style = seriesOptions.dataLabels.style,
                    labelCSS = {
                        fontFamily: style.fontFamily,
                        fontSize: style.fontSize,
                        lineHeight: style.lineHeight,
                        fontWeight: style.fontWeight,
                        fontStyle: style.fontStyle
                    },
                    xAxis = chart.xAxis[dataOptions.xAxis || 0],
                    yAxis = chart.yAxis[dataOptions.yAxis || 0],
                    // is 3D
                    is3D = logic.is3D,
                    // is stacked chart
                    isStacked = logic.isStacked,
                    canvasBorderOpacity = chartOptions.canvasBorderOpacity =
                        R.color(chartOptions.plotBorderColor).opacity,
                    canvasBorderWidth = chart.canvasBorderWidth,
                    hasValidCanvasBorder = chartOptions.isCanvasBorder =
                        canvasBorderOpacity !== 0 && canvasBorderWidth > 0,

                    animationDuration = isNaN(+seriesOptions.animation) && seriesOptions.animation.duration ||
                        seriesOptions.animation * 1000,

                    numColumns = dataOptions.numColumns || 1,
                    columnPosition = dataOptions.columnPosition || 0,

                    use3DLighting = chartOptions.use3DLighting,
                    seriesVisibility = dataOptions.visible === false ?
                        'hidden' : 'visible',
                    overlapColumns = chartOptions.overlapColumns,

                    xAxisZeroPos = xAxis.getAxisPosition(0),
                    xAxisFirstPos = xAxis.getAxisPosition(1),
                    groupMaxWidth = xAxisFirstPos - xAxisZeroPos,
                    definedGroupPadding = chartAttributes &&
                        chartAttributes.plotspacepercent,
                    plotPaddingPercent = pluckNumber(chartAttributes &&
                        chartAttributes.plotpaddingpercent),
                    groupPadding = seriesOptions.groupPadding,
                    maxColWidth = seriesOptions.maxColWidth,
                    groupNetWidth = (1 - definedGroupPadding * 0.01) * groupMaxWidth ||
                        mathMin(
                            groupMaxWidth * (1 - groupPadding * 2),
                            maxColWidth * numColumns
                    ),

                    groupNetHalfWidth = groupNetWidth / 2,
                    columnWidth = groupNetWidth / numColumns,
                    plotPadding = numColumns > 1 ?
                        (!overlapColumns && plotPaddingPercent === UNDEFINED ?
                        4 :
                        (plotPaddingPercent > 0 ? (columnWidth * plotPaddingPercent / 100) : 0)) : 0,
                    plotEffectivePadding = mathMin(columnWidth - 1, plotPadding),
                    height = columnWidth - plotEffectivePadding,

                    yPosFactor = (columnPosition * columnWidth) - groupNetHalfWidth +
                        plotEffectivePadding / 2,

                    yMax = yAxis.max,
                    yMin = yAxis.min,

                    isAllPositive = yMax > 0 && yMin > 0,
                    isAllNegative = yMax < 0 && yMin < 0,

                    yBase = isAllNegative ? yMax :
                        (isAllPositive ? yMin : 0),

                    yBasePos = yAxis.getAxisPosition(yBase),

                    plotRadius = pluckNumber(chartOptions.useRoundEdges, 0),

                    canvasTop = chart.canvasTop,
                    canvasLeft = chart.canvasLeft,
                    canvasHeight = chart.canvasHeight,
                    canvasRight = chart.canvasRight,
                    chartW = chart.chartWidth,
                    chartH = chart.chartHeight,
                    animationComplete,

                    MINWIDTH = 1,
                    xDepth,
                    yDepth,
                    width,

                    // Hover settings
                    setHoverEffect,
                    setRolloverProperties,
                    setRolloutAttr,
                    setRolloverAttr,

                    isNegative,
                    valEle,
                    plotItem,
                    i,
                    fi,
                    set,
                    setLink,
                    setBorderWidth,

                    x,
                    y,
                    previousY,
                    xPos,
                    yPos,
                    previousYPos,

                    // Zero plane settings
                    zeroPlaneColor,
                    zeroPlaneBorderColor,
                    zeroPlaneShowBorder,
                    effectiveZeroPlaneThickness = yAxis.axisData.effectiveZeroPlaneThickness,

                    datasetLayer = layers.dataset = layers.dataset || paper.group('dataset-orphan'),
                    dataLabelsLayer = layers.datalabels = layers.datalabels ||
                        paper.group('datalabels').insertAfter(datasetLayer),
                    trackerLayer = layers.tracker,

                    setElem,
                    hotElem,
                    eventArgs,
                    attrObj,
                    group,
                    plotGroup,
                    plotNegativeGroup,
                    plotNegativeGroupArray,
                    zeroPlaneGroup,
                    plotPositiveGroup,
                    plotPositiveGroupArray,
                    targetGroup,
                    shadowGroup,
                    crispBox,
                    clickFunc = function (data) {
                        var ele = this;
                        plotEventHandler.call(ele, chart, data);
                    },
                    rolloverResponseSetter = function (elem, elemHoverAttr) {
                        return function (data) {
                            var ele = this;
                            elem.attr(elemHoverAttr);
                            plotEventHandler.call(ele, chart, data, ROLLOVER);
                        };
                    },
                    rolloutResponseSetter = function (elem, elemUnHoverAttr) {
                        return function (data) {
                            var ele = this;
                            elem.attr(elemUnHoverAttr);
                            plotEventHandler.call(ele, chart, data, ROLLOUT);
                        };
                    },
                    crispenedHeight;

                // Dynamic CSS
                // @todo: Move to the proper place according to the architecture.
                chart.addCSSDefinition('.fusioncharts-datalabels .fusioncharts-label', labelCSS);
                dataLabelsLayer.attr('class', 'fusioncharts-datalabels');

                // hide the data labels group. Will be visible after animation completes
                if (animationDuration) {
                    chart.animationCompleteQueue.push({
                        fn: function () {
                            dataLabelsLayer.attr({
                                transform: '...t' + -chartW + COMMA + -chartH
                            });
                        },
                        scope: chart
                    });
                    dataLabelsLayer.attr({
                        transform: '...t' + chartW + COMMA + chartH
                    });
                }


                // create plot group
                group = datasetLayer;
                if (isStacked) {
                    shadowGroup = group.shadows || (group.shadows = paper.group('shadows', group).toBack());
                }
                plotGroup = group.column = (group.column || paper.group('bars', group));

                if (is3D) {

                    xDepth = chartOptions.xDepth || 0;
                    yDepth = chartOptions.yDepth || 0;

                    plotNegativeGroup = plotGroup.negative =
                        (plotGroup.negative || paper.group('negative-values', plotGroup));

                    plotPositiveGroup = plotGroup.column =
                        (plotGroup.column || paper.group('positive-values', plotGroup));

                    // Draw zero plane
                    zeroPlaneGroup = plotGroup.zeroPlane;
                    if (!zeroPlaneGroup && yMin < 0 && yMax >= 0) {

                        zeroPlaneGroup = plotGroup.zeroPlane =
                            paper.group('zero-plane', plotGroup)
                            .insertBefore(plotPositiveGroup);

                        zeroPlaneColor = chartOptions.zeroPlaneColor;
                        zeroPlaneBorderColor = chartOptions.zeroPlaneBorderColor;
                        zeroPlaneShowBorder = chartOptions.zeroPlaneShowBorder;

                        elements.zeroplane = paper.cubepath(
                            yBasePos - xDepth,
                            canvasTop + yDepth,
                            MINWIDTH,
                            canvasHeight,
                            xDepth,
                            yDepth,
                            zeroPlaneGroup
                        )
                            .attr({
                                'fill': [zeroPlaneColor, !use3DLighting],
                                'stroke': zeroPlaneBorderColor || NONE,
                                'stroke-width': zeroPlaneShowBorder ? 1 : 0
                            });

                    }

                    if (!(plotNegativeGroupArray = plotNegativeGroup.data('categoryplots'))) {
                        plotNegativeGroup.data('categoryplots', new Array(ln));
                        plotNegativeGroupArray = plotNegativeGroup.data('categoryplots');

                    }
                    if (!(plotPositiveGroupArray = plotPositiveGroup.data('categoryplots'))) {
                        plotPositiveGroup.data('categoryplots', new Array(ln));
                        plotPositiveGroupArray = plotPositiveGroup.data('categoryplots');

                    }

                    for (i = 0; i < ln; i += 1) {
                        plotNegativeGroupArray[i] = plotNegativeGroupArray[i] ||
                            paper.group(plotNegativeGroup);
                        plotPositiveGroupArray[i] = plotPositiveGroupArray[i] ||
                            paper.group(plotPositiveGroup);
                    }

                } else {

                    // clip bars inside canvas
                    if (!plotGroup.attrs['clip-rect']) {
                        plotGroup.attr({
                            'clip-rect': elements['clip-canvas']
                        });
                    }

                    targetGroup = plotGroup;
                }

                //draw data
                for (i = 0, fi = ln - 1; i < ln; i += 1, fi -= 1) {
                    set = data[i];
                    y = set.y;

                    setElem = hotElem = null;

                    if (y === null) {
                        if ((plotItem = plotItems[i])) {

                            setElem = plotItem.graphic;
                            if (!is3D) {
                                setElem.attr({
                                    width: 0
                                });
                            }
                        }
                    }
                    // when valid value
                    else {
                        x = pluckNumber(set.x, i);
                        setLink = set.link,
                        toolText = set.toolText;
                        setBorderWidth = toFloat(set.borderWidth) || 0;

                        yPos = xAxis.getAxisPosition(x) + yPosFactor;

                        previousY = set.previousY;
                        previousYPos = previousY ? yAxis.getAxisPosition(previousY) : yBasePos;
                        xPos = yAxis.getAxisPosition(y + (previousY || 0));
                        width = mathAbs(xPos - previousYPos);

                        isNegative = true;
                        if (y > 0) {
                            xPos = previousYPos;
                            isNegative = false;
                        }

                        eventArgs = {
                            index: i,
                            link: setLink,
                            value: set.y,
                            displayValue: set.displayValue,
                            categoryLabel: set.categoryLabel,
                            toolText: set.toolText,
                            id: plot.userID,
                            datasetIndex: plot.index,
                            datasetName: plot.name,
                            visible: plot.visible
                        };

                        if (is3D) {

                            // manage positive and negative group
                            targetGroup = y < 0 ? plotNegativeGroupArray :
                                plotPositiveGroupArray;

                            if (!(plotItem = plotItems[i])) {
                                plotItem = plotItems[i] = {
                                    index: i,
                                    value: y,
                                    graphic: paper.cubepath(targetGroup[fi]),
                                    dataLabel: null,
                                    tracker: null
                                };
                            }

                            setElem = plotItem.graphic;


                            // Hover consmetics
                            setRolloutAttr = setRolloverAttr = {};
                            if ((setHoverEffect = set.hoverEffects)) {
                                setRolloutAttr = {
                                    'fill': [toRaphaelColor(set.color), !use3DLighting],
                                    stroke: setBorderWidth &&
                                        toRaphaelColor(set.borderColor) || 'NONE',
                                    'stroke-width': setBorderWidth
                                };

                                setRolloverProperties = set.rolloverProperties;

                                setRolloverAttr = {
                                    'fill': [toRaphaelColor(setRolloverProperties.color), !use3DLighting],
                                    stroke: setRolloverProperties.borderWidth &&
                                        toRaphaelColor(setRolloverProperties.borderColor) || 'NONE',
                                    'stroke-width': setRolloverProperties.borderWidth
                                };

                            }

                            setElem.attr({
                                cubepath: [
                                    animationDuration ? yBasePos - xDepth : xPos - xDepth,
                                    yPos + yDepth,
                                    animationDuration ? 0 : width,
                                    height,
                                    xDepth,
                                    yDepth
                                ],
                                'fill': [toRaphaelColor(set.color), !use3DLighting],
                                stroke: setBorderWidth &&
                                    toRaphaelColor(set.borderColor) || 'NONE',
                                'stroke-width': setBorderWidth,
                                'stroke-dasharray': set.dashStyle,
                                'cursor': setLink ? 'pointer' : '',
                                'visibility': seriesVisibility
                            })
                                .shadow(seriesOptions.shadow && set.shadow, shadowGroup)
                                .data('BBox', {
                                    height: height,
                                    width: width,
                                    x: xPos,
                                    y: yPos
                                });
                            if (animationDuration) {
                                setElem.animate({
                                    cubepath: [
                                        xPos - xDepth,
                                        yPos + yDepth,
                                        width,
                                        height,
                                        xDepth,
                                        yDepth
                                    ]
                                }, animationDuration, 'normal', chart.getAnimationCompleteFn());
                            }

                            if (setLink || isTooltip) {
                                if (!isStacked && width < HTP) {
                                    xPos -= (HTP - width) / 2;
                                    width = HTP;
                                }
                                if (!plotItem.tracker) {
                                    plotItem.tracker = paper.cubepath(trackerLayer);
                                }
                                hotElem = plotItem.tracker;

                                hotElem.attr({
                                    cubepath: [
                                        xPos - xDepth,
                                        yPos + yDepth,
                                        width,
                                        height,
                                        xDepth,
                                        yDepth
                                    ],
                                    'cursor': setLink ? 'pointer' : '',
                                    stroke: setBorderWidth &&
                                        TRACKER_FILL || 'NONE',
                                    'stroke-width': setBorderWidth,
                                    'fill': TRACKER_FILL,
                                    ishot: true
                                });
                            }

                            (hotElem || setElem)
                                .data('eventArgs', eventArgs)
                                .click(clickFunc)
                                .hover(
                                    rolloverResponseSetter(setElem, setRolloverAttr),
                                    rolloutResponseSetter(setElem, setRolloutAttr)
                                )
                                .tooltip(toolText);
                            (hotElem || setElem)._.cubetop
                                .data('eventArgs', eventArgs)
                                .click(clickFunc)
                                .hover(
                                    rolloverResponseSetter(setElem, setRolloverAttr),
                                    rolloutResponseSetter(setElem, setRolloutAttr)
                                );
                            (hotElem || setElem)._.cubeside
                                .data('eventArgs', eventArgs)
                                .click(clickFunc)
                                .hover(
                                    rolloverResponseSetter(setElem, setRolloverAttr),
                                    rolloutResponseSetter(setElem, setRolloutAttr)
                                );

                            if (!isStacked || (isStacked && y < 0)) {
                                setElem.toBack();
                                hotElem && hotElem.toBack();
                            }
                        }
                        // 2D bars
                        else {
                            /* hotfixes start */
                            // in case xPos is right of canvas-left position -
                            // normalize
                            if (toInt(xPos) <= canvasLeft) {
                                width += xPos;
                                // 0.2 pixel gutter is used so that after crispening it does not cross the canvas-left
                                xPos = canvasLeft + (setBorderWidth / 2) + 0.2;
                                // compensate crispening of axisline
                                if (chartOptions.xAxisLineVisible && !hasValidCanvasBorder) {
                                    xPos -= 1;
                                }
                                width -= xPos;
                            }
                            // in case plot exceeds canvas-right position -
                            // normalize width
                            if (mathRound(xPos + width) >= canvasRight) {
                                // 0.2 pixel gutter is used so that after crispening it does not cross the canvas-right
                                width = canvasRight - xPos - (setBorderWidth / 2) - 0.2;
                            }

                            /* hotfixes end */

                            // crisp column
                            crispBox = R.crispBound(xPos, yPos, width, height,
                                setBorderWidth);
                            xPos = crispBox.x;
                            yPos = crispBox.y;
                            width = crispBox.width;
                            crispenedHeight = crispBox.height;
                            if (width <= MINWIDTH) {
                                width = MINWIDTH;
                                xPos += y < 0 ? -width : y === 0 ? 0 :
                                    effectiveZeroPlaneThickness > 1 ? width : 0;
                            }

                            if (!(plotItem = plotItems[i])) {
                                plotItem = plotItems[i] = {
                                    index: i,
                                    value: y,
                                    height: crispenedHeight,
                                    graphic: null,
                                    dataLabel: null,
                                    tracker: null
                                };
                            }
                            setElem = plotItem.graphic;

                            // Hover consmetics
                            setRolloutAttr = setRolloverAttr = {};
                            if ((setHoverEffect = set.hoverEffects)) {
                                setRolloutAttr = {
                                    fill: toRaphaelColor(set.color),
                                    stroke: toRaphaelColor(set.borderColor),
                                    'stroke-width': setBorderWidth,
                                    'stroke-dasharray': set.dashStyle
                                };

                                setRolloverProperties = set.rolloverProperties;

                                setRolloverAttr = {
                                    fill: toRaphaelColor(setRolloverProperties.color),
                                    stroke: toRaphaelColor(setRolloverProperties.borderColor),
                                    'stroke-width': setRolloverProperties.borderWidth,
                                    'stroke-dasharray': setRolloverProperties.dashStyle
                                };
                            }

                            attrObj = {
                                x: animationDuration ? yBasePos : xPos,
                                y: yPos,
                                width: animationDuration ? 0 : (width || MINWIDTH),
                                height: crispenedHeight,
                                r: plotRadius,
                                fill: toRaphaelColor(set.color),
                                stroke: toRaphaelColor(set.borderColor),
                                'stroke-width': setBorderWidth,
                                'stroke-dasharray': set.dashStyle,
                                'stroke-linejoin': 'miter',
                                'cursor': setLink ? 'pointer' : '',
                                'visibility': seriesVisibility
                            };

                            if (!setElem) {
                                setElem = plotItem.graphic = paper.rect(attrObj, targetGroup);
                            }
                            else {
                                setElem.attr(attrObj);
                            }

                            setElem.shadow(seriesOptions.shadow && set.shadow, shadowGroup)
                                .data('BBox', crispBox);

                            if (animationDuration) {
                                setElem.animate({
                                    x: xPos,
                                    width: width || MINWIDTH
                                }, animationDuration, 'normal', chart.getAnimationCompleteFn());
                            }
                            // Remove animation complete callback function, so that
                            // this will be called only once
                            animationComplete = undefined;

                            if (setLink || isTooltip) {
                                if (!isStacked && width < HTP) {
                                    xPos -= (HTP - width) / 2;
                                    width = HTP;
                                }

                                hotElem = plotItem.tracker;

                                attrObj = {
                                    x: xPos,
                                    y: yPos,
                                    width: width,
                                    height: height,
                                    r: plotRadius,
                                    'cursor': setLink ? 'pointer' : '',
                                    stroke: TRACKER_FILL,
                                    'stroke-width': setBorderWidth,
                                    'fill': TRACKER_FILL,
                                    ishot: true
                                };

                                if (!hotElem) {
                                    hotElem = plotItem.tracker = paper.rect(attrObj, trackerLayer);
                                }
                                else {
                                    hotElem.attr(attrObj);
                                }

                                hotElem.data('eventArgs', eventArgs);
                            }


                            (hotElem || setElem)
                                .data('eventArgs', eventArgs)
                                .click(clickFunc)
                                .hover(
                                    rolloverResponseSetter(setElem, setRolloverAttr),
                                    rolloutResponseSetter(setElem, setRolloutAttr)
                                )
                                .tooltip(toolText);
                        }

                        // Drawing of displayValue
                        valEle = chart.drawPlotBarLabel(plot, dataOptions, i, xPos, yPos);
                    }

                    valEle && datasetGraphics.push(valEle);
                    setElem && datasetGraphics.push(setElem);
                    hotElem && datasetGraphics.push(hotElem);

                    chart.drawTracker &&
                        chart.drawTracker.call(chart, plot, dataOptions, i);

                }

                plot.visible = (dataOptions.visible !== false);

                return plot;
            },

            drawPlotBarLabel: function (plot, dataOptions, i, xPos, yPos, dataLabelsLayer) {
                var chart = this,
                    options = chart.options,
                    logic = chart.logic,
                    chartOptions = options.chart,
                    seriesOptions = options.plotOptions.series,
                    paper = chart.paper,
                    layers = chart.layers,
                    style = seriesOptions.dataLabels.style,
                    rotateValues = chartOptions.rotateValues === 1 ? 270 : 0,
                    canvasLeft = chart.canvasLeft,
                    canvasWidth = chart.canvasWidth,
                    plotItems = plot.items,
                    data = plot.data,
                    set = data[i],
                    plotItem = plotItems[i],
                    valuePadding = chartOptions.valuePadding + GUTTER_2,
                    setElem = plotItem.graphic,
                    valEle = plotItem.dataLabel,
                    isNegative = set.y < 0,
                    // is stacked chart
                    isStacked = logic.isStacked,
                    // is 3D
                    is3D = logic.is3D,
                    xDepth = chartOptions.xDepth || 0,
                    yDepth = chartOptions.yDepth || 0,
                    displayValue = set.displayValue,
                    seriesVisibility = dataOptions.visible === false ? 'hidden' : 'visible',
                    placeValuesInside = chartOptions.placeValuesInside,
                    height,
                    colBBox,
                    insideColSpace,
                    outsideColSpace,
                    textHeight,
                    textY,
                    textX,
                    bBoxObj,
                    origTextWidth,
                    textWidth,
                    textGutter,
                    width,
                    xAdjust;

                dataLabelsLayer = dataLabelsLayer || layers.datalabels;

                if (defined(displayValue) && displayValue !== BLANK && set.y !== null) {
                    // First render the value text
                    if (!valEle) {
                        valEle = plotItem.dataLabel = paper.text({
                                'class': 'fusioncharts-label',
                                text: displayValue,
                                'font-size': style.fontSize,
                                'text-anchor': isStacked ? 'middle' : (isNegative ?
                                    /** @todo this boolean check needs optimisation */
                                    (placeValuesInside ? 'start' : 'end') : (placeValuesInside ? 'end' : 'start')),
                                title: (set.originalText || ''),
                                fill: style.color,
                                x: 0,
                                y: 0,
                                'line-height': style.lineHeight
                            }, dataLabelsLayer)
                            .attr('text-bound', [style.backgroundColor, style.borderColor,
                                style.borderThickness, style.borderPadding, style.borderRadius, style.borderDash
                            ]);
                            //.css(css);
                    }

                    // get the bBox to find height and width of the
                    // text.
                    bBoxObj = valEle.getBBox();
                    colBBox = setElem.data('BBox');
                    height = colBBox.height;
                    width = colBBox.width;

                    // If rotated values we use the width of the
                    // text as height
                    textHeight = rotateValues ? bBoxObj.width :
                        bBoxObj.height;
                    textWidth = origTextWidth = bBoxObj.width;
                    textWidth += valuePadding;
                    // in case of negative value place the value
                    // text below the
                    insideColSpace = height;
                    textY = yPos + (height * 0.5);
                    textX = xPos + (isNegative ? 0 : width);
                    textGutter = GUTTER_4;
                    xAdjust = valuePadding;

                    if (isNegative) {
                        outsideColSpace = xPos - canvasLeft;
                    } else {
                        outsideColSpace = (canvasLeft + canvasWidth) - (xPos + width);
                    }

                    // Space-management of dataValues
                    if (isStacked) {
                        textX += (isNegative ? width : -width) * 0.5;
                        textX -= is3D ? xDepth : 0;
                        textY += is3D ? yDepth : 0;
                    } else {
                        if (placeValuesInside) {
                            if (width >= textWidth) {
                                textX += isNegative ? xAdjust : -xAdjust;
                                if (is3D) {
                                    textX -= xDepth;
                                    textY += yDepth;
                                }
                            } else {
                                textX += isNegative ? -xAdjust : xAdjust;
                                if (is3D && isNegative) {
                                    textX -= xDepth;
                                }
                            }
                        } else {
                            if (outsideColSpace >= textWidth) {
                                textX += isNegative ? -xAdjust : xAdjust;
                                if (is3D && isNegative) {
                                    textX -= xDepth;
                                    textY += xDepth;
                                }
                            } else {
                                // Adjust text if there is not enough space to place
                                // the label outside of the data plot
                                textX += isNegative ? xAdjust + textWidth : -(xAdjust + textWidth);
                                if (is3D) {
                                    textX -= xDepth;
                                    textY += yDepth;
                                }
                            }
                        }
                        // Adjust if the text is going outside the canvas Area.
                        if (textX > (canvasLeft + canvasWidth)) {
                            textX = (canvasLeft + canvasWidth) -
                                (bBoxObj.width * 0.5) - GUTTER_4;
                        }
                        if (textX < canvasLeft) {
                            textX = canvasLeft + (bBoxObj.width * 0.5) + GUTTER_4;
                        }
                    }

                    valEle.attr({
                        x: textX,
                        y: textY,
                        visibility: seriesVisibility
                    });
                } else if (valEle) {
                    valEle.attr({
                        text: BLANK
                    });
                }
                return valEle;
            },

            drawPlotBar3d: function (plot, dataOptions) {
                this.drawPlotBar.call(this, plot, dataOptions);
            },

            drawPlotLine: function (plot, dataOptions) {
                var chart = this,
                    paper = chart.paper,
                    elements = chart.elements,
                    options = chart.options,
                    chartOptions = options.chart,
                    logic = chart.logic,
                    seriesOptions = options.plotOptions.series,
                    plotItems = plot.items,
                    datasetGraphics = plot.graphics = (plot.graphics || []),

                    plotItem,
                    xAxis = chart.xAxis[dataOptions.xAxis || 0],
                    yAxis = chart.yAxis[dataOptions.yAxis || 0],

                    // force segmeneted lines
                    isForceSegmentedLine = logic.multisetRealtime || logic.dragExtended,

                    // is waterfall
                    isWaterfall = logic.isWaterfall,
                    definedGroupPadding,
                    chartAttributes,
                    groupPadding,
                    maxColWidth,
                    groupNetWidth,
                    groupNetHalfWidth = 0,

                    // tooltip options
                    tooltipOptions = options.tooltip || {},
                    isTooltip = tooltipOptions.enabled !== false,
                    toolText,

                    animationDuration = isNaN(+seriesOptions.animation) &&
                        seriesOptions.animation.duration ||
                        seriesOptions.animation * 1000,
                    lineAnimation,

                    style = seriesOptions.dataLabels.style,
                    labelCSS = {
                        fontFamily: style.fontFamily,
                        fontSize: style.fontSize,
                        lineHeight: style.lineHeight,
                        fontWeight: style.fontWeight,
                        fontStyle: style.fontStyle
                    },

                    xDepth = chartOptions.xDepth || 0,
                    yDepth = chartOptions.yDepth || 0,
                    series2D3Dshift = chartOptions.series2D3Dshift,
                    isStepLine = dataOptions.step,
                    stepLineDrawVerticalJoins = dataOptions.drawVerticalJoins,
                    stepLineUseForwardSteps = dataOptions.useForwardSteps,
                    data = plot.data,
                    seriesVisibility = dataOptions.visible === false ? 'hidden' : 'visible',
                    i,
                    ln = data.length,
                    xAxisZeroPos = xAxis.getAxisPosition(0),
                    xAxisFirstPos = xAxis.getAxisPosition(1),
                    pointDistance = xAxisFirstPos - xAxisZeroPos,
                    totalCanvasWidth = pointDistance * ln,

                    scroll = xAxis.axisData.scroll || {},
                    isScroll = chartOptions.hasScroll || false,
                    scrollPosition,

                    connectNullData = seriesOptions.connectNullData,
                    chartW = chart.chartWidth,
                    chartH = chart.chartHeight,
                    animationComplete = function () {
                        lineGroup.attr({
                            'clip-rect': null
                        });
                        anchorShadowGroup.show();
                        lineShadowGroup.show();
                        anchorGroup.show();
                        dataLabelsLayer.attr({
                            transform: '...t' + -chartW + COMMA + -chartH
                        });
                    },
                    set,
                    setLink,
                    markerRadius,
                    x,
                    y,
                    previousY,
                    lastXPos,
                    lastYPos = null,
                    xPos,
                    yPos,
                    seriesLineWidth = seriesOptions.connectorWidth = toFloat(dataOptions.lineWidth),
                    plotColor = dataOptions.color,
                    setColor,
                    setDashStyle,
                    seriesDashStyle = seriesOptions.connectorDashStyle = dataOptions.dashStyle,
                    marker,
                    symbol,
                    dip,
                    setMarkerElem,
                    hotElem,
                    // Hover settings
                    setRolloverProperties,
                    setRolloutAttr,
                    setRolloverAttr,
                    setLineElem,
                    layers = chart.layers,
                    datasetLayer = layers.dataset = layers.dataset || paper.group('dataset-orphan'),
                    dataLabelsLayer = layers.datalabels = layers.datalabels ||
                        paper.group('datalabels').insertAfter(datasetLayer),
                    trackerLayer = layers.tracker,
                    clipCanvasInit = elements['clip-canvas-init'].slice(0),
                    clipCanvas = elements['clip-canvas'].slice(0),
                    isReverse = yAxis.axisData.reversed,
                    yMax = yAxis.max,
                    yMin = yAxis.min,
                    yBase = yMax > 0 && yMin > 0 ? !isReverse ? yMin : yMax :
                        (yMax < 0 && yMin < 0 ? !isReverse ? yMax : yMin : !isReverse ? 0 : yMax),
                    yBasePos = yAxis.getAxisPosition(yBase) + (series2D3Dshift ? yDepth : 0),
                    linePath = [],
                    trackerRadius = chartOptions.anchorTrackingRadius,
                    isDragable = /drag/ig.test(chart.logic.rendererId),
                    groupId,
                    eventArgs,
                    group,
                    lineGroupParent,
                    lineShadowGroup,
                    anchorShadowGroup,
                    lineGroup,
                    anchorGroup,
                    anchorShadow,
                    lineSegmentChange,
                    lscthash,
                    valEle,
                    imgRef,
                    lastMoveCommand = [],
                    clickFunc = function (data) {
                        var ele = this;
                        plotEventHandler.call(ele, chart, data);
                    },
                    rolloverResponseSetter = function (plotItem) {
                        return function (data) {
                            chart.hoverPlotAnchor(this, data, ROLLOVER, plotItem, chart);
                        };
                    },
                    rolloutResponseSetter = function (plotItem) {
                        return function (data) {
                            chart.hoverPlotAnchor(this, data, ROLLOUT, plotItem, chart);
                        };
                    },
                    onLoadSetter = function (x, y, marker, plotItem, eventArgs, toolText, setRollover, i) {
                        return function () {
                            var imgRef = this,
                                url = marker.imageUrl,
                                scale = marker.imageScale,
                                alpha = marker.imageAlpha,
                                hoverAlpha = setRollover.imageHoverAlpha,
                                hoverScale = setRollover.imageHoverScale,
                                imgH = imgRef.height * scale * 0.01,
                                imgW = imgRef.width * scale * 0.01,
                                hotW = (imgRef.width * hoverScale * 0.01),
                                trackerAttr;

                            setRolloutAttr = {
                                x: x - imgRef.width * scale * 0.005,
                                y: y - imgRef.height * scale * 0.005,
                                width: imgW,
                                height: imgH,
                                alpha: alpha
                            };

                            setRolloverAttr = {
                                x: x - imgRef.width * hoverScale * 0.005,
                                y: y - imgRef.height * hoverScale * 0.005,
                                width: hotW,
                                height: imgRef.height * hoverScale * 0.01,
                                alpha: hoverAlpha
                            };

                            trackerAttr = (hotW > imgW) ? setRolloverAttr : setRolloutAttr;
                            if (isDragable) {
                                trackerAttr = {
                                    cx: x,
                                    cy: y,
                                    r: mathMax(imgH, imgW) * 0.5
                                };
                            }

                            plotItem.graphic = setMarkerElem = paper.image(url, anchorGroup)
                                .attr(setRolloutAttr)
                                .css({
                                    opacity: alpha * 0.01
                                })
                                .data('alwaysInvisible', !scale)
                                .data('setRolloverProperties', setRollover)
                                .data('setRolloverAttr', setRolloverAttr)
                                .data('setRolloutAttr', setRolloutAttr)
                                .data('anchorRadius', scale)
                                .data('anchorHoverRadius', hoverScale);

                            setMarkerElem && datasetGraphics.push(setMarkerElem);

                            if (setLink || isTooltip || setRollover) {
                                hotElem = plotItem.tracker = (isDragable ?
                                    paper.circle(trackerLayer) : paper.rect(trackerLayer))
                                    .attr(trackerAttr)
                                    .attr({
                                        cursor: setLink ? 'pointer' : '',
                                        stroke: TRACKER_FILL,
                                        'stroke-width': marker.lineWidth,
                                        fill: TRACKER_FILL,
                                        ishot: true,
                                        visibility: seriesVisibility
                                    })
                                    .data('eventArgs', eventArgs)
                                    .data('groupId', groupId)
                                    .click(clickFunc)
                                    .hover(
                                        rolloverResponseSetter(plotItem),
                                        rolloutResponseSetter(plotItem)
                                    )
                                    .tooltip(toolText);
                            }
                            chart.drawTracker && chart.drawTracker.call(chart, plot, dataOptions, i);

                            valEle = plotItem.dataLabel = chart.drawPlotLineLabel(plot, dataOptions, i, x, y);
                            valEle && datasetGraphics.push(valEle);
                        };
                    },
                    onErrorSetter = function (x, y, marker, plotItem, eventArgs, toolText, setRollover, i) {
                        // Handle if image load error
                        return function () {
                            valEle = plotItem.dataLabel = chart.drawPlotLineLabel(plot, dataOptions, i, x, y);
                            valEle && datasetGraphics.push(valEle);
                        };
                    };

                // Dynamic CSS
                // @todo: Move to the proper place according to the architecture.
                chart.addCSSDefinition('.fusioncharts-datalabels .fusioncharts-label', labelCSS);
                dataLabelsLayer.attr('class', 'fusioncharts-datalabels');

                seriesOptions.connectorOpacity = R.color(plotColor).opacity;
                yAxis.yBasePos = yBasePos;

                if (isWaterfall) {
                    // column calculation for waterfall chart
                    // Directly Accessing chart definition JSON Data
                    chartAttributes = chart.definition.chart;
                    definedGroupPadding = chartAttributes &&
                        chartAttributes.plotspacepercent;
                    groupPadding = seriesOptions.groupPadding;
                    maxColWidth = seriesOptions.maxColWidth;
                    groupNetWidth = (1 - definedGroupPadding * 0.01) * pointDistance ||
                        mathMin(
                            pointDistance * (1 - groupPadding * 2),
                            maxColWidth * 1
                    );
                    groupNetHalfWidth = groupNetWidth / 2;
                }

                // hide the data labels group. Will be visible after animation completes
                dataLabelsLayer.attr({
                    transform: '...t' + chartW + COMMA + chartH
                });

                if (animationDuration) {
                    chart.animationCompleteQueue.push({
                        fn: animationComplete,
                        scope: chart
                    });
                }

                //create series group
                group = datasetLayer;
                lineGroupParent = group.line ||
                    (group.line = paper.group('line-connector', group));
                lineShadowGroup = plot.lineShadowLayer ||
                    (plot.lineShadowLayer = paper.group('connector-shadow', lineGroupParent));
                anchorShadowGroup = plot.anchorShadowLayer ||
                    (plot.anchorShadowLayer = paper.group('anchor-shadow', lineGroupParent));
                lineGroup = plot.lineLayer ||
                    (plot.lineLayer = paper.group('connector', lineGroupParent));
                anchorGroup = plot.anchorLayer ||
                    (plot.anchorLayer = paper.group('anchors', lineGroupParent));

                anchorGroup.hide();
                lineShadowGroup.hide();
                anchorShadowGroup.hide();

                //draw data
                for (i = 0; i < ln; i += 1) {
                    set = data[i];
                    y = set.y;
                    previousY = set.previousY || 0;
                    toolText = set.toolText;
                    groupId = plot.index + '_' + i;

                    setLineElem = valEle = setMarkerElem = hotElem = null;
                    plotItem = plotItems[i] = {
                        index: i,
                        value: null,
                        graphic: null,
                        connector: null,
                        dataLabel: null,
                        shadowGroup: anchorShadowGroup,
                        tracker: null
                    };

                    if (y === null) {
                        lastMoveCommand.length = 0;
                        if (connectNullData === 0) {
                            lastYPos = null;
                        }
                    } else {

                        x = pluckNumber(set.x, i);
                        setLink = set.link;
                        /*
                         * BoxAndWhisker chart uses line to draw its other related seris
                         * and its anchor. Due to this and BoxAndWhisker being a
                         * multiSeries chart. We have to take few extra measures
                         */
                        if (dataOptions.relatedSeries === 'boxandwhisker') {
                            //a displacemnet value defined in box and whisker
                            dataOptions.pointStart && (x += dataOptions.pointStart);
                        }

                        //Multi series related management.
                        yPos = yAxis.getAxisPosition(y + previousY) +
                            (series2D3Dshift ? yDepth : 0);
                        xPos = xAxis.getAxisPosition(x) - xDepth;

                        // crisp line positions
                        xPos = getCrispValues(xPos, seriesLineWidth, seriesLineWidth).position;
                        yPos = getCrispValues(yPos, seriesLineWidth, seriesLineWidth).position;

                        marker = set.marker;
                        if (marker && marker.enabled) {
                            symbol = marker.symbol.split('_');
                            dip = symbol[0] === 'spoke' ? 1 : 0;
                            markerRadius = marker.radius;
                            anchorShadow = marker.shadow;

                            eventArgs = {
                                index: i,
                                link: setLink,
                                value: set.y,
                                displayValue: set.displayValue,
                                categoryLabel: set.categoryLabel,
                                toolText: set.toolText,
                                id: plot.userID,
                                datasetIndex: plot.index,
                                datasetName: plot.name,
                                visible: plot.visible
                            };

                            // Hover consmetics
                            setRolloutAttr = setRolloverAttr = {};
                            setRolloverProperties = set.rolloverProperties;

                            if (marker.imageUrl) {
                                imgRef = new Image();
                                imgRef.onload = onLoadSetter(xPos, yPos, marker, plotItem, eventArgs, toolText,
                                    setRolloverProperties, i);

                                imgRef.onerror = onErrorSetter(xPos, yPos, marker, plotItem, eventArgs, toolText,
                                    setRolloverProperties, i);

                                imgRef.src = marker.imageUrl;
                            } else {
                                if (setRolloverProperties) {
                                    setRolloutAttr = {
                                        polypath: [symbol[1] || 2, xPos, yPos,
                                            markerRadius, marker.startAngle,
                                            dip
                                        ],
                                        fill: toRaphaelColor(marker.fillColor),
                                        'stroke-width': marker.lineWidth,
                                        stroke: toRaphaelColor(marker.lineColor)
                                    };

                                    setRolloverAttr = {
                                        polypath: [setRolloverProperties.sides || 2,
                                            xPos, yPos,
                                            setRolloverProperties.radius,
                                            setRolloverProperties.startAngle,
                                            setRolloverProperties.dip
                                        ],
                                        fill: toRaphaelColor(setRolloverProperties.fillColor),
                                        'stroke-width': setRolloverProperties.lineWidth,
                                        stroke: toRaphaelColor(setRolloverProperties.lineColor)
                                    };

                                }

                                setMarkerElem = plotItem.graphic =
                                    paper.polypath(symbol[1] || 2, xPos, yPos,
                                        markerRadius, marker.startAngle,
                                        dip, anchorGroup)
                                    .attr({
                                        fill: toRaphaelColor(marker.fillColor),
                                        'stroke-width': marker.lineWidth,
                                        stroke: toRaphaelColor(marker.lineColor),
                                        'cursor': setLink ? 'pointer' : '',
                                        'visibility': !markerRadius ? 'hidden' : seriesVisibility
                                    })
                                    .data('alwaysInvisible', !markerRadius)
                                    .data('setRolloverProperties', setRolloverProperties)
                                    .data('setRolloverAttr', setRolloverAttr)
                                    .data('setRolloutAttr', setRolloutAttr)
                                    .data('anchorRadius', markerRadius)
                                    .data('anchorHoverRadius', setRolloverProperties &&
                                        setRolloverProperties.radius)
                                    .shadow(anchorShadow || false, anchorShadowGroup);

                                if (setLink || isTooltip || setRolloverProperties) {
                                    markerRadius = mathMax(markerRadius,
                                        setRolloverProperties &&
                                        setRolloverProperties.radius || 0, trackerRadius);

                                    hotElem = plotItem.tracker =
                                        paper.circle({
                                            cx: xPos,
                                            cy: yPos,
                                            r: markerRadius,
                                            cursor: setLink ? 'pointer' : '',
                                            stroke: TRACKER_FILL,
                                            'stroke-width': marker.lineWidth,
                                            fill: TRACKER_FILL,
                                            ishot: true,
                                            visibility: seriesVisibility
                                        }, trackerLayer);
                                }

                                (hotElem || setMarkerElem)
                                    .data('eventArgs', eventArgs)
                                    .data('groupId', groupId)
                                    .click(clickFunc)
                                    .hover(rolloverResponseSetter(plotItem), rolloutResponseSetter(plotItem))
                                    .tooltip(toolText);

                                chart.drawTracker &&
                                    chart.drawTracker.call(chart, plot, dataOptions, i);
                            }
                        }

                        lineSegmentChange = (lscthash !== [
                            toRaphaelColor(set.color || plotColor),
                            set.dashStyle || seriesDashStyle
                        ].join(':'));

                        if (lastYPos !== null) {
                            if (lastMoveCommand.length) {
                                linePath = linePath.concat(lastMoveCommand);
                                lastMoveCommand.length = 0;
                            }
                            // move to the starting position of the line segment
                            if (isForceSegmentedLine || isWaterfall || !linePath.join('')) {
                                linePath.push(M, lastXPos, lastYPos);
                            }

                            isWaterfall && linePath.push('m', -groupNetHalfWidth, 0);

                            // Management for Step Line
                            if (isStepLine) {
                                if (stepLineUseForwardSteps) {
                                    // When asked to use forwardSteps, draw horizontally first
                                    linePath.push(H, xPos);

                                    isWaterfall && linePath.push('h', groupNetHalfWidth);

                                    if (stepLineDrawVerticalJoins) {
                                        // and then draw vertically
                                        // Applicable only if drawVerticalJoins is true
                                        linePath.push(V, yPos);
                                    } else {
                                        linePath.push('m', 0, yPos - lastYPos);
                                    }
                                } else {
                                    // When forwardSteps is false, draw vertically first
                                    // Applicable only if drawVerticalJoins is true
                                    if (stepLineDrawVerticalJoins) {
                                        linePath.push(V, yPos);
                                    }
                                    // Draw horizontally after verical drawing
                                    // Move to the vertical position as a safegurd
                                    // when drawVerticalJoins is false
                                    linePath.push(M, lastXPos, yPos, H, xPos);
                                }
                            }
                            // Drawing for normal line drawing
                            else {
                                // Draw line to end position
                                linePath.push(L, xPos, yPos);
                            }

                            if (isForceSegmentedLine || lineSegmentChange) {
                                // draw line path

                                setLineElem = plotItem.connector = paper.path(linePath, lineGroup)
                                    .attr({
                                        'stroke-dasharray': setDashStyle,
                                        'stroke-width': seriesLineWidth,
                                        'stroke': setColor,
                                        'stroke-linecap': 'round',
                                        'stroke-linejoin': seriesLineWidth > MAX_MITER_LINEJOIN ? 'round' : 'miter',
                                        'visibility': seriesVisibility
                                    })
                                    .shadow(seriesOptions.shadow && set.shadow, lineShadowGroup);
                                linePath = [];
                            }
                        } else {
                           /**
                            * @todo retain this line for future reference
                            !isForceSegmentedLine && linePath.push(M, xPos, yPos);
                            */
                            !isForceSegmentedLine && lastMoveCommand.push(M, xPos, yPos);
                        }


                        !(marker && marker.imageUrl) && (valEle = plotItem.dataLabel =
                            chart.drawPlotLineLabel(plot, dataOptions, i, xPos, yPos));

                        lastXPos = xPos;
                        lastYPos = yPos;
                        setColor = toRaphaelColor(set.color || plotColor);
                        setDashStyle = set.dashStyle || seriesDashStyle;

                        lscthash = [setColor, setDashStyle].join(':');
                    }

                    valEle && datasetGraphics.push(valEle);
                    setMarkerElem && datasetGraphics.push(setMarkerElem);
                    setLineElem && datasetGraphics.push(setLineElem);
                    hotElem && datasetGraphics.push(hotElem);
                }

                // draw final line path after iterating all points
                if (!isForceSegmentedLine && linePath.join('')) {
                    setLineElem = paper.path(linePath, lineGroup)
                        .attr({
                            'stroke-dasharray': setDashStyle,
                            'stroke-width': seriesLineWidth,
                            'stroke': setColor,
                            'stroke-linecap': 'round',
                            'stroke-linejoin': seriesLineWidth > MAX_MITER_LINEJOIN ? 'round' : 'miter',
                            'visibility': seriesVisibility
                        })
                        .shadow(seriesOptions.shadow && set.shadow, lineShadowGroup);
                    setLineElem && datasetGraphics.push(setLineElem);
                }

                // Animation from right when scrollToEnd is 1
                if (isScroll) {
                    scrollPosition = scroll.startPercent;
                    clipCanvas[2] = totalCanvasWidth + clipCanvasInit[0];
                    if (scrollPosition === 1) {
                        clipCanvasInit[0] = clipCanvas[2];
                        clipCanvas[0] = 0;
                    }

                }


                if (animationDuration) {
                    // clip-canvas animation to line chart
                    lineAnimation = R.animation({
                            'clip-rect': clipCanvas
                        },
                        animationDuration,
                        isScroll ? 'easeIn' : 'normal',
                        chart.getAnimationCompleteFn());


                    lineGroup.attr({
                        'clip-rect': clipCanvasInit
                    })
                        .animate(isWaterfall ?
                            lineAnimation.delay(animationDuration) : lineAnimation);
                } else {
                    animationComplete && animationComplete();
                    // Remove animation complete callback function, so that
                    // this will be called only once
                    animationComplete = undefined;
                }

                plot.visible = (dataOptions.visible !== false);
                return plot;
            },

            hoverPlotAnchor: function (event, data, eventType, plotItem, chart) {

                var plotElem = plotItem.graphic,
                    valElem = plotItem.dataLabel,
                    options = chart.options,
                    chartOptions = options.chart,
                    rotateValues = chartOptions.rotateValues === 1 ? 270 : 0,
                    setRolloverProperties = plotElem.data('setRolloverProperties'),
                    isRealtime = plotElem.data('isRealtime'),
                    anchorDef = isRealtime && plotElem.attr('polypath'),
                    elemHoverAttr = plotElem.data('setRolloverAttr'),
                    isImg = plotElem.type === 'image',
                    elemUnHoverAttr = plotElem.data('setRolloutAttr'),
                    radiusDiff = valElem && (valElem.data('isBelow') ? 1 : -1) *
                        (isImg ? (elemHoverAttr.height - elemUnHoverAttr.height) * 0.5 :
                            (plotElem.data('anchorHoverRadius') - plotElem.data('anchorRadius'))),
                    selectedAttr = eventType == ROLLOVER ? elemHoverAttr : elemUnHoverAttr,
                    valAnimation = {
                        transform: 'T0,' + ((eventType === ROLLOVER) ? radiusDiff : 0) + 'R' + rotateValues
                    },
                    staticAttr = {
                        fill: selectedAttr.fill,
                        'stroke-width': selectedAttr['stroke-width'],
                        stroke: selectedAttr.stroke
                    },
                    animationAttr = isImg ? selectedAttr : {
                        polypath: selectedAttr.polypath
                    },
                    shiftValues = chartOptions.syncLabelWithAnchor,
                    anchorRadius = plotElem.data('anchorRadius'),
                    anchorHoverRaius = plotElem.data('anchorHoverRadius'),
                    animationDuration = !(/,0\)$/.test(elemHoverAttr.fill) &&
                        /,0\)$/.test(elemUnHoverAttr.fill)) &&
                        plotElem.data('anchorHoverRadius') - plotElem.data('anchorRadius') &&
                        setRolloverProperties.animation &&
                        rolloverAnimationDuration;

                if (valElem && valElem.data('isMiddle')) {
                    valAnimation = {
                        transform: 'T,' + ((eventType === ROLLOVER) ? radiusDiff : 0) + ',0R' + rotateValues
                    };
                }

                if (setRolloverProperties) {

                    if ((eventType == ROLLOVER && anchorHoverRaius !== 0) ||
                        (eventType == ROLLOUT && anchorRadius !== 0)) {
                        plotElem.attr({
                            visibility: 'visible'
                        });
                    }

                    if (isImg) {
                        plotElem.css({
                            opacity: animationAttr.alpha * 0.01
                        });
                    } else {
                        plotElem.attr(staticAttr);
                    }

                    if (isRealtime) {
                        if (!isImg) {
                            animationAttr.polypath[1] = anchorDef[1];
                            animationAttr.polypath[2] = anchorDef[2];
                        }
                    }
                    plotElem.stop();
                    plotElem.animate(
                        animationAttr,
                        animationDuration,
                        'easeOut',
                        function () {
                            if ((eventType == ROLLOVER && !anchorHoverRaius) ||
                                (eventType == ROLLOUT && !anchorRadius)) {
                                plotElem.attr({
                                    'visibility': 'hidden'
                                });
                            }
                        }
                    );

                    valElem && valElem.stop();
                    animationDuration && shiftValues && valElem &&
                        valElem.animate(valAnimation, animationDuration, 'easeOut');
                }

                plotEventHandler.call(event, chart, data, eventType);
            },

            drawPlotArea: function (plot, dataOptions) {
                var chart = this,
                    paper = chart.paper,
                    options = chart.options,
                    chartOptions = options.chart,
                    logic = chart.logic,
                    seriesOptions = options.plotOptions.series,
                    elements = chart.elements,
                    plotItems = plot.items,
                    datasetGraphics = plot.graphics = (plot.graphics || []),
                    plotItem,

                    xAxis = chart.xAxis[dataOptions.xAxis || 0],
                    yAxis = chart.yAxis[dataOptions.yAxis || 0],

                    isReverse = yAxis.axisData.reversed,
                    xDepth = chartOptions.xDepth || 0,
                    yDepth = chartOptions.yDepth || 0,

                    // is stacked chart
                    isStacked = logic.isStacked,

                    // tooltip options
                    tooltipOptions = options.tooltip || {},
                    isTooltip = tooltipOptions.enabled !== false,
                    toolText,

                    eventArgs,

                    style = seriesOptions.dataLabels.style,
                    labelCSS = {
                        fontFamily: style.fontFamily,
                        fontSize: style.fontSize,
                        lineHeight: style.lineHeight,
                        fontWeight: style.fontWeight,
                        fontStyle: style.fontStyle,
                        color: style.color
                    },
                    animationDuration = isNaN(+seriesOptions.animation) && seriesOptions.animation.duration ||
                        seriesOptions.animation * 1000,

                    series2D3Dshift = chartOptions.series2D3Dshift,

                    // Directly Accessing chart definition JSON Data
                    chartAttributes = chart.definition.chart,
                    // decides whether a separate line over area will be drawn and
                    // area boder will be hidden
                    isOnlyLineBorder = chartAttributes.drawfullareaborder === '0',

                    data = plot.data,

                    seriesVisibility = dataOptions.visible === false ?
                        'hidden' : 'visible',
                    i,
                    ln = data.length,

                    xAxisZeroPos = xAxis.getAxisPosition(0),
                    xAxisFirstPos = xAxis.getAxisPosition(1),
                    pointDistance = xAxisFirstPos - xAxisZeroPos,
                    totalCanvasWidth = pointDistance * ln,

                    scroll = xAxis.axisData.scroll || {},
                    isScroll = chartOptions.hasScroll || false,
                    scrollPosition,

                    connectNullData = seriesOptions.connectNullData,
                    set,
                    setLink,
                    anchorRadius,
                    x,
                    y,
                    previousY,
                    previousYPos,
                    yMax = yAxis.max,
                    yMin = yAxis.min,

                    isAllPositiveZero = yMax > 0 && yMin >= 0,
                    isPositiveNegative = yMax > 0 && yMin < 0,

                    yBase = isPositiveNegative ? 0 : !isReverse && isAllPositiveZero ? yMin : yMax,

                    yBasePos = yAxis.getAxisPosition(yBase) +
                        (series2D3Dshift ? yDepth : 0),
                    chartW = chart.chartWidth,
                    chartH = chart.chartHeight,
                    animationComplete = function () {
                        areaGroup.attr({
                            'clip-rect': null
                        });
                        anchorGroup.show();
                        anchorShadowGroup.show();
                        dataLabelsLayer.attr({
                            transform: '...t' + -chartW + COMMA + -chartH
                        });
                    },

                    optimalYPos,
                    lastXPos,
                    lastYPos = null,
                    xPos,
                    yPos,

                    lineWidth = dataOptions.lineWidth,
                    dashStyle = dataOptions.dashStyle,
                    fillColor = toRaphaelColor(dataOptions.fillColor),
                    lineColor = toRaphaelColor(dataOptions.lineColor),

                    // This variable stores number of datapoints joined by the area
                    // A valid area required minimum of 2 data points
                    validPointsJoined = 0,
                    isDragable = /drag/ig.test(chart.logic.rendererId),
                    symbol,
                    anchorElement,
                    hotElem,

                    // Hover settings
                    setRolloverProperties,
                    setRolloutAttr,
                    setRolloverAttr,

                    areaPath = [],
                    areaReversePath = [],

                    areaElement = null,

                    linePath = [],
                    lineElement,

                    layers = chart.layers,
                    datasetLayer = layers.dataset = layers.dataset || paper.group('dataset-orphan'),
                    dataLabelsLayer = layers.datalabels = layers.datalabels ||
                        paper.group('datalabels').insertAfter(datasetLayer),
                    trackerLayer = layers.tracker,
                    clipCanvasInit = elements['clip-canvas-init'].slice(0),
                    clipCanvas = elements['clip-canvas'].slice(0),
                    trackerRadius = chartOptions.anchorTrackingRadius,
                    attrObj,
                    group,
                    areaConnectorGroup,
                    lineShadowGroup,
                    anchorShadowGroup,
                    lineGroup,
                    anchorGroup,
                    areaGroup,
                    shadowGroup,

                    areaAnimation,
                    anchorShadow,
                    imgRef,
                    marker,
                    valEle,
                    clickFunc = function (data) {
                        var ele = this;
                        plotEventHandler.call(ele, chart, data);
                    },
                    rolloverResponseSetter = function (plotItem) {
                        return function (data) {
                            chart.hoverPlotAnchor(this, data, ROLLOVER, plotItem, chart);
                        };
                    },
                    rolloutResponseSetter = function (plotItem) {
                        return function (data) {
                            chart.hoverPlotAnchor(this, data, ROLLOUT, plotItem, chart);
                        };
                    },
                    onLoadSetter = function (x, y, marker, plotItem, eventArgs, toolText, setRollover, i) {
                        return function () {
                            var imgRef = this,
                                url = marker.imageUrl,
                                scale = marker.imageScale,
                                alpha = marker.imageAlpha,
                                hoverAlpha = setRollover.imageHoverAlpha,
                                hoverScale = setRollover.imageHoverScale,
                                imgW = imgRef.width * scale * 0.01,
                                hotW = (imgRef.width * hoverScale * 0.01),
                                trackerAttr;

                            setRolloutAttr = {
                                x: x - imgRef.width * scale * 0.005,
                                y: y - imgRef.height * scale * 0.005,
                                width: imgW,
                                height: imgRef.height * scale * 0.01,
                                alpha: alpha
                            };

                            setRolloverAttr = {
                                x: x - imgRef.width * hoverScale * 0.005,
                                y: y - imgRef.height * hoverScale * 0.005,
                                width: hotW,
                                height: imgRef.height * hoverScale * 0.01,
                                alpha: hoverAlpha
                            };

                            trackerAttr = (hotW > imgW) ? setRolloverAttr : setRolloutAttr;
                            if (isDragable) {
                                trackerAttr = {
                                    cx: x,
                                    cy: y,
                                    r: mathMax(hotW, imgW) * 0.5
                                };
                            }

                            plotItem.graphic = anchorElement = paper.image(url, anchorGroup)
                                .attr(setRolloutAttr)
                                .css({
                                    opacity: alpha * 0.01
                                })
                                .data('alwaysInvisible', !scale)
                                .data('setRolloverProperties', setRollover)
                                .data('setRolloverAttr', setRolloverAttr)
                                .data('setRolloutAttr', setRolloutAttr)
                                .data('anchorRadius', scale)
                                .data('anchorHoverRadius', hoverScale);

                            anchorElement && datasetGraphics.push(anchorElement);

                            if (setLink || isTooltip || setRollover) {
                                attrObj = extend2({
                                    cursor: setLink ? 'pointer' : '',
                                    stroke: TRACKER_FILL,
                                    'stroke-width': marker.lineWidth,
                                    fill: TRACKER_FILL,
                                    ishot: true,
                                    visibility: seriesVisibility
                                }, trackerAttr);

                                hotElem = plotItem.tracker =
                                    (isDragable ?
                                        paper.circle(attrObj, trackerLayer) : paper.rect(attrObj, trackerLayer))
                                        .data('eventArgs', eventArgs)
                                        .click(clickFunc)
                                        .hover(rolloverResponseSetter(plotItem), rolloutResponseSetter(plotItem))
                                        .tooltip(toolText);

                                chart.drawTracker && chart.drawTracker.call(chart, plot, dataOptions, i);
                            }

                            valEle = plotItem.dataLabel = chart.drawPlotLineLabel(plot, dataOptions, i, x, y);
                            valEle && datasetGraphics.push(valEle);
                        };
                    },
                    onErrorSetter = function (x, y, marker, plotItem, eventArgs, toolText,  setRollover, i) {
                        // Handle if image load error
                        return function () {
                            valEle = plotItem.dataLabel = chart.drawPlotLineLabel(plot, dataOptions, i, x, y);
                            valEle && datasetGraphics.push(valEle);
                        };
                    };

                /** @todo: Move to the proper place according to the architecture. */
                chart.addCSSDefinition('.fusioncharts-datalabels .fusioncharts-label', labelCSS);
                dataLabelsLayer.attr('class', 'fusioncharts-datalabels');

                yAxis.yBasePos = yBasePos;

                // hide the data labels group. Will be visible after animation completes
                dataLabelsLayer.attr({
                    transform: '...t' + chartW + COMMA + chartH
                });

                if (animationDuration) {
                    chart.animationCompleteQueue.push({
                        fn: animationComplete,
                        scope: chart
                    });
                }
                //create series group
                group = datasetLayer;
                if (isStacked) {
                    shadowGroup = group.shadows || (group.shadows = paper.group('shadows', group).toBack());
                }
                areaGroup = group.area = (group.area || paper.group('area', group));
                areaConnectorGroup = group.areaConnector ||
                    (group.areaConnector = paper.group('area-connector', group));
                lineShadowGroup = plot.lineShadowLayer ||
                    (plot.lineShadowLayer = paper.group('connector-shadow', areaConnectorGroup));
                anchorShadowGroup = plot.anchorShadowLayer ||
                    (plot.anchorShadowLayer = paper.group('anchor-shadow', areaConnectorGroup));
                lineGroup = plot.lineLayer ||
                    (plot.lineLayer = paper.group('connector', areaConnectorGroup));
                anchorGroup = plot.anchorLayer ||
                    (plot.anchorLayer = paper.group('anchors', areaConnectorGroup));

                anchorGroup.hide();
                anchorShadowGroup.hide();

                //create series group
                group = datasetLayer;

                //draw data
                for (i = 0; i < ln; i += 1) {
                    set = data[i];
                    y = set.y;
                    x = pluckNumber(set.x, i);
                    xPos = xAxis.getAxisPosition(x) - xDepth;

                    anchorElement = valEle = hotElem = null;
                    plotItem = plotItems[i] = {};
                    // null value
                    if (y === null) {
                        if (connectNullData === 0) {
                            lastYPos = null;

                            if (validPointsJoined > 0) {
                                if (validPointsJoined === 1) {
                                    areaPath.splice(-8, 8);
                                } else {
                                    areaPath = areaPath.concat(areaReversePath);
                                    areaPath.push(Z);
                                }

                                areaReversePath = [];
                            }
                        }
                        plotItem.chart = chart;
                        plotItem.index = i;
                        plotItem.value = y;
                    }
                    // valid value
                    else {
                        setLink = set.link;
                        toolText = set.toolText;

                        previousY = set.previousY;
                        previousYPos = yAxis.getAxisPosition(previousY) || null;
                        optimalYPos = previousYPos || yBasePos;
                        yPos = yAxis.getAxisPosition(y + (previousY || 0)) +
                            (series2D3Dshift ? yDepth : 0);

                        marker = set.marker;
                        if (marker && marker.enabled) {

                            eventArgs = {
                                index: i,
                                link: setLink,
                                value: set.y,
                                displayValue: set.displayValue,
                                categoryLabel: set.categoryLabel,
                                toolText: set.toolText,
                                id: plot.userID,
                                datasetIndex: plot.index,
                                datasetName: plot.name,
                                visible: plot.visible
                            };

                            // Hover consmetics
                            setRolloutAttr = setRolloverAttr = {};
                            setRolloverProperties = set.rolloverProperties;
                            if (marker.imageUrl) {
                                imgRef = new Image();
                                imgRef.onload = onLoadSetter(xPos, yPos, marker, plotItem, eventArgs, toolText,
                                    setRolloverProperties, i);

                                imgRef.onerror = onErrorSetter(xPos, yPos, marker, plotItem, eventArgs, toolText,
                                    setRolloverProperties, i);

                                imgRef.src = marker.imageUrl;
                            } else {
                                symbol = marker.symbol.split('_');
                                anchorRadius = marker.radius;
                                anchorShadow = marker.shadow;

                                if (setRolloverProperties) {
                                    setRolloutAttr = {
                                        polypath: [symbol[1] || 2, xPos, yPos,
                                            anchorRadius, marker.startAngle, 0
                                        ],
                                        fill: toRaphaelColor(marker.fillColor),
                                        'stroke-width': marker.lineWidth,
                                        stroke: toRaphaelColor(marker.lineColor)
                                    };

                                    setRolloverProperties = set.rolloverProperties;

                                    setRolloverAttr = {
                                        polypath: [setRolloverProperties.sides || 2,
                                            xPos, yPos,
                                            setRolloverProperties.radius,
                                            setRolloverProperties.startAngle,
                                            setRolloverProperties.dip
                                        ],
                                        fill: toRaphaelColor(setRolloverProperties.fillColor),
                                        'stroke-width': setRolloverProperties.lineWidth,
                                        stroke: toRaphaelColor(setRolloverProperties.lineColor)
                                    };

                                }

                                anchorElement = plotItem.graphic = paper.polypath(symbol[1] || 2, xPos, yPos,
                                    anchorRadius, marker.startAngle, 0,
                                    anchorGroup)
                                    .attr({
                                        fill: toRaphaelColor(marker.fillColor),
                                        'stroke-width': marker.lineWidth,
                                        stroke: toRaphaelColor(marker.lineColor),
                                        'cursor': setLink ? 'pointer' : '',
                                        'visibility': !anchorRadius ? 'hidden' : seriesVisibility
                                    })
                                    .data('alwaysInvisible', !anchorRadius)
                                    .data('setRolloverProperties', setRolloverProperties)
                                    .data('setRolloverAttr', setRolloverAttr)
                                    .data('setRolloutAttr', setRolloutAttr)
                                    .data('anchorRadius', anchorRadius)
                                    .data('anchorHoverRadius', setRolloverProperties &&
                                        setRolloverProperties.radius)
                                    .shadow(anchorShadow || false, anchorShadowGroup);

                                if (setLink || isTooltip || setRolloverProperties) {
                                    if (!isStacked) {
                                        anchorRadius = mathMax(anchorRadius,
                                            setRolloverProperties &&
                                            setRolloverProperties.radius || 0, trackerRadius);
                                    }

                                    hotElem = plotItem.tracker = paper.circle({
                                        cx: xPos,
                                        cy: yPos,
                                        r: anchorRadius,
                                        'cursor': setLink ? 'pointer' : '',
                                        stroke: TRACKER_FILL,
                                        'stroke-width': marker.lineWidth,
                                        'fill': TRACKER_FILL,
                                        ishot: true,
                                        'visibility': seriesVisibility
                                    }, trackerLayer);
                                }

                                (hotElem || anchorElement)
                                    .data('eventArgs', eventArgs)
                                    .click(clickFunc)
                                    .hover(rolloverResponseSetter(plotItem), rolloutResponseSetter(plotItem))
                                    .tooltip(toolText);

                                chart.drawTracker &&
                                    chart.drawTracker.call(chart, plot, dataOptions, i);

                            }
                        }

                        // First initial valid value or  valid value after null
                        if (lastYPos === null) {

                            // start/restart line path
                            linePath.push(M, xPos, COMMA, yPos);

                            // start area
                            // move to base position
                            areaPath.push(M, xPos, COMMA, optimalYPos);

                            // initialted count of  the number of valid points joined
                            validPointsJoined = 0;


                        } else {
                            linePath.push(L, xPos, COMMA, yPos);
                        }

                        // continue drawing area path
                        areaPath.push(L, xPos, COMMA, yPos);
                        // draw reverse path for the base of staacked chart
                        areaReversePath.unshift(L, xPos, COMMA, optimalYPos);

                        // counts the number of valid points joined
                        validPointsJoined++;

                        lastXPos = xPos;
                        lastYPos = yPos;

                        !(marker && marker.imageUrl) && (valEle = plotItem.dataLabel =
                            chart.drawPlotLineLabel(plot, dataOptions, i, xPos, yPos));
                        plotItem.chart = chart;
                        plotItem.index = i;
                        plotItem.value = y;
                        plotItem.dataLabel = valEle;
                    }

                    valEle && datasetGraphics.push(valEle);
                    anchorElement && datasetGraphics.push(anchorElement);
                    hotElem && datasetGraphics.push(hotElem);
                }

                if (validPointsJoined > 0) {
                    // Remove single line thickness area arising out of single value
                    if (validPointsJoined === 1) {
                        areaPath.splice(-8, 8);
                    }
                    // Join reverse path, required mostly in stacked  chart
                    else {
                        areaPath = areaPath.concat(areaReversePath);
                        areaPath.push(Z);
                    }
                }

                areaElement = plot.graphic = paper.path(areaPath, areaGroup)
                    .attr({
                        fill: fillColor,
                        'stroke-dasharray': dashStyle,
                        'stroke-width': isOnlyLineBorder ? 0 : lineWidth,
                        'stroke': lineColor,
                        'stroke-linecap': 'round',
                        'stroke-linejoin': lineWidth > MAX_MITER_LINEJOIN ? 'round' : 'miter',
                        'visibility': seriesVisibility
                    })
                    .shadow(seriesOptions.shadow && set.shadow, shadowGroup);

                areaElement && datasetGraphics.push(areaElement);

                // Animation from right when scrollToEnd is 1
                if (isScroll) {
                    scrollPosition = scroll.startPercent;
                    clipCanvas[2] = totalCanvasWidth + clipCanvasInit[0];
                    if (scrollPosition === 1) {
                        clipCanvasInit[0] = clipCanvas[2];
                        clipCanvas[0] = 0;
                    }
                }

                if (animationDuration) {
                    // clip-canvas animation to area chart
                    areaAnimation = areaGroup.attr({
                        'clip-rect': clipCanvasInit
                    })
                    .animate({
                        'clip-rect': clipCanvas
                    }, animationDuration, isScroll ? 'easeIn' : 'normal', chart.getAnimationCompleteFn());

                } else {
                    animationComplete && animationComplete();
                    // Remove animation complete callback function, so that
                    // this will be called only once
                    animationComplete = undefined;
                }

                if (shadowGroup) {

                    if (animationDuration) {
                        shadowGroup.attr({
                            'clip-rect': clipCanvasInit
                        })
                        .animateWith(areaGroup, areaAnimation, {
                            'clip-rect': clipCanvas
                        }, animationDuration, isScroll ? 'easeIn' : 'normal', function () {
                            shadowGroup.attr({
                                'clip-rect': null
                            });
                        });
                    } else {
                        shadowGroup.attr({
                            'clip-rect': null
                        });
                    }

                }

                if (isOnlyLineBorder) {

                    lineElement = plot.connector = paper.path(linePath, lineGroup)
                        .attr({
                            'stroke-dasharray': dashStyle,
                            'stroke-width': lineWidth,
                            'stroke': lineColor,
                            'stroke-linecap': 'round',
                            'stroke-linejoin': lineWidth > MAX_MITER_LINEJOIN ?
                                'round' : 'miter',
                            'visibility': seriesVisibility
                        });

                    if (animationDuration) {
                        lineGroup.attr({
                            'clip-rect': clipCanvasInit
                        })
                        .animateWith(areaGroup, areaAnimation, {
                            'clip-rect': clipCanvas
                        }, animationDuration, isScroll ? 'easeIn' : 'normal', function () {
                            lineGroup.attr({
                                'clip-rect': null
                            });
                        });
                    } else {
                        lineGroup.attr({
                            'clip-rect': null
                        });
                    }

                    lineElement && datasetGraphics.push(lineElement);
                }

                plot.visible = (dataOptions.visible !== false);

                return plot;
            },

            drawPlotScatter: function (plot, dataOptions) {
                var chart = this,
                    options = chart.options,
                    chartOptions = options.chart,
                    seriesOptions = options.plotOptions.series,
                    paper = chart.paper,
                    elements = chart.elements,
                    plotItems = plot.items,
                    plotItem,
                    datasetGraphics = plot.graphics = (plot.graphics || []),
                    xAxis = chart.xAxis[dataOptions.xAxis || 0],
                    yAxis = chart.yAxis[dataOptions.yAxis || 0],
                    data = plot.data,
                    seriesVisibility = dataOptions.visible === false ? 'hidden' : 'visible',

                    // tooltip options
                    tooltipOptions = options.tooltip || {},
                    isTooltip = tooltipOptions.enabled !== false,
                    toolText,

                    style = seriesOptions.dataLabels.style,
                    labelCSS = {
                        fontFamily: style.fontFamily,
                        fontSize: style.fontSize,
                        lineHeight: style.lineHeight,
                        fontWeight: style.fontWeight,
                        fontStyle: style.fontStyle,
                        color: style.color
                    },

                    animationDuration = isNaN(+seriesOptions.animation) &&
                        seriesOptions.animation.duration ||
                        seriesOptions.animation * 1000,
                    chartW = chart.chartWidth,
                    chartH = chart.chartHeight,
                    i,
                    ln,
                    set,
                    setLink,
                    x,
                    y,
                    lastXPos,
                    lastYPos,
                    xPos,
                    yPos,

                    lineWidth = dataOptions.lineWidth,
                    isLine = lineWidth > 0,
                    lineColor = dataOptions.color,
                    dashStyle = dataOptions.dashStyle,
                    connectNullData = seriesOptions.connectNullData,
                    linePath = [],

                    marker,
                    eventArgs,
                    markerRadius,
                    symbol,
                    setElem,
                    connectorElem,
                    hotElem,

                    // Hover settings
                    setHoverEffect,
                    setRolloverProperties,
                    setRolloutAttr,
                    setRolloverAttr,

                    layers = chart.layers,
                    datasetLayer = layers.dataset || (layers.dataset = paper.group('dataset-orphan')),
                    dataLabelsLayer = layers.datalabels || (layers.datalabels =
                        paper.group('datalabels').insertAfter(datasetLayer)),
                    trackerLayer = layers.tracker,
                    trackerRadius = chartOptions.anchorTrackingRadius,

                    group,
                    lineGroupParent,
                    lineShadowGroup,
                    anchorShadowGroup,
                    lineGroup,
                    anchorGroup,
                    anchorShadow,
                    anchorAnimation,
                    groupId,
                    valEle,
                    clickFunc = function (data) {
                        var ele = this;
                        plotEventHandler.call(ele, chart, data);
                    },
                    rolloverResponseSetter = function (plotItem) {
                        return function (data) {
                            chart.hoverPlotAnchor(this, data, ROLLOVER, plotItem, chart);
                        };
                    },
                    rolloutResponseSetter = function (plotItem) {
                        return function (data) {
                            chart.hoverPlotAnchor(this, data, ROLLOUT, plotItem, chart);
                        };
                    };

                /** @todo: Move to the proper place according to the architecture. */
                chart.addCSSDefinition('.fusioncharts-datalabels .fusioncharts-label', labelCSS);
                dataLabelsLayer.attr('class', 'fusioncharts-datalabels');

                // initially hide data values
                if (animationDuration) {
                    chart.animationCompleteQueue.push({
                        fn: function () {
                            dataLabelsLayer.attr({
                                transform: '...t' + -chartW + COMMA + -chartH
                            });
                        },
                        scope: chart
                    });
                    dataLabelsLayer.attr({
                        transform: '...t' + chartW + COMMA + chartH
                    });
                }


                //create series group
                group = datasetLayer;

                lineGroupParent = group.line || (group.line = paper.group('line-connector', group));
                lineShadowGroup = plot.lineShadowLayer = paper.group('connector-shadow', lineGroupParent);
                anchorShadowGroup = plot.anchorShadowLayer = paper.group('anchor-shadow', lineGroupParent);
                lineGroup = plot.lineLayer = paper.group('connector', lineGroupParent);
                anchorGroup = plot.anchorLayer = paper.group('anchors', lineGroupParent);

                //draw data
                for (i = 0, ln = data.length; i < ln; i += 1) {
                    set = data[i];
                    marker = set.marker;
                    xPos = yPos = setElem = valEle = hotElem = null;
                    groupId = plot.index + '_' + i;

                    y = set.y;
                    x = set.x;

                    if (y !== null && x !== null) {

                        if (marker && marker.enabled) {
                            setLink = set.link;
                            toolText = set.toolText;
                            markerRadius = marker.radius;
                            anchorShadow = marker.shadow;

                            yPos = yAxis.getAxisPosition(y);
                            xPos = xAxis.getAxisPosition(x);

                            eventArgs = {
                                index: i,
                                link: setLink,
                                y: set.y,
                                x: set.x,
                                displayValue: set.displayValue,
                                categoryLabel: set.categoryLabel,
                                toolText: set.toolText,
                                id: plot.userID,
                                datasetIndex: plot.index,
                                datasetName: plot.name,
                                visible: plot.visible
                            };

                            symbol = marker.symbol.split('_');

                            plotItem = plotItems[i] = {
                                index: i,
                                x: x,
                                y: y,
                                value: y
                            };

                            // Hover consmetics
                            setRolloutAttr = setRolloverAttr = {};
                            if ((setHoverEffect = set.hoverEffects)) {
                                setRolloutAttr = {
                                    polypath: [symbol[1] || 2, xPos, yPos,
                                        markerRadius, marker.startAngle, 0
                                    ],
                                    fill: toRaphaelColor(marker.fillColor),
                                    'stroke-width': marker.lineWidth,
                                    stroke: toRaphaelColor(marker.lineColor)
                                };

                                setRolloverProperties = set.rolloverProperties;

                                setRolloverAttr = {
                                    polypath: [setRolloverProperties.sides || 2,
                                        xPos, yPos,
                                        setRolloverProperties.radius,
                                        setRolloverProperties.startAngle,
                                        setRolloverProperties.dip
                                    ],
                                    fill: toRaphaelColor(setRolloverProperties.fillColor),
                                    'stroke-width': setRolloverProperties.lineWidth,
                                    stroke: toRaphaelColor(setRolloverProperties.lineColor)
                                };

                            }

                            setElem = plotItem.graphic = paper.polypath(symbol[1] || 2, xPos, yPos,
                                markerRadius, marker.startAngle, 0,
                                anchorGroup)
                                .attr({
                                    fill: toRaphaelColor(marker.fillColor),
                                    'stroke-width': marker.lineWidth,
                                    stroke: toRaphaelColor(marker.lineColor),
                                    'cursor': setLink ? 'pointer' : '',
                                    'visibility': !markerRadius ? 'hidden' : seriesVisibility
                                })
                                .data('alwaysInvisible', !markerRadius)
                                .data('setRolloverProperties', setRolloverProperties)
                                .data('setRolloverAttr', setRolloverAttr)
                                .data('setRolloutAttr', setRolloutAttr)
                                .data('anchorRadius', markerRadius)
                                .data('anchorHoverRadius', setRolloverProperties && setRolloverProperties.radius)
                                .shadow(anchorShadow || false, anchorShadowGroup);

                            if (setLink || isTooltip || setRolloverProperties) {
                                markerRadius = mathMax(
                                    markerRadius,
                                    setRolloverProperties && setRolloverProperties.radius || 0,
                                    trackerRadius
                                );

                                hotElem = plotItem.tracker = paper.circle({
                                    cx: xPos,
                                    cy: yPos,
                                    r: markerRadius,
                                    cursor: setLink ? 'pointer' : '',
                                    stroke: TRACKER_FILL,
                                    'stroke-width': marker.lineWidth,
                                    fill: TRACKER_FILL,
                                    ishot: true,
                                    visibility: seriesVisibility
                                }, trackerLayer);
                            }

                            (hotElem || setElem)
                                .data('eventArgs', eventArgs)
                                .data('groupId', groupId)
                                .click(clickFunc)
                                .hover(rolloverResponseSetter(plotItem), rolloutResponseSetter(plotItem))
                                .tooltip(toolText);
                        }

                        if (isLine) {
                            if (lastYPos === undefined ||
                                (lastYPos === null && connectNullData === 0)) {
                                // move to the starting position of the line segment
                                xPos && yPos && linePath.push(M, xPos, COMMA, yPos);
                            }

                            xPos && yPos && linePath.push(L, xPos, COMMA, yPos);

                            lastXPos = xPos;
                            lastYPos = yPos;
                        }

                        // Draw the dataLabel
                        valEle = plotItem.dataLabel = chart.drawPlotLineLabel(plot,
                            dataOptions, i, xPos, yPos);

                    } else {
                        if (isLine && connectNullData === 0) {
                            lastXPos = lastYPos = null;
                        }
                        plotItems[i] = {
                            chart: chart,
                            index: i,
                            x: x,
                            y: y
                        };
                    }

                    valEle && datasetGraphics.push(valEle);
                    setElem && datasetGraphics.push(setElem);
                    hotElem && datasetGraphics.push(hotElem);

                    chart.drawTracker &&
                        chart.drawTracker.call(chart, plot, dataOptions, i);

                }


                if (linePath.length) {
                    connectorElem = plot.graphic = paper.path(linePath, lineGroup)
                        .attr({
                            'stroke-dasharray': dashStyle,
                            'stroke-width': lineWidth,
                            'stroke': lineColor,
                            'stroke-linecap': 'round',
                            'stroke-linejoin': lineWidth > MAX_MITER_LINEJOIN ?
                                'round' : 'miter',
                            'visibility': seriesVisibility
                        })
                        .shadow(seriesOptions.shadow && set.shadow);
                    // clip-canvas animation to line
                    lineGroup.attr({
                        'clip-rect': elements[animationDuration ? 'clip-canvas-init' : 'clip-canvas']
                    });

                    if (animationDuration) {
                        lineGroup.animate({
                            'clip-rect': elements['clip-canvas']
                        }, animationDuration, 'normal');
                    }

                    datasetGraphics.push(connectorElem);
                }

                // animation to anchors
                if (animationDuration) {
                    anchorAnimation = anchorGroup.attr({
                        'opacity': 0
                    })
                    .animate({
                        opacity: 1
                    }, animationDuration, 'normal', chart.getAnimationCompleteFn());
                }

                plot.visible = (dataOptions.visible !== false);
                return plot;
            },

            drawPlotLineLabel: function (plot, dataOptions, i, xPos, yPos, dataLabelsLayer) {

                var chart = this,
                    options = chart.options,
                    chartOptions = options.chart,
                    seriesOptions = options.plotOptions.series,
                    paper = chart.paper,
                    layers = chart.layers,
                    style = seriesOptions.dataLabels.style,
                    rotateValues = chartOptions.rotateValues === 1 ? 270 : 0,
                    canvasHeight = chart.canvasHeight,
                    canvasTop = chart.canvasTop,
                    plotItems = plot.items,
                    data = plot.data,
                    set = data[i],
                    plotItem = plotItems[i],
                    valuePosition = getValidValue(set.valuePosition, 'auto').toLowerCase(),
                    seriesType = chart.logic.defaultSeriesType,
                    graphic = plotItem.graphic,
                    marker = set.marker,
                    markerRadius = marker && marker.enabled ? (graphic && graphic.type == 'image' &&
                        graphic.attr('height') * 0.5) || marker && marker.radius - 3 : 0,
                    valuePadding = chartOptions.valuePadding + GUTTER_2 + markerRadius,
                    seriesVisibility = dataOptions.visible === false ?
                        'hidden' : 'visible',
                    valEle = plotItem.dataLabel,
                    yAdjust,
                    topSpace,
                    bottomSpace,
                    prevDataObj,
                    nextDataObj,
                    placeValuesInside,
                    textHeight,
                    origTextHeight,
                    textY,
                    bBoxObj,
                    displayValue;

                dataLabelsLayer = dataLabelsLayer || layers.datalabels;

                switch (valuePosition) {
                case 'above':
                    placeValuesInside = 0;
                    break;

                case 'below':
                    placeValuesInside = 1;
                    break;

                default:
                    prevDataObj = data[i - 1] || {};
                    nextDataObj = data[i + 1] || {};

                    placeValuesInside = !i ?
                        0 : prevDataObj.y > set.y ? 1 : (prevDataObj.y == null && nextDataObj.y) > set.y ? 1 : 0;
                }

                // Drawing of displayValue
                displayValue = set.displayValue;

                if (defined(displayValue) && displayValue !== BLANK) {
                    // First render the value text

                    if (!valEle) {
                        valEle = plotItem.dataLabel = paper.text(dataLabelsLayer)
                            .attr({
                                'class': 'fusioncharts-label',
                                text: displayValue,
                                fill: style.color,
                                'text-bound': [style.backgroundColor, style.borderColor,
                                    style.borderThickness, style.borderPadding,
                                    style.borderRadius, style.borderDash
                                ],
                                'font-weight': style.fontWeight,
                                'font-style': style.fontStyle,
                                'font-family': style.fontFamily,
                                'font-size': style.fontSize,
                                'line-height': style.lineHeight
                            });
                            //.css(css);
                    } else {
                        rotateValues && valEle.attr('transform', ['r', 360 - rotateValues]);
                    }

                    valEle.attr({
                        title: (set.originalText || ''),
                        fill: style.color
                    });


                    if (!plotItem._state || !plotItem._state.labelWidth) {
                        // get the bBox to find height and width of the text.
                        bBoxObj = valEle.getBBox();

                        // store the width and height for optimization in realtime charts.
                        plotItem._state = {
                            labelWidth: bBoxObj.width,
                            labelHeight: bBoxObj.height
                        };
                    }

                    // If rotated values we use the width of the text as
                    // height
                    textHeight = origTextHeight = (rotateValues ? plotItem._state.labelWidth :
                        plotItem._state.labelHeight);
                    textHeight += valuePadding;
                    topSpace = yPos - canvasTop;
                    bottomSpace = (canvasTop + canvasHeight) - yPos;
                    textY = yPos;

                    textHeight = textHeight + GUTTER_4;
                    yAdjust = (origTextHeight * 0.5) + valuePadding;

                    if (!/bubble/i.test(seriesType)) {
                        if (placeValuesInside) {
                            if (bottomSpace > textHeight) {
                                textY += yAdjust;
                                set._valueBelowPoint = 1;
                            } else if (topSpace > textHeight) {
                                textY -= yAdjust;
                                set._valueBelowPoint = 0;
                            }
                        } else {
                            if (topSpace > textHeight) {
                                textY -= yAdjust;
                                set._valueBelowPoint = 0;
                            } else if (bottomSpace > textHeight) {
                                textY += yAdjust;
                                set._valueBelowPoint = 1;
                            }
                        }
                    }

                    valEle.attr({
                        x: xPos,
                        y: textY,
                        visibility: seriesVisibility
                    })
                        .data('isBelow', set._valueBelowPoint);

                    rotateValues && valEle.attr('transform', 'T0,0,R' + rotateValues);
                } else if (valEle) {
                    valEle.attr({
                        text: BLANK
                    });
                }
                return valEle;
            },

            drawLabels: function () {
                var chart = this,
                    paper = chart.paper,
                    options = chart.options,
                    items = options.labels && options.labels.items &&
                        options.labels.items,
                    ln = items && items.length,
                    aboveDataset = chart.layers.layerAboveDataset,
                    quadran = chart.elements.quadran || (chart.elements.quadran = []),
                    marginTop = chart.canvasTop,
                    marginLeft = chart.canvasLeft,
                    textAnchor = {
                        right: POSITION_END,
                        left: POSITION_START,
                        'undefined': POSITION_START
                    },
                    style,
                    css,
                    textEle,
                    labelObj;

                while (ln--) {
                    labelObj = items[ln];
                    style = labelObj.style;
                    css = {
                        fontFamily: style.fontFamily,
                        fontSize: style.fontSize,
                        lineHeight: style.lineHeight,
                        fontWeight: style.fontWeight,
                        fontStyle: style.fontStyle,
                        fill: style.color
                    };

                    if (defined(labelObj.html) && labelObj.html !== BLANK) {
                        textEle = quadran[ln] = paper.text(aboveDataset)
                            .attr({
                                text: labelObj.html,
                                x: pInt(style.left, 10) + marginLeft,
                                y: pInt(style.top, 10) + marginTop,
                                //fill: style.color,
                                'text-anchor': textAnchor[labelObj.textAlign],
                                'vertical-align': labelObj.vAlign
                            })
                            .css(css);
                    }
                }
            }
        }, renderer['renderer.root']);

        /**
         * The renderering definition for pie series charts.
         *
         * @id TypeAPI['renderer.pie']
         * @returns TypeAPI
         */
        renderer('renderer.piebase', {
            isHovered: false,
            getPlotData: function (id, slicedState) {
                var chart = this,
                    dataset = chart.datasets[0],
                    data = dataset.data[id],
                    userData = dataset.userData || (dataset.userData = []),
                    plotData,
                    value,
                    prop;

                if (!userData[id]) {
                    plotData = userData[id] = {};
                    for (prop in data) {
                        typeof (value = data[prop]) !== 'object' &&
                            typeof (value) !== 'function' &&
                            prop.indexOf('_') !== 0 && (plotData[prop] = value);
                    }
                    plotData.value = plotData.y;
                    plotData.label = plotData.name;

                    delete plotData.y;
                    delete plotData.total;
                    delete plotData.doNotSlice;
                    delete plotData.name;
                    delete plotData.centerAngle;
                    delete plotData.showInLegend;
                }
                else {
                    plotData = userData[id];
                }

                plotData.sliced = slicedState;
                return plotData;
            },
            redrawDataLabels: function (chart) {
                var plot = chart.elements.plots[0];
                chart.placeDataLabels(true, plot.items, plot);
                return {};
            },
            sliceInOtherPies: function (mainPieId) {
                var chart = this,
                    series = chart.options.series[0],
                    plotItems = series.plot.items,
                    i = plotItems.length,
                    numSliced = 0,
                    plot;

                series.enableMultiSlicing = true;

                while (i--) {
                    i !== mainPieId && (plot = plotItems[i]).sliced && ++numSliced && chart.plotGraphicClick.call(plot);
                }

                series.enableMultiSlicing = false;
                // Returns true when at least one other pie is sliced
                return !!numSliced;
            },
            plotGraphicClick: function (evt) {
                var o = this.graphic || this,
                    plotItem = o.plotItem || o.data('plotItem'),
                    //plotItem = o.data('plotItem'),
                    seriesData = plotItem.seriesData,
                    chart = plotItem.chart,
                    chartInstance = chart.logic.chartInstance,
                    index = plotItem.index,
                    chartSeriesData = chart.options.series[0],
                    enableMultiSlicing = chartSeriesData.enableMultiSlicing,
                    doNotSlice = seriesData.data[plotItem.index].doNotSlice,
                    atleastOneOtherSliced,
                    graphic,
                    connector,
                    dataLabel,
                    sliced,
                    slicedTranslation = plotItem.slicedTranslation,
                    connectorPath,
                    transX,
                    transY,
                    reflowData,
                    reflowUpdate;
                    //innerDiameter,
                    //centerLabelText,
                    //centerLabelConfig;

                !seriesData.isRotating && plotEventHandler.call(o, chart, evt);

                if (seriesData.isRotating || seriesData.singletonCase || doNotSlice) {
                    return;
                }

                // If 'enableMultiSlicing' is false, sliceInOtherPies is called only once
                // for the clicked pie. From within sliceInOtherPies, 'enableMultiSlicing'
                // is set to true, method plotGraphicClick is called once for each
                // sliced pie and finally, value of 'enableMultiSlicing' is reset to false.
                // Value of multiSliced is always false for plotGraphicClick call from
                // sliceInOtherPies. However, its value may be true or false, by the
                // return value of the sliceInOtherPies.
                atleastOneOtherSliced = !enableMultiSlicing && chart.sliceInOtherPies(index);

                if ((sliced = plotItem.sliced) && atleastOneOtherSliced) {
                    return;
                }

                graphic = plotItem.graphic;
                connector = plotItem.connector;
                dataLabel = plotItem.dataLabel;

                slicedTranslation = typeof slicedTranslation === 'object' ? 't' + slicedTranslation : slicedTranslation;
                connectorPath = plotItem.connectorPath;
                transX = (sliced ? -1 : 1) * plotItem.transX;
                transY = (sliced ? -1 : 1) * plotItem.transY;
                /**
                 * This event is fired when a pieSlice in pie-chart starts slicing transition.
                 *
                 * @event FusionCharts#slicingStart
                 * @group chart:pie-slice
                 *
                 * @param {object} data - Contains the values for the following
                 *                 attributes borderColor, borderWidth,
                 *                 categoryLabel, dashStyle, displayValue,
                 *                 hoverEffects(boolean), label, link,
                 *                 rolloverProperties(boolean), sliced(boolean),
                 *                 toolText, value(value of the sliced object)
                 * @param {boolean} slicedState - Tells the state of the slice before
                 *                  transition begins. The value is true for
                 *                  sliced-out state and false for sliced-in state.
                 */
                global.raiseEvent('slicingStart', {
                    slicedState: sliced,
                    data: chart.getPlotData(index, sliced)
                }, chartInstance);

                graphic.animate({
                    transform: sliced ? 't0,0' : slicedTranslation
                }, 200, 'easeIn', function () {
                    /**
                     * This event is fired when a pieSlice in pie-chart ends slicing transition.
                     *
                     * @event FusionCharts#slicingEnd
                     * @group chart:pie-slice
                     *
                     * @param {object} data - Contains the values for the following
                     *                 attributes borderColor, borderWidth,
                     *                 categoryLabel, dashStyle, displayValue,
                     *                 hoverEffects(boolean), label, link,
                     *                 rolloverProperties(boolean), sliced(boolean),
                     *                 toolText, value(value of the sliced object)
                     * @param {boolean} slicedState - Tells the state of the slice
                     *                  before transition begins. The value is true
                     *                  for sliced-out state and false for
                     *                  sliced-in state.
                     */
                    global.raiseEvent('slicingEnd', {
                        slicedState: plotItem.sliced,
                        data: chart.getPlotData(index, plotItem.sliced)
                    }, chartInstance);
                });

                if (dataLabel && dataLabel.x) {
                    dataLabel.animate({
                        x: dataLabel.x + (sliced ? 0 : transX)
                    }, 200, 'easeIn');
                }

                if (connectorPath) {
                    connectorPath[1] += transX;
                    connectorPath[2] += transY;
                    connectorPath[4] += transX;
                    connectorPath[6] += transX;

                    connector.animate({
                        path: connectorPath
                    }, 200, 'easeIn');
                }

                sliced = plotItem.sliced = !sliced;

                // save state
                reflowUpdate = {
                    hcJSON: {
                        series: []
                    }
                };
                reflowUpdate.hcJSON.series[0] = {
                    data: reflowData = []
                };
                reflowData[index] = {
                    sliced: sliced
                };
                extend2(chartInstance.jsVars._reflowData, reflowUpdate, true);

				/** @todo: Enable center label feature related to enableMultiSlicing */
				//if ((innerDiameter = plotItem.innerDiameter) && !enableMultiSlicing) {
				//	(centerLabelConfig = sliced && plotItem.centerLabelConfig.label ?
				//		plotItem.centerLabelConfig : chartSeriesData.centerLabelConfig) &&
				//	(centerLabelText = centerLabelConfig.label) &&
				//	chart.drawDoughnutCenterLabel(centerLabelText, plotItem.center[0], plotItem.center[1],
				//		innerDiameter, innerDiameter, centerLabelConfig, true);
				//}

                return sliced;
            },
            plotDragStart: function (x, y, evt) {
                var o = this,
                    plotItem = o.data('plotItem'),
                    chart = plotItem.chart,
                    seriesData = plotItem.seriesData,
                    datasets = chart.options.series,
                    startingAng = -chart.datasets[0].startAngle * rad2deg,
                    angle;

                if (!datasets[0].enableRotation) {
                    return;
                }
                angle = getClickArcTangent.call(evt, x, y, seriesData.pieCenter,
                    seriesData.chartPosition);
                seriesData.dragStartAngle = angle;
                seriesData.startingAngleOnDragStart = startingAng;
            },
            plotDragEnd: function () {
                var o = this,
                    plotItem = o.data('plotItem'),
                    chart = plotItem.chart,
                    seriesData = plotItem.seriesData,
                    startingAng = -chart.datasets[0].startAngle * rad2deg,
                    // save state
                    reflowUpdate = {
                        hcJSON: {
                            series: [{
                                startAngle: startingAng
                            }]
                        }
                    };
                if (!chart.disposed) {
                    extend2(chart.logic.chartInstance.jsVars._reflowData,
                        reflowUpdate, true);

                    chart.rotate(seriesData, chart.options.series[0]);
                }

                if (seriesData.isRotating) {
                    /* The events mouseup, dragend and click are raised in order. In order
                     * to update the flag isRotating to false post click event, setTimeout
                     * called, to take immediate effect, is programmed to update the flag.
                     * Thus, the flag gets updated post the series of events, in effect.
                     * NB: Click event is subscribed conditionally.
                     */
                    setTimeout(function () {
                        seriesData.isRotating = false;
                    }, 0);
                    /**
                     * This event is fired on drag rotation end of pie chart.
                     *
                     * @event FusionCharts#rotationEnd
                     * @group chart:pie
                     *
                     * @param {number} changeInAngle - Gives the value by how much
                     *                 the chart was rotated
                     * @param {number} startingAngle - Gives the value of the
                     *                 startingAngle of the chart on rotation end.
                     */

                    global.raiseEvent('RotationEnd', {
                        startingAngle: normalizeAngle(startingAng, true),
                        changeInAngle: startingAng - seriesData.startingAngleOnDragStart
                    }, chart.logic.chartInstance);
                }
                !chart.isHovered && chart.onPlotHover(o, false);
            },
            plotDragMove: function (dx, dy, x, y, evt) {

                var o = this,
                    plotItem = o.data('plotItem'),
                    chart = plotItem.chart,
                    seriesData = plotItem.seriesData,
                    datasets = chart.options.series,
                    angle,
                    currentTime;

                if (!datasets[0].enableRotation || seriesData.singletonCase) {
                    return;
                }

                if (!seriesData.isRotating) {
                    seriesData.isRotating = true;
                    /**
                     * This event is fired on drag rotation start of pie chart.
                     *
                     * @event FusionCharts#rotationStart
                     * @group chart:pie
                     *
                     * @param {number} startingAngle - Gives the value of the
                     *                 startingAngle of the chart, when the chart
                     *                 starts rotating
                     */
                    global.raiseEvent('RotationStart', {
                            startingAngle: normalizeAngle(seriesData.startingAngleOnDragStart, true)
                        },
                        chart.logic.chartInstance
                    );
                }

                angle = getClickArcTangent.call(evt, x, y, seriesData.pieCenter,
                    seriesData.chartPosition);

                datasets[0].startAngle += (angle - seriesData.dragStartAngle);
                seriesData.dragStartAngle = angle;
                seriesData.moveDuration = 0;

                currentTime = new Date().getTime();

                if (!seriesData._lastTime || (seriesData._lastTime + seriesData.timerThreshold < currentTime)) {
                    setTimeout(function () {
                        chart.rotate(seriesData, datasets[0]);
                    }, 0);
                    seriesData._lastTime = currentTime;
                }
            },
            plotMouseDown: function () {
                var o = this,
                    plotItem = o.plotItem || o.data('plotItem'),
                    seriesData = plotItem.seriesData;

                seriesData.isRotating = false;
            },
            plotMouseUp: function (e) {
                var o = this,
                    plotItem = o.plotItem || o.data('plotItem'),
                    chart = plotItem.chart,
                    seriesData = plotItem.seriesData;

                if (R.supportsTouch && !seriesData.isRotating) {
                    chart.plotGraphicClick.call(plotItem, e);
                }
            },
            plotRollOver: function (e) {
                var ele = this,
                    plotItem = ele.plotItem || ele.data('plotItem'),
                    chart = plotItem.chart,
                    innerDiameter,
                    centerLabelConfig,
                    centerLabelText;
                if (!plotItem.seriesData.isRotating) {
                    plotEventHandler.call(ele, chart, e, ROLLOVER);
                    chart.onPlotHover(ele, true);
                }
                chart.isHovered = true;
                if (innerDiameter = plotItem.innerDiameter) {
                    (centerLabelConfig = plotItem.centerLabelConfig) &&
                        (centerLabelText = centerLabelConfig.label) &&
                        chart.drawDoughnutCenterLabel(centerLabelText, plotItem.center[0],
                            plotItem.center[1], innerDiameter, innerDiameter, centerLabelConfig, false);
                }
            },
            plotRollOut: function (e) {
                var ele = this,
                    plotItem = ele.plotItem || ele.data('plotItem'),
                    chart = plotItem.chart,
                    seriesData = chart.options.series[0],
                    /** @todo: enable doughnut center label feature related to enableMultiSlicing */
                    enableMultiSlicing = true, //seriesData.enableMultiSlicing,
                    innerDiameter,
                    centerLabelConfig,
                    centerLabelText;
                if (!plotItem.seriesData.isRotating) {
                    plotEventHandler.call(ele, chart, e, ROLLOUT);
                    chart.onPlotHover(ele, false);
                }
                chart.isHovered = false;
                if (innerDiameter = plotItem.innerDiameter) {
                    (centerLabelConfig = !enableMultiSlicing ?
                        seriesData.lastCenterLabelConfig : seriesData.centerLabelConfig) &&
                        ((centerLabelText = centerLabelConfig.label) || !centerLabelText) &&
                        chart.drawDoughnutCenterLabel(centerLabelText, plotItem.center[0],
                            plotItem.center[1], innerDiameter, innerDiameter, centerLabelConfig, false);
                }
            },
            onPlotHover: function (plot, hover) {
                var plotItem = plot.data('plotItem'),
                    rolloverProps = plotItem.rolloverProperties,
                    color = hover ? rolloverProps.color : plotItem.color,
                    borderWidth = hover ? rolloverProps.borderWidth : plotItem.borderWidth,
                    borderColor = hover ? rolloverProps.borderColor : plotItem.borderColor;

                rolloverProps && plotItem.graphic.attr({
                    fill: toRaphaelColor(color),
                    'stroke-width': borderWidth,
                    'stroke': borderColor
                });
            },
            getEventArgs: function (plot) {
                plot = plot || {};
                return {
                    datasetName: plot.label,
                    datasetIndex: plot.originalIndex,
                    id: plot.userID,
                    visible: true,
                    label: plot.label,
                    value: plot.value,
                    percentValue: plot.percentage,
                    tooltext: plot.toolText,
                    link: plot.link,
                    sliced: plot.sliced
                };
            },
            legendClick: function (plot) {
                var chart = plot.chart,
                    plots = chart.elements.plots[0];
                plots.isRotating = false;
                chart.plotGraphicClick.call(plot);
            },
			placeDataLabels: (function () {
				/*
				 * Pie Helper Functions.
				 */

				var sortArrayByPoint = function (a, b) {
						return a.point.value - b.point.value;
					},
					sortArrayByAngle = function (a, b) {
						return a.angle - b.angle;
					},
					alignments = ['start', 'start', 'end', 'end'],
					alignCenter = 'middle',
					ySign = [-1, 1, 1, -1],
					xSign = [1, 1, -1, -1];

                return function (isRotating, plotItems, plot, seriesData) {
                    var chart = this,
                        plotOptions = chart.options.plotOptions,
                        piePlotOptions = plotOptions.pie,
                        cx = chart.canvasLeft + chart.canvasWidth * 0.5,
                        cy = chart.canvasTop + chart.canvasHeight * 0.5,
                        smartLabel = chart.smartLabel,
                        dataLabelsOptions = plotOptions.series.dataLabels,
                        style = dataLabelsOptions.style,
                        lineHeight = pluckNumber(mathCeil(parseFloat(style.lineHeight)), 12),
                        placeInside = getFirstValue(dataLabelsOptions.placeLabelsInside, (plotItems.length === 1 ?
                            true : false)),
                        skipOverlapLabels = dataLabelsOptions.skipOverlapLabels,
                        manageLabelOverflow = dataLabelsOptions.manageLabelOverflow,
                        connectorPadding = dataLabelsOptions.connectorPadding,
                        distanceOption = dataLabelsOptions.distance,
                        remainingHeight,
                        seriesCenter = seriesData && seriesData.metrics || [
                            cx,
                            cy,
                            piePlotOptions.size,
                            (piePlotOptions.innerSize || 0)
						],
						centerY = seriesCenter[1],
						centerX = seriesCenter[0],
						radius = seriesCenter[2] * 0.5,
						// divide the points into quarters for anti collision
						quarters = [
							[], // top right
							[], // bottom right
							[], // bottom left
							[] // top left
						],
						plotLeft = chart.canvasLeft,
						plotTop = chart.canvasTop,
						plotWidth = chart.canvasWidth,
						dataLabelsRadius = plot.labelsRadius ||
							(plot.labelsRadius = radius + distanceOption),
						labelFontSize = parseInt(style.fontSize, 10),
						labelHeight = labelFontSize,
						halfLabelHeight = labelHeight / 2,
						xDisplacement = [connectorPadding,
							connectorPadding, -connectorPadding, -connectorPadding
						],
						maxLabels = plot.labelsMaxInQuadrant ||
							(plot.labelsMaxInQuadrant = mathFloor(
							dataLabelsRadius / labelHeight)),
						isSmartLineSlanted = dataLabelsOptions.isSmartLineSlanted,
						innerRadius = seriesCenter[3] / 2,
						align,
						i,
						labelWidth,
						j,
						oriY,
						maxYmayHave,
						spaceRequired,
						length,
						k,
						sliced,
						x1,
						x2,
						x3,
						x4,
						y1,
						y2,
						y3,
						points,
						point,
						angle,
						connector,
						connectorPath,
						excess,
						excessArr,
						labelQuadrantHeight,
						maxQuadrantLabel,
						dataLabel,
						quarter,
						transX,
						transY,
						smartLabelObj,
                        slicedTranslation,
                        centerDistance;

					// run parent method
					/**^
					 * Introduced the isRotating argument too to detect
					 * whether this is called during rotation.
					 */
					if (!isRotating) {
						//do not set the style every time
						// Do it for first time
						smartLabel.setStyle(style);
					}

					// arrange points for detection collision
					// Creates an array of quarter containing labels of each
					// quarter if there has only one label the draw it inside
					if (plotItems.length == 1 && !innerRadius && placeInside) {
						point = plotItems[0];
						dataLabel = point.dataLabel;
						dataLabel && dataLabel.show();

						point.slicedTranslation = [plotLeft, plotTop];
						if (dataLabel) {
							dataLabel.attr({
								visibility: VISIBLE,
								align: alignCenter,
								transform: ['t', centerX, centerY + halfLabelHeight - 2]
							});
							dataLabel.x = centerX;
						}
					}
					else {
						if (placeInside) {
							centerDistance = innerRadius + ((radius - innerRadius) / 2);
							each(plotItems, function (point) {
								dataLabel = point.dataLabel;
								dataLabel && dataLabel.show();

								if (dataLabel) {
									angle = point.angle;
									y3 = centerY + (centerDistance *
										mathSin(angle)) + halfLabelHeight - 2;
									x3 = centerX + (centerDistance * mathCos(angle));
									dataLabel.x = x3;
									// storing original x value
									// to use while slicing in (IE Issue original
									//  x get changed form animate)
									dataLabel._x = x3;

									dataLabel.y = y3;
									if (point.sliced) {
										slicedTranslation = point.slicedTranslation;
										transX = slicedTranslation[0] - plotLeft;
										transY = slicedTranslation[1] - plotTop;
										x3 = x3 + transX;
										y3 = y3 + transY;
									}
									dataLabel.attr({
										visibility: VISIBLE,
										align: alignCenter,
										transform: ['t', x3, y3]
									});
								}
							});
						}
						else { //outside
							each(plotItems, function (point) {
								dataLabel = point.dataLabel;
								dataLabel && dataLabel.show();

								if (dataLabel) {
									angle = point.angle % pi2;

									if (angle < 0) {
										angle = pi2 + angle;
									}
									// Calculate bottom right quarter labels
									if (angle >= 0 && angle < piBy2) {
										quarter = 1;
									} else
									// Calculate bottom left quarter labels
									if (angle < pi) {
										quarter = 2;
									} else
									// Calculate top left quarter labels
									if (angle < pi3By2) {
										quarter = 3;
									}
									// Calculate top right quarter labels
									else {
										quarter = 0;
									}

									// Now put labels according to each quarter
									quarters[quarter].push({
										point: point,
										angle: angle
									});
								}
							});

							i = k = 4;
							//if excess then remove the low value slice first
							while (i--) {
								if (skipOverlapLabels) {
									// Find labels can fit into the quarters or not
									excess = quarters[i].length - maxLabels;
									if (excess > 0) {
										// sort by point.value
										quarters[i].sort(sortArrayByPoint);
										// remove extra data form the array
										// which labels can not be fitted into
										// the quarters
										excessArr = quarters[i].splice(0, excess);
										//hide all removed labels
										for (j = 0, length = excessArr.length; j < length; j += 1) {
											point = excessArr[j].point;
											point.dataLabel.attr({
												visibility: HIDDEN
											});
											if (point.connector) {
												point.connector.attr({
													visibility: HIDDEN
												});
											}
										}
									}
								}
								// now we sort the data labels by its label angle
								quarters[i].sort(sortArrayByAngle);
							}

							maxQuadrantLabel = mathMax(
								quarters[0].length,
								quarters[1].length,
								quarters[2].length,
								quarters[3].length
							);
							labelQuadrantHeight = mathMax(
								mathMin(maxQuadrantLabel, maxLabels) * labelHeight,
								dataLabelsRadius + labelHeight
							);

							// reverse 1st and 3rd quardent points
							quarters[1].reverse();
							quarters[3].reverse();

							while (k--) {
								points = quarters[k];
								length = points.length;

								if (!skipOverlapLabels) {
									if (length > maxLabels) {
										labelHeight = labelQuadrantHeight / length;
									}
									else {
										labelHeight = labelFontSize;
									}
									halfLabelHeight = labelHeight / 2;
								}

								//1st pass
								//place all labels at 1st quarter

								// calculate the total available space to put labels
								spaceRequired = length * labelHeight;
								// calculate the remaining height
								remainingHeight = labelQuadrantHeight;
								//place all child point
								for (i = 0; i < length; i += 1, spaceRequired -= labelHeight) {
									// Get the y position of the label (radius
									// where data label is to draw)
									oriY = mathAbs(labelQuadrantHeight * mathSin(points[i].angle));

									if (remainingHeight < oriY) {
										oriY = remainingHeight;
									}
									else if (oriY < spaceRequired) {
										oriY = spaceRequired;
									}

									remainingHeight = (points[i].oriY = oriY) - labelHeight;
								}

								//2nd pass(reverse)
								align = alignments[k];
								//place all labels at 1st quarter
								maxYmayHave = labelQuadrantHeight - ((length - 1) * labelHeight);
								remainingHeight = 0;

								//place all child point
								for (i = points.length - 1; i >= 0; i -= 1, maxYmayHave += labelHeight) {
									point = points[i].point;
									angle = points[i].angle;
									sliced = point.sliced;
									dataLabel = point.dataLabel;

									oriY = mathAbs(labelQuadrantHeight * mathSin(angle));

									if (oriY < remainingHeight) {
										oriY = remainingHeight;
									}
									else if (oriY > maxYmayHave) {
										oriY = maxYmayHave;
									}

									remainingHeight = oriY + labelHeight;

                                    y1 = ((oriY + points[i].oriY) / 2);
                                    x1 = centerX + xSign[k] * dataLabelsRadius *
                                        mathCos(math.asin(y1 / labelQuadrantHeight));
									y1 *= ySign[k];
									y1 += centerY;

									y2 = centerY + (radius * mathSin(angle));
									x2 = centerX + (radius * mathCos(angle));

                                    // Relation: centerX <= connectorStartX <= connectorEndX
                                    // (for right half and vice versa for left half)
									(k < 2 && x1 < x2 || k > 1 && x1 > x2) && (x1 = x2);

									x3 = x1 + xDisplacement[k];
									y3 = y1 - halfLabelHeight - 2;
									x4 = x3 + xDisplacement[k];

									dataLabel.x = x4;
									// storing original x value
									// to use while slicing in (IE Issue original
									// x get changed form animate)
									dataLabel._x = x4;

									if (manageLabelOverflow) {
										labelWidth = k > 1 ? x4 - chart.canvasLeft : chart.canvasLeft + plotWidth - x4;
                                        smartLabel.setStyle(point.style);
                                        lineHeight = pluckNumber(mathCeil(parseFloat(point.style.lineHeight)), 12) +
                                                (mathCeil(parseFloat(point.style.border), 12) * 2);
                                        smartLabelObj =
                                            smartLabel.getSmartText(point.labelText, labelWidth, lineHeight);
										dataLabel.attr({
											text: smartLabelObj.text,
											title: (smartLabelObj.tooltext || '')
										});
									}
									dataLabel.y = y3;

									if (sliced) {
										transX = point.transX;
										transY = point.transY;
										x3 = x3 + transX;
										x1 = x1 + transX;
										x2 = x2 + transX;
										y2 = y2 + transY;
										x4 = x4 + transX;
									}

									dataLabel.attr({
										visibility: VISIBLE,
										'text-anchor': align,
										vAlign: 'middle',
										x: x4,
										y: y1
									});

									// draw the connector
									if ((connector = point.connector)) {
										point.connectorPath = connectorPath = [
											M,
											x2, y2, // base
											L,
											// first break, next to the label
											isSmartLineSlanted ? x1 : x2, y1,
											x3, y1 // end of the string at the label
										];

										connector.attr({
											path: connectorPath,
											'visibility': VISIBLE
										});
									}
								}
							}
						}
					}
				};
			}())
		}, renderer['renderer.root']);
	}
]);
/**
 * @private
 *
 * @module fusioncharts.renderer.javascript.interface
 * @requires fusioncharts.renderer.javascript
 * @requires fusioncharts.renderer.javascript.visualizer
 */
FusionCharts.register('module', ['private', 'modules.renderer.js-interface', function() {
    var global = this,
        STUB = 'stub',
        /**
         * Get a reference to the renderer specific global library store.
         */
        lib = global.hcLib,
        /**
         * Get a reference to the JavaScript renderer.
         */
        renderer = global.renderer.getRenderer('javascript'),
        hasModule = lib.hasModule,
        loadModule = lib.loadModule,
        getMetaSentence = lib.getMetaSentence,
        moduleCmdQueue = lib.moduleCmdQueue,
        executeWaitingCommands = lib.executeWaitingCommands,
        injectModuleDependency = lib.injectModuleDependency,
        /**
         * List of chart types that are dependent on each module. There has to be
         * a one-to-one mapping to ensure that module is requested for loading
         * when it is rendered.
         */
        moduleDependencies = lib.moduleDependencies,
        /**
         * Find the relevant required module names from a given chart type.
         *
         * @param {string} type depermines the chart type (alias) that needs to
         * be looked up for dependent module names
         *
         * @type Array
         */
        getDependentModuleName = lib.getDependentModuleName,
        probeLoadErrorMessage, // fn
        showUnsupportedChartMessage; // fn

    /**
     * Function to check charts that are pending render process and are marked
     * as error in loading.
     */
    probeLoadErrorMessage = function (key) {
        var item,
            vars,
            type,
            typeComposite,
            modules,
            terminalModule,
            affectedModules = {},
            module;

        key = getMetaSentence(key);

        for (item in global.core.items) {
            item = global.core.items[item];
            type = item.chartType();
            typeComposite = item.options.chartTypeSourcePath + type,
            vars = item.jsVars;

            if (vars && vars.waitingModule && item.__state.rendering &&
                    lib.needsModule(key.predicate, typeComposite)) { //^ will it be typecomposite or predicate
                vars.waitingModuleError = true;
                modules = getDependentModuleName(typeComposite).concat(vars.userModules);
                if (modules.length) {
                    terminalModule = modules[modules.length - 1];
                    affectedModules[terminalModule] =
                        lib.moduleCmdQueue[terminalModule];
                }
            }
        }

        // Execute all the waiting queues that are affected due to lack of one
        // module.
        for (module in affectedModules) {
            executeWaitingCommands(affectedModules[module]);
        }

        // raise a global event
        global.raiseError(global.core, '11171116151', 'run', 'HC-interface~renderer.load',
            'Unable to load required modules and resources: ' + key.key);
    };

    /**
     * Function to display chart not supported message
     */
    showUnsupportedChartMessage = function (chartObj, container, callback) {
        var args = chartObj.args,
            options = chartObj.options;

        // Set chart message styling for chart type not supported
        chartObj._chartMessageStyle = {
            color: args.typeNotSupportedMessageColor || options.baseChartMessageColor,
            fontFamily: args.typeNotSupportedMessageFont || options.baseChartMessageFont,
            fontSize: args.typeNotSupportedMessageFontSize || options.baseChartMessageFontSize
        };
        global.hcLib.createChart(chartObj, container, STUB, callback, options.typeNotSupportedMessage);
    };

    /**
     * List of events that has an equivalent legacy event. Used by the
     * raiseEvent method to check whether a particular event raised
     * has any corresponding legacy event.
     *
     * @type object
     */
    lib.eventList = global.extend(global.legacyEventList, {
        loaded: 'FC_Loaded',
        dataloaded: 'FC_DataLoaded',
        rendered: 'FC_Rendered',
        drawcomplete: 'FC_DrawComplete',
        dataxmlinvalid: 'FC_DataXMLInvalid',
        nodatatodisplay: 'FC_NoDataToDisplay',
        exported: 'FC_Exported'
    });
    lib.raiseEvent = global.raiseEventWithLegacy;

    /**
     * List of chart types for individual modules with corresponding load order
     * for the resource.
     * This is the default chart types under the "charts" group.
     *
     * @type object
     */
    moduleDependencies.charts = (global.extend(moduleDependencies.charts || {}, {
        column2d: 0,
        column3d: 0,
        bar2d: 0,
        bar3d: 0,
        pie2d: 0,
        pie3d: 0,
        line: 0,
        area2d: 0,
        doughnut2d: 0,
        doughnut3d: 0,
        pareto2d: 0,
        pareto3d: 0,
        mscolumn2d: 0,
        mscolumn3d: 0,
        msline: 0,
        msarea: 0,
        msbar2d: 0,
        msbar3d: 0,
        stackedcolumn2d: 0,
        marimekko: 0,
        stackedcolumn3d: 0,
        stackedarea2d: 0,
        stackedcolumn2dline: 0,
        stackedcolumn3dline: 0,
        stackedbar2d: 0,
        stackedbar3d: 0,
        msstackedcolumn2d: 0,
        mscombi2d: 0,
        mscombi3d: 0,
        mscolumnline3d: 0,
        mscombidy2d: 0,
        mscolumn3dlinedy: 0,
        stackedcolumn3dlinedy: 0,
        msstackedcolumn2dlinedy: 0,
        scatter: 0,
        bubble: 0,
        ssgrid: 0,
        scrollcolumn2d: 0,
        scrollcolumn3d: 0,
        scrollline2d: 0,
        scrollarea2d: 0,
        scrollstackedcolumn2d: 0,
        scrollcombi2d: 0,
        scrollcombidy2d: 0,
        zoomline: 0
    }));

    /**
     * List of chart types for individual modules with corresponding load order
     * for the resource.
     * This is the default chart types under the "powercharts" group.
     *
     * @type object
     */
    moduleDependencies.powercharts = (global.extend(moduleDependencies.powercharts || {}, {
        spline: 0,
        splinearea: 0,
        msspline: 0,
        mssplinearea: 0,
        mssplinedy: 0,
        multiaxisline: 0,
        multilevelpie: 0,
        waterfall2d: 0,
        msstepline: 0,
        inversemsline: 0,
        inversemscolumn2d: 0,
        inversemsarea: 0,
        errorbar2d: 0,
        errorscatter: 0,
        errorline: 0,
        logmsline: 0,
        logmscolumn2d: 0,
        logstackedcolumn2d: 0,
        radar: 0,
        dragnode: 0,
        candlestick: 0,
        selectscatter: 0,
        dragcolumn2d: 0,
        dragline: 0,
        dragarea: 0,
        boxandwhisker2d: 0,
        kagi: 0,
        heatmap: 0
    }));

    /**
     * List of chart types for individual modules with corresponding load order
     * for the resource.
     * This is the default chart types under the "widgets" group.
     *
     * @type object
     */
    moduleDependencies.widgets = global.extend(moduleDependencies.widgets || {}, {
        angulargauge: 0,
        bulb: 0,
        cylinder: 0,
        drawingpad: 0,
        funnel: 0,
        hbullet: 0,
        hled: 0,
        hlineargauge: 0,
        vlineargauge: 0,
        pyramid: 0,
        realtimearea: 0,
        realtimecolumn: 0,
        realtimeline: 0,
        realtimelinedy: 0,
        realtimestackedarea: 0,
        realtimestackedcolumn: 0,
        sparkcolumn: 0,
        sparkline: 0,
        sparkwinloss: 0,
        thermometer: 0,
        vbullet: 0,
        gantt: 0,
        vled: 0
    });

    /**
     * List of chart types for individual modules with corresponding load order
     * for the resource.
     * This is the default chart types under the "maps" group.
     *
     * @type object
     */
    moduleDependencies.maps = global.extend(moduleDependencies.maps || {}, { });

    // Update renderer functions with functions that are intended to
    global.extend(renderer, {

        render: function (container, callback) {
            /* algorithm:
             * 1. If JS Renderer is not ready then queue the chart.
             * 2. Prepare the chart DOM element
             * 3. Send the chart for rendering if JS Renderer is ready
             */

            var chartObj = this,
                chartType = chartObj.chartType(),
                typeComposite = chartObj.options.chartTypeSourcePath + chartType,
                vars = chartObj.jsVars,
                state = chartObj.__state,
                chartAPI = lib.chartAPI,
                options = chartObj.options,
                args = chartObj.args,
                showChartLoadingMessage = chartObj.options.showChartLoadingMessage,
                loadMessage,
                objModuleNames,
                cmdQueue,
                eiMethod;

            // vars.userModules has been validated from renderer's
            // BeforeInitialize event and is also part of policy
            objModuleNames = getDependentModuleName(typeComposite).concat(vars.userModules);

            // If chart is resizing... prevent it.
            vars.isResizing && (vars.isResizing = clearTimeout(vars.isResizing));

            // Destroy old chart if needed during update.
            vars.hcObj && vars.hcObj.destroy && vars.hcObj.destroy();

            if (!chartAPI[chartType]) { // check presence of API

                // Set command queue based on stock modules or dynamic modules
                // In case of blank chart-type, we should not attempt loading
                // module.
                if (chartType && hasModule(objModuleNames)) {
                    // Try loading the filename and see if that works!
                    if (!vars.drLoadAttempted) {
                        // Add a commandqueue and corresponding dummy dynamic
                        // dependency definition for this chart.
                        if (injectModuleDependency(typeComposite)) {
                            // since injection took place for first time, we
                            // need to correct the present dependency list.
                            objModuleNames = getDependentModuleName(typeComposite)
                                .concat(vars.userModules);
                        }

                        vars.drLoadAttempted = true;
                    }
                    else {
                        // If chart api is absent but all modules are present, we
                        // assume charts are not supported, provided a dynamic load
                        // has been attempted.
                        global.raiseError(chartObj, 11112822001, 'run',
                            'HC-interface~renderer.render',
                            'Chart runtimes not loaded even when resource is present');
                        showUnsupportedChartMessage(chartObj, container, callback);
                        return;
                    }
                }
                // Check whether this is a valid chart type as per static
                // dependency list (this block will be executed when dynamic
                // resource load is not attempted)
                else if (!objModuleNames.length) {
                    showUnsupportedChartMessage(chartObj, container, callback);
                    return;
                }
                else if (vars.waitingModuleError) {
                    showUnsupportedChartMessage(chartObj, container, callback);
                    // If error is displayed wrt module absence, clear all
                    // flags wrt module load wait. This is done so that next
                    // re-render tries to execute the same load algo.
                    delete vars.waitingModule;
                    delete vars.waitingModuleError;
                    return;
                }

                // Get reference to the command queue for the terminal module.
                cmdQueue = moduleCmdQueue[objModuleNames[objModuleNames.length - 1]];

                if (cmdQueue) {
                    cmdQueue.push({
                        cmd: 'render',
                        obj: chartObj,
                        args: arguments
                    });
                }
                // In case a reference to the command queue has not been found,
                // raise an error.
                else {
                    global.raiseError(chartObj, 12080515551, 'run',
                        'HC-interface~renderer.render',
                        'Unregistered module in dependentModule definition.');
                    // Set chart message styling for render error message
                    chartObj._chartMessageStyle = {
                        color: args.renderErrorMessageColor || options.baseChartMessageColor,
                        fontFamily: args.renderErrorMessageFont || options.baseChartMessageFont,
                        fontSize: args.renderErrorMessageFontSize || options.baseChartMessageFontSize
                    };
                    global.hcLib.createChart(chartObj, container, STUB, undefined, options.renderErrorMessage);
                    return;
                }

                if (!vars.waitingModule) {
                    // Get chart loading message
                    loadMessage = showChartLoadingMessage ? (options.PBarLoadingText || options.loadMessage) : '';

                    // Set chart message styling for loading message
                    chartObj._chartMessageStyle = {
                        color: args.loadMessageColor || options.baseChartMessageColor,
                        fontFamily: args.loadMessageFont || options.baseChartMessageFont,
                        fontSize: args.loadMessageFontSize || options.baseChartMessageFontSize
                    };
                    // Show loading message if not already shown
                    global.hcLib.createChart(chartObj, container, STUB, undefined, loadMessage);
                    renderer.load.call(chartObj, container, callback);
                }
                return;
            }

            // Need to delete earlier eiMethods.
            if (chartAPI[state.lastRenderedType] && state.lastRenderedType !== chartType) {
                /**
                 * This event is fired when a change in chart type is triggered by calling
                 * {@link FusionCharts#chartType} on a chart. The event is raised only when the chart type has been
                 * explicitly changed from what was set earlier.
                 *
                 * This event is *not* fired when:
                 *
                 *  - A chart is rendered using {@link FusionCharts.render}.
                 *  - A chart type is set for the first time on a chart, even using {@link FusionCharts#chartType}. For
                 * example, if no `type` option is provided to the FusionCharts constructor when creating the chart, and
                 * later on {@link FusionCharts#chartType} is called on that chart instance for the first time, this
                 * event is not triggered.
                 *  - If the chart type parameter sent to {@link FusionCharts#chartType} is the same as the current
                 * chart type.
                 *  - If the new chart type provided is invalid.
                 *
                 * @see FusionCharts#chartType
                 *
                 * @event FusionCharts#chartTypeChanged
                 * @group chart
                 *
                 * @param {string} previousType - The previously assigned chart type of the chart.
                 * @param {string} newType - The new chart type that has been set on the chart.
                 */
                global.raiseEvent('chartTypeChanged', {
                    previousType: state.lastRenderedType,
                    newType: chartType
                }, chartObj);

                for (eiMethod in chartAPI[state.lastRenderedType].eiMethods) {
                    delete chartObj[eiMethod];
                }

            }
            // Updated last-rendererd type to current type.
            state.lastRenderedType = chartType;

            // Store a copy of the currently rendered src value for later
            // use while comparing during update.
            state.lastRenderedSrc = chartObj.src;

            /**
             * Fired when all modules for a chart is available.
             *
             * Internal Note: This should be the actual location of firing the loaded method with its true meaning. The
             * current flash mimic loaded event needs to be phased out.
             * @private
             *
             * @event FusionCharts#internal.loaded
             * @param {string} type This is the type of chart that is being rendered.
             */
            !vars.waitingModuleError && lib.raiseEvent('internal.loaded', {
                type: chartType,
                triggeredModuleLoad: vars.drLoadAttempted || vars.waitingModule
            }, chartObj, [chartObj.id]);

            delete vars.waitingModule;
            delete vars.waitingModuleError;
            delete vars.drLoadAttempted; // remove flag for next.

            // Call renderer to generate FusionCharts.
            global.hcLib.createChart(chartObj, container, chartType, callback);
        },

        update: function (param) {
            var chartObj = this,
                chart = chartObj.ref,
                vars = chartObj.jsVars;

            // Destroy old chart if needed during update.
            vars.hcObj && vars.hcObj.destroy && vars.hcObj.destroy();

            if (vars.isResizing) {
                vars.isResizing = clearTimeout(vars.isResizing);
            }

            // Check whether there was an error or not.
            if (param.error === undefined) {
                delete vars.stallLoad;
                delete vars.loadError;
                // Call ExternalInterface method and update the data
                if (this.isActive()) {
                    if (chartObj.src !== chartObj.__state.lastRenderedSrc) {
                        chartObj.render();
                    }
                    else {
                        // Call renderer to generate FusionCharts.
                        global.hcLib.createChart(chartObj, vars.container);
                    }
                }
                else if (chartObj.__state.rendering && !vars.waitingModule) {
                    global.hcLib.createChart(chartObj, vars.container);
                }
            }
            // Show error message.
            else {
                // Call ExternalInterface method to show message
                if (this.isActive() && typeof chart.showChartMessage === 'function') {
                    chart.showChartMessage('InvalidXMLText');
                }
                delete vars.loadError;
            }
        },

        resize: function (size) {
            var container = this.ref,
            cssSize,
            vars = this.jsVars;

            // Set the sizes of the DOM elements for the resize and fire related
            // commands needed for resize.
            if (!(container && container.resize)) {
                return;
            }

            if (vars.isResizing) { // need to be cleared on other interface fns
                vars.isResizing = clearTimeout(vars.isResizing);
            }

            // resize chart async so that consecutive resizes can be blocked
            vars.isResizing = setTimeout(function () {
                cssSize = global.normalizeCSSDimension(size.width, size.height,
                    container);
                if (size.width !== undefined) {
                    container.style.width = cssSize.width;
                }
                if (size.height !== undefined) {
                    container.style.height = cssSize.height;
                }

                container.resize();
                delete vars.isResizing;
            }, 0);
        },

        dispose: function () {
            var container,
                vars = this.jsVars;

            if (vars.isResizing) {
                vars.isResizing = clearTimeout(vars.isResizing);
            }

            // do chartAPI instance cleanup
            vars.instanceAPI && vars.instanceAPI.dispose && (vars.instanceAPI.dispose(), delete vars.instanceAPI);

            // Proceed with disposal only when the HTML element exists.
            if ((container = this.ref)) {
                global.purgeDOM(container);
                // Delete DOM element
                if (container.parentNode) {
                    container.parentNode.removeChild(container);
                }
            }
            vars.container = null;
            // On dispose remove any waiting commands.
            lib.cleanupWaitingCommands(this);
        },

        load: function (_container, _callback) {
            var chart = this,
                vars = chart.jsVars,
                type = chart.chartType(),
                api = global.hcLib.chartAPI[type],
                // merge with user modules while loading dependencies
                modules = getDependentModuleName(type).concat(vars.userModules),
                terminalModule = modules[modules.length - 1];

            if (api || !modules || (modules && modules.length === 0)) {
                delete vars.waitingModule;
                _container && showUnsupportedChartMessage(chart, _container || chart.ref, _callback);
                return;
            }

            // Request load of the specific chart module
            if (!vars.waitingModule) {
                // Mark the object that it is waiting for module load.
                vars.waitingModule = true;
                delete vars.waitingModuleError;

                loadModule(modules, function () {
                    delete vars.waitingModule;
                    executeWaitingCommands(lib.moduleCmdQueue[terminalModule]);
                }, probeLoadErrorMessage, chart);
                // Above: Since this may not be the terminal module for all
                // charts, we need to check and raise error on all modules.
            }
        }
    });


}]);

/**
 * This module contains codes required to get and set chart attributes from a FusionCharts object using simple getter
 * and setter functions.
 * @private
 *
 * @module fusioncharts.api.chartattributes
 * @requires fusioncharts.transcoder
 * @requires fusioncharts.renderer
 */
FusionCharts.register('module', ['private', 'modules.api.dynamicchartattributes', function () {

    var global = this;

    global.extend(global.core, /** @lends FusionCharts# */ {
        /**
         * Updates a chart's data attributes with the new attribute-value pair. In other words, it updates a chart's
         * data definition root. That would be `<chart>` node in case data is in `XML` format or the `chart {}` object
         * in case it is in `JSON` format. You must have the chart's data being set for these attributes to take effect.
         *
         * This function is useful when updating a chart's configuration after it has been rendered once. The function
         * internally retrieves the last data set on the chart (using {@link FusionCharts#getJSONData}). It then updates
         * the `{ chart: {} }` object of the data using the new attributes provided and then sets this data back to the
         * chart.
         *
         * > Setting the value of a parameter to `null` causes the attribute to be removed (unset) and restored to it's
         * > default value.
         *
         * @group data
         *
         * @param {object|string} attributes - The set of attributes to be is passed on as key-value pair of an
         * object. In case of updating a single attribute, the key can be passed as a `string` and the value as the
         * second parameter.
         *
         * @param {?string=} [value] - In case the first parameter is a single attribute as string, the second parameter
         * (i.e. this parameter) must be provided as the value of that key.
         *
         * @example
         * // Here we would render a chart in a DOM element with an id, say "chart-container", and upon clicking the
         * // chart, we would toggle the visibility of its legend.
         * FusionCharts.ready(function () {
         *     FusionCharts.render({
         *         id: 'salesChart',
         *         type: 'pie2d',
         *         renderAt: 'chart-container',
         *
         *         dataSource: {
         *             chart: {
         *                 caption: 'Revenue distribution'
         *             },
         *             data: [
         *                 { value: '22', label: 'Redistribution' },
         *                 { value: '54', label: 'Internal Circulation' },
         *                 { value: '24', label: 'Sale' },
         *             ]
         *         },
         *
         *         events: {
         *             chartClick: function (event) {
         *                 var chart = event.sender,
         *                     // Check whether legend is currently visible by fetching the showLegend attribute
         *                     legendVisible = !!+chart.getChartAttribute('showLegend');
         *
         *                 // Set the opposite of the current state of the legend's visibility.
         *                 chart.setChartAttribute('showLegend', legendVisible ? '0' : '1');
         *             }
         *         }
         *     });
         * });
         */
        setChartAttribute: function (attributes, value) {
            var json,
                prop,
                attList,
                temp,
                i;

            // In case attribute is sent as separate arguments, combine them
            // to one object.
            if (typeof attributes === 'string') {
                temp = arguments[0];
                attributes = {};
                attributes[temp] = value;
            }
            // In case user sends invalid parameters for attributes.
            else if (attributes === null || typeof attributes !== 'object') {
                return;
            }

            i = 0;
            json = this.getChartData(global.dataFormats.JSON);
            attList = json && (json.chart || json.graph || json.map);

            if (!attList) {
                /**
                 * {@link FusionCharts#setChartAttribute} was called while chart data was not set or while chart data
                 * had an error. Check whether {@link FusionCharts.event:dataLoaded} had been successfully fired before
                 * {@link FusionCharts.event:renderComplete} and that none of the data load error events such as
                 * {@link FusionCharts.event:dataLoadError} or {@link FusionCharts.event:invalidData} has been fired.
                 *
                 * @typedef {RuntimeException} Error-2105141421
                 * @memberOf FusionCharts.debugger
                 * @group debugger-error
                 */
                global.raiseError(this, '2105141421', 'run', '#setChartAttribute()',
                    'Could not retrieve attribute list. Is data ready?');
                return;
            }

            // Iterate through attributes and update them.
            for (prop in attributes) {
                i += 1;
                if (attributes[prop] === null) {
                    delete attList[prop.toLowerCase()];
                    continue;
                }
                attList[prop.toLowerCase()] = attributes[prop];
            }
            // Update chart's XML.
            if (i > 0) {
                // In case animation is not specified, then turn it off.
                if (typeof attList.animation === 'undefined') {
                    attList.animation = '0';
                }
                this.setChartData(json, global.dataFormats.JSON);
            }
        },

        /**
         * Fetch value of chart attributes (configurations) that have been explicitly applied to root level `chart`.
         * This function can be used to return value of a single attribute or a list of attributes or all attributes
         * have been applied to the chart.
         *
         * - To fetch a single attribute, pass the name of the attribute as a string.
         * - To fetch a list of selected attributes, pass an array of attribute names. This will return an object with
         * items in the order in which they are provided in the array.
         * - To fetch a list of all attributes, do not pass a parameter to this function.
         *
         * If any attribute requested is not set on the chart, the value for that attribute is returned as `undefined`.
         * This will be `undefined` even for values that are internally computed but not explicitly set. For example,
         * for Multi-series Column2D charts, `showLegend` defaults to `"1"`. But, if `showLegend` is not provided as
         * part of chart configuration, requesting the value of `showLegend` through this function will return
         * `undefined`.
         *
         * @group data
         *
         * @param {string|string[]} [attribute] - The attribute or an array of attributes that is to be fetched. If
         * this parameter is not provided, then all available chart attributes are returned.
         *
         * @returns {string|object} The value of the attribute in form of a string in case a single attribute
         * was requested. Otherwise, an object containing a set of key value pairs.
         */
        getChartAttribute: function (attribute) {

            // Get chart attributes.
            var json = this.getChartData(global.dataFormats.JSON),
                attList = json && (json.chart || json.graph || json.map),
                // Create a variable that will store reference to the parameter that
                // contains attributes. This helps in case user sends one attribute
                // as string, we covert it to an array witj one element.
                value,
                i;

            // In case no argument is passed, we return the entire set of
            // chart attributes object.
            if (arguments.length === 0 || attribute === undefined ||
                    attList === undefined) {
                return attList;
            }

            // Convert single attribute to array with one element or directly
            // send the value as return.
            if (typeof attribute === 'string') {
                value = attList[attribute.toString().toLowerCase()];
            }

            // In case user sends an array of attributes, we compile an object
            // for the same and return.
            else if (attribute instanceof Array) {
                value = {};
                for (i = 0; i < attribute.length; i += 1) {
                    value[attribute[i]] =
                        attList[attribute[i].toString().toLowerCase()];
                }
            }

            // If all above conditions fail, there must be some issue with the
            // parameters.
            else {
                /**
                 * {@link FusionCharts#getChartAttribute} accepts only a string or an array of attribute names as its
                 * paramater. Check whether your call to the function involved passing some other type of parameter.
                 *
                 * @typedef {RuntimeException} Error-25081429
                 * @memberOf FusionCharts.debugger
                 * @group debugger-error
                 */
                global.raiseError(this, '25081429', 'param',
                    '~getChartAttribute()', 'Unexpected value of "attribute"');
            }

            // We return 'value' variable here as because it is equivalent to
            // sending '{}' in case above conditions fail.
            return value;
        }
    }, true);

}]);
/**
 * This module allows for easy drill-down of charts by handling the link
 * attrribute of charts.
 * @private
 *
 * @module fusioncharts.api.linkedcharts
 * @requires fusioncharts.transcoder
 */
FusionCharts.register('module', ['private', 'api.linkmanager', function () {

    var global = this,
        FusionChartsDOMInsertModes = global.FusionChartsDOMInsertModes,
        // Create a collection to store configuration of every root link.
        store = {},

        // Store root and parent reference of every element. This would allow us
        // to save the parent and root reference of the "link" object of every
        // chart.
        LinkInformation = function (root, parent) {
            this.items = {};
            this.root = root;
            this.parent = parent;

            // Do initialization work in case this is the root link. We verify root
            // link in case parent is undefined
            if (parent instanceof global.core) {
                this.level = this.parent.link.level + 1;
            } else {
            // Parent is not an instance of FusionCharts, this implies this link is
            // a root link
                store[root.id] = [{}];
                this.level = 0;
            }
        },

        checkObjectRenderLocationOverride = function (obj, parent) {
            return (obj.options.containerElement ===
                parent.options.containerElement || obj.options.containerElementId ===
                parent.options.containerElementId) && obj.options.insertMode  ===
                FusionChartsDOMInsertModes.REPLACE;
        };

    // Add parameter policy to pass link information during construction of
    // new FusionCharts object.
    global.policies.link = ['link', undefined];


    // This function would return the current configuration of the link that is
    // to be used for construction of a new chart.
    LinkInformation.prototype.configuration = function () {
        var param = store[this.root.id][this.level] ||
            (store[this.root.id][this.level] = {});

        // Return the parameters
        return param;
    };

    // Add global link configuration API using which users will be able to set
    // parameters for every level of link.
    global.extend(global.core, /** @lends FusionCharts# */ {
        /**
         * Configure the properties of _LinkedCharts_. This function accepts all properties that FusionCharts
         * constructor function accepts. Any property passed to this function is applied to the _LinkedCharts_. If no
         * properties are provided, _LinkedCharts_ will inherit properties from the parent chart.
         *
         * _LinkedCharts_ are essentially n-level drill-down of charts, where data points on one chart can create and
         * render a new chart. Each level can be configured by passing the level as the second parameter of this
         * function. Note that the first chart that triggers the drill-down (root chart) has level `0`.
         *
         * Alternatively, _LinkedCharts_ configuration for multiple levels of drill-down can be configured at once by
         * passing them as an array to this function. In that case, the array is the only parameter passed to the
         * function.
         *
         * __The Overlay Button:__
         *
         * Other than the usual construction parameters of FusionCharts, the `param` parameter of this function also
         * accepts configuration for the "overlay button" of _LinkedCharts_. When a _LinkedChart_ is rendered on
         * clicking a data point, a button is rendered on the top-right corner of the chart. When this button is
         * clicked, it closes (disposes) the linked chart.
         *
         * The cosmetics of this button can be configured by passing an `overlayButton` object to `param`. This object
         * can have the following properties.
         *
         * | Button Parameter   | Type        | Description  |
         * | -------------------|-------------| -------------|
         * | `show`             | boolean     | Whether to show the button or not |
         * | `message`          | string      | The label of the button. The default is "Close" or "Back" |
         * | `bgColor`          | string      | Background color of the button in hex format |
         * | `borderColor`      | string      | Border color of the button in hex format |
         * | `font`             | string      | Font family of the button (comma separated list of fonts) |
         * | `fontColor`        | string      | The color of the button label text |
         * | `fontSize`         | string      | The size of the button label text |
         * | `bold`             | boolean     | Specify whether the button label text appears bold |
         * | `padding`          | number      | The padding between the label and the edges of the button |
         *
         * @tutorial interactivity-drill-down-linkedcharts
         * @see FusionCharts#event:beforeLinkedItemOpen
         * @see FusionCharts#event:linkedItemOpened
         * @see FusionCharts#event:beforeLinkedItemClose
         * @see FusionCharts#event:linkedItemClosed
         * @group linked-charts
         *
         * @param {object|array} param
         * @param {!number=} [level=0] - Since linked charts are multi-level drill-down, you can configure the
         * parameters of a particular drill-down level by specifying it in this parameter.
         *
         * @example
         * myChart.configureLink({
         *     type: 'pie2d', // Set the linked-charts configuration to load all linked charts as Pie
         *     width: '80%', // The width of the charts would be 80% of their parent container
         *     overlayButton: {
         *         message: ' X ', // Set the button to show letter "X"
         *         bgColor:'#999999',
         *         borderColor: '#cccccc'
         *     }
         * });
         *
         * @example
         * // Configure linked charts to show the first level drill-down as bar chart, the next as line charts and
         * // the third level as pie charts.
         * myChart.configureLink([
         *     { type: 'bar2d' },
         *     { type: 'line' },
         *     { type: 'pie2d' }
         * ]);
         */
        configureLink: function (param, level) {
            var i;

            // In case user provides an array of configuration, we assume that the
            // user wants to redefine the entire configuration train.
            if (param instanceof Array) {
                for (i = 0; i < param.length; i += 1) {
                    // We initialize a blank configuration object for
                    // the link configuration train, in case it is not
                    // pre-defined.
                    if (typeof store[this.link.root.id][i] !== 'object') {
                        store[this.link.root.id][i] = {};
                    }
                    // The configuration is one-by-one copied two the store.
                    global.extend(store[this.link.root.id][i], param[i]);
                }
                // Delete any extra configuration.
                store[this.link.root.id].splice(param.length);
            }
            else if (typeof param === 'object') {
            // If user has sent one object, we assume he wants to configure
                // In case level is undefined, we need to assign the current
                // level of the object.
                if (typeof level !== 'number') {
                    level = this.link.level;
                }
                // Create a blank parameter object in store in case it is not
                // defined.
                if (store[this.link.root.id][level] === undefined) {
                    store[this.link.root.id][level] = {};
                }
                // Copy all parameters passed on to the store.
                global.extend(store[this.link.root.id][level], param);
            }
            else {
                /**
                 * {@link FusionCharts#configureLink} accepts a configuration object or an array of configuration
                 * objects as its parameter. Check whether some other data type has been passed or not.
                 *
                 * @typedef {ParameterException} Error-25081731
                 * @memberOf FusionCharts.debugger
                 * @group debugger-error
                 */
                global.raiseError(this, '25081731', 'param', '~configureLink()',
                    'Unable to update link configuration from set parameters');
            }
        }
    }, true);


    // Add construction routines to manage link parameters.
    global.addEventListener('beforeInitialize', function (event) {

        // If LinkInformation is not present in the object, we can assume
        // that this chart is a root chart and hence we need to create
        // link related information.
        if (!(event.sender.link instanceof LinkInformation)) {
            event.sender.link = new LinkInformation(event.sender);
        } else {
        // In case link is predefined, we need to add the new object to the
        // 'items' collection of parent of the new object.
            // In case of root link, parent is undefined, we do not need to
            // add any type of item configuration.
            if (event.sender.link.parent instanceof global.core) {
                event.sender.link.parent.link.items[event.sender.id] = event.sender;
            }
        }
    });

    // Handle the linked-chart click event.
    global.addEventListener('linkedChartInvoked', function (event, args) {
        var obj = event.sender,
            param = obj.clone({
                dataSource: args.data,
                dataFormat: args.linkType,
                // Create a new link between the source chart and the to-be-created
                // new chart.
                link: new LinkInformation(obj.link.root, obj)
            }, true),
            alias = args.alias,
            childObj;

        // Pass on the chart alias if passed by event.
        if (alias) {
            // In case no swf path is specifed, try to recover the same from
            // swfUrl.
            if (!param.typeSource && param.swfUrl) {
                param.typeSource = param.swfUrl
                        .replace(/(.*?)?[^\/]*\.swf.*?/ig, '$1');
            }
            param.type = alias;
        }

        // Delete certain default or post-render state related variables from
        // params.
        if (obj.args && parseInt(obj.args.animate, 10) !== 0) {
            delete param.animate;
        }
        // Update parameters by overrides set by user
        global.extend(param, obj.link.configuration());

        /**
         * This event is fired when a linked item in a *LinkedChart* is about to open after its parent link has been
         * clicked. This event is raised before instantiating the the instance of the drill-down chart. To know more
         * about *LinkedCharts*, see {@tutorial interactivity-drill-down-linkedcharts}.
         *
         * You can cancel the drill-down process using `eventObject.preventDefault()` during this event.
         *
         * @see FusionCharts#configureLink
         * @see FusionCharts#event:linkedItemOpened
         *
         * @event FusionCharts#beforeLinkedItemOpen
         * @group linked-charts
         *
         * @param {string} level - Level of the linked item with respect to the parent chart (starts from '0').
         */
        global.raiseEvent('beforeLinkedItemOpen', {
            level: obj.link.level
        }, obj.link.root, undefined, function () {
            // Delete the chart with same id, if there is one.
            if (global.core.items[param.id] instanceof global.core) {
                global.core.items[param.id].dispose();
            }

            // Create a new FusionCharts object with the construction parameters of
            // the above link configuration.
            childObj = new global.core(param);


            // Check whether the overlay button text is "close" or "back" depending
            // upon the place of render of the chart.
            if (!checkObjectRenderLocationOverride(childObj, obj) && !(obj.options.overlayButton &&
                    obj.options.overlayButton.message)) {

                if (typeof obj.options.overlayButton !== 'object') {
                    obj.options.overlayButton = {};
                }
                obj.options.overlayButton.message = 'Close';
            }

            // Render the linked chart.
            childObj.render();

            /**
             * Linked charts have data plot items, clicking on which a linked chart is opened. The data of the child
             * linked charts is given along with the data to the parent chart. This event is fired once the child linked
             * chart is rendered.
             *
             * Any action to be performed after opening the linked chart can accomplished using this event.
             *
             * The parameter of this event,`level`, indicates the depth of the closed linked chart from the parent
             * chart.
             *
             * @see FusionCharts#event:beforeLinkedItemOpen
             * @see FusionCharts#event:beforeLinkedItemClose
             * @see FusionCharts#event:linkedItemClosed
             * @see FusionCharts#configureLink
             * @event FusionCharts#linkedItemOpened
             * @group linked-charts
             *
             * @param {object} item - The JavaScript object instance of the LinkedChart that is opened
             * @param {string} level - Level (as number) of the LinkedChart.
             *
             * @tutorial interactivity-drill-down-linkedcharts
             */
            global.raiseEvent('linkedItemOpened', {
                level: obj.link.level,
                item: childObj
            }, obj.link.root);
        });
    });

    /**
     * This method handles the routines that are performed when a linked chart
     * is closed.
     */
    global.addEventListener('overlayButtonClick', function (event, args) {

        // We need to verify whether this overlay button was initiated by
        // link-manager or not.
        if (args.id !== 'LinkManager') {
            return;
        }

        var sender = event.sender,
            level = sender.link.level - 1, // compute the target link level
            parent = sender.link.parent,
            root = sender.link.root;

        /**
         * Upon clicking the dataplot items (columns, pie etc.) of the linked charts, users can drill down into child
         * linked charts. The user  can navigate back to the parent chart by clicking on the back button. Before
         * re-opening the parent chart, the child linked item is closed.
         *
         * This event is fired just *before* closing a linked chart. Any action to be done before closing the linked
         * chart can be accomplished with this event.
         *
         * A parent chart can have multiple linked charts. These child linked charts might have linked charts of their
         * own. The parameter of this event,`level`, indicates the depth of the closed linked chart from the parent
         * chart. The *level* of the linked item starts from 0.
         *
         * @see FusionCharts#event:beforeLinkedItemOpen
         * @see FusionCharts#event:linkedItemOpened
         * @see FusionCharts#event:linkedItemClosed
         * @see FusionCharts#configureLink
         * @event FusionCharts#beforeLinkedItemClose
         * @group linked-charts
         *
         * @param {object} item - The JavaScript object instance of the LinkedChart that is opened
         * @param {string} level - Level (as number) of the LinkedChart.
         */
        global.raiseEvent('beforeLinkedItemClose', {
            level: level,
            item: sender
        }, root, sender, function () {
            setTimeout(function () {
                if (global.core.items[sender.id] ) {
                    /**
                     * @todo
                     * 1. If enabled, delete all child charts and then dispose this chart
                     * 2. If not enabled, unlink this chart from child and link it to grand-parent
                     */
                    sender.dispose();
                }

                /**
                 * Upon clicking the dataplot items (columns, pie etc.) of the linked charts, users can drill down into
                 * child linked charts. The user can navigate back to the parent chart by clicking on the back button.
                 * Before re-opening the parent chart, the child linked item is closed.
                 *
                 * Once the child linked chart is closed,this event is fired.
                 *
                 * A parent chart can have multiple linked charts. These child linked charts might have linked charts of
                 * their own. The parameter of this event,`level`, indicates the depth of the closed linked chart from
                 * the parent chart.
                 *
                 * The *level* of the linked item starts from 0.
                 * @see FusionCharts#event:beforeLinkedItemOpen
                 * @see FusionCharts#event:linkedItemOpened
                 * @see FusionCharts#event:beforeLinkedItemClose
                 * @see FusionCharts#configureLink
                 * @event FusionCharts#linkedItemClosed
                 * @group linked-charts
                 *
                 * @param {string} level - Level of the linked item which starts from '0'.
                 */
                global.raiseEvent('linkedItemClosed', {
                    level: level
                }, root);
            }, 0);

            // In case link item was closed for an object whose parent is not
            // active, we re-render it.
            if (!parent.disposed && !parent.isActive() && checkObjectRenderLocationOverride(sender, parent)) {
                parent.render();
            }
        });
    });

    global.addEventListener('Loaded', function (event) {

        var obj = event.sender,
            config;

        // When Chart is rendered using HTML rendering "event.sender.link" is undefined.
        if (!obj || obj.link === undefined) {
            return;
        }
        // Verify whether the loaded item is a root item or not. In case the
        // item is a root item, we do not need to process an overlay button.
        if (obj.link.root === obj || !(obj.link.parent instanceof global.core)) {
            return;
        }

        // Verify whether overlay button API is available
        if (!(obj.ref && typeof obj.ref.drawOverlayButton === 'function')) {
            /**
             * Unable to draw the overlay button for linked charts. Something has gone wrong with thexpected DOM
             * structure of the chart and its surroundings.
             * @private
             *
             * @typedef {ParameterException} Error-04091602
             * @memberOf FusionCharts.debugger
             * @group debugger-warning
             */
            global.raiseWarning(obj, '04091602', 'run', '::LinkManager^Loaded',
                'Unable to draw overlay button on object. -' + obj.id);
            return;
        }

        // Get configuration of overlay button
        config = global.extend({
            show: true,
            id: 'LinkManager'
        }, obj.link.parent.options.overlayButton);
        global.extend(config, obj.link.parent.link.configuration().overlayButton || {});
        obj.ref.drawOverlayButton(config);
    });

    // Add method to make sure to delete all fusioncharts objects when
    // dispose method is invoked.
    global.addEventListener('beforeDispose', function (e) {
        var obj = e.sender;
        // Validate environment to check sender and its link exists.
        if (!(obj && obj.link instanceof LinkInformation)) {
            return;
        }

        // In case the object is not a root object, we would need to perform
        // additional cleanup.
        if (obj && obj.link && obj.link.parent instanceof global.core) {
            // Cleanup the reference to this object to the 'items' collection of its parent.
            if (obj.link.parent.link && obj.link.parent.link.items) {
                delete obj.link.parent.link.items[e.sender.id];
            }
        }
        // Remove any configuration set as root configuration
        delete store[obj.id];
    });
}]);
/**
 * Theme manager module to enable theme the charts externally without manipulating the chart data.
 * @private
 *
 * @module fusioncharts.api.themes
 * @requires fusioncharts.renderer.javascript.lib
 */
FusionCharts.register('module', ['private', 'modules.renderer.js-thememanager', function () {

    var global = this,
        BLANK = '',
        OBJECTSTRING = 'object',
        arrayToStr = '[object Array]',
        objectToStr = '[object Object]',
        ThemeManager,
        ThemeInstance,
        themer,
        isImportantRegEx = /\s+!important$/,
        importantStrRegEx = /\\!important$/,
        trimString = function(str) {
            str = str.replace(/^\s\s*/, '');
            var ws = /\s/, i = str.length;

            while (ws.test(str.charAt(i -= 1))) { /* jshint noempty:false */ }
            return str.slice(0, i + 1);
        },
        checkCyclicRef = function(obj, parentArr) {
            var i = parentArr.length,
                bIndex = -1;

            while (i--) {
                if (obj === parentArr[i]) {
                    bIndex = i;
                    return bIndex;
                }
            }

            return bIndex;
        },
        merge = function(obj1, obj2, skipUndef, tgtArr, srcArr) {
            var item,
                srcVal,
                tgtVal,
                str,
                cRef;

            if (!srcArr) {
                tgtArr = [obj1];
                srcArr = [obj2];
            }
            else {
                tgtArr.push(obj1);
                srcArr.push(obj2);
            }

            if (obj2 instanceof Array) {
                for (item = 0; item < obj2.length; item += 1) {
                    try {
                        srcVal = obj1[item];
                        tgtVal = obj2[item];
                    }
                    catch (e) {
                        continue;
                    }

                    if (typeof tgtVal !== OBJECTSTRING) {
                        if (!(skipUndef && tgtVal === undefined)) {
                            obj1[item] = tgtVal;
                        }
                    }
                    else {
                        if (srcVal === null || typeof srcVal !== OBJECTSTRING) {
                            srcVal = obj1[item] = tgtVal instanceof Array ? [] : {};
                        }
                        cRef = checkCyclicRef(tgtVal, srcArr);
                        if (cRef !== -1) {
                            srcVal = obj1[item] = tgtArr[cRef];
                        }
                        else {
                            merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
                        }
                    }
                }
            }
            else {
                for (item in obj2) {
                    try {
                        srcVal = obj1[item];
                        tgtVal = obj2[item];
                    }
                    catch (e) {
                        continue;
                    }

                    if (tgtVal !== null && typeof tgtVal === OBJECTSTRING) {
                        // Fix for issue BUG: FWXT-602
                        // IE < 9 Object.prototype.toString.call(null) gives
                        // '[object Object]' instead of '[object Null]'
                        // that's why null value becomes Object in IE < 9
                        str = Object.prototype.toString.call(tgtVal);
                        if (str === objectToStr) {
                            if (srcVal === null || typeof srcVal !== OBJECTSTRING) {
                                srcVal = obj1[item] = {};
                            }
                            cRef = checkCyclicRef(tgtVal, srcArr);
                            if (cRef !== -1) {
                                srcVal = obj1[item] = tgtArr[cRef];
                            }
                            else {
                                merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
                            }
                        }
                        else if (str === arrayToStr) {
                            if (srcVal === null || !(srcVal instanceof Array)) {
                                srcVal = obj1[item] = [];
                            }
                            cRef = checkCyclicRef(tgtVal, srcArr);
                            if (cRef !== -1) {
                                srcVal = obj1[item] = tgtArr[cRef];
                            }
                            else {
                                merge(srcVal, tgtVal, skipUndef, tgtArr, srcArr);
                            }
                        }
                        else {
                            obj1[item] = tgtVal;
                        }
                    }
                    else {
                        obj1[item] = tgtVal;
                    }
                }
            }
            return obj1;
        },
        extend2 = function(obj1, obj2, skipUndef) {
            //if none of the arguments are object then return back
            if (typeof obj1 !== OBJECTSTRING && typeof obj2 !== OBJECTSTRING) {
                return null;
            }

            if (typeof obj2 !== OBJECTSTRING || obj2 === null) {
                return obj1;
            }

            if (typeof obj1 !== OBJECTSTRING) {
                obj1 = obj2 instanceof Array ? [] : {};
            }
            merge(obj1, obj2, skipUndef);
            return obj1;
        },
        checkImportance = function (value) {

            var returnObj = {
                important: false,
                str: BLANK
            };

            if (!value) {
                return returnObj;
            }

            value = value.toString();
            if(isImportantRegEx.test(value)) {
                value = value.replace(isImportantRegEx, BLANK);
                returnObj.important = true;
            }
            else {
                value = value.replace(importantStrRegEx, '!imporant');
                returnObj.important = false;
            }
            returnObj.str = value;
            return returnObj;
        },
        recursiveApply = function (dataObj, themeObject) {
            var key,
                dataItem,
                themeComponent,
                item,
                i,
                ii,
                vLineIndex = 0, // needed for the special handling of vlines in the category array
                catIndex = 0; // needed for the special handling of vlines in the category array

            for (key in dataObj) {
                dataItem = dataObj[key];
                if (dataItem instanceof Array) {
                    ii = dataItem.length;
                    for (i = 0; i < ii; i += 1) {
                        item = dataItem[i];
                        if (typeof item === 'object') {
                            if (key === 'category') {
                                // The category array in the data needs special handling as it may
                                // contain vlines also which are in the same array as the categories
                                // enumerated on the xaxis. By handling this exception, we can theme
                                // the vlines separately.
                                if (item.vline === 'true') {
                                    if (themeComponent = themeObject.component('vline', vLineIndex, item)) {
                                        mergeThemeWithData(item, themeComponent);
                                        vLineIndex += 1;
                                    }
                                }
                                else {
                                    if (themeComponent = themeObject.component('category', catIndex, item, ii)) {
                                        mergeThemeWithData(item, themeComponent);
                                        catIndex += 1;
                                    }
                                }
                            }
                            else if (themeComponent = themeObject.component(key, i, item, ii)) {
                                mergeThemeWithData(item, themeComponent);
                                recursiveApply(item, themeComponent);
                            }
                        }
                    }
                }
                else if (typeof dataItem === 'object') {
                    if (themeComponent = themeObject.component(key, null, dataItem)) {
                        mergeThemeWithData(dataItem, themeComponent);
                        recursiveApply(dataItem, themeComponent);
                    }
                }
            }
        },

        mergeThemeWithData = function (dataJSON, themeComponent) {
            var items = themeComponent.getAll(),
                key,
                valStr,
                imp;

            for (key in items) {
                valStr = items[key].toString();
                imp = checkImportance(valStr);
                if (imp.important) {
                    dataJSON[key.toLowerCase()] = imp.str;
                }
                else if (dataJSON[key.toLowerCase()] === undefined) {
                    dataJSON[key.toLowerCase()] = imp.str;
                }
            }
        },

        onDrawStart = function (event, args) {
            if (args.defaultSeriesType === 'geo') {
                onChartTypeChange.call(this, event, args);
            }
        },

        onChartTypeChange = function (eventObj, args) {

            var chartObj = eventObj.sender,
                dataObj = chartObj.getChartData(global.dataFormats.JSON, true),
                chartTheme;

            if (!dataObj.error) {
                chartTheme = dataObj.data.chart.theme;
                if (chartTheme) {
                    themer.themify(chartTheme, chartObj, chartObj.chartType(), dataObj.data,
                        (args.defaultSeriesType === 'geo') && 'geo');
                }
                else {
                    chartObj.jsVars.themeObject && chartObj.jsVars.themeObject.dispose();
                }
            }
        };


    /**
     * The ThemeManager is a class that exists at the FusionCharts framework
     * level i.e there is one instance of this class in the whole framework.
     *
     * This class is responsible for
     * - storing all the themes that are registered with it
     * - evaluating the final theme that get applied to the chart from the
     * theme file that contains themes for single as well as repeating elements
     * - creating a theme instance per chart instance that contains the theme
     * related details corresponding to the chart
     *
     * @param {object} components A object containing all the components of the
     * chart that can be themed.
     * @property {object} themeStore Contains all the themes extracted from the
     * theme file indexed according to the theme name.
     *
     *
     *
     */
    ThemeManager = function () {
        this.themeStore = {};
    };

    ThemeManager.prototype = {
        constructor: ThemeManager,

        /**
         * Add a themeJSON to the themeStore.
         *
         * @param {object} themeJSON Contains the themeJSON extracted as is from the
         * theme file.
         */
        add: function (themeJSON) {
            var tm = this,
                i = 0,
                ii = themeJSON.length,
                themeName;

            for (; i < ii; i += 1) {
                themeName = themeJSON[i].name;
                if (themeName) {
                    tm.themeStore[themeName] = themeJSON[i];
                }
            }
        },

        /**
         * Applies a particular theme to the chart by modifying the chart definition (dataObj)
         *
         * @param  {string} themeName A comma (,) separated list of themes that have to be applied
         * to the chart. All the themes provided here get cascaded at runtime and then applied
         * depending on the precedence. The theme applied later gets higher precedence.
         *
         */
        themify: function (themeName, chartInstance, chartType, chartDefinition, additionalBase) {
            // get theme object from theme name
            var tm = this,
                jsVars = chartInstance.jsVars,
                themes = themeName.split(','),
                themeArr = [],
                ii = themes.length,
                themeJSON,
                i;

            if (ii) {
                for (i = 0; i < ii; i += 1) {
                    themeJSON = tm.themeStore[trimString(themes[i])];
                    themeJSON &&
                        themeArr.push(tm.evaluateThemeJSON(themeJSON.theme, chartInstance, chartType, additionalBase));
                }

                if (themeArr.length) {
                    // Create a theme instance using the array of evaluated themes.
                    // The logic to cascade the themes is handled by the theme instance.
                    jsVars.themeObject = new ThemeInstance(themeArr, chartInstance, false, chartDefinition);
                    tm.applyTheme(chartInstance);

                    chartInstance.addEventListener('chartTypeChanged', onChartTypeChange);
                    chartInstance.addEventListener('internal.drawstart', onDrawStart);
                }
                else {
                    /**
                     * The reference to the theme name provided as part of the chart data is not registered. Verify
                     * whether the corresponding theme file has been included in page.
                     *
                     * @typedef {RuntimeException} Warning-14051100501
                     * @memberOf FusionCharts.debugger
                     * @group debugger-warning
                     */
                    global.raiseWarning(chartInstance, '14051100501', 'run', 'api.themes~themify()',
                        'The theme \"' + themeName + '\" requested has not been registered.');
                }
            }
        },

        /**
         * Evaluates a themeJSON and creates the final evaled theme json that can be passed in an
         * array to the themeInstance.
         * @param  {object} themeObject The theme object as stored in the theme file.
         * @param  {object} logic The chart visualization logic the contains a reference to the
         * chart definition.
         *
         * @return {object} evaledTheme The evaluated theme object.
         */
        evaluateThemeJSON: function (themeObject, chartInstance, chartType, additionalBase) {
            var evaledTheme = {},
                jsVars = chartInstance.jsVars,
                evaluator = function (tblock) {
                    var key,
                        item;

                    for (key in tblock) {
                        item = tblock[key];

                        if (item instanceof Array) {
                            evaledTheme[key] = extend2(evaledTheme[key] || [], item);
                        }
                        else if (typeof item === 'object') {
                            evaledTheme[key] = extend2(evaledTheme[key] || {}, item);
                        }
                        else {
                            evaledTheme[key] = item;
                        }
                    }
                };

            chartType = chartType || chartInstance.chartType();

            /**
             * @todo: Why is this here?
             */
            if (jsVars.themeObject && themeObject !== jsVars.themeObject) {
                jsVars.themeObject.dispose();
                delete jsVars.themeObject;
            }
            evaluator(themeObject.base);

            // Special evaluation for maps. Maps need to have a generic definition as well.
            if (additionalBase && themeObject[additionalBase]) {
                evaluator(themeObject[additionalBase]);
            }

            // Apply chart type specifix theme
            if (chartType && themeObject[chartType]) {
                evaluator(themeObject[chartType]);
            }

            return evaledTheme;
        },

        /**
         * applyTheme applies the theme information stored in the themeInstance object to the
         * various components of the chart definition.
         *
         * @param {object} logic stores a reference to the chart definition that will be merged with
         * the theme object.
         *
         */
        applyTheme: function (chartInstance) {
            var themeObj = chartInstance.jsVars.themeObject,
                themedData = themeObj.getThemedJSONData().data;

            if (themedData) {
                recursiveApply(themedData, themeObj);
            }
        }
    };


    /**
     * ThemeInstance is a class that get instantiated per chart. It contains all the theme related
     * information that pertains to that particular chart instance.
     *
     * @param {array} themeJSONArr Contains an array of JSON that correspond to the themes that have
     * to be cascaded and applied to the chart.
     * @param {ThemeInstance} parent In case the theme instance corresponds to one of the sub
     * components of the chart definition.
     *
     * @property {array} themeArray contains the array of themes that get cascaded when the theme is
     * applied.
     * @property {object} themeComponents contains the sub components of the theme that will get
     * evaluated and applied as the theme application moves to the respective components of the
     * chart.
     * @property {object} base contains all the items of the theme that gets applied to the component
     * to which this theme instance pertains.
     *
     * @private
     */
    ThemeInstance = function (themeJSONArr, parent, isChildInstance, chartDefinition) {

        this.themeArray = themeJSONArr;
        this.themeComponents = {};
        this.base = {};
        this.chartInstance = parent;
        this.isChildInstance = Boolean(isChildInstance);

        this.themedData = isChildInstance ? null : extend2({}, chartDefinition);

        this.length = themeJSONArr.length;

        var i = 0,
            ii = themeJSONArr.length;

        for (; i < ii; i += 1) {
            this.parse(themeJSONArr[i]);
        }
    };

    ThemeInstance.prototype = {
        constructor: ThemeInstance,

        /**
         * Adds a new theme to cascade with the existing theme array.
         * @param  {object} themeJSON an evaled theme JSON.
         * @memberOf ThemeInstance
         */
        pushTheme: function (themeJSON) {

            if (themeJSON) {
                this.themeArray.push(themeJSON);
                this.parse(themeJSON);
                this.length += 1;
            }
        },

        /**
         * Removes a theme JSON from the theme array
         */
        popTheme: function () {
            // Not implemented as there isn't really a use-case for this.
        },

        /**
         * Parses the theme JSON and creates themeComponents based on the JSON structure.
         * @param  {object} themeJSON
         * @private
         */
        parse: function (themeJSON) {
            var ti = this,
                components = ti.themeComponents,
                parent = ti.chartInstance,
                base = ti.base,
                componentArr,
                key,
                imp1,
                imp2,
                block;

            block = themeJSON;

            for (key in block) {
                if (typeof block[key] === 'string' || typeof block[key] === 'number') {
                    if (base[key]) {
                        // If the base has already been populated by a previous theme then merge the
                        // new value properly.
                        imp1 = checkImportance(block[key]);
                        imp2 = checkImportance(base[key]);

                        if (imp1.important || !imp2.important) {
                            base[key] = block[key];
                        }
                    }
                    else {
                        base[key] = block[key];
                    }
                }
                else {
                    if (!components[key]) {
                        components[key] = [];
                    }

                    componentArr = components[key];
                    // If it is an array then it has to be applied to repeating elements of the chart
                    if (block[key] instanceof Array) {
                        componentArr.push(extend2([], block[key]));
                    }
                    // If an object then we make a separate theme instance for the component that
                    // will get cascaded with other theme objects (if any) and applied to the
                    // component.
                    else if (typeof block[key] === 'object') {
                        componentArr.push(new ThemeInstance([block[key]], parent, true));
                    }
                    // If it is a function then it has to be invoked during runtime and applied to
                    // chart component depending on the return type.
                    else if (typeof block[key] === 'function') {
                        componentArr.push(block[key]);
                    }
                }
            }
        },
        /**
         * Merges the ThemeInstance object passed with itself.
         * @param  {ThemeInstance} instance The object to be merged
         *
         */
        merge: function (instance) {

            var ti = this,
                thisBase = ti.base,
                thatBase = instance.base,
                thisComponents = ti.themeComponents,
                thatComponents = instance.themeComponents,
                imp1,
                imp2,
                key;

            for (key in thatBase) {
                imp1 = checkImportance(thisBase[key]);
                imp2 = checkImportance(thatBase[key]);

                if (!imp1.important || imp2.important) {
                    thisBase[key] = thatBase[key];
                }
            }

            for (key in thatComponents) {
                if (thisComponents[key]) {
                    thisComponents[key] = thisComponents[key].concat(thatComponents[key]);
                }
                else {
                    thisComponents[key] = [].concat(thatComponents[key]);
                }
            }

            ti.length += instance.length;
        },

        /**
         * Getter function to get the value of a theme property from the `base` property of the
         * theme instance.
         *
         * @param  {string} key The key corresponding to the theme property.
         * @return {string} The value of the theme property as given in the evaled theme JSON.
         */
        get: function (key) {
            return this.base[key];
        },

        /**
         * Getter to get all the properties that are there in the base.
         *
         * @return {object} a copy of the base object that contains all the key value pairs
         * corresponding to the chart component.
         */
        getAll: function () {
            return extend2({}, this.base);
        },

        /**
         * Traverses the themeComponents of the parent theme instance and returns a new themeInstance
         * corresponding to the chart component for which it is being fetched.
         *
         * @param  {string} key - The key corresponding to the chart component to be themed
         *
         * @param  {number} index - If it is a repeating component then the index indicating the
         * index of the component is also passed.
         *
         * @param {number=} [length] - Specify the total length of the component for function iterators that needs the
         * total length to be passed as a parameter.
         *
         * @return {themeInstance} The ThemeInstance object corresponding to the component.
         */
        component: function (key, index, dataJSON, length) {

            var ti = this,
                components = ti.themeComponents,
                parent = ti.chartInstance,
                returnInstance = new ThemeInstance([], parent, true),
                item,
                i,
                ii,
                len,
                componentArr,
                each;

            componentArr = components[key];

            if (!componentArr) {
                return null;
            }

            for (i = 0, ii = componentArr.length; i < ii; i += 1) {
                each = componentArr[i];

                if (typeof each === 'function') {
                    index = index || 0;
                    returnInstance.pushTheme(each.call(parent, index, dataJSON, length));
                }
                else {
                    if (each instanceof Array) {
                        index = index || 0;
                        len = each.length;

                        index = index % len;
                        item = each[index];

                        if (item instanceof ThemeInstance) {
                            returnInstance.merge(item);
                        }
                        else {
                            if (typeof item === 'function') {
                                returnInstance.pushTheme(item.call(parent, index, dataJSON, length));
                            }
                            else {
                                returnInstance.pushTheme(item);
                            }
                        }
                    }
                    else {
                        if (each instanceof ThemeInstance) {
                            returnInstance.merge(each);
                        }
                        else {
                            returnInstance.pushTheme(each);
                        }
                    }
                }
            }

            return returnInstance;
        },

        getThemedJSONData: function () {
            return {data: this.themedData};
        },

        /**
         * Disposes the theme instance.
         */
        dispose: function () {

            var ti = this,
                components = ti.themeComponents,
                chartObj = ti.chartInstance,
                key,
                i;

            for (key in components) {
                i = components[key].length;
                if (i) {
                    while (i--) {
                        components[key][i].dispose && components[key][i].dispose();
                    }
                    delete components[key];
                }
            }

            if (!ti.isChildInstance) {
                chartObj.removeEventListener('chartTypeChanged', onChartTypeChange);
                chartObj.removeEventListener('internal.drawstart', onDrawStart);
            }

            ti.themeComponents = null;
            ti.chartInstance = null;
            ti.base = null;
            ti.themeArray = null;
            ti.isChildInstance = null;
            ti.dataWithoutTheme = null;
        }
    };

    /**
     * The single instance of ThemeManager that handles the theming of all the charts.
     * @private
     */
    themer = new ThemeManager();

    /**
     * Every theme file should call the `registerTheme` method of the global handle.
     *
     * @param {object|array} themeDefinition an array of theme JSONs where, the format of each theme JSON is as
     * follows:
     *    {
     *        name: <theme name> // theme name should be unique and should be a valid JSON key.
     *        theme: {
     *            base: { // This theme will be applied to all the charts by default.
     *                chart: {
     *                    // the attribute name and value provided should be the same as allowed
     *                    // in the chart defintion.
     *                    <attribute name>: <attribute value>,
     *                    <attribute name>: <attribute value>
     *                    ...
     *                },
     *                <component name>: <component value>
     *                <compoenent name>: <component value>,
     *                <compoenent name>: <component value>
     *                ...
     *
     *                // The component name corresponds to the chart component e.g `datasets` and
     *                // the value can either be an array, a function or an object. If it is a
     *                // function then the function will be invoked when that particular component
     *                // is being themed and will be passed an index depending on which repeating
     *                // nature of the component being themed and should return an object that
     *                // will be contain theme information to be used to theme the component and
     *                // it's subcomponents.
     *            },
     *            column2d: { // or any other chart type for which the theme has to be extended
     *                // more theme components and their properties
     *                // more theme components and their properties
     *            },
     *            <chart type>: {
     *                ...
     *            }
     *        }
     *  }
     */
    global.registrars.theme = global.registerTheme = function (themeDefinition) {
        if (themeDefinition) {
            (Object.prototype.toString.call(themeDefinition) !== arrayToStr) && (themeDefinition = [themeDefinition]);
            themer.add(themeDefinition);
        }
    };

    // Listening to the data updated event fired when the chart data is updated and themifying the chart definition
    // before the chart attributes are read and applied to the chart definition.
    global.addEventListener('beforeDataUpdate', function (eventObj, args) {
        var chartObj = eventObj.sender,
            dataObj = global.core.transcodeData(args.data, args.format, global.dataFormats.JSON),
            themeName = dataObj.chart && dataObj.chart.theme;

        if (themeName) {
            themer.themify(themeName, chartObj, chartObj.args.type, dataObj);
        }
        else if (chartObj.jsVars.themeObject) {
            chartObj.jsVars.themeObject.dispose();
            delete chartObj.jsVars.themeObject;
        }
    });
}]);
/**!
 * @license FusionCharts JavaScript Library
 * Copyright FusionCharts Technologies LLP
 * License Information at <http://www.fusioncharts.com/license>
 */
/**
 * @private
 * @module fusioncharts.api.themes.default
 */
FusionCharts.register('theme', {
    name: 'default',
    theme: {
        base: {
            chart: {
                labelDisplay: 'stagger !important',
                caption: 'Theme Caption \\!important',
                canvasBgColor: '#56EF22',
                borderThickness: '5 !important',
                borderColor: '#E60539',
                baseFontColor: '#781129'
            },
            categories: [{
                fontColor: '#0F4F40',
                fontSize: 15,
                category: function (index) {
                    return {
                        showLabel: (index % 2) ? 0 : 1
                    };
                },
                vline: {
                    color: '#000000',
                    thickness: 2
                }
            }],
            dataset: [{
                color: '#8C3146',
                data: function (index, dataObj) {
                    if (index == 8) {
                        dataObj.value = '';
                    }
                    return {
                        color: (Number(dataObj.value) < 32000 ? '#8C3146' : '#FF0000'),
                        alpha: '100'
                    };
                }
            }],
            trendlines: [{
                line: function (index) {
                    if (index) {
                        return {
                            color: '#ff0000',
                            thickness: 3
                        };
                    }
                    else {
                        return {
                            color: '#ffff00',
                            thickness: 3
                        };
                    }
                }
            }]
        },
        pie2d: {
            chart: {
                bgColor: '#FF0000'
            }
        },
        msline: {
            chart: {
                canvasBgColor: '#ff0000'
            }
        },

        geo: {
            chart: {
                canvasBgColor: '#0000ff'
            }
        },

        world: {
            chart: {
                canvasBgColor: '#00ff00'
            }
        }
    }
});
/**!
 * @license FusionCharts JavaScript Library
 * Copyright FusionCharts Technologies LLP
 * License Information at <http://www.fusioncharts.com/license>
 *
 * @version 3.5.0
 *
 * @attributions (infers respective third-party copyrights)
 * Raphael 2.1.0 (modified as 'Red Raphael') <http://raphaeljs.com/license.html>
 * JSON v2 <http://www.JSON.org/js.html>
 * Firebug Lite 1.3.0 <http://getfirebug.com/firebuglite>
 */

/**
 * @private
 * @module fusioncharts
 *
 * @requires fusioncharts.constructor
 *
 * @requires fusioncharts.transcoder
 * @requires fusioncharts.transcoder.json
 * @requires fusioncharts.transcoder.xml
 * @requires fusioncharts.transcoder.csv
 *
 * @requires fusioncharts.renderer
 * @requires fusioncharts.renderer.javascript
 * @requires fusioncharts.renderer.javascript.interface
 *
 * @requires fusioncharts.api.chartattributes
 * @requires fusioncharts.api.linkedcharts
 * @requires fusioncharts.api.themes
 * @requires fusioncharts.api.themes.default
 *
 * @export fusioncharts.js
 */
